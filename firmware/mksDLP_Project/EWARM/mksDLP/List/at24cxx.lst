###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  11:14:28
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\BSP\Components\at24cxx\at24cxx.cpp
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\BSP\Components\at24cxx\at24cxx.cpp
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --eec++ -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\at24cxx.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\at24cxx.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\BSP\Components\at24cxx\at24cxx.cpp
      1          
      2          #include "at24cxx.h"
      3          
      4          
      5          #define heval_I2c					hi2c1								/*	I2C_HandleTypeDef structure		*/
      6          
      7          #define I2C_TIMEOUT  100 /*<! Value of Timeout when I2C communication fails */
      8          
      9          #define I2Cx_Init		MX_I2C1_Init			/*	Initializes I2C HAL.	*/
     10          #define HAL_I2C_DeInit		HAL_I2C_MspDeInit		/*	De-initialize		*/
     11          
     12          /*
     13          static void     I2Cx_Write(uint8_t Addr, uint8_t Reg, uint16_t MemAddSize, uint8_t Value);
     14          static uint8_t  I2Cx_Read(uint8_t Addr, uint8_t Reg, uint16_t MemAddSize);
     15          static HAL_StatusTypeDef I2Cx_WriteMultiple(uint8_t Addr, uint16_t Reg, uint16_t MemAddSize, uint8_t *Buffer, uint16_t Length);
     16          static HAL_StatusTypeDef I2Cx_ReadMultiple(uint8_t Addr, uint16_t Reg, uint16_t MemAddSize, uint8_t *Buffer, uint16_t Length);
     17          static HAL_StatusTypeDef  I2Cx_IsDeviceReady(uint16_t DevAddress, uint32_t Trials);
     18          static void     I2Cx_Error(uint8_t Addr);
     19          */
     20          /**
     21            * @brief  Reads a single data.
     22            * @param  Addr: I2C address
     23            * @param  Reg: Reg address 
     24            * @param  MemAddSize Size of internal memory address
     25            * @retval Data to be read
     26            */

   \                                 In section .text, align 2, keep-with-next
     27          uint8_t I2Cx_Read(uint8_t Addr, uint8_t Reg, uint16_t MemAddSize)
     28          {
   \                     _Z9I2Cx_Readhht: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
     29            HAL_StatusTypeDef status = HAL_OK;
     30            uint8_t Value = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF88D 0x000C      STRB     R0,[SP, #+12]
     31            
     32            status = HAL_I2C_Mem_Read(&heval_I2c, Addr, Reg, MemAddSize, &Value, 1, I2C_TIMEOUT);
     33            
     34            /* Check the communication status */
     35            if(status != HAL_OK)
   \   0000000A   0x2064             MOVS     R0,#+100
   \   0000000C   0x9002             STR      R0,[SP, #+8]
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x9001             STR      R0,[SP, #+4]
   \   00000012   0xA803             ADD      R0,SP,#+12
   \   00000014   0x9000             STR      R0,[SP, #+0]
   \   00000016   0x4613             MOV      R3,R2
   \   00000018   0x460A             MOV      R2,R1
   \   0000001A   0x4621             MOV      R1,R4
   \   0000001C   0x....             LDR.N    R0,??DataTable5
   \   0000001E   0x.... 0x....      BL       HAL_I2C_Mem_Read
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD002             BEQ.N    ??I2Cx_Read_0
     36            {
     37              /* Execute user timeout callback */
     38              I2Cx_Error(Addr);
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       I2Cx_Error
     39            }
     40            
     41            return Value;   
   \                     ??I2Cx_Read_0: (+1)
   \   0000002C   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   00000030   0xB004             ADD      SP,SP,#+16
   \   00000032   0xBD10             POP      {R4,PC}          ;; return
     42          }
     43          
     44          /**
     45            * @brief  Writes a single data.
     46            * @param  Addr: I2C address
     47            * @param  Reg: Reg address 
     48            * @param  MemAddSize Size of internal memory address
     49            * @param  Value: Data to be written
     50            */

   \                                 In section .text, align 2, keep-with-next
     51          void I2Cx_Write(uint8_t Addr, uint8_t Reg, uint16_t MemAddSize, uint8_t Value)
     52          {
   \                     _Z10I2Cx_Writehhth: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
     53            HAL_StatusTypeDef status = HAL_OK;
     54            
     55            status = HAL_I2C_Mem_Write(&heval_I2c, Addr, (uint16_t)Reg, MemAddSize, &Value, 1, I2C_TIMEOUT); 
     56            
     57            /* Check the communication status */
     58            if(status != HAL_OK)
   \   00000004   0x2064             MOVS     R0,#+100
   \   00000006   0x9002             STR      R0,[SP, #+8]
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x9001             STR      R0,[SP, #+4]
   \   0000000C   0xA803             ADD      R0,SP,#+12
   \   0000000E   0x9000             STR      R0,[SP, #+0]
   \   00000010   0x4613             MOV      R3,R2
   \   00000012   0x460A             MOV      R2,R1
   \   00000014   0x4621             MOV      R1,R4
   \   00000016   0x....             LDR.N    R0,??DataTable5
   \   00000018   0x.... 0x....      BL       HAL_I2C_Mem_Write
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD002             BEQ.N    ??I2Cx_Write_0
     59            {
     60              /* I2C error occured */
     61              I2Cx_Error(Addr);
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       I2Cx_Error
     62            }
     63          }
   \                     ??I2Cx_Write_0: (+1)
   \   00000026   0xBD1F             POP      {R0-R4,PC}       ;; return
     64          
     65          /**
     66            * @brief  Reads multiple data.
     67            * @param  Addr: I2C address
     68            * @param  Reg: Reg address 
     69            * @param  MemAddSize Size of internal memory address
     70            * @param  Buffer: Pointer to data buffer
     71            * @param  Length: Length of the data
     72            * @retval Number of read data
     73            */

   \                                 In section .text, align 2, keep-with-next
     74          HAL_StatusTypeDef I2Cx_ReadMultiple(uint8_t Addr, uint16_t Reg, uint16_t MemAddSize, uint8_t *Buffer, uint16_t Length)
     75          {
   \                     _Z17I2Cx_ReadMultiplehttPht: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
     76            HAL_StatusTypeDef status = HAL_OK;
     77            
     78            status = HAL_I2C_Mem_Read(&heval_I2c, Addr, (uint16_t)Reg, MemAddSize, Buffer, Length, I2C_TIMEOUT);
   \   00000004   0x2064             MOVS     R0,#+100
   \   00000006   0x9002             STR      R0,[SP, #+8]
   \   00000008   0x9806             LDR      R0,[SP, #+24]
   \   0000000A   0x9001             STR      R0,[SP, #+4]
   \   0000000C   0x9300             STR      R3,[SP, #+0]
   \   0000000E   0x4613             MOV      R3,R2
   \   00000010   0x460A             MOV      R2,R1
   \   00000012   0x4621             MOV      R1,R4
   \   00000014   0x....             LDR.N    R0,??DataTable5
   \   00000016   0x.... 0x....      BL       HAL_I2C_Mem_Read
   \   0000001A   0x0005             MOVS     R5,R0
     79            
     80            /* Check the communication status */
     81            if(status != HAL_OK)
   \   0000001C   0xD002             BEQ.N    ??I2Cx_ReadMultiple_0
     82            {
     83              /* I2C error occured */
     84              I2Cx_Error(Addr);
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       I2Cx_Error
     85            }
     86            return status;    
   \                     ??I2Cx_ReadMultiple_0: (+1)
   \   00000024   0x4628             MOV      R0,R5
   \   00000026   0xBD3E             POP      {R1-R5,PC}       ;; return
     87          }
     88          
     89          /**
     90            * @brief  Write a value in a register of the device through BUS in using DMA mode
     91            * @param  Addr: Device address on BUS Bus.  
     92            * @param  Reg: The target register address to write
     93            * @param  MemAddSize Size of internal memory address
     94            * @param  Buffer: The target register value to be written 
     95            * @param  Length: buffer size to be written
     96            * @retval HAL status
     97            */

   \                                 In section .text, align 2, keep-with-next
     98          HAL_StatusTypeDef I2Cx_WriteMultiple(uint8_t Addr, uint16_t Reg, uint16_t MemAddSize, uint8_t *Buffer, uint16_t Length)
     99          {
   \                     _Z18I2Cx_WriteMultiplehttPht: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    100            HAL_StatusTypeDef status = HAL_OK;
    101            
    102            status = HAL_I2C_Mem_Write(&heval_I2c, Addr, (uint16_t)Reg, MemAddSize, Buffer, Length, I2C_TIMEOUT);
   \   00000004   0x2064             MOVS     R0,#+100
   \   00000006   0x9002             STR      R0,[SP, #+8]
   \   00000008   0x9806             LDR      R0,[SP, #+24]
   \   0000000A   0x9001             STR      R0,[SP, #+4]
   \   0000000C   0x9300             STR      R3,[SP, #+0]
   \   0000000E   0x4613             MOV      R3,R2
   \   00000010   0x460A             MOV      R2,R1
   \   00000012   0x4621             MOV      R1,R4
   \   00000014   0x....             LDR.N    R0,??DataTable5
   \   00000016   0x.... 0x....      BL       HAL_I2C_Mem_Write
   \   0000001A   0x0005             MOVS     R5,R0
    103            
    104            /* Check the communication status */
    105            if(status != HAL_OK)
   \   0000001C   0xD002             BEQ.N    ??I2Cx_WriteMultiple_0
    106            {
    107              /* Re-Initiaize the I2C Bus */
    108              I2Cx_Error(Addr);
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       I2Cx_Error
    109            }
    110            return status;
   \                     ??I2Cx_WriteMultiple_0: (+1)
   \   00000024   0x4628             MOV      R0,R5
   \   00000026   0xBD3E             POP      {R1-R5,PC}       ;; return
    111          }
    112          
    113          /**
    114            * @brief  Checks if target device is ready for communication. 
    115            * @note   This function is used with Memory devices
    116            * @param  DevAddress: Target device address
    117            * @param  Trials: Number of trials
    118            * @retval HAL status
    119            */

   \                                 In section .text, align 2, keep-with-next
    120          HAL_StatusTypeDef I2Cx_IsDeviceReady(uint16_t DevAddress, uint32_t Trials)
    121          { 
    122            return (HAL_I2C_IsDeviceReady(&heval_I2c, DevAddress, Trials, I2C_TIMEOUT));
   \                     _Z18I2Cx_IsDeviceReadytj: (+1)
   \   00000000   0x2364             MOVS     R3,#+100
   \   00000002   0x460A             MOV      R2,R1
   \   00000004   0x4601             MOV      R1,R0
   \   00000006   0x....             LDR.N    R0,??DataTable5
   \   00000008   0x.... 0x....      B.W      HAL_I2C_IsDeviceReady
    123          }
    124          
    125          /**
    126            * @brief  Manages error callback by re-initializing I2C.
    127            * @param  Addr: I2C Address
    128            */

   \                                 In section .text, align 2, keep-with-next
    129          void I2Cx_Error(uint8_t Addr)
    130          {
   \                     I2Cx_Error: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    131          	/* De-initialize the IOE comunication BUS */
    132            HAL_I2C_DeInit(&heval_I2c);
   \   00000002   0x....             LDR.N    R0,??DataTable5
   \   00000004   0x.... 0x....      BL       HAL_I2C_MspDeInit
    133            
    134            /* Re-Initiaize the IOE comunication BUS */
    135            I2Cx_Init();  
   \   00000008   0xE8BD 0x4001      POP      {R0,LR}
   \   0000000C   0x.... 0x....      B.W      MX_I2C1_Init
    136          }
    137          
    138          /******************************** LINK I2C AT24CXX *****************************/
    139          
    140          /**
    141            * @brief  Initializes peripherals used by the I2C EEPROM driver.
    142            */

   \                                 In section .text, align 2, keep-with-next
    143          void AT24CXX_Init(void)
    144          {
    145            //I2Cx_Init();        //skyblue
    146          }
   \                     AT24CXX_Init: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    147          
    148          /**
    149            * @brief  Camera writes single data.
    150            * @param  Reg: Reg address 
    151            * @param  Value: Data to be written
    152            */

   \                                 In section .text, align 2, keep-with-next
    153          void AT24CXX_WriteByte(uint8_t Reg, uint8_t Value)
    154          {
   \                     AT24CXX_WriteByte: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    155            I2Cx_Write(AT24CXX_ADDRESS, Reg, AT24CXX_MEMADD_SIZE, Value);
   \   00000002   0x460B             MOV      R3,R1
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x4601             MOV      R1,R0
   \   00000008   0x20A0             MOVS     R0,#+160
   \   0000000A   0x.... 0x....      BL       _Z10I2Cx_Writehhth
    156          	
    157              HAL_Delay(2);       //必须延时
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xE8BD 0x4002      POP      {R1,LR}
   \   00000014   0x.... 0x....      B.W      HAL_Delay
    158          }
    159          
    160          /**
    161            * @brief  Camera reads single data.
    162            * @param  Reg: Reg address 
    163            * @retval Read data
    164            */

   \                                 In section .text, align 2, keep-with-next
    165          uint8_t AT24CXX_ReadByte(uint8_t Reg)
    166          {
    167            return I2Cx_Read(AT24CXX_ADDRESS, Reg, AT24CXX_MEMADD_SIZE);
   \                     AT24CXX_ReadByte: (+1)
   \   00000000   0x2201             MOVS     R2,#+1
   \   00000002   0x4601             MOV      R1,R0
   \   00000004   0x20A0             MOVS     R0,#+160
   \   00000006   0x....             B.N      _Z9I2Cx_Readhht
    168          }
    169          
    170          /** 描述  ：在EEPROM的一个写循环中可以写多个字节，但一次写入的字节数
    171          	*         不能超过EEPROM页的大小。AT24C04每页有16个字节。
    172          	* 输入  ：-pBuffer 缓冲区指针
    173          	*         -MemAddress 接收数据的EEPROM的地址 
    174          	*         -BufferSize 要写入EEPROM的字节数
    175          	*/

   \                                 In section .text, align 2, keep-with-next
    176          HAL_StatusTypeDef AT24CXX_PageWrite(uint16_t MemAddress, uint8_t* pBuffer, uint32_t BufferSize)
    177          {
   \                     AT24CXX_PageWrite: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    178          	HAL_StatusTypeDef status = HAL_OK;
    179          	
    180          	status = I2Cx_WriteMultiple((AT24CXX_ADDRESS+((MemAddress/256)<<1)),MemAddress,AT24CXX_MEMADD_SIZE, pBuffer,BufferSize); //skyblue
   \   00000004   0xB292             UXTH     R2,R2
   \   00000006   0x9200             STR      R2,[SP, #+0]
   \   00000008   0x460B             MOV      R3,R1
   \   0000000A   0x2201             MOVS     R2,#+1
   \   0000000C   0x4601             MOV      R1,R0
   \   0000000E   0x0A00             LSRS     R0,R0,#+8
   \   00000010   0x0040             LSLS     R0,R0,#+1
   \   00000012   0x30A0             ADDS     R0,R0,#+160
   \   00000014   0xB2C0             UXTB     R0,R0
   \   00000016   0x.... 0x....      BL       _Z18I2Cx_WriteMultiplehttPht
   \   0000001A   0x4604             MOV      R4,R0
    181          	
    182          	HAL_Delay(5);   //必须延时
   \   0000001C   0x2005             MOVS     R0,#+5
   \   0000001E   0x.... 0x....      BL       HAL_Delay
    183          	return status;
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    184          }
    185          
    186          /**
    187            * @brief Write data to I2C EEPROM driver in using DMA channel
    188            * @param MemAddress: memory address
    189            * @param pBuffer: Pointer to data buffer
    190            * @param BufferSize: Amount of data to be sent
    191            * @retval HAL status
    192            */

   \                                 In section .text, align 2, keep-with-next
    193          HAL_StatusTypeDef AT24CXX_Write(uint16_t MemAddress, uint8_t* pBuffer, uint32_t BufferSize)
    194          {
   \                     AT24CXX_Write: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    195          	uint8_t NumOfPage = 0, NumOfSingle = 0, Addr = 0, count = 0;
    196          	HAL_StatusTypeDef err = HAL_OK;
   \   00000008   0x2000             MOVS     R0,#+0
    197          
    198          	Addr = MemAddress % AT24CXX_PAGE_SIZE;
   \   0000000A   0xF004 0x010F      AND      R1,R4,#0xF
    199          	count = AT24CXX_PAGE_SIZE - Addr;
   \   0000000E   0xF1C1 0x0610      RSB      R6,R1,#+16
   \   00000012   0xB2F6             UXTB     R6,R6
    200          	NumOfPage =  BufferSize / AT24CXX_PAGE_SIZE;
   \   00000014   0x0917             LSRS     R7,R2,#+4
    201          	NumOfSingle = BufferSize % AT24CXX_PAGE_SIZE;
   \   00000016   0xF002 0x080F      AND      R8,R2,#0xF
    202           
    203          	/* If WriteAddr is I2C_PageSize aligned  */
    204          	if(Addr == 0) 
   \   0000001A   0x2900             CMP      R1,#+0
   \   0000001C   0xD120             BNE.N    ??AT24CXX_Write_0
    205          	{
    206          		/* If NumByteToWrite < I2C_PageSize */
    207          		if(NumOfPage == 0) 
   \   0000001E   0xB2FF             UXTB     R7,R7
   \   00000020   0x2F00             CMP      R7,#+0
   \   00000022   0xD10E             BNE.N    ??AT24CXX_Write_1
    208          		{
    209          			return (AT24CXX_PageWrite(MemAddress,pBuffer,BufferSize));
   \   00000024   0x4629             MOV      R1,R5
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   0000002C   0x....             B.N      AT24CXX_PageWrite
    210          		}
    211          		/* If NumByteToWrite > I2C_PageSize */
    212          		else  
    213          		{
    214          			while(NumOfPage--)
    215          			{
    216          				err = AT24CXX_PageWrite(MemAddress,pBuffer,AT24CXX_PAGE_SIZE);
   \                     ??AT24CXX_Write_2: (+1)
   \   0000002E   0x2210             MOVS     R2,#+16
   \   00000030   0x4629             MOV      R1,R5
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0xB280             UXTH     R0,R0
   \   00000036   0x.... 0x....      BL       AT24CXX_PageWrite
    217          				if(err != HAL_OK)
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD13F             BNE.N    ??AT24CXX_Write_3
    218          					return err; 
    219          				MemAddress +=  AT24CXX_PAGE_SIZE;
   \   0000003E   0x3410             ADDS     R4,R4,#+16
    220          				pBuffer += AT24CXX_PAGE_SIZE;
   \   00000040   0x3510             ADDS     R5,R5,#+16
    221          			}
   \                     ??AT24CXX_Write_1: (+1)
   \   00000042   0x4639             MOV      R1,R7
   \   00000044   0x1E4F             SUBS     R7,R1,#+1
   \   00000046   0xB2C9             UXTB     R1,R1
   \   00000048   0x2900             CMP      R1,#+0
   \   0000004A   0xD1F0             BNE.N    ??AT24CXX_Write_2
    222          
    223          			if(NumOfSingle!=0)
   \   0000004C   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000050   0xD035             BEQ.N    ??AT24CXX_Write_3
    224          			{
    225          				return (AT24CXX_PageWrite(MemAddress,pBuffer,NumOfSingle)); 
   \   00000052   0x4642             MOV      R2,R8
   \   00000054   0x4629             MOV      R1,R5
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0xB280             UXTH     R0,R0
   \   0000005A   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   0000005E   0x....             B.N      AT24CXX_PageWrite
    226          			}
    227          		}
    228          	}
    229          	  /* If WriteAddr is not I2C_PageSize aligned  */
    230          	else 
    231          	{
    232          		/* If NumByteToWrite < I2C_PageSize */
    233          		if(BufferSize <= count) 
   \                     ??AT24CXX_Write_0: (+1)
   \   00000060   0x4296             CMP      R6,R2
   \   00000062   0xD305             BCC.N    ??AT24CXX_Write_4
    234          		{
    235          			return (AT24CXX_PageWrite(MemAddress,pBuffer,NumOfSingle));
   \   00000064   0x4642             MOV      R2,R8
   \   00000066   0x4629             MOV      R1,R5
   \   00000068   0x4620             MOV      R0,R4
   \   0000006A   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   0000006E   0x....             B.N      AT24CXX_PageWrite
    236          		}
    237          		/* If NumByteToWrite > I2C_PageSize */
    238          		else
    239          		{
    240          			BufferSize -= count;
   \                     ??AT24CXX_Write_4: (+1)
   \   00000070   0x1B92             SUBS     R2,R2,R6
    241          			NumOfPage =  BufferSize / AT24CXX_PAGE_SIZE;
   \   00000072   0x0917             LSRS     R7,R2,#+4
    242          			NumOfSingle = BufferSize % AT24CXX_PAGE_SIZE;	
   \   00000074   0xF002 0x080F      AND      R8,R2,#0xF
    243          		  
    244          			err = AT24CXX_PageWrite(MemAddress,pBuffer,count);
   \   00000078   0x4632             MOV      R2,R6
   \   0000007A   0x4629             MOV      R1,R5
   \   0000007C   0x4620             MOV      R0,R4
   \   0000007E   0x.... 0x....      BL       AT24CXX_PageWrite
    245          			if(err != HAL_OK)
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD11B             BNE.N    ??AT24CXX_Write_3
    246          				return err; 
    247          			MemAddress += count;
   \   00000086   0x1934             ADDS     R4,R6,R4
    248          			pBuffer += count;
   \   00000088   0x1975             ADDS     R5,R6,R5
   \   0000008A   0xE009             B.N      ??AT24CXX_Write_5
    249          		  
    250          			while(NumOfPage--)
    251          			{
    252          				err = AT24CXX_PageWrite(MemAddress,pBuffer,AT24CXX_PAGE_SIZE);
   \                     ??AT24CXX_Write_6: (+1)
   \   0000008C   0x2210             MOVS     R2,#+16
   \   0000008E   0x4629             MOV      R1,R5
   \   00000090   0x4620             MOV      R0,R4
   \   00000092   0xB280             UXTH     R0,R0
   \   00000094   0x.... 0x....      BL       AT24CXX_PageWrite
    253          				if(err != HAL_OK)
   \   00000098   0x2800             CMP      R0,#+0
   \   0000009A   0xD110             BNE.N    ??AT24CXX_Write_3
    254          					return err;
    255          				MemAddress +=  AT24CXX_PAGE_SIZE;
   \   0000009C   0x3410             ADDS     R4,R4,#+16
    256          				pBuffer += AT24CXX_PAGE_SIZE;  
   \   0000009E   0x3510             ADDS     R5,R5,#+16
    257          			}
   \                     ??AT24CXX_Write_5: (+1)
   \   000000A0   0x4639             MOV      R1,R7
   \   000000A2   0x1E4F             SUBS     R7,R1,#+1
   \   000000A4   0xB2C9             UXTB     R1,R1
   \   000000A6   0x2900             CMP      R1,#+0
   \   000000A8   0xD1F0             BNE.N    ??AT24CXX_Write_6
    258          			
    259          			if(NumOfSingle != 0)
   \   000000AA   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000AE   0xD006             BEQ.N    ??AT24CXX_Write_3
    260          			{
    261          				return (AT24CXX_PageWrite(MemAddress,pBuffer,NumOfSingle)); 
   \   000000B0   0x4642             MOV      R2,R8
   \   000000B2   0x4629             MOV      R1,R5
   \   000000B4   0x4620             MOV      R0,R4
   \   000000B6   0xB280             UXTH     R0,R0
   \   000000B8   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   000000BC   0x....             B.N      AT24CXX_PageWrite
    262          			}
    263          		}
    264          	}
    265          
    266          	return err;
   \                     ??AT24CXX_Write_3: (+1)
   \   000000BE   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    267          }
    268          
    269          /**
    270            * @brief  Reads data from I2C EEPROM driver in using DMA channel.
    271            * @param  MemAddress: memory address
    272            * @param  pBuffer: Pointer to data buffer
    273            * @param  BufferSize: Amount of data to be read
    274            * @retval HAL status
    275            */

   \                                 In section .text, align 2, keep-with-next
    276          HAL_StatusTypeDef AT24CXX_Read(uint16_t MemAddress, uint8_t* pBuffer, uint32_t BufferSize)
    277          {
   \                     AT24CXX_Read: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    278            return (I2Cx_ReadMultiple((AT24CXX_ADDRESS+((MemAddress/256)<<1)), MemAddress, AT24CXX_MEMADD_SIZE, pBuffer, BufferSize));    
   \   00000002   0xB292             UXTH     R2,R2
   \   00000004   0x9200             STR      R2,[SP, #+0]
   \   00000006   0x460B             MOV      R3,R1
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0x4601             MOV      R1,R0
   \   0000000C   0x0A00             LSRS     R0,R0,#+8
   \   0000000E   0x0040             LSLS     R0,R0,#+1
   \   00000010   0x30A0             ADDS     R0,R0,#+160
   \   00000012   0xB2C0             UXTB     R0,R0
   \   00000014   0x.... 0x....      BL       _Z17I2Cx_ReadMultiplehttPht
   \   00000018   0xBD02             POP      {R1,PC}          ;; return
    279          }
    280          
    281          /**
    282            * @brief  Checks if target device is ready for communication. 
    283            * @note   This function is used with Memory devices
    284            * @param  Trials: Number of trials
    285            * @retval HAL status
    286            */

   \                                 In section .text, align 2, keep-with-next
    287          HAL_StatusTypeDef AT24CXX_IsDeviceReady(uint32_t Trials)
    288          { 
    289            return (I2Cx_IsDeviceReady(AT24CXX_ADDRESS, Trials));
   \                     AT24CXX_IsDeviceReady: (+1)
   \   00000000   0x4601             MOV      R1,R0
   \   00000002   0x20A0             MOVS     R0,#+160
   \   00000004   0x....             B.N      _Z18I2Cx_IsDeviceReadytj
    290          }
    291          
    292          //检查AT24CXX是否正常
    293          //这里用了24XX的最后一个地址(2047)来存储标志字.
    294          //如果用其他24C系列,这个地址要修改
    295          //返回1:检测失败
    296          //返回0:检测成功

   \                                 In section .text, align 2, keep-with-next
    297          uint8_t AT24CXX_Check(void)
    298          {
   \                     AT24CXX_Check: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    299          	uint8_t temp;
    300          	temp=AT24CXX_ReadByte(AT24CXX_TYPE);//避免每次开机都写AT24CXX			   
                 	                      ^
Warning[Pe069]: integer conversion resulted in truncation
    301          	if(temp==0XAA)return 0;		   
   \   00000002   0x20FF             MOVS     R0,#+255
   \   00000004   0x.... 0x....      BL       AT24CXX_ReadByte
   \   00000008   0x28AA             CMP      R0,#+170
   \   0000000A   0xD101             BNE.N    ??AT24CXX_Check_0
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xBD02             POP      {R1,PC}
    302          	else//排除第一次初始化的情况
    303          	{
    304                      AT24CXX_WriteByte(AT24CXX_TYPE,0XAA);
                                               ^
Warning[Pe069]: integer conversion resulted in truncation
   \                     ??AT24CXX_Check_0: (+1)
   \   00000010   0x21AA             MOVS     R1,#+170
   \   00000012   0x20FF             MOVS     R0,#+255
   \   00000014   0x.... 0x....      BL       AT24CXX_WriteByte
    305          	    temp=AT24CXX_ReadByte(AT24CXX_TYPE);	  
                 	                          ^
Warning[Pe069]: integer conversion resulted in truncation
    306                      if(temp==0XAA)return 0;
   \   00000018   0x20FF             MOVS     R0,#+255
   \   0000001A   0x.... 0x....      BL       AT24CXX_ReadByte
   \   0000001E   0x28AA             CMP      R0,#+170
   \   00000020   0xD101             BNE.N    ??AT24CXX_Check_1
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xBD02             POP      {R1,PC}
    307          	}
    308          	return 1;											  
   \                     ??AT24CXX_Check_1: (+1)
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xBD02             POP      {R1,PC}          ;; return
    309          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     hi2c1
    310          
    311          
    312          
    313          
    314          
    315          
    316          
    317          
    318          
    319          
    320          
    321          
    322          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   AT24CXX_Check
         8   -> AT24CXX_ReadByte
         8   -> AT24CXX_WriteByte
       0   AT24CXX_Init
       0   AT24CXX_IsDeviceReady
         0   -> I2Cx_IsDeviceReady(uint16_t, uint32_t)
      16   AT24CXX_PageWrite
        16   -> HAL_Delay
        16   -> I2Cx_WriteMultiple(uint8_t, uint16_t, uint16_t, uint8_t *, uint16_t)
       8   AT24CXX_Read
         8   -> I2Cx_ReadMultiple(uint8_t, uint16_t, uint16_t, uint8_t *, uint16_t)
       0   AT24CXX_ReadByte
         0   -> I2Cx_Read(uint8_t, uint8_t, uint16_t)
      24   AT24CXX_Write
         0   -> AT24CXX_PageWrite
        24   -> AT24CXX_PageWrite
       8   AT24CXX_WriteByte
         0   -> HAL_Delay
         8   -> I2Cx_Write(uint8_t, uint8_t, uint16_t, uint8_t)
       8   I2Cx_Error
         8   -> HAL_I2C_MspDeInit
         0   -> MX_I2C1_Init
       0   I2Cx_IsDeviceReady(uint16_t, uint32_t)
         0   -> HAL_I2C_IsDeviceReady
      24   I2Cx_Read(uint8_t, uint8_t, uint16_t)
        24   -> HAL_I2C_Mem_Read
        24   -> I2Cx_Error
      24   I2Cx_ReadMultiple(uint8_t, uint16_t, uint16_t, uint8_t *, uint16_t)
        24   -> HAL_I2C_Mem_Read
        24   -> I2Cx_Error
      24   I2Cx_Write(uint8_t, uint8_t, uint16_t, uint8_t)
        24   -> HAL_I2C_Mem_Write
        24   -> I2Cx_Error
      24   I2Cx_WriteMultiple(uint8_t, uint16_t, uint16_t, uint8_t *, uint16_t)
        24   -> HAL_I2C_Mem_Write
        24   -> I2Cx_Error


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
      42  AT24CXX_Check
       2  AT24CXX_Init
       6  AT24CXX_IsDeviceReady
      38  AT24CXX_PageWrite
      26  AT24CXX_Read
       8  AT24CXX_ReadByte
     194  AT24CXX_Write
      24  AT24CXX_WriteByte
      16  I2Cx_Error
      12  I2Cx_IsDeviceReady(uint16_t, uint32_t)
      52  I2Cx_Read(uint8_t, uint8_t, uint16_t)
      40  I2Cx_ReadMultiple(uint8_t, uint16_t, uint16_t, uint8_t *, uint16_t)
      40  I2Cx_Write(uint8_t, uint8_t, uint16_t, uint8_t)
      40  I2Cx_WriteMultiple(uint8_t, uint16_t, uint16_t, uint8_t *, uint16_t)

 
 544 bytes in section .text
 
 544 bytes of CODE memory

Errors: none
Warnings: 3
