###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  10:59:19
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Widget\MULTIPAGE.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Widget\MULTIPAGE.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\MULTIPAGE.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\MULTIPAGE.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Widget\MULTIPAGE.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              µC/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : MULTIPAGE.c
     16          Purpose     : Implementation of MULTIPAGE widget
     17          ---------------------------END-OF-HEADER------------------------------
     18          */
     19          
     20          #include <stdlib.h>
     21          #include <string.h>
     22          #include "GUI_Protected.h"
     23          #include "GUI_ARRAY.h"
     24          #include "MULTIPAGE_Private.h"
     25          #include "WIDGET.h"
     26          
     27          #if GUI_WINSUPPORT
     28          
     29          /*********************************************************************
     30          *
     31          *       Macros for internal use
     32          *
     33          **********************************************************************
     34          */
     35          
     36          #define MAX(a, b)	((a > b) ? a : b)
     37          
     38          /*********************************************************************
     39          *
     40          *       Private config defaults
     41          *
     42          **********************************************************************
     43          */
     44           
     45          /* Define default fonts */
     46          #ifndef MULTIPAGE_FONT_DEFAULT
     47            #define MULTIPAGE_FONT_DEFAULT        &GUI_Font13_1
     48          #endif
     49          
     50          #ifndef MULTIPAGE_ALIGN_DEFAULT
     51            #define MULTIPAGE_ALIGN_DEFAULT       (MULTIPAGE_ALIGN_LEFT | MULTIPAGE_ALIGN_TOP)
     52          #endif
     53          
     54          /* Define colors */
     55          #define MULTIPAGE_NUMCOLORS 2
     56          
     57          #ifndef MULTIPAGE_BKCOLOR0_DEFAULT
     58            #define MULTIPAGE_BKCOLOR0_DEFAULT    0xD0D0D0 /* disabled page */
     59          #endif
     60          
     61          #ifndef MULTIPAGE_BKCOLOR1_DEFAULT
     62            #define MULTIPAGE_BKCOLOR1_DEFAULT    0xC0C0C0 /* enabled page */
     63          #endif
     64          
     65          #ifndef MULTIPAGE_TEXTCOLOR0_DEFAULT
     66            #define MULTIPAGE_TEXTCOLOR0_DEFAULT  0x808080 /* disabled page */
     67          #endif
     68          
     69          #ifndef MULTIPAGE_TEXTCOLOR1_DEFAULT
     70            #define MULTIPAGE_TEXTCOLOR1_DEFAULT  0x000000 /* enabled page */
     71          #endif
     72          
     73          /*********************************************************************
     74          *
     75          *       Object definition
     76          *
     77          **********************************************************************
     78          */
     79          
     80          typedef struct {
     81            WM_HWIN hWin;
     82            U8      Status;
     83            char    acText;
     84          } MULTIPAGE_PAGE;
     85          
     86          typedef struct {
     87            WIDGET          Widget;
     88            WM_HWIN         hClient;
     89            GUI_ARRAY       Handles;
     90            unsigned        Selection;
     91            int             ScrollState;
     92            unsigned        Align;
     93            const GUI_FONT GUI_UNI_PTR * Font;
     94            GUI_COLOR       aBkColor[MULTIPAGE_NUMCOLORS];
     95            GUI_COLOR       aTextColor[MULTIPAGE_NUMCOLORS];
     96            #if GUI_DEBUG_LEVEL >1
     97              int DebugId;
     98            #endif  
     99          } MULTIPAGE_Obj;
    100          
    101          /*********************************************************************
    102          *
    103          *       Static data
    104          *
    105          **********************************************************************
    106          */
    107          

   \                                 In section .data, align 4
    108          const GUI_FONT GUI_UNI_PTR * MULTIPAGE__pDefaultFont        = MULTIPAGE_FONT_DEFAULT;
    109          unsigned                     MULTIPAGE__DefaultAlign        = MULTIPAGE_ALIGN_DEFAULT;
    110          GUI_COLOR                    MULTIPAGE__DefaultBkColor[2]   = { MULTIPAGE_BKCOLOR0_DEFAULT, MULTIPAGE_BKCOLOR1_DEFAULT };
   \                     MULTIPAGE__DefaultBkColor:
   \   00000000   0x00D0D0D0         DC32 13684944, 12632256
   \              0x00C0C0C0   
    111          GUI_COLOR                    MULTIPAGE__DefaultTextColor[2] = { MULTIPAGE_TEXTCOLOR0_DEFAULT, MULTIPAGE_TEXTCOLOR1_DEFAULT };
   \                     MULTIPAGE__DefaultTextColor:
   \   00000008   0x00808080         DC32 8421504, 0
   \              0x00000000   
   \                     MULTIPAGE__pDefaultFont:
   \   00000010   0x........         DC32 GUI_Font13_1
   \                     MULTIPAGE__DefaultAlign:
   \   00000014   0x00000000         DC32 0
    112          
    113          /*********************************************************************
    114          *
    115          *       Static code, helper functions
    116          *
    117          **********************************************************************
    118          */
    119          /*********************************************************************
    120          *
    121          *       _AddScrollbar
    122          */

   \                                 In section .text, align 2, keep-with-next
    123          static void _AddScrollbar(MULTIPAGE_Handle hObj, MULTIPAGE_Obj* pObj, int x, int y, int w, int h) {
   \                     _AddScrollbar: (+1)
   \   00000000   0xE92D 0x47FF      PUSH     {R0-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x461F             MOV      R7,R3
    124            SCROLLBAR_Handle hScroll;
    125            if ((hScroll = WM_GetScrollbarH(hObj)) == 0) {
   \   0000000C   0x.... 0x....      BL       WM_GetScrollbarH
   \   00000010   0x4682             MOV      R10,R0
   \   00000012   0xF8DD 0x8030      LDR      R8,[SP, #+48]
   \   00000016   0xF8DD 0x9034      LDR      R9,[SP, #+52]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD110             BNE.N    ??_AddScrollbar_0
    126              hScroll = SCROLLBAR_Create(x, y, w, h, hObj, GUI_ID_HSCROLL, WM_CF_SHOW, 0);
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x9003             STR      R0,[SP, #+12]
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0x9002             STR      R0,[SP, #+8]
   \   00000026   0x20FF             MOVS     R0,#+255
   \   00000028   0x9001             STR      R0,[SP, #+4]
   \   0000002A   0x9400             STR      R4,[SP, #+0]
   \   0000002C   0x464B             MOV      R3,R9
   \   0000002E   0x4642             MOV      R2,R8
   \   00000030   0x4639             MOV      R1,R7
   \   00000032   0x4630             MOV      R0,R6
   \   00000034   0x.... 0x....      BL       SCROLLBAR_Create
    127              WIDGET_SetEffect(hScroll, pObj->Widget.pEffect);
   \   00000038   0x6A29             LDR      R1,[R5, #+32]
   \   0000003A   0x.... 0x....      BL       WIDGET_SetEffect
   \   0000003E   0xE008             B.N      ??_AddScrollbar_1
    128            } else {
    129              WM_MoveChildTo(hScroll, x, y);
   \                     ??_AddScrollbar_0: (+1)
   \   00000040   0x463A             MOV      R2,R7
   \   00000042   0x4631             MOV      R1,R6
   \   00000044   0x.... 0x....      BL       WM_MoveChildTo
    130              WM_SetSize(hScroll, w, h);
   \   00000048   0x464A             MOV      R2,R9
   \   0000004A   0x4641             MOV      R1,R8
   \   0000004C   0x4650             MOV      R0,R10
   \   0000004E   0x.... 0x....      BL       WM_SetSize
    131            }
    132            pObj->Widget.State |= MULTIPAGE_STATE_SCROLLMODE;
   \                     ??_AddScrollbar_1: (+1)
   \   00000052   0x8CE8             LDRH     R0,[R5, #+38]
   \   00000054   0xF440 0x7080      ORR      R0,R0,#0x100
   \   00000058   0x84E8             STRH     R0,[R5, #+38]
    133          }
   \   0000005A   0xE8BD 0x87FF      POP      {R0-R10,PC}      ;; return
    134          
    135          /*********************************************************************
    136          *
    137          *       _SetScrollbar
    138          */

   \                                 In section .text, align 2, keep-with-next
    139          static void _SetScrollbar(MULTIPAGE_Handle hObj, MULTIPAGE_Obj* pObj, int NumItems) {
   \                     _SetScrollbar: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x4615             MOV      R5,R2
    140            SCROLLBAR_Handle hScroll;
    141            hScroll = WM_GetScrollbarH(hObj);
   \   00000006   0x.... 0x....      BL       WM_GetScrollbarH
   \   0000000A   0x4606             MOV      R6,R0
    142            SCROLLBAR_SetNumItems(hScroll, NumItems);
   \   0000000C   0x4629             MOV      R1,R5
   \   0000000E   0x.... 0x....      BL       SCROLLBAR_SetNumItems
    143            SCROLLBAR_SetPageSize(hScroll, 1);
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0x4630             MOV      R0,R6
   \   00000016   0x.... 0x....      BL       SCROLLBAR_SetPageSize
    144            if (pObj->ScrollState >= NumItems) {
   \   0000001A   0x6B60             LDR      R0,[R4, #+52]
   \   0000001C   0x42A8             CMP      R0,R5
   \   0000001E   0xDB01             BLT.N    ??_SetScrollbar_0
    145              pObj->ScrollState = 0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x6360             STR      R0,[R4, #+52]
    146            }
    147            SCROLLBAR_SetValue(hScroll, pObj->ScrollState);
   \                     ??_SetScrollbar_0: (+1)
   \   00000024   0x6B61             LDR      R1,[R4, #+52]
   \   00000026   0x4630             MOV      R0,R6
   \   00000028   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000002C   0x.... 0x....      B.W      SCROLLBAR_SetValue
    148          }
    149          
    150          /*********************************************************************
    151          *
    152          *       _DeleteScrollbar
    153          */

   \                                 In section .text, align 2, keep-with-next
    154          static void _DeleteScrollbar(MULTIPAGE_Handle hObj, MULTIPAGE_Obj* pObj) {
   \                     _DeleteScrollbar: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
    155            WM_DeleteWindow(WM_GetScrollbarH(hObj));
   \   00000004   0x.... 0x....      BL       WM_GetScrollbarH
   \   00000008   0x.... 0x....      BL       WM_DeleteWindow
    156            pObj->Widget.State &= ~MULTIPAGE_STATE_SCROLLMODE;
   \   0000000C   0x8CE0             LDRH     R0,[R4, #+38]
   \   0000000E   0xF64F 0x61FF      MOVW     R1,#+65279
   \   00000012   0x4008             ANDS     R0,R1,R0
   \   00000014   0x84E0             STRH     R0,[R4, #+38]
    157          }
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
    158          
    159          /*********************************************************************
    160          *
    161          *       _ShowPage
    162          */

   \                                 In section .text, align 2, keep-with-next
    163          static void _ShowPage(MULTIPAGE_Obj* pObj, unsigned Index) {
   \                     _ShowPage: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    164            WM_HWIN hWin = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    165            WM_HWIN hChild;
    166            WM_Obj* pChild;
    167            WM_Obj* pClient = WM_H2P(pObj->hClient);
   \   00000008   0xF9B4 0x0028      LDRSH    R0,[R4, #+40]
   \   0000000C   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000010   0x4607             MOV      R7,R0
    168            if ((int)Index < pObj->Handles.NumItems) {
   \   00000012   0x8D60             LDRH     R0,[R4, #+42]
   \   00000014   0x4285             CMP      R5,R0
   \   00000016   0xDA06             BGE.N    ??_ShowPage_0
    169              MULTIPAGE_PAGE* pPage;
    170              pPage = (MULTIPAGE_PAGE*) GUI_ARRAY_GetpItem(&pObj->Handles, Index);
   \   00000018   0x4629             MOV      R1,R5
   \   0000001A   0xF104 0x002A      ADD      R0,R4,#+42
   \   0000001E   0x.... 0x....      BL       GUI_ARRAY_GetpItem
    171              hWin = pPage->hWin;
   \   00000022   0xF9B0 0x6000      LDRSH    R6,[R0, #+0]
    172            }
    173            for (hChild = pClient->hFirstChild; hChild; hChild = pChild->hNext) {
   \                     ??_ShowPage_0: (+1)
   \   00000026   0xF9B7 0x4018      LDRSH    R4,[R7, #+24]
   \   0000002A   0xE003             B.N      ??_ShowPage_1
    174              pChild = WM_H2P(hChild);
    175              if (hChild == hWin) {
    176                WM_ShowWindow(hChild);
    177                WM_SetFocus(hChild);
    178              } else {
    179                WM_HideWindow(hChild);
   \                     ??_ShowPage_2: (+1)
   \   0000002C   0x.... 0x....      BL       WM_HideWindow
    180              }
   \                     ??_ShowPage_3: (+1)
   \   00000030   0xF9B5 0x401A      LDRSH    R4,[R5, #+26]
   \                     ??_ShowPage_1: (+1)
   \   00000034   0x2C00             CMP      R4,#+0
   \   00000036   0xD00C             BEQ.N    ??_ShowPage_4
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000003E   0x4605             MOV      R5,R0
   \   00000040   0x42B4             CMP      R4,R6
   \   00000042   0x4620             MOV      R0,R4
   \   00000044   0xD1F2             BNE.N    ??_ShowPage_2
   \   00000046   0x.... 0x....      BL       WM_ShowWindow
   \   0000004A   0x4620             MOV      R0,R4
   \   0000004C   0x.... 0x....      BL       WM_SetFocus
   \   00000050   0xE7EE             B.N      ??_ShowPage_3
    181            }
    182          }
   \                     ??_ShowPage_4: (+1)
   \   00000052   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    183          
    184          /*********************************************************************
    185          *
    186          *       _SetEnable
    187          */

   \                                 In section .text, align 2, keep-with-next
    188          static void _SetEnable(MULTIPAGE_Obj* pObj, unsigned Index, int State) {
   \                     _SetEnable: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4614             MOV      R4,R2
    189            if ((int)Index < pObj->Handles.NumItems) {
   \   00000004   0x8D42             LDRH     R2,[R0, #+42]
   \   00000006   0x4291             CMP      R1,R2
   \   00000008   0xDA0C             BGE.N    ??_SetEnable_0
    190              MULTIPAGE_PAGE* pPage;
    191              pPage = (MULTIPAGE_PAGE*) GUI_ARRAY_GetpItem(&pObj->Handles, Index);
   \   0000000A   0x302A             ADDS     R0,R0,#+42
   \   0000000C   0x.... 0x....      BL       GUI_ARRAY_GetpItem
    192              if (State) {
   \   00000010   0x7881             LDRB     R1,[R0, #+2]
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD003             BEQ.N    ??_SetEnable_1
    193                pPage->Status |= MULTIPAGE_STATE_ENABLED;
   \   00000016   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000001A   0x7081             STRB     R1,[R0, #+2]
   \   0000001C   0xBD10             POP      {R4,PC}
    194              } else {
    195                pPage->Status &= ~MULTIPAGE_STATE_ENABLED;
   \                     ??_SetEnable_1: (+1)
   \   0000001E   0xF001 0x01FE      AND      R1,R1,#0xFE
   \   00000022   0x7081             STRB     R1,[R0, #+2]
    196              }
    197            }
    198          }
   \                     ??_SetEnable_0: (+1)
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    199          
    200          /*********************************************************************
    201          *
    202          *       _GetEnable
    203          */

   \                                 In section .text, align 2, keep-with-next
    204          static int _GetEnable(MULTIPAGE_Obj* pObj, unsigned Index) {
   \                     _GetEnable: (+1)
   \   00000000   0x4602             MOV      R2,R0
    205            int r = 0;
   \   00000002   0x2000             MOVS     R0,#+0
    206            if ((int)Index < pObj->Handles.NumItems) {
   \   00000004   0x8D53             LDRH     R3,[R2, #+42]
   \   00000006   0x4299             CMP      R1,R3
   \   00000008   0xDB00             BLT.N    ??_GetEnable_0
   \   0000000A   0x4770             BX       LR
    207              MULTIPAGE_PAGE* pPage;
    208              pPage = (MULTIPAGE_PAGE*) GUI_ARRAY_GetpItem(&pObj->Handles, Index);
   \                     ??_GetEnable_0: (+1)
   \   0000000C   0xB580             PUSH     {R7,LR}
   \   0000000E   0xF102 0x002A      ADD      R0,R2,#+42
   \   00000012   0x.... 0x....      BL       GUI_ARRAY_GetpItem
    209              r = (pPage->Status & MULTIPAGE_STATE_ENABLED) ? 1 : 0;
   \   00000016   0x7880             LDRB     R0,[R0, #+2]
   \   00000018   0xF000 0x0001      AND      R0,R0,#0x1
    210            }
    211            return r;
   \   0000001C   0xBD02             POP      {R1,PC}          ;; return
    212          }
    213          
    214          /*********************************************************************
    215          *
    216          *       _CalcClientRect
    217          *
    218          *  Calculates the rect of the client area.
    219          */

   \                                 In section .text, align 2, keep-with-next
    220          static void _CalcClientRect(MULTIPAGE_Obj* pObj, GUI_RECT* pRect) {
   \                     _CalcClientRect: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460C             MOV      R4,R1
    221            WIDGET__GetInsideRect(&pObj->Widget, pRect);
   \   00000006   0x.... 0x....      BL       WIDGET__GetInsideRect
    222            if (pObj->Align & MULTIPAGE_ALIGN_BOTTOM) {
   \   0000000A   0x6BE8             LDR      R0,[R5, #+60]
   \   0000000C   0xF895 0x1038      LDRB     R1,[R5, #+56]
   \   00000010   0x0749             LSLS     R1,R1,#+29
   \   00000012   0xD506             BPL.N    ??_CalcClientRect_0
    223              pRect->y1 -= GUI_GetYSizeOfFont(pObj->Font) + 6;
   \   00000014   0x88E5             LDRH     R5,[R4, #+6]
   \   00000016   0x.... 0x....      BL       GUI_GetYSizeOfFont
   \   0000001A   0x1A28             SUBS     R0,R5,R0
   \   0000001C   0x1F80             SUBS     R0,R0,#+6
   \   0000001E   0x80E0             STRH     R0,[R4, #+6]
   \   00000020   0xBD31             POP      {R0,R4,R5,PC}
    224            } else {
    225              pRect->y0 += GUI_GetYSizeOfFont(pObj->Font) + 6;
   \                     ??_CalcClientRect_0: (+1)
   \   00000022   0x8865             LDRH     R5,[R4, #+2]
   \   00000024   0x.... 0x....      BL       GUI_GetYSizeOfFont
   \   00000028   0x1D80             ADDS     R0,R0,#+6
   \   0000002A   0x1940             ADDS     R0,R0,R5
   \   0000002C   0x8060             STRH     R0,[R4, #+2]
    226            }
    227          }
   \   0000002E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    228          
    229          /*********************************************************************
    230          *
    231          *       _CalcBorderRect
    232          *
    233          *  Calculates the border rect of the client area.
    234          */

   \                                 In section .text, align 2, keep-with-next
    235          static void _CalcBorderRect(MULTIPAGE_Obj* pObj, GUI_RECT* pRect) {
   \                     _CalcBorderRect: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460C             MOV      R4,R1
    236            WM__GetClientRectWin(&pObj->Widget.Win, pRect);
   \   00000006   0x.... 0x....      BL       WM__GetClientRectWin
    237            if (pObj->Align & MULTIPAGE_ALIGN_BOTTOM) {
   \   0000000A   0x6BE8             LDR      R0,[R5, #+60]
   \   0000000C   0xF895 0x1038      LDRB     R1,[R5, #+56]
   \   00000010   0x0749             LSLS     R1,R1,#+29
   \   00000012   0xD506             BPL.N    ??_CalcBorderRect_0
    238              pRect->y1 -= GUI_GetYSizeOfFont(pObj->Font) + 6;
   \   00000014   0x88E5             LDRH     R5,[R4, #+6]
   \   00000016   0x.... 0x....      BL       GUI_GetYSizeOfFont
   \   0000001A   0x1A28             SUBS     R0,R5,R0
   \   0000001C   0x1F80             SUBS     R0,R0,#+6
   \   0000001E   0x80E0             STRH     R0,[R4, #+6]
   \   00000020   0xBD31             POP      {R0,R4,R5,PC}
    239            } else {
    240              pRect->y0 += GUI_GetYSizeOfFont(pObj->Font) + 6;
   \                     ??_CalcBorderRect_0: (+1)
   \   00000022   0x8865             LDRH     R5,[R4, #+2]
   \   00000024   0x.... 0x....      BL       GUI_GetYSizeOfFont
   \   00000028   0x1D80             ADDS     R0,R0,#+6
   \   0000002A   0x1940             ADDS     R0,R0,R5
   \   0000002C   0x8060             STRH     R0,[R4, #+2]
    241            }
    242          }
   \   0000002E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    243          
    244          /*********************************************************************
    245          *
    246          *       _GetPageSizeX
    247          *
    248          *  Returns the width of a page item.
    249          */

   \                                 In section .text, align 2, keep-with-next
    250          static int _GetPageSizeX(MULTIPAGE_Obj* pObj, unsigned Index) {
   \                     _GetPageSizeX: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    251            int r = 0;
   \   00000006   0x2000             MOVS     R0,#+0
    252            if ((int)Index < pObj->Handles.NumItems) {
   \   00000008   0x8D61             LDRH     R1,[R4, #+42]
   \   0000000A   0x428D             CMP      R5,R1
   \   0000000C   0xDA0B             BGE.N    ??_GetPageSizeX_0
    253              MULTIPAGE_PAGE* pPage;
    254              GUI_SetFont(pObj->Font);
   \   0000000E   0x6BE0             LDR      R0,[R4, #+60]
   \   00000010   0x.... 0x....      BL       GUI_SetFont
    255              pPage = (MULTIPAGE_PAGE*) GUI_ARRAY_GetpItem(&pObj->Handles, Index);
   \   00000014   0x4629             MOV      R1,R5
   \   00000016   0xF104 0x002A      ADD      R0,R4,#+42
   \   0000001A   0x.... 0x....      BL       GUI_ARRAY_GetpItem
    256              r = GUI_GetStringDistX(&pPage->acText) + 10;
   \   0000001E   0x1CC0             ADDS     R0,R0,#+3
   \   00000020   0x.... 0x....      BL       GUI_GetStringDistX
   \   00000024   0x300A             ADDS     R0,R0,#+10
    257            }
    258            return r;
   \                     ??_GetPageSizeX_0: (+1)
   \   00000026   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    259          }
    260          
    261          /*********************************************************************
    262          *
    263          *       _GetPagePosX
    264          *
    265          *  Returns the x-position of a page item.
    266          */

   \                                 In section .text, align 2, keep-with-next
    267          static int _GetPagePosX(MULTIPAGE_Obj* pObj, unsigned Index) {
   \                     _GetPagePosX: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    268            unsigned i, r = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    269            for (i = 0; i < Index; i++) {
   \   00000008   0x4637             MOV      R7,R6
   \   0000000A   0xE005             B.N      ??_GetPagePosX_0
    270              r += _GetPageSizeX(pObj, i);
   \                     ??_GetPagePosX_1: (+1)
   \   0000000C   0x4639             MOV      R1,R7
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       _GetPageSizeX
   \   00000014   0x1986             ADDS     R6,R0,R6
    271            }
   \   00000016   0x1C7F             ADDS     R7,R7,#+1
   \                     ??_GetPagePosX_0: (+1)
   \   00000018   0x42AF             CMP      R7,R5
   \   0000001A   0xD3F7             BCC.N    ??_GetPagePosX_1
    272            return r;
   \   0000001C   0x4630             MOV      R0,R6
   \   0000001E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    273          }
    274          
    275          /*********************************************************************
    276          *
    277          *       _GetTextWidth
    278          *
    279          *  Returns the width of all text items.
    280          */

   \                                 In section .text, align 2, keep-with-next
    281          static int _GetTextWidth(MULTIPAGE_Obj* pObj) {
    282            return _GetPagePosX(pObj, pObj->Handles.NumItems);
   \                     _GetTextWidth: (+1)
   \   00000000   0x8D41             LDRH     R1,[R0, #+42]
   \   00000002   0x....             B.N      _GetPagePosX
    283          }
    284          
    285          /*********************************************************************
    286          *
    287          *       _GetTextRect
    288          */

   \                                 In section .text, align 2, keep-with-next
    289          static void _GetTextRect(MULTIPAGE_Obj* pObj, GUI_RECT* pRect) {
   \                     _GetTextRect: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    290            GUI_RECT rBorder;
    291            int Width, Height;
    292            Height = GUI_GetYSizeOfFont(pObj->Font) + 6;
   \   00000006   0x6BE0             LDR      R0,[R4, #+60]
   \   00000008   0x.... 0x....      BL       GUI_GetYSizeOfFont
   \   0000000C   0x1D86             ADDS     R6,R0,#+6
    293            _CalcBorderRect(pObj, &rBorder);
   \   0000000E   0xA900             ADD      R1,SP,#+0
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       _CalcBorderRect
    294            /* Calculate Y-Position of text item */
    295            if (pObj->Align & MULTIPAGE_ALIGN_BOTTOM) {
   \   00000016   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   0000001A   0x0740             LSLS     R0,R0,#+29
   \   0000001C   0xD503             BPL.N    ??_GetTextRect_0
    296              pRect->y0 = rBorder.y1;
   \   0000001E   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \   00000022   0x8068             STRH     R0,[R5, #+2]
   \   00000024   0xE001             B.N      ??_GetTextRect_1
    297            } else {
    298              pRect->y0 = 0;
   \                     ??_GetTextRect_0: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x8068             STRH     R0,[R5, #+2]
    299            }
    300            pRect->y1 = pRect->y0 + Height;
   \                     ??_GetTextRect_1: (+1)
   \   0000002A   0x8868             LDRH     R0,[R5, #+2]
   \   0000002C   0x1830             ADDS     R0,R6,R0
   \   0000002E   0x80E8             STRH     R0,[R5, #+6]
    301            /* Calculate width of text items */
    302            if (pObj->Widget.State & MULTIPAGE_STATE_SCROLLMODE) {
   \   00000030   0x8CE0             LDRH     R0,[R4, #+38]
   \   00000032   0x05C0             LSLS     R0,R0,#+23
   \   00000034   0xD507             BPL.N    ??_GetTextRect_2
    303              Width = rBorder.x1 - ((Height * 3) >> 1) - 3;
   \   00000036   0xF9BD 0x0004      LDRSH    R0,[SP, #+4]
   \   0000003A   0xEB06 0x0146      ADD      R1,R6,R6, LSL #+1
   \   0000003E   0xEBA0 0x0061      SUB      R0,R0,R1, ASR #+1
   \   00000042   0x1EC0             SUBS     R0,R0,#+3
   \   00000044   0xE002             B.N      ??_GetTextRect_3
    304            } else {
    305              Width = _GetTextWidth(pObj);
   \                     ??_GetTextRect_2: (+1)
   \   00000046   0x4620             MOV      R0,R4
   \   00000048   0x.... 0x....      BL       _GetTextWidth
    306            }
    307            /* Calculate X-Position of text item */
    308            if (pObj->Align & MULTIPAGE_ALIGN_RIGHT) {
   \                     ??_GetTextRect_3: (+1)
   \   0000004C   0xF894 0x1038      LDRB     R1,[R4, #+56]
   \   00000050   0x07C9             LSLS     R1,R1,#+31
   \   00000052   0xD507             BPL.N    ??_GetTextRect_4
    309              pRect->x0 = rBorder.x1 - Width;
   \   00000054   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000058   0x1A08             SUBS     R0,R1,R0
   \   0000005A   0x8028             STRH     R0,[R5, #+0]
    310              pRect->x1 = rBorder.x1;
   \   0000005C   0xF8BD 0x0004      LDRH     R0,[SP, #+4]
   \   00000060   0x80A8             STRH     R0,[R5, #+4]
   \   00000062   0xBD73             POP      {R0,R1,R4-R6,PC}
    311            } else {
    312              pRect->x0 = 0;
   \                     ??_GetTextRect_4: (+1)
   \   00000064   0x2100             MOVS     R1,#+0
   \   00000066   0x8029             STRH     R1,[R5, #+0]
    313              pRect->x1 = Width;
   \   00000068   0x80A8             STRH     R0,[R5, #+4]
    314            }
    315          }
   \   0000006A   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    316          
    317          /*********************************************************************
    318          *
    319          *       _UpdatePositions
    320          */

   \                                 In section .text, align 2, keep-with-next
    321          static void _UpdatePositions(MULTIPAGE_Handle hObj, MULTIPAGE_Obj* pObj) {
   \                     _UpdatePositions: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
    322            GUI_RECT rBorder;
    323            int Width;
    324            Width = _GetTextWidth(pObj);
   \   0000000A   0x4628             MOV      R0,R5
   \   0000000C   0x.... 0x....      BL       _GetTextWidth
   \   00000010   0x4606             MOV      R6,R0
    325            _CalcBorderRect(pObj, &rBorder);
   \   00000012   0xA902             ADD      R1,SP,#+8
   \   00000014   0x4628             MOV      R0,R5
   \   00000016   0x.... 0x....      BL       _CalcBorderRect
    326            /* Set scrollmode according to the text width */
    327            if (Width > rBorder.x1) {
   \   0000001A   0xF9BD 0x000C      LDRSH    R0,[SP, #+12]
   \   0000001E   0x42B0             CMP      R0,R6
   \   00000020   0xDA40             BGE.N    ??_UpdatePositions_0
    328              GUI_RECT rText;
    329              int Size, x0, y0, NumItems = 0;
   \   00000022   0x2700             MOVS     R7,#+0
    330              Size   = ((GUI_GetYSizeOfFont(pObj->Font) + 6) * 3) >> 2;
   \   00000024   0x6BE8             LDR      R0,[R5, #+60]
   \   00000026   0x.... 0x....      BL       GUI_GetYSizeOfFont
   \   0000002A   0x1D80             ADDS     R0,R0,#+6
   \   0000002C   0xEB00 0x0040      ADD      R0,R0,R0, LSL #+1
   \   00000030   0x1080             ASRS     R0,R0,#+2
    331              x0     = (pObj->Align & MULTIPAGE_ALIGN_RIGHT)  ? (rBorder.x0) : (rBorder.x1 - 2*Size + 1);
   \   00000032   0x6BA9             LDR      R1,[R5, #+56]
   \   00000034   0x07CA             LSLS     R2,R1,#+31
   \   00000036   0xD502             BPL.N    ??_UpdatePositions_1
   \   00000038   0xF9BD 0x2008      LDRSH    R2,[SP, #+8]
   \   0000003C   0xE004             B.N      ??_UpdatePositions_2
   \                     ??_UpdatePositions_1: (+1)
   \   0000003E   0xF9BD 0x200C      LDRSH    R2,[SP, #+12]
   \   00000042   0xEBA2 0x0240      SUB      R2,R2,R0, LSL #+1
   \   00000046   0x1C52             ADDS     R2,R2,#+1
    332              y0     = (pObj->Align & MULTIPAGE_ALIGN_BOTTOM) ? (rBorder.y1) : (rBorder.y0 -   Size + 1);
   \                     ??_UpdatePositions_2: (+1)
   \   00000048   0x0749             LSLS     R1,R1,#+29
   \   0000004A   0xD502             BPL.N    ??_UpdatePositions_3
   \   0000004C   0xF9BD 0x300E      LDRSH    R3,[SP, #+14]
   \   00000050   0xE003             B.N      ??_UpdatePositions_4
   \                     ??_UpdatePositions_3: (+1)
   \   00000052   0xF9BD 0x100A      LDRSH    R1,[SP, #+10]
   \   00000056   0x1A09             SUBS     R1,R1,R0
   \   00000058   0x1C4B             ADDS     R3,R1,#+1
    333              /* A scrollbar is required so we add one to the multipage */
    334              _AddScrollbar(hObj, pObj, x0, y0, 2 * Size, Size);
   \                     ??_UpdatePositions_4: (+1)
   \   0000005A   0x9001             STR      R0,[SP, #+4]
   \   0000005C   0x0040             LSLS     R0,R0,#+1
   \   0000005E   0x9000             STR      R0,[SP, #+0]
   \   00000060   0x4629             MOV      R1,R5
   \   00000062   0x4620             MOV      R0,R4
   \   00000064   0x.... 0x....      BL       _AddScrollbar
    335              _GetTextRect(pObj, &rText);
   \   00000068   0xA904             ADD      R1,SP,#+16
   \   0000006A   0x4628             MOV      R0,R5
   \   0000006C   0x.... 0x....      BL       _GetTextRect
   \   00000070   0xE005             B.N      ??_UpdatePositions_5
    336              while (Width >= MAX((rText.x1 - rText.x0 + 1), 1)) {
    337                Width -= _GetPageSizeX(pObj, NumItems++);
   \                     ??_UpdatePositions_6: (+1)
   \   00000072   0x4639             MOV      R1,R7
   \   00000074   0x4628             MOV      R0,R5
   \   00000076   0x.... 0x....      BL       _GetPageSizeX
   \   0000007A   0x4647             MOV      R7,R8
   \   0000007C   0x1A36             SUBS     R6,R6,R0
    338              }
   \                     ??_UpdatePositions_5: (+1)
   \   0000007E   0xF9BD 0x0014      LDRSH    R0,[SP, #+20]
   \   00000082   0xF9BD 0x1010      LDRSH    R1,[SP, #+16]
   \   00000086   0x1A40             SUBS     R0,R0,R1
   \   00000088   0x1C40             ADDS     R0,R0,#+1
   \   0000008A   0x2802             CMP      R0,#+2
   \   0000008C   0xDA00             BGE.N    ??_UpdatePositions_7
   \   0000008E   0x2001             MOVS     R0,#+1
   \                     ??_UpdatePositions_7: (+1)
   \   00000090   0xF107 0x0801      ADD      R8,R7,#+1
   \   00000094   0x4286             CMP      R6,R0
   \   00000096   0xDAEC             BGE.N    ??_UpdatePositions_6
    339              _SetScrollbar(hObj, pObj, NumItems + 1);
   \   00000098   0x4642             MOV      R2,R8
   \   0000009A   0x4629             MOV      R1,R5
   \   0000009C   0x4620             MOV      R0,R4
   \   0000009E   0x.... 0x....      BL       _SetScrollbar
   \   000000A2   0xE003             B.N      ??_UpdatePositions_8
    340            } else {
    341              /* Scrollbar is no longer required. We delete it if there was one */
    342              _DeleteScrollbar(hObj, pObj);
   \                     ??_UpdatePositions_0: (+1)
   \   000000A4   0x4629             MOV      R1,R5
   \   000000A6   0x4620             MOV      R0,R4
   \   000000A8   0x.... 0x....      BL       _DeleteScrollbar
    343            }
    344            /* Move and resize the client area to the updated positions */
    345            _CalcClientRect(pObj, &rBorder);
   \                     ??_UpdatePositions_8: (+1)
   \   000000AC   0xA902             ADD      R1,SP,#+8
   \   000000AE   0x4628             MOV      R0,R5
   \   000000B0   0x.... 0x....      BL       _CalcClientRect
    346            WM_MoveChildTo(pObj->hClient, rBorder.x0, rBorder.y0);
   \   000000B4   0xF9BD 0x200A      LDRSH    R2,[SP, #+10]
   \   000000B8   0xF9BD 0x1008      LDRSH    R1,[SP, #+8]
   \   000000BC   0xF9B5 0x0028      LDRSH    R0,[R5, #+40]
   \   000000C0   0x.... 0x....      BL       WM_MoveChildTo
    347            WM_SetSize(pObj->hClient, rBorder.x1 - rBorder.x0 + 1, rBorder.y1 - rBorder.y0 + 1);
   \   000000C4   0xF9BD 0x000E      LDRSH    R0,[SP, #+14]
   \   000000C8   0xF9BD 0x100A      LDRSH    R1,[SP, #+10]
   \   000000CC   0x1A40             SUBS     R0,R0,R1
   \   000000CE   0x1C42             ADDS     R2,R0,#+1
   \   000000D0   0xF9BD 0x000C      LDRSH    R0,[SP, #+12]
   \   000000D4   0xF9BD 0x1008      LDRSH    R1,[SP, #+8]
   \   000000D8   0x1A40             SUBS     R0,R0,R1
   \   000000DA   0x1C41             ADDS     R1,R0,#+1
   \   000000DC   0xF9B5 0x0028      LDRSH    R0,[R5, #+40]
   \   000000E0   0x.... 0x....      BL       WM_SetSize
    348            WM_InvalidateWindow(hObj);
   \   000000E4   0x4620             MOV      R0,R4
   \   000000E6   0x.... 0x....      BL       WM_InvalidateWindow
    349          }
   \   000000EA   0xB006             ADD      SP,SP,#+24
   \   000000EC   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    350          
    351          /*********************************************************************
    352          *
    353          *       Static code, drawing functions
    354          *
    355          **********************************************************************
    356          */
    357          /*********************************************************************
    358          *
    359          *       _DrawTextItem
    360          */

   \                                 In section .text, align 2, keep-with-next
    361          static void _DrawTextItem(MULTIPAGE_Obj* pObj, const char* pText, unsigned Index,
    362                                    const GUI_RECT* pRect, int x0, int w, int ColorIndex) {
   \                     _DrawTextItem: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4617             MOV      R7,R2
   \   0000000A   0x461E             MOV      R6,R3
    363            GUI_RECT r;
    364            r = *pRect;
   \   0000000C   0xA800             ADD      R0,SP,#+0
   \   0000000E   0x4631             MOV      R1,R6
   \   00000010   0x2208             MOVS     R2,#+8
   \   00000012   0x.... 0x....      BL       __aeabi_memcpy
    365            r.x0 += x0;
   \   00000016   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000001A   0x9908             LDR      R1,[SP, #+32]
   \   0000001C   0x1808             ADDS     R0,R1,R0
   \   0000001E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    366            r.x1  = r.x0 + w;
   \   00000022   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000026   0x9909             LDR      R1,[SP, #+36]
   \   00000028   0x1808             ADDS     R0,R1,R0
   \   0000002A   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    367            WIDGET__EFFECT_DrawUpRect(&pObj->Widget, &r);
   \   0000002E   0xA900             ADD      R1,SP,#+0
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       WIDGET__EFFECT_DrawUpRect
    368            GUI__ReduceRect(&r, &r, pObj->Widget.pEffect->EffectSize);
   \   00000036   0x6A20             LDR      R0,[R4, #+32]
   \   00000038   0x6942             LDR      R2,[R0, #+20]
   \   0000003A   0xA900             ADD      R1,SP,#+0
   \   0000003C   0xA800             ADD      R0,SP,#+0
   \   0000003E   0x.... 0x....      BL       GUI__ReduceRect
    369            if (pObj->Selection == Index) {
   \   00000042   0x6B20             LDR      R0,[R4, #+48]
   \   00000044   0x42B8             CMP      R0,R7
   \   00000046   0xD14C             BNE.N    ??_DrawTextItem_0
   \   00000048   0x6A20             LDR      R0,[R4, #+32]
   \   0000004A   0x6940             LDR      R0,[R0, #+20]
   \   0000004C   0xF894 0x1038      LDRB     R1,[R4, #+56]
   \   00000050   0x0749             LSLS     R1,R1,#+29
   \   00000052   0xD522             BPL.N    ??_DrawTextItem_1
    370              if (pObj->Align & MULTIPAGE_ALIGN_BOTTOM) {
    371                r.y0 -= pObj->Widget.pEffect->EffectSize + 1;
   \   00000054   0xF8BD 0x1002      LDRH     R1,[SP, #+2]
   \   00000058   0x1A08             SUBS     R0,R1,R0
   \   0000005A   0x1E40             SUBS     R0,R0,#+1
   \   0000005C   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    372          	    if (pObj->Widget.pEffect->EffectSize > 1) {
   \   00000060   0x6A20             LDR      R0,[R4, #+32]
   \   00000062   0x6940             LDR      R0,[R0, #+20]
   \   00000064   0x2802             CMP      R0,#+2
   \   00000066   0xDB3C             BLT.N    ??_DrawTextItem_0
    373          		    LCD_SetColor(GUI_WHITE);
   \   00000068   0xF06F 0x407F      MVN      R0,#-16777216
   \   0000006C   0x.... 0x....      BL       LCD_SetColor
    374          		    GUI_DrawVLine(r.x0 - 1, r.y0, r.y0 + 1);
   \   00000070   0xF9BD 0x1002      LDRSH    R1,[SP, #+2]
   \   00000074   0x1C4A             ADDS     R2,R1,#+1
   \   00000076   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \   0000007A   0x1E40             SUBS     R0,R0,#+1
   \   0000007C   0x.... 0x....      BL       GUI_DrawVLine
    375          		    LCD_SetColor(0x555555);
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable1  ;; 0x555555
   \   00000084   0x.... 0x....      BL       LCD_SetColor
    376          		    GUI_DrawVLine(r.x1 + 1, r.y0, r.y0 + 1);
   \   00000088   0xF9BD 0x1002      LDRSH    R1,[SP, #+2]
   \   0000008C   0x1C4A             ADDS     R2,R1,#+1
   \   0000008E   0xF9BD 0x0004      LDRSH    R0,[SP, #+4]
   \   00000092   0x1C40             ADDS     R0,R0,#+1
   \   00000094   0x.... 0x....      BL       GUI_DrawVLine
   \   00000098   0xE023             B.N      ??_DrawTextItem_0
    377          	    }
    378              } else {
    379                r.y1 += pObj->Widget.pEffect->EffectSize + 1;
   \                     ??_DrawTextItem_1: (+1)
   \   0000009A   0xF8BD 0x1006      LDRH     R1,[SP, #+6]
   \   0000009E   0x1C40             ADDS     R0,R0,#+1
   \   000000A0   0x1840             ADDS     R0,R0,R1
   \   000000A2   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    380          	    if (pObj->Widget.pEffect->EffectSize > 1) {
   \   000000A6   0x6A20             LDR      R0,[R4, #+32]
   \   000000A8   0x6940             LDR      R0,[R0, #+20]
   \   000000AA   0x2802             CMP      R0,#+2
   \   000000AC   0xDB19             BLT.N    ??_DrawTextItem_0
    381          		    LCD_SetColor(GUI_WHITE);
   \   000000AE   0xF06F 0x407F      MVN      R0,#-16777216
   \   000000B2   0x.... 0x....      BL       LCD_SetColor
    382          		    GUI_DrawVLine(r.x0 - 1, r.y1 - 2, r.y1 - 1);
   \   000000B6   0xF9BD 0x0006      LDRSH    R0,[SP, #+6]
   \   000000BA   0x1E42             SUBS     R2,R0,#+1
   \   000000BC   0x1E81             SUBS     R1,R0,#+2
   \   000000BE   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \   000000C2   0x1E40             SUBS     R0,R0,#+1
   \   000000C4   0x.... 0x....      BL       GUI_DrawVLine
    383          		    LCD_SetColor(0x555555);
   \   000000C8   0x.... 0x....      LDR.W    R0,??DataTable1  ;; 0x555555
   \   000000CC   0x.... 0x....      BL       LCD_SetColor
    384          		    GUI_DrawVLine(r.x1 + 1, r.y1 - 2, r.y1 - 1);
   \   000000D0   0xF9BD 0x0006      LDRSH    R0,[SP, #+6]
   \   000000D4   0x1E42             SUBS     R2,R0,#+1
   \   000000D6   0x1E81             SUBS     R1,R0,#+2
   \   000000D8   0xF9BD 0x0004      LDRSH    R0,[SP, #+4]
   \   000000DC   0x1C40             ADDS     R0,R0,#+1
   \   000000DE   0x.... 0x....      BL       GUI_DrawVLine
   \                     ??_DrawTextItem_0: (+1)
   \   000000E2   0x980A             LDR      R0,[SP, #+40]
    385          	    }
    386              }
    387            }
    388            LCD_SetColor(pObj->aBkColor[ColorIndex]);
   \   000000E4   0xEB04 0x0780      ADD      R7,R4,R0, LSL #+2
   \   000000E8   0x6C38             LDR      R0,[R7, #+64]
   \   000000EA   0x.... 0x....      BL       LCD_SetColor
    389            WIDGET__FillRectEx(&pObj->Widget, &r);
   \   000000EE   0xA900             ADD      R1,SP,#+0
   \   000000F0   0x4620             MOV      R0,R4
   \   000000F2   0x.... 0x....      BL       WIDGET__FillRectEx
    390            LCD_SetBkColor(pObj->aBkColor[ColorIndex]);
   \   000000F6   0x6C38             LDR      R0,[R7, #+64]
   \   000000F8   0x.... 0x....      BL       LCD_SetBkColor
    391            LCD_SetColor(pObj->aTextColor[ColorIndex]);
   \   000000FC   0x6CB8             LDR      R0,[R7, #+72]
   \   000000FE   0x.... 0x....      BL       LCD_SetColor
    392            GUI_DispStringAt(pText, r.x0 + 4, pRect->y0 + 3);
   \   00000102   0xF9B6 0x0002      LDRSH    R0,[R6, #+2]
   \   00000106   0x1CC2             ADDS     R2,R0,#+3
   \   00000108   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \   0000010C   0x1D01             ADDS     R1,R0,#+4
   \   0000010E   0x4628             MOV      R0,R5
   \   00000110   0x.... 0x....      BL       GUI_DispStringAt
    393          }
   \   00000114   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
    394          
    395          /*********************************************************************
    396          *
    397          *       Static code, multipage callbacks
    398          *
    399          **********************************************************************
    400          */
    401          /*********************************************************************
    402          *
    403          *       _Paint
    404          */

   \                                 In section .text, align 2, keep-with-next
    405          static void _Paint(MULTIPAGE_Obj* pObj) {
   \                     _Paint: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB08A             SUB      SP,SP,#+40
   \   00000006   0x4604             MOV      R4,R0
    406            GUI_RECT rBorder;
    407            /* Draw border of multipage */
    408            _CalcBorderRect(pObj, &rBorder);
   \   00000008   0xA907             ADD      R1,SP,#+28
   \   0000000A   0x.... 0x....      BL       _CalcBorderRect
    409            WIDGET__EFFECT_DrawUpRect(&pObj->Widget, &rBorder);
   \   0000000E   0xA907             ADD      R1,SP,#+28
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       WIDGET__EFFECT_DrawUpRect
    410            /* Draw text items */
    411            if (pObj->Handles.NumItems > 0) {
   \   00000016   0x8D60             LDRH     R0,[R4, #+42]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD04D             BEQ.N    ??_Paint_0
    412              MULTIPAGE_PAGE* pPage;
    413              GUI_RECT rText, rClip;
    414              int i, w = 0, x0 = 0;
   \   0000001C   0x2500             MOVS     R5,#+0
   \   0000001E   0x462E             MOV      R6,R5
    415              if (pObj->Widget.State & MULTIPAGE_STATE_SCROLLMODE) {
   \   00000020   0x8CE0             LDRH     R0,[R4, #+38]
   \   00000022   0x05C0             LSLS     R0,R0,#+23
   \   00000024   0xD50C             BPL.N    ??_Paint_1
    416                if (pObj->Align & MULTIPAGE_ALIGN_RIGHT) {
   \   00000026   0x6B61             LDR      R1,[R4, #+52]
   \   00000028   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   0000002C   0x07C0             LSLS     R0,R0,#+31
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0xD503             BPL.N    ??_Paint_2
    417                  x0 = -_GetPagePosX(pObj, pObj->ScrollState);
   \   00000032   0x.... 0x....      BL       _GetPagePosX
   \   00000036   0x4246             RSBS     R6,R0,#+0
   \   00000038   0xE002             B.N      ??_Paint_1
    418                } else {
    419                  x0 = -_GetPagePosX(pObj, pObj->ScrollState);
   \                     ??_Paint_2: (+1)
   \   0000003A   0x.... 0x....      BL       _GetPagePosX
   \   0000003E   0x4246             RSBS     R6,R0,#+0
    420                }
    421              }
    422              _GetTextRect(pObj, &rText);
   \                     ??_Paint_1: (+1)
   \   00000040   0xA903             ADD      R1,SP,#+12
   \   00000042   0x4620             MOV      R0,R4
   \   00000044   0x.... 0x....      BL       _GetTextRect
    423              rClip = rText;
   \   00000048   0xE9DD 0x0103      LDRD     R0,R1,[SP, #+12]
   \   0000004C   0xE9CD 0x0105      STRD     R0,R1,[SP, #+20]
    424              rClip.y0 = rText.y0 - 1;
   \   00000050   0xF8BD 0x000E      LDRH     R0,[SP, #+14]
   \   00000054   0x1E40             SUBS     R0,R0,#+1
   \   00000056   0xF8AD 0x0016      STRH     R0,[SP, #+22]
    425              rClip.y1 = rText.y1 + 1;
   \   0000005A   0xF8BD 0x0012      LDRH     R0,[SP, #+18]
   \   0000005E   0x1C40             ADDS     R0,R0,#+1
   \   00000060   0xF8AD 0x001A      STRH     R0,[SP, #+26]
    426              WM_SetUserClipRect(&rClip);
   \   00000064   0xA805             ADD      R0,SP,#+20
   \   00000066   0x.... 0x....      BL       WM_SetUserClipRect
    427              GUI_SetFont(pObj->Font);
   \   0000006A   0x6BE0             LDR      R0,[R4, #+60]
   \   0000006C   0x.... 0x....      BL       GUI_SetFont
    428              for (i = 0; i < pObj->Handles.NumItems; i++) {
   \   00000070   0x462F             MOV      R7,R5
   \   00000072   0xE01B             B.N      ??_Paint_3
    429                pPage = (MULTIPAGE_PAGE*) GUI_ARRAY_GetpItem(&pObj->Handles, i);
   \                     ??_Paint_4: (+1)
   \   00000074   0x4639             MOV      R1,R7
   \   00000076   0xF104 0x002A      ADD      R0,R4,#+42
   \   0000007A   0x.... 0x....      BL       GUI_ARRAY_GetpItem
   \   0000007E   0x4680             MOV      R8,R0
    430                x0 += w;
   \   00000080   0x19AE             ADDS     R6,R5,R6
    431                w   = GUI_GetStringDistX(&pPage->acText) + 10;
   \   00000082   0xF108 0x0003      ADD      R0,R8,#+3
   \   00000086   0x.... 0x....      BL       GUI_GetStringDistX
   \   0000008A   0xF100 0x050A      ADD      R5,R0,#+10
    432                _DrawTextItem(pObj, &pPage->acText, i, &rText, x0, w, (pPage->Status & MULTIPAGE_STATE_ENABLED) ? 1 : 0);
   \   0000008E   0xF898 0x0002      LDRB     R0,[R8, #+2]
   \   00000092   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000096   0x9002             STR      R0,[SP, #+8]
   \   00000098   0x9501             STR      R5,[SP, #+4]
   \   0000009A   0x9600             STR      R6,[SP, #+0]
   \   0000009C   0xAB03             ADD      R3,SP,#+12
   \   0000009E   0x463A             MOV      R2,R7
   \   000000A0   0xF108 0x0103      ADD      R1,R8,#+3
   \   000000A4   0x4620             MOV      R0,R4
   \   000000A6   0x.... 0x....      BL       _DrawTextItem
    433              }    
   \   000000AA   0x1C7F             ADDS     R7,R7,#+1
   \                     ??_Paint_3: (+1)
   \   000000AC   0x8D60             LDRH     R0,[R4, #+42]
   \   000000AE   0x4287             CMP      R7,R0
   \   000000B0   0xDBE0             BLT.N    ??_Paint_4
    434              WM_SetUserClipRect(NULL);
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0x.... 0x....      BL       WM_SetUserClipRect
    435            }
    436          }
   \                     ??_Paint_0: (+1)
   \   000000B8   0xB00A             ADD      SP,SP,#+40
   \   000000BA   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    437          
    438          /*********************************************************************
    439          *
    440          *       _ClickedOnMultipage
    441          */

   \                                 In section .text, align 2, keep-with-next
    442          static int _ClickedOnMultipage(MULTIPAGE_Handle hObj, MULTIPAGE_Obj* pObj, int x, int y) {
   \                     _ClickedOnMultipage: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4616             MOV      R6,R2
   \   0000000C   0x461F             MOV      R7,R3
    443            GUI_RECT rText;
    444            _GetTextRect(pObj, &rText);
   \   0000000E   0xA900             ADD      R1,SP,#+0
   \   00000010   0x4628             MOV      R0,R5
   \   00000012   0x.... 0x....      BL       _GetTextRect
    445            if ((y >= rText.y0) && (y <= rText.y1)) {
   \   00000016   0xF9BD 0x0002      LDRSH    R0,[SP, #+2]
   \   0000001A   0x4287             CMP      R7,R0
   \   0000001C   0xDB38             BLT.N    ??_ClickedOnMultipage_0
   \   0000001E   0xF9BD 0x0006      LDRSH    R0,[SP, #+6]
   \   00000022   0x42B8             CMP      R0,R7
   \   00000024   0xDB34             BLT.N    ??_ClickedOnMultipage_0
    446              if ((pObj->Handles.NumItems > 0) && (x >= rText.x0) && (x <= rText.x1)) {
   \   00000026   0x8D68             LDRH     R0,[R5, #+42]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD02F             BEQ.N    ??_ClickedOnMultipage_1
   \   0000002C   0xF9BD 0x7000      LDRSH    R7,[SP, #+0]
   \   00000030   0x42BE             CMP      R6,R7
   \   00000032   0xDB2B             BLT.N    ??_ClickedOnMultipage_1
   \   00000034   0xF9BD 0x0004      LDRSH    R0,[SP, #+4]
   \   00000038   0x42B0             CMP      R0,R6
   \   0000003A   0xDB27             BLT.N    ??_ClickedOnMultipage_1
    447                int i, w = 0, x0 = rText.x0;
   \   0000003C   0xF04F 0x0800      MOV      R8,#+0
    448                /* Check if another page must be selected */
    449                if (pObj->Widget.State & MULTIPAGE_STATE_SCROLLMODE) {
   \   00000040   0x8CE8             LDRH     R0,[R5, #+38]
   \   00000042   0x05C0             LSLS     R0,R0,#+23
   \   00000044   0xD504             BPL.N    ??_ClickedOnMultipage_2
    450                  x0 -= _GetPagePosX(pObj, pObj->ScrollState);
   \   00000046   0x6B69             LDR      R1,[R5, #+52]
   \   00000048   0x4628             MOV      R0,R5
   \   0000004A   0x.... 0x....      BL       _GetPagePosX
   \   0000004E   0x1A3F             SUBS     R7,R7,R0
    451                }
    452                for (i = 0; i < pObj->Handles.NumItems; i++) {
   \                     ??_ClickedOnMultipage_2: (+1)
   \   00000050   0x46C1             MOV      R9,R8
   \   00000052   0xE001             B.N      ??_ClickedOnMultipage_3
   \                     ??_ClickedOnMultipage_4: (+1)
   \   00000054   0xF109 0x0901      ADD      R9,R9,#+1
   \                     ??_ClickedOnMultipage_3: (+1)
   \   00000058   0x8D68             LDRH     R0,[R5, #+42]
   \   0000005A   0x4581             CMP      R9,R0
   \   0000005C   0xDA16             BGE.N    ??_ClickedOnMultipage_1
    453                  x0 += w;
   \   0000005E   0x4447             ADD      R7,R8,R7
    454                  w   = _GetPageSizeX(pObj, i);
   \   00000060   0x4649             MOV      R1,R9
   \   00000062   0x4628             MOV      R0,R5
   \   00000064   0x.... 0x....      BL       _GetPageSizeX
   \   00000068   0x4680             MOV      R8,R0
    455                  if (x >= x0 && x <= (x0 + w - 1)) {
   \   0000006A   0x42BE             CMP      R6,R7
   \   0000006C   0xDBF2             BLT.N    ??_ClickedOnMultipage_4
   \   0000006E   0xEB08 0x0007      ADD      R0,R8,R7
   \   00000072   0x1E40             SUBS     R0,R0,#+1
   \   00000074   0x42B0             CMP      R0,R6
   \   00000076   0xDBED             BLT.N    ??_ClickedOnMultipage_4
    456                    MULTIPAGE_SelectPage(hObj, i);
   \   00000078   0x4649             MOV      R1,R9
   \   0000007A   0x4620             MOV      R0,R4
   \   0000007C   0x.... 0x....      BL       MULTIPAGE_SelectPage
    457                    WM_NotifyParent(hObj, WM_NOTIFICATION_VALUE_CHANGED);
   \   00000080   0x2105             MOVS     R1,#+5
   \   00000082   0x4620             MOV      R0,R4
   \   00000084   0x.... 0x....      BL       WM_NotifyParent
    458                    return 1;
   \   00000088   0x2001             MOVS     R0,#+1
   \   0000008A   0xE002             B.N      ??_ClickedOnMultipage_5
    459                  }
    460                }
    461              }
    462              return 0;
   \                     ??_ClickedOnMultipage_1: (+1)
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0xE000             B.N      ??_ClickedOnMultipage_5
    463            }
    464            return 1;
   \                     ??_ClickedOnMultipage_0: (+1)
   \   00000090   0x2001             MOVS     R0,#+1
   \                     ??_ClickedOnMultipage_5: (+1)
   \   00000092   0xE8BD 0x83FE      POP      {R1-R9,PC}       ;; return
    465          }
    466          
    467          /*********************************************************************
    468          *
    469          *       _OnTouch
    470          */

   \                                 In section .text, align 2, keep-with-next
    471          static void _OnTouch(MULTIPAGE_Handle hObj, MULTIPAGE_Obj* pObj, WM_MESSAGE*pMsg) {
   \                     _OnTouch: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4615             MOV      R5,R2
    472            GUI_PID_STATE* pState;
    473            int Notification;
    474            if (pMsg->Data.p) {  /* Something happened in our area (pressed or released) */
   \   00000008   0x68AE             LDR      R6,[R5, #+8]
   \   0000000A   0x2E00             CMP      R6,#+0
   \   0000000C   0xD037             BEQ.N    ??_OnTouch_0
    475              pState = (GUI_PID_STATE*)pMsg->Data.p;
    476              if (pState->Pressed) {
   \   0000000E   0x7A30             LDRB     R0,[R6, #+8]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD032             BEQ.N    ??_OnTouch_1
    477                int x = pState->x;
   \   00000014   0x6837             LDR      R7,[R6, #+0]
    478                int y = pState->y;
   \   00000016   0xF8D6 0x8004      LDR      R8,[R6, #+4]
    479                if (!_ClickedOnMultipage(hObj, pObj, x, y)) {
   \   0000001A   0x4643             MOV      R3,R8
   \   0000001C   0x463A             MOV      R2,R7
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       _ClickedOnMultipage
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0xD123             BNE.N    ??_OnTouch_2
    480                  WM_HWIN hBelow;
    481                  x += WM_GetWindowOrgX(hObj);
   \   0000002A   0x.... 0x....      BL       WM_GetWindowOrgX
   \   0000002E   0x19C7             ADDS     R7,R0,R7
    482                  y += WM_GetWindowOrgY(hObj);
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       WM_GetWindowOrgY
   \   00000036   0x4480             ADD      R8,R0,R8
    483                  hBelow = WM_Screen2hWinEx(hObj, x, y);
   \   00000038   0x4642             MOV      R2,R8
   \   0000003A   0x4639             MOV      R1,R7
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0x.... 0x....      BL       WM_Screen2hWinEx
   \   00000042   0x4681             MOV      R9,R0
    484                  if (hBelow) {
   \   00000044   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000048   0xD015             BEQ.N    ??_OnTouch_3
    485                    pState->x = x - WM_GetWindowOrgX(hBelow);
   \   0000004A   0x.... 0x....      BL       WM_GetWindowOrgX
   \   0000004E   0x1A38             SUBS     R0,R7,R0
   \   00000050   0x6030             STR      R0,[R6, #+0]
    486                    pState->y = y - WM_GetWindowOrgY(hBelow);
   \   00000052   0x4648             MOV      R0,R9
   \   00000054   0x.... 0x....      BL       WM_GetWindowOrgY
   \   00000058   0xEBA8 0x0000      SUB      R0,R8,R0
   \   0000005C   0x6070             STR      R0,[R6, #+4]
    487                    pMsg->hWin = hBelow;
   \   0000005E   0xF8A5 0x9004      STRH     R9,[R5, #+4]
    488                    (*WM_H2P(hBelow)->cb)(pMsg);
   \   00000062   0x4648             MOV      R0,R9
   \   00000064   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000068   0x4601             MOV      R1,R0
   \   0000006A   0x4628             MOV      R0,R5
   \   0000006C   0x6909             LDR      R1,[R1, #+16]
   \   0000006E   0x4788             BLX      R1
   \   00000070   0xE001             B.N      ??_OnTouch_3
    489                  }
    490                } else {
    491                  WM_BringToTop(hObj);
   \                     ??_OnTouch_2: (+1)
   \   00000072   0x.... 0x....      BL       WM_BringToTop
    492                }
    493                Notification = WM_NOTIFICATION_CLICKED;
   \                     ??_OnTouch_3: (+1)
   \   00000076   0x2101             MOVS     R1,#+1
   \   00000078   0xE002             B.N      ??_OnTouch_4
    494              } else {
    495                Notification = WM_NOTIFICATION_RELEASED;
   \                     ??_OnTouch_1: (+1)
   \   0000007A   0x2102             MOVS     R1,#+2
   \   0000007C   0xE000             B.N      ??_OnTouch_4
    496              }
    497            } else {
    498              Notification = WM_NOTIFICATION_MOVED_OUT;
   \                     ??_OnTouch_0: (+1)
   \   0000007E   0x2103             MOVS     R1,#+3
    499            }
    500            WM_NotifyParent(hObj, Notification);
   \                     ??_OnTouch_4: (+1)
   \   00000080   0x4620             MOV      R0,R4
   \   00000082   0xE8BD 0x43F4      POP      {R2,R4-R9,LR}
   \   00000086   0x.... 0x....      B.W      WM_NotifyParent
    501          }
    502          
    503          /*********************************************************************
    504          *
    505          *       _Callback
    506          */

   \                                 In section .text, align 2, keep-with-next
    507          static void _Callback (WM_MESSAGE *pMsg) {
   \                     _Callback: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    508            MULTIPAGE_Handle hObj = pMsg->hWin;
   \   00000004   0xF9B4 0x5004      LDRSH    R5,[R4, #+4]
    509            MULTIPAGE_Obj* pObj;
    510            int Handled;
    511            WM_LOCK();
    512            pObj    = MULTIPAGE_H2P(hObj);
   \   00000008   0x4628             MOV      R0,R5
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000000E   0x4606             MOV      R6,R0
    513            Handled = WIDGET_HandleActive(hObj, pMsg);
   \   00000010   0x4621             MOV      R1,R4
   \   00000012   0x4628             MOV      R0,R5
   \   00000014   0x.... 0x....      BL       WIDGET_HandleActive
   \   00000018   0x4607             MOV      R7,R0
    514            switch (pMsg->MsgId) {
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x2805             CMP      R0,#+5
   \   0000001E   0xD03B             BEQ.N    ??_Callback_0
   \   00000020   0x280B             CMP      R0,#+11
   \   00000022   0xD03E             BEQ.N    ??_Callback_1
   \   00000024   0x280C             CMP      R0,#+12
   \   00000026   0xD00F             BEQ.N    ??_Callback_2
   \   00000028   0x280F             CMP      R0,#+15
   \   0000002A   0xD009             BEQ.N    ??_Callback_3
   \   0000002C   0x2814             CMP      R0,#+20
   \   0000002E   0xD028             BEQ.N    ??_Callback_4
   \   00000030   0x2817             CMP      R0,#+23
   \   00000032   0xD022             BEQ.N    ??_Callback_5
   \   00000034   0x2826             CMP      R0,#+38
   \   00000036   0xD00D             BEQ.N    ??_Callback_6
   \   00000038   0xF5B0 0x7F40      CMP      R0,#+768
   \   0000003C   0xD026             BEQ.N    ??_Callback_7
   \   0000003E   0xE034             B.N      ??_Callback_8
    515            case WM_PAINT:
    516              _Paint(pObj);
   \                     ??_Callback_3: (+1)
   \   00000040   0x4630             MOV      R0,R6
   \   00000042   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   00000046   0x....             B.N      _Paint
    517              break;
    518            case WM_TOUCH:
    519              _OnTouch(hObj, pObj, pMsg);
   \                     ??_Callback_2: (+1)
   \   00000048   0x4622             MOV      R2,R4
   \   0000004A   0x4631             MOV      R1,R6
   \   0000004C   0x4628             MOV      R0,R5
   \   0000004E   0xE8BD 0x40F8      POP      {R3-R7,LR}
   \   00000052   0x....             B.N      _OnTouch
    520              break;
    521            case WM_NOTIFY_PARENT:
    522              if (pMsg->Data.v == WM_NOTIFICATION_VALUE_CHANGED) {
   \                     ??_Callback_6: (+1)
   \   00000054   0x68A0             LDR      R0,[R4, #+8]
   \   00000056   0x2805             CMP      R0,#+5
   \   00000058   0xD12E             BNE.N    ??_Callback_9
    523                if (WM_GetId(pMsg->hWinSrc) == GUI_ID_HSCROLL) {
   \   0000005A   0xF9B4 0x0006      LDRSH    R0,[R4, #+6]
   \   0000005E   0x.... 0x....      BL       WM_GetId
   \   00000062   0x28FF             CMP      R0,#+255
   \   00000064   0xD128             BNE.N    ??_Callback_9
    524                  pObj->ScrollState = SCROLLBAR_GetValue(pMsg->hWinSrc);
   \   00000066   0xF9B4 0x0006      LDRSH    R0,[R4, #+6]
   \   0000006A   0x.... 0x....      BL       SCROLLBAR_GetValue
   \   0000006E   0x6370             STR      R0,[R6, #+52]
    525                  WM_InvalidateWindow(hObj);
   \   00000070   0x4628             MOV      R0,R5
   \   00000072   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   00000076   0x.... 0x....      B.W      WM_InvalidateWindow
    526                }
    527              }
    528              break;
    529            case WM_GET_CLIENT_WINDOW:
    530              pMsg->Data.v = (int)pObj->hClient;
   \                     ??_Callback_5: (+1)
   \   0000007A   0xF9B6 0x0028      LDRSH    R0,[R6, #+40]
   \   0000007E   0x60A0             STR      R0,[R4, #+8]
    531              break;
   \   00000080   0xBDF1             POP      {R0,R4-R7,PC}
    532            case WM_GET_INSIDE_RECT:
    533              _CalcClientRect(pObj, (GUI_RECT*)(pMsg->Data.p));
   \                     ??_Callback_4: (+1)
   \   00000082   0x68A1             LDR      R1,[R4, #+8]
   \   00000084   0x4630             MOV      R0,R6
   \   00000086   0xE8BD 0x40F4      POP      {R2,R4-R7,LR}
   \   0000008A   0x....             B.N      _CalcClientRect
    534              break;
    535            case WM_WIDGET_SET_EFFECT:
    536              WIDGET_SetEffect(WM_GetScrollbarH(hObj), (WIDGET_EFFECT const *)pMsg->Data.p);
   \                     ??_Callback_7: (+1)
   \   0000008C   0x4628             MOV      R0,R5
   \   0000008E   0x.... 0x....      BL       WM_GetScrollbarH
   \   00000092   0x68A1             LDR      R1,[R4, #+8]
   \   00000094   0x.... 0x....      BL       WIDGET_SetEffect
    537            case WM_SIZE:
    538              _UpdatePositions(hObj, pObj);
   \                     ??_Callback_0: (+1)
   \   00000098   0x4631             MOV      R1,R6
   \   0000009A   0x4628             MOV      R0,R5
   \   0000009C   0xE8BD 0x40F4      POP      {R2,R4-R7,LR}
   \   000000A0   0x....             B.N      _UpdatePositions
    539              break;
    540            case WM_DELETE:
    541              GUI_ARRAY_Delete(&pObj->Handles);
   \                     ??_Callback_1: (+1)
   \   000000A2   0xF106 0x002A      ADD      R0,R6,#+42
   \   000000A6   0x.... 0x....      BL       GUI_ARRAY_Delete
    542              /* No break here ... WM_DefaultProc needs to be called */
    543            default:
    544              /* Let widget handle the standard messages */
    545              if (Handled) {
   \                     ??_Callback_8: (+1)
   \   000000AA   0x2F00             CMP      R7,#+0
   \   000000AC   0xD004             BEQ.N    ??_Callback_9
    546                WM_DefaultProc(pMsg);
   \   000000AE   0x4620             MOV      R0,R4
   \   000000B0   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   000000B4   0x.... 0x....      B.W      WM_DefaultProc
    547              }
    548            }
    549            WM_UNLOCK();
    550          }
   \                     ??_Callback_9: (+1)
   \   000000B8   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    551          
    552          /*********************************************************************
    553          *
    554          *       _ClientCallback
    555          */

   \                                 In section .text, align 2, keep-with-next
    556          static void _ClientCallback(WM_MESSAGE* pMsg) {
   \                     _ClientCallback: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    557            WM_HWIN hObj = pMsg->hWin;
   \   00000004   0xF9B4 0x5004      LDRSH    R5,[R4, #+4]
    558            WM_HWIN hParent = WM_GetParent(hObj);
   \   00000008   0x4628             MOV      R0,R5
   \   0000000A   0x.... 0x....      BL       WM_GetParent
   \   0000000E   0x4606             MOV      R6,R0
    559            MULTIPAGE_Obj* pParent;
    560            WM_LOCK();
    561            pParent = MULTIPAGE_H2P(hParent);
   \   00000010   0x.... 0x....      BL       GUI_ALLOC_h2p
    562            switch (pMsg->MsgId) {
   \   00000014   0x6821             LDR      R1,[R4, #+0]
   \   00000016   0x290C             CMP      R1,#+12
   \   00000018   0xD00D             BEQ.N    ??_ClientCallback_0
   \   0000001A   0x290F             CMP      R1,#+15
   \   0000001C   0xD004             BEQ.N    ??_ClientCallback_1
   \   0000001E   0x2914             CMP      R1,#+20
   \   00000020   0xD013             BEQ.N    ??_ClientCallback_2
   \   00000022   0x2917             CMP      R1,#+23
   \   00000024   0xD00F             BEQ.N    ??_ClientCallback_3
   \   00000026   0xBD70             POP      {R4-R6,PC}
    563            case WM_PAINT:
    564              LCD_SetBkColor(pParent->aBkColor[1]);
   \                     ??_ClientCallback_1: (+1)
   \   00000028   0x6C40             LDR      R0,[R0, #+68]
   \   0000002A   0x.... 0x....      BL       LCD_SetBkColor
    565              GUI_Clear();
   \   0000002E   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000032   0x.... 0x....      B.W      GUI_Clear
    566              break;
    567            case WM_TOUCH:
    568              WM_SetFocus(hParent);
   \                     ??_ClientCallback_0: (+1)
   \   00000036   0x4630             MOV      R0,R6
   \   00000038   0x.... 0x....      BL       WM_SetFocus
    569              WM_BringToTop(hParent);
   \   0000003C   0x4630             MOV      R0,R6
   \   0000003E   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000042   0x.... 0x....      B.W      WM_BringToTop
    570              break;
    571            case WM_GET_CLIENT_WINDOW:
    572              pMsg->Data.v = (int)hObj;
   \                     ??_ClientCallback_3: (+1)
   \   00000046   0x60A5             STR      R5,[R4, #+8]
    573              break;
   \   00000048   0xBD70             POP      {R4-R6,PC}
    574            case WM_GET_INSIDE_RECT:
    575              WM_DefaultProc(pMsg);
   \                     ??_ClientCallback_2: (+1)
   \   0000004A   0x4620             MOV      R0,R4
   \   0000004C   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000050   0x.... 0x....      B.W      WM_DefaultProc
    576            }
    577            WM_UNLOCK();
    578          }
    579          
    580          /*********************************************************************
    581          *
    582          *       Exported routines:  Create
    583          *
    584          **********************************************************************
    585          */
    586          
    587          /* Note: the parameters to a create function may vary.
    588                   Some widgets may have multiple create functions */
    589          
    590          /*********************************************************************
    591          *
    592          *       MULTIPAGE_CreateEx
    593          */

   \                                 In section .text, align 2, keep-with-next
    594          MULTIPAGE_Handle MULTIPAGE_CreateEx(int x0, int y0, int xsize, int ysize, WM_HWIN hParent,
    595                                              int WinFlags, int ExFlags, int Id)
    596          {
   \                     MULTIPAGE_CreateEx: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
    597            MULTIPAGE_Handle hObj;
    598            GUI_USE_PARA(ExFlags);
    599            /* Create the window */
    600            hObj = WM_CreateWindowAsChild(x0, y0, xsize, ysize, hParent, WinFlags | WM_CF_HASTRANS, &_Callback,
    601                                          sizeof(MULTIPAGE_Obj) - sizeof(WM_Obj));
   \   00000004   0x2430             MOVS     R4,#+48
   \   00000006   0x9403             STR      R4,[SP, #+12]
   \   00000008   0x....             LDR.N    R4,??DataTable1_1
   \   0000000A   0x9402             STR      R4,[SP, #+8]
   \   0000000C   0x9C0B             LDR      R4,[SP, #+44]
   \   0000000E   0xF044 0x0401      ORR      R4,R4,#0x1
   \   00000012   0xB2A4             UXTH     R4,R4
   \   00000014   0x9401             STR      R4,[SP, #+4]
   \   00000016   0xF9BD 0x4028      LDRSH    R4,[SP, #+40]
   \   0000001A   0x9400             STR      R4,[SP, #+0]
   \   0000001C   0x.... 0x....      BL       WM_CreateWindowAsChild
   \   00000020   0x0004             MOVS     R4,R0
    602            if (hObj) {
   \   00000022   0xD038             BEQ.N    ??MULTIPAGE_CreateEx_0
    603              MULTIPAGE_Obj* pObj;
    604              GUI_RECT rClient;
    605              int Flags;
    606              WM_LOCK();
    607              pObj = MULTIPAGE_H2P(hObj);
   \   00000024   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000028   0x4605             MOV      R5,R0
    608              /* Init sub-classes */
    609              GUI_ARRAY_CREATE(&pObj->Handles);
    610              /* init widget specific variables */
    611              WIDGET__Init(&pObj->Widget, Id, WIDGET_STATE_FOCUSSABLE);
   \   0000002A   0x2210             MOVS     R2,#+16
   \   0000002C   0x990D             LDR      R1,[SP, #+52]
   \   0000002E   0x.... 0x....      BL       WIDGET__Init
    612              /* init member variables */
    613              MULTIPAGE_INIT_ID(pObj);
    614              pObj->aBkColor[0]     = MULTIPAGE__DefaultBkColor[0];
   \   00000032   0x....             LDR.N    R0,??DataTable1_2
   \   00000034   0x6801             LDR      R1,[R0, #+0]
   \   00000036   0x6429             STR      R1,[R5, #+64]
    615              pObj->aBkColor[1]     = MULTIPAGE__DefaultBkColor[1];
   \   00000038   0x6841             LDR      R1,[R0, #+4]
   \   0000003A   0x6469             STR      R1,[R5, #+68]
    616              pObj->aTextColor[0]   = MULTIPAGE__DefaultTextColor[0];
   \   0000003C   0x6881             LDR      R1,[R0, #+8]
   \   0000003E   0x64A9             STR      R1,[R5, #+72]
    617              pObj->aTextColor[1]   = MULTIPAGE__DefaultTextColor[1];
   \   00000040   0x68C1             LDR      R1,[R0, #+12]
   \   00000042   0x64E9             STR      R1,[R5, #+76]
    618              pObj->Font            = MULTIPAGE__pDefaultFont;
   \   00000044   0x6901             LDR      R1,[R0, #+16]
   \   00000046   0x63E9             STR      R1,[R5, #+60]
    619              pObj->Align           = MULTIPAGE__DefaultAlign;
   \   00000048   0x6940             LDR      R0,[R0, #+20]
   \   0000004A   0x63A8             STR      R0,[R5, #+56]
    620              pObj->Selection       = 0xffff;
   \   0000004C   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000050   0x6328             STR      R0,[R5, #+48]
    621              pObj->ScrollState     = 0;
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x6368             STR      R0,[R5, #+52]
    622              pObj->Widget.State    = 0;
   \   00000056   0x84E8             STRH     R0,[R5, #+38]
    623              _CalcClientRect(pObj, &rClient);
   \   00000058   0xA904             ADD      R1,SP,#+16
   \   0000005A   0x4628             MOV      R0,R5
   \   0000005C   0x.... 0x....      BL       _CalcClientRect
    624              Flags = WM_CF_SHOW | WM_CF_ANCHOR_LEFT | WM_CF_ANCHOR_RIGHT | WM_CF_ANCHOR_TOP | WM_CF_ANCHOR_BOTTOM;
    625              pObj->hClient = WM_CreateWindowAsChild(rClient.x0, rClient.y0,
    626                                                     rClient.x1 - rClient.x0 + 1,
    627                                                     rClient.y1 - rClient.y0 + 1,
    628                                                     hObj, Flags, &_ClientCallback, 0);
   \   00000060   0xF9BD 0x1012      LDRSH    R1,[SP, #+18]
   \   00000064   0xF9BD 0x0010      LDRSH    R0,[SP, #+16]
   \   00000068   0x2200             MOVS     R2,#+0
   \   0000006A   0x9203             STR      R2,[SP, #+12]
   \   0000006C   0x....             LDR.N    R2,??DataTable1_3
   \   0000006E   0x9202             STR      R2,[SP, #+8]
   \   00000070   0xF240 0x7282      MOVW     R2,#+1922
   \   00000074   0x9201             STR      R2,[SP, #+4]
   \   00000076   0x9400             STR      R4,[SP, #+0]
   \   00000078   0xF9BD 0x2016      LDRSH    R2,[SP, #+22]
   \   0000007C   0x1A52             SUBS     R2,R2,R1
   \   0000007E   0x1C53             ADDS     R3,R2,#+1
   \   00000080   0xF9BD 0x2014      LDRSH    R2,[SP, #+20]
   \   00000084   0x1A12             SUBS     R2,R2,R0
   \   00000086   0x1C52             ADDS     R2,R2,#+1
   \   00000088   0x.... 0x....      BL       WM_CreateWindowAsChild
   \   0000008C   0x8528             STRH     R0,[R5, #+40]
    629              _UpdatePositions(hObj, pObj);
   \   0000008E   0x4629             MOV      R1,R5
   \   00000090   0x4620             MOV      R0,R4
   \   00000092   0x.... 0x....      BL       _UpdatePositions
    630              WM_UNLOCK();
    631            } else {
    632              GUI_DEBUG_ERROROUT_IF(hObj==0, "MULTIPAGE_Create failed")
    633            }
    634            return hObj;
   \                     ??MULTIPAGE_CreateEx_0: (+1)
   \   00000096   0x4620             MOV      R0,R4
   \   00000098   0xB007             ADD      SP,SP,#+28
   \   0000009A   0xBD30             POP      {R4,R5,PC}       ;; return
    635          }
    636          
    637          /*********************************************************************
    638          *
    639          *       Exported routines:  Page management
    640          *
    641          **********************************************************************
    642          */
    643          /*********************************************************************
    644          *
    645          *       MULTIPAGE_AddPage
    646          */

   \                                 In section .text, align 2, keep-with-next
    647          void MULTIPAGE_AddPage(MULTIPAGE_Handle hObj, WM_HWIN hWin ,const char* pText) {
   \                     MULTIPAGE_AddPage: (+1)
   \   00000000   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460F             MOV      R7,R1
   \   00000008   0x4615             MOV      R5,R2
    648            MULTIPAGE_Obj* pObj;
    649            GUI_USE_PARA(hWin);
    650            if (hObj) {
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD05B             BEQ.N    ??MULTIPAGE_AddPage_0
    651              WM_LOCK();
    652              pObj = MULTIPAGE_H2P(hObj);
   \   0000000E   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000012   0x4606             MOV      R6,R0
    653              MULTIPAGE_ASSERT_IS_VALID_PTR(pObj);
    654              if (!hWin) {
   \   00000014   0xF9B6 0x1028      LDRSH    R1,[R6, #+40]
   \   00000018   0x2F00             CMP      R7,#+0
   \   0000001A   0xD123             BNE.N    ??MULTIPAGE_AddPage_1
    655                /* If we get no handle we must find it. To do this, we search      */
    656                /* all children until we found one that has not yet become a page. */
    657                MULTIPAGE_PAGE* pPage;
    658                WM_HWIN hChild;
    659                WM_Obj* pChild;
    660                WM_Obj* pClient = WM_H2P(pObj->hClient);
   \   0000001C   0x4608             MOV      R0,R1
   \   0000001E   0x.... 0x....      BL       GUI_ALLOC_h2p
    661                int i;
    662                for (hChild = pClient->hFirstChild; hChild && !hWin; hChild = pChild->hNext) {
   \   00000022   0xF9B0 0x8018      LDRSH    R8,[R0, #+24]
   \   00000026   0xE010             B.N      ??MULTIPAGE_AddPage_2
    663                  pChild = WM_H2P(hChild);
    664                  hWin = hChild;
    665                  for (i = 0; i < pObj->Handles.NumItems; i++) {
   \                     ??MULTIPAGE_AddPage_3: (+1)
   \   00000028   0xF10A 0x0A01      ADD      R10,R10,#+1
   \                     ??MULTIPAGE_AddPage_4: (+1)
   \   0000002C   0x8D70             LDRH     R0,[R6, #+42]
   \   0000002E   0x4582             CMP      R10,R0
   \   00000030   0xDA09             BGE.N    ??MULTIPAGE_AddPage_5
    666                    pPage = (MULTIPAGE_PAGE*) GUI_ARRAY_GetpItem(&pObj->Handles, i);
   \   00000032   0x4651             MOV      R1,R10
   \   00000034   0xF106 0x002A      ADD      R0,R6,#+42
   \   00000038   0x.... 0x....      BL       GUI_ARRAY_GetpItem
    667                    if (pPage->hWin == hChild) {
   \   0000003C   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000040   0x4540             CMP      R0,R8
   \   00000042   0xD1F1             BNE.N    ??MULTIPAGE_AddPage_3
    668                      hWin = 0;
   \   00000044   0x2700             MOVS     R7,#+0
    669                      break;
    670                    }
    671                  }
   \                     ??MULTIPAGE_AddPage_5: (+1)
   \   00000046   0xF9B9 0x801A      LDRSH    R8,[R9, #+26]
   \                     ??MULTIPAGE_AddPage_2: (+1)
   \   0000004A   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000004E   0xD00E             BEQ.N    ??MULTIPAGE_AddPage_6
   \   00000050   0x2F00             CMP      R7,#+0
   \   00000052   0xD10C             BNE.N    ??MULTIPAGE_AddPage_6
   \   00000054   0x4640             MOV      R0,R8
   \   00000056   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000005A   0x4681             MOV      R9,R0
   \   0000005C   0x4647             MOV      R7,R8
   \   0000005E   0xF04F 0x0A00      MOV      R10,#+0
   \   00000062   0xE7E3             B.N      ??MULTIPAGE_AddPage_4
    672                }
    673              } else {
    674                /* If we get a handle we must ensure that it was attached to the multipage */
    675                WM_AttachWindowAt(hWin, pObj->hClient, 0, 0);
   \                     ??MULTIPAGE_AddPage_1: (+1)
   \   00000064   0x2300             MOVS     R3,#+0
   \   00000066   0x461A             MOV      R2,R3
   \   00000068   0x4638             MOV      R0,R7
   \   0000006A   0x.... 0x....      BL       WM_AttachWindowAt
    676              }
    677              if (hWin) {
   \                     ??MULTIPAGE_AddPage_6: (+1)
   \   0000006E   0x2F00             CMP      R7,#+0
   \   00000070   0xD029             BEQ.N    ??MULTIPAGE_AddPage_0
    678                MULTIPAGE_PAGE Page;
    679                char NullByte = 0;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0xF88D 0x0004      STRB     R0,[SP, #+4]
    680                if (!pText) {
   \   00000078   0x2D00             CMP      R5,#+0
   \   0000007A   0xD100             BNE.N    ??MULTIPAGE_AddPage_7
    681                  pText = &NullByte;
   \   0000007C   0xAD01             ADD      R5,SP,#+4
    682                }
    683                Page.hWin   = hWin;
   \                     ??MULTIPAGE_AddPage_7: (+1)
   \   0000007E   0xF8AD 0x7000      STRH     R7,[SP, #+0]
    684                Page.Status = MULTIPAGE_STATE_ENABLED;
   \   00000082   0x2001             MOVS     R0,#+1
   \   00000084   0xF88D 0x0002      STRB     R0,[SP, #+2]
    685                if (GUI_ARRAY_AddItem(&pObj->Handles, &Page, sizeof(MULTIPAGE_PAGE) + strlen(pText)) == 0) {
   \   00000088   0x4628             MOV      R0,R5
   \   0000008A   0x.... 0x....      BL       strlen
   \   0000008E   0x1D02             ADDS     R2,R0,#+4
   \   00000090   0xA900             ADD      R1,SP,#+0
   \   00000092   0xF106 0x002A      ADD      R0,R6,#+42
   \   00000096   0x.... 0x....      BL       GUI_ARRAY_AddItem
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD10E             BNE.N    ??MULTIPAGE_AddPage_8
    686                  MULTIPAGE_PAGE* pPage;
    687                  pPage = (MULTIPAGE_PAGE*) GUI_ARRAY_GetpItem(&pObj->Handles, pObj->Handles.NumItems - 1);
   \   0000009E   0x8D70             LDRH     R0,[R6, #+42]
   \   000000A0   0x1E41             SUBS     R1,R0,#+1
   \   000000A2   0xF106 0x002A      ADD      R0,R6,#+42
   \   000000A6   0x.... 0x....      BL       GUI_ARRAY_GetpItem
   \   000000AA   0x4607             MOV      R7,R0
    688                  memcpy(&pPage->acText, pText, strlen(pText) + 1);
   \   000000AC   0x4628             MOV      R0,R5
   \   000000AE   0x.... 0x....      BL       strlen
   \   000000B2   0x1C42             ADDS     R2,R0,#+1
   \   000000B4   0x4629             MOV      R1,R5
   \   000000B6   0x1CF8             ADDS     R0,R7,#+3
   \   000000B8   0x.... 0x....      BL       memcpy
    689                }
    690                MULTIPAGE_SelectPage(hObj, pObj->Handles.NumItems - 1);
   \                     ??MULTIPAGE_AddPage_8: (+1)
   \   000000BC   0x8D70             LDRH     R0,[R6, #+42]
   \   000000BE   0x1E41             SUBS     R1,R0,#+1
   \   000000C0   0x4620             MOV      R0,R4
   \   000000C2   0x.... 0x....      BL       MULTIPAGE_SelectPage
    691              }
    692              WM_UNLOCK();
    693            }
    694          }
   \                     ??MULTIPAGE_AddPage_0: (+1)
   \   000000C6   0xE8BD 0x87F3      POP      {R0,R1,R4-R10,PC}  ;; return
    695          
    696          /*********************************************************************
    697          *
    698          *       MULTIPAGE_DeletePage
    699          */

   \                                 In section .text, align 2, keep-with-next
    700          void MULTIPAGE_DeletePage(MULTIPAGE_Handle hObj, unsigned Index, int Delete) {
   \                     MULTIPAGE_DeletePage: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
    701            if (hObj) {
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD034             BEQ.N    ??MULTIPAGE_DeletePage_0
    702              MULTIPAGE_Obj* pObj;
    703              WM_LOCK();
    704              pObj = MULTIPAGE_H2P(hObj);
   \   0000000E   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000012   0x0007             MOVS     R7,R0
    705              MULTIPAGE_ASSERT_IS_VALID_PTR(pObj);
    706              if (pObj) {
   \   00000014   0xD030             BEQ.N    ??MULTIPAGE_DeletePage_0
    707                if ((int)Index < pObj->Handles.NumItems) {
   \   00000016   0x8D78             LDRH     R0,[R7, #+42]
   \   00000018   0x4285             CMP      R5,R0
   \   0000001A   0xDA2D             BGE.N    ??MULTIPAGE_DeletePage_0
    708                  WM_HWIN hWin;
    709                  MULTIPAGE_PAGE* pPage;
    710                  pPage = (MULTIPAGE_PAGE*) GUI_ARRAY_GetpItem(&pObj->Handles, Index);
   \   0000001C   0x4629             MOV      R1,R5
   \   0000001E   0xF107 0x002A      ADD      R0,R7,#+42
   \   00000022   0x.... 0x....      BL       GUI_ARRAY_GetpItem
    711                  hWin = pPage->hWin;
   \   00000026   0xF9B0 0x8000      LDRSH    R8,[R0, #+0]
    712                  /* Remove the page from the multipage object */
    713                  if (Index == pObj->Selection) {
   \   0000002A   0x6B38             LDR      R0,[R7, #+48]
   \   0000002C   0x4285             CMP      R5,R0
   \   0000002E   0xD110             BNE.N    ??MULTIPAGE_DeletePage_1
    714                    if (Index == ((unsigned)pObj->Handles.NumItems - 1)) {
   \   00000030   0x8D78             LDRH     R0,[R7, #+42]
   \   00000032   0x1E40             SUBS     R0,R0,#+1
   \   00000034   0x4285             CMP      R5,R0
   \   00000036   0xD107             BNE.N    ??MULTIPAGE_DeletePage_2
    715                      _ShowPage(pObj, Index - 1);
   \   00000038   0x1E69             SUBS     R1,R5,#+1
   \   0000003A   0x4638             MOV      R0,R7
   \   0000003C   0x.... 0x....      BL       _ShowPage
    716                      pObj->Selection--;
   \   00000040   0x6B38             LDR      R0,[R7, #+48]
   \   00000042   0x1E40             SUBS     R0,R0,#+1
   \   00000044   0x6338             STR      R0,[R7, #+48]
   \   00000046   0xE007             B.N      ??MULTIPAGE_DeletePage_3
    717                    } else {
    718                      _ShowPage(pObj, Index + 1);
   \                     ??MULTIPAGE_DeletePage_2: (+1)
   \   00000048   0x1C69             ADDS     R1,R5,#+1
   \   0000004A   0x4638             MOV      R0,R7
   \   0000004C   0x.... 0x....      BL       _ShowPage
   \   00000050   0xE002             B.N      ??MULTIPAGE_DeletePage_3
    719                    }
    720                  } else {
    721                    if (Index < pObj->Selection) {
   \                     ??MULTIPAGE_DeletePage_1: (+1)
   \   00000052   0xD201             BCS.N    ??MULTIPAGE_DeletePage_3
    722                      pObj->Selection--;
   \   00000054   0x1E40             SUBS     R0,R0,#+1
   \   00000056   0x6338             STR      R0,[R7, #+48]
    723                    }
    724                  }
    725                  GUI_ARRAY_DeleteItem(&pObj->Handles, Index);
   \                     ??MULTIPAGE_DeletePage_3: (+1)
   \   00000058   0x4629             MOV      R1,R5
   \   0000005A   0xF107 0x002A      ADD      R0,R7,#+42
   \   0000005E   0x.... 0x....      BL       GUI_ARRAY_DeleteItem
    726                  _UpdatePositions(hObj, pObj);
   \   00000062   0x4639             MOV      R1,R7
   \   00000064   0x4620             MOV      R0,R4
   \   00000066   0x.... 0x....      BL       _UpdatePositions
    727                  /* Delete the window of the page */
    728                  if (Delete) {
   \   0000006A   0x2E00             CMP      R6,#+0
   \   0000006C   0xD004             BEQ.N    ??MULTIPAGE_DeletePage_0
    729                    WM_DeleteWindow(hWin);
   \   0000006E   0x4640             MOV      R0,R8
   \   00000070   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   00000074   0x.... 0x....      B.W      WM_DeleteWindow
    730                  }
    731                }
    732              }
    733              WM_UNLOCK();
    734            }
    735          }
   \                     ??MULTIPAGE_DeletePage_0: (+1)
   \   00000078   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    736          
    737          /*********************************************************************
    738          *
    739          *       MULTIPAGE_SelectPage
    740          */

   \                                 In section .text, align 2, keep-with-next
    741          void MULTIPAGE_SelectPage(MULTIPAGE_Handle hObj, unsigned Index) {
   \                     MULTIPAGE_SelectPage: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    742            if (hObj) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD019             BEQ.N    ??MULTIPAGE_SelectPage_0
    743              MULTIPAGE_Obj* pObj;
    744              WM_LOCK();
    745              pObj = MULTIPAGE_H2P(hObj);
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000000E   0x0006             MOVS     R6,R0
    746              MULTIPAGE_ASSERT_IS_VALID_PTR(pObj);
    747              if (pObj) {
   \   00000010   0xD015             BEQ.N    ??MULTIPAGE_SelectPage_0
    748                if ((int)Index < pObj->Handles.NumItems) {
   \   00000012   0x8D70             LDRH     R0,[R6, #+42]
   \   00000014   0x4285             CMP      R5,R0
   \   00000016   0xDA12             BGE.N    ??MULTIPAGE_SelectPage_0
    749                  if (Index != pObj->Selection && _GetEnable(pObj, Index)) {
   \   00000018   0x6B30             LDR      R0,[R6, #+48]
   \   0000001A   0x4285             CMP      R5,R0
   \   0000001C   0xD00F             BEQ.N    ??MULTIPAGE_SelectPage_0
   \   0000001E   0x4629             MOV      R1,R5
   \   00000020   0x4630             MOV      R0,R6
   \   00000022   0x.... 0x....      BL       _GetEnable
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD009             BEQ.N    ??MULTIPAGE_SelectPage_0
    750                    _ShowPage(pObj, Index);
   \   0000002A   0x4629             MOV      R1,R5
   \   0000002C   0x4630             MOV      R0,R6
   \   0000002E   0x.... 0x....      BL       _ShowPage
    751                    pObj->Selection = Index;
   \   00000032   0x6335             STR      R5,[R6, #+48]
    752                    _UpdatePositions(hObj, pObj);
   \   00000034   0x4631             MOV      R1,R6
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000003C   0x....             B.N      _UpdatePositions
    753                  }
    754                }
    755              }
    756              WM_UNLOCK();
    757            }
    758          }
   \                     ??MULTIPAGE_SelectPage_0: (+1)
   \   0000003E   0xBD70             POP      {R4-R6,PC}       ;; return
    759          
    760          /*********************************************************************
    761          *
    762          *       MULTIPAGE_DisablePage
    763          */

   \                                 In section .text, align 2, keep-with-next
    764          void MULTIPAGE_DisablePage(MULTIPAGE_Handle hObj, unsigned Index) {
   \                     MULTIPAGE_DisablePage: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    765            if (hObj) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD00C             BEQ.N    ??MULTIPAGE_DisablePage_0
    766              MULTIPAGE_Obj* pObj;
    767              WM_LOCK();
    768              pObj = MULTIPAGE_H2P(hObj);
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
    769              MULTIPAGE_ASSERT_IS_VALID_PTR(pObj);
    770              if (pObj) {
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD008             BEQ.N    ??MULTIPAGE_DisablePage_0
    771                _SetEnable(pObj, Index, 0);
   \   00000012   0x2200             MOVS     R2,#+0
   \   00000014   0x4629             MOV      R1,R5
   \   00000016   0x.... 0x....      BL       _SetEnable
    772                WM_InvalidateWindow(hObj);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000020   0x.... 0x....      B.W      WM_InvalidateWindow
    773              }
    774              WM_UNLOCK();
    775            }
    776          }
   \                     ??MULTIPAGE_DisablePage_0: (+1)
   \   00000024   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    777          
    778          /*********************************************************************
    779          *
    780          *       MULTIPAGE_EnablePage
    781          */

   \                                 In section .text, align 2, keep-with-next
    782          void MULTIPAGE_EnablePage(MULTIPAGE_Handle hObj, unsigned Index) {
   \                     MULTIPAGE_EnablePage: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    783            if (hObj) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD00C             BEQ.N    ??MULTIPAGE_EnablePage_0
    784              MULTIPAGE_Obj* pObj;
    785              WM_LOCK();
    786              pObj = MULTIPAGE_H2P(hObj);
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
    787              MULTIPAGE_ASSERT_IS_VALID_PTR(pObj);
    788              if (pObj) {
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD008             BEQ.N    ??MULTIPAGE_EnablePage_0
    789                _SetEnable(pObj, Index, 1);
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0x4629             MOV      R1,R5
   \   00000016   0x.... 0x....      BL       _SetEnable
    790                WM_InvalidateWindow(hObj);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000020   0x.... 0x....      B.W      WM_InvalidateWindow
    791              }
    792              WM_UNLOCK();
    793            }
    794          }
   \                     ??MULTIPAGE_EnablePage_0: (+1)
   \   00000024   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    795          
    796          /*********************************************************************
    797          *
    798          *       Exported routines:  Various methods
    799          *
    800          **********************************************************************
    801          */
    802          /*********************************************************************
    803          *
    804          *       MULTIPAGE_SetText
    805          */

   \                                 In section .text, align 2, keep-with-next
    806          void MULTIPAGE_SetText(MULTIPAGE_Handle hObj, const char* pText, unsigned Index) {
   \                     MULTIPAGE_SetText: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4617             MOV      R7,R2
    807            MULTIPAGE_Obj* pObj;
    808            if (hObj && pText) {
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD035             BEQ.N    ??MULTIPAGE_SetText_0
   \   00000010   0x2D00             CMP      R5,#+0
   \   00000012   0xD033             BEQ.N    ??MULTIPAGE_SetText_0
    809              WM_LOCK();
    810              pObj = MULTIPAGE_H2P(hObj);
   \   00000014   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000018   0x0006             MOVS     R6,R0
    811              MULTIPAGE_ASSERT_IS_VALID_PTR(pObj);
    812              if (pObj) {
   \   0000001A   0xD02F             BEQ.N    ??MULTIPAGE_SetText_0
    813                if ((int)Index < pObj->Handles.NumItems) {
   \   0000001C   0x8D70             LDRH     R0,[R6, #+42]
   \   0000001E   0x4287             CMP      R7,R0
   \   00000020   0xDA2C             BGE.N    ??MULTIPAGE_SetText_0
    814                  MULTIPAGE_PAGE* pPage;
    815                  MULTIPAGE_PAGE Page;
    816                  pPage = (MULTIPAGE_PAGE*) GUI_ARRAY_GetpItem(&pObj->Handles, Index);
   \   00000022   0x4639             MOV      R1,R7
   \   00000024   0xF106 0x002A      ADD      R0,R6,#+42
   \   00000028   0x.... 0x....      BL       GUI_ARRAY_GetpItem
   \   0000002C   0x4680             MOV      R8,R0
    817                  Page.hWin   = pPage->hWin;
   \   0000002E   0xF8B8 0x0000      LDRH     R0,[R8, #+0]
   \   00000032   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    818                  Page.Status = pPage->Status;
   \   00000036   0xF898 0x0002      LDRB     R0,[R8, #+2]
   \   0000003A   0xF88D 0x0002      STRB     R0,[SP, #+2]
    819                  if (GUI_ARRAY_SetItem(&pObj->Handles, Index, &Page, sizeof(MULTIPAGE_PAGE) + strlen(pText))) {
   \   0000003E   0x4628             MOV      R0,R5
   \   00000040   0x.... 0x....      BL       strlen
   \   00000044   0x1D03             ADDS     R3,R0,#+4
   \   00000046   0xAA00             ADD      R2,SP,#+0
   \   00000048   0x4639             MOV      R1,R7
   \   0000004A   0xF106 0x002A      ADD      R0,R6,#+42
   \   0000004E   0x.... 0x....      BL       GUI_ARRAY_SetItem
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD012             BEQ.N    ??MULTIPAGE_SetText_0
    820                    pPage = (MULTIPAGE_PAGE*) GUI_ARRAY_GetpItem(&pObj->Handles, Index);
   \   00000056   0x4639             MOV      R1,R7
   \   00000058   0xF106 0x002A      ADD      R0,R6,#+42
   \   0000005C   0x.... 0x....      BL       GUI_ARRAY_GetpItem
   \   00000060   0x4680             MOV      R8,R0
    821                    memcpy(&pPage->acText, pText, strlen(pText) + 1);          
   \   00000062   0x4628             MOV      R0,R5
   \   00000064   0x.... 0x....      BL       strlen
   \   00000068   0x1C42             ADDS     R2,R0,#+1
   \   0000006A   0x4629             MOV      R1,R5
   \   0000006C   0xF108 0x0003      ADD      R0,R8,#+3
   \   00000070   0x.... 0x....      BL       memcpy
    822                    _UpdatePositions(hObj, pObj);
   \   00000074   0x4631             MOV      R1,R6
   \   00000076   0x4620             MOV      R0,R4
   \   00000078   0x.... 0x....      BL       _UpdatePositions
    823                  }
    824                }
    825              }
    826              WM_UNLOCK();
    827            }
    828          }
   \                     ??MULTIPAGE_SetText_0: (+1)
   \   0000007C   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}  ;; return
    829          
    830          /*********************************************************************
    831          *
    832          *       MULTIPAGE_SetBkColor
    833          */

   \                                 In section .text, align 2, keep-with-next
    834          void MULTIPAGE_SetBkColor(MULTIPAGE_Handle hObj, GUI_COLOR Color, unsigned Index) {
   \                     MULTIPAGE_SetBkColor: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    835            MULTIPAGE_Obj* pObj;
    836            if (hObj && ((int)Index < MULTIPAGE_NUMCOLORS)) {
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD00D             BEQ.N    ??MULTIPAGE_SetBkColor_0
   \   0000000C   0x2E02             CMP      R6,#+2
   \   0000000E   0xDA0B             BGE.N    ??MULTIPAGE_SetBkColor_0
    837              WM_LOCK();
    838              pObj = MULTIPAGE_H2P(hObj);
   \   00000010   0x.... 0x....      BL       GUI_ALLOC_h2p
    839              MULTIPAGE_ASSERT_IS_VALID_PTR(pObj);
    840              if (pObj) {
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD007             BEQ.N    ??MULTIPAGE_SetBkColor_0
    841                pObj->aBkColor[Index] = Color;
   \   00000018   0xEB00 0x0086      ADD      R0,R0,R6, LSL #+2
   \   0000001C   0x6405             STR      R5,[R0, #+64]
    842                WM_InvalidateWindow(hObj);
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000024   0x.... 0x....      B.W      WM_InvalidateWindow
    843              }
    844              WM_UNLOCK();
    845            }
    846          }
   \                     ??MULTIPAGE_SetBkColor_0: (+1)
   \   00000028   0xBD70             POP      {R4-R6,PC}       ;; return
    847          
    848          /*********************************************************************
    849          *
    850          *       MULTIPAGE_SetTextColor
    851          */

   \                                 In section .text, align 2, keep-with-next
    852          void MULTIPAGE_SetTextColor(MULTIPAGE_Handle hObj, GUI_COLOR Color, unsigned Index) {
   \                     MULTIPAGE_SetTextColor: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    853            MULTIPAGE_Obj* pObj;
    854            if (hObj && ((int)Index < MULTIPAGE_NUMCOLORS)) {
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD00D             BEQ.N    ??MULTIPAGE_SetTextColor_0
   \   0000000C   0x2E02             CMP      R6,#+2
   \   0000000E   0xDA0B             BGE.N    ??MULTIPAGE_SetTextColor_0
    855              WM_LOCK();
    856              pObj = MULTIPAGE_H2P(hObj);
   \   00000010   0x.... 0x....      BL       GUI_ALLOC_h2p
    857              MULTIPAGE_ASSERT_IS_VALID_PTR(pObj);
    858              if (pObj) {
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD007             BEQ.N    ??MULTIPAGE_SetTextColor_0
    859                pObj->aTextColor[Index] = Color;
   \   00000018   0xEB00 0x0086      ADD      R0,R0,R6, LSL #+2
   \   0000001C   0x6485             STR      R5,[R0, #+72]
    860                WM_InvalidateWindow(hObj);
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000024   0x.... 0x....      B.W      WM_InvalidateWindow
    861              }
    862              WM_UNLOCK();
    863            }
    864          }
   \                     ??MULTIPAGE_SetTextColor_0: (+1)
   \   00000028   0xBD70             POP      {R4-R6,PC}       ;; return
    865          
    866          /*********************************************************************
    867          *
    868          *       MULTIPAGE_SetFont
    869          */

   \                                 In section .text, align 2, keep-with-next
    870          void MULTIPAGE_SetFont(MULTIPAGE_Handle hObj, const GUI_FONT GUI_UNI_PTR * pFont) {
   \                     MULTIPAGE_SetFont: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    871            MULTIPAGE_Obj* pObj;
    872            if (hObj && pFont) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD00C             BEQ.N    ??MULTIPAGE_SetFont_0
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD00A             BEQ.N    ??MULTIPAGE_SetFont_0
    873              WM_LOCK();
    874              pObj = MULTIPAGE_H2P(hObj);
   \   0000000E   0x.... 0x....      BL       GUI_ALLOC_h2p
    875              MULTIPAGE_ASSERT_IS_VALID_PTR(pObj);
    876              if (pObj) {
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD006             BEQ.N    ??MULTIPAGE_SetFont_0
    877                pObj->Font = pFont;
   \   00000016   0x63C5             STR      R5,[R0, #+60]
    878                _UpdatePositions(hObj, pObj);
   \   00000018   0x4601             MOV      R1,R0
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000020   0x.... 0x....      B.W      _UpdatePositions
    879              }
    880              WM_UNLOCK();
    881            }
    882          }
   \                     ??MULTIPAGE_SetFont_0: (+1)
   \   00000024   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    883          
    884          /*********************************************************************
    885          *
    886          *       MULTIPAGE_SetAlign
    887          */

   \                                 In section .text, align 2, keep-with-next
    888          void MULTIPAGE_SetAlign(MULTIPAGE_Handle hObj, unsigned Align) {
   \                     MULTIPAGE_SetAlign: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    889            MULTIPAGE_Obj* pObj;
    890            GUI_RECT rClient;
    891            if (hObj) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD01B             BEQ.N    ??MULTIPAGE_SetAlign_0
    892              WM_LOCK();
    893              pObj = MULTIPAGE_H2P(hObj);
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000000E   0x0006             MOVS     R6,R0
    894              MULTIPAGE_ASSERT_IS_VALID_PTR(pObj);
    895              if (pObj) {
   \   00000010   0xD017             BEQ.N    ??MULTIPAGE_SetAlign_0
    896                pObj->Align = Align;
   \   00000012   0x63B5             STR      R5,[R6, #+56]
    897                _CalcClientRect(pObj, &rClient);
   \   00000014   0xA900             ADD      R1,SP,#+0
   \   00000016   0x.... 0x....      BL       _CalcClientRect
    898                WM_MoveTo(pObj->hClient, rClient.x0 + pObj->Widget.Win.Rect.x0,
    899                                         rClient.y0 + pObj->Widget.Win.Rect.y0);
   \   0000001A   0xF9BD 0x0002      LDRSH    R0,[SP, #+2]
   \   0000001E   0xF9B6 0x1002      LDRSH    R1,[R6, #+2]
   \   00000022   0xFA01 0xF280      SXTAH    R2,R1,R0
   \   00000026   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \   0000002A   0xF9B6 0x1000      LDRSH    R1,[R6, #+0]
   \   0000002E   0xFA01 0xF180      SXTAH    R1,R1,R0
   \   00000032   0xF9B6 0x0028      LDRSH    R0,[R6, #+40]
   \   00000036   0x.... 0x....      BL       WM_MoveTo
    900                _UpdatePositions(hObj, pObj);
   \   0000003A   0x4631             MOV      R1,R6
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0x.... 0x....      BL       _UpdatePositions
    901              }
    902              WM_UNLOCK();
    903            }
    904          }
   \                     ??MULTIPAGE_SetAlign_0: (+1)
   \   00000042   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    905          
    906          /*********************************************************************
    907          *
    908          *       MULTIPAGE_GetSelection
    909          */

   \                                 In section .text, align 2, keep-with-next
    910          int MULTIPAGE_GetSelection(MULTIPAGE_Handle hObj) {
   \                     MULTIPAGE_GetSelection: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    911            int r = 0;
   \   00000002   0x2400             MOVS     R4,#+0
    912            if (hObj) {
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD004             BEQ.N    ??MULTIPAGE_GetSelection_0
    913              MULTIPAGE_Obj* pObj;
    914              WM_LOCK();
    915              pObj = MULTIPAGE_H2P(hObj);
   \   00000008   0x.... 0x....      BL       GUI_ALLOC_h2p
    916              MULTIPAGE_ASSERT_IS_VALID_PTR(pObj);
    917              if (pObj) {
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD000             BEQ.N    ??MULTIPAGE_GetSelection_0
    918                r = pObj->Selection;
   \   00000010   0x6B04             LDR      R4,[R0, #+48]
    919              }
    920              WM_UNLOCK();
    921            }
    922            return r;
   \                     ??MULTIPAGE_GetSelection_0: (+1)
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    923          }
    924          
    925          /*********************************************************************
    926          *
    927          *       MULTIPAGE_GetWindow
    928          */

   \                                 In section .text, align 2, keep-with-next
    929          WM_HWIN MULTIPAGE_GetWindow(MULTIPAGE_Handle hObj, unsigned Index) {
   \                     MULTIPAGE_GetWindow: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
    930            WM_HWIN r = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    931            if (hObj) {
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD00C             BEQ.N    ??MULTIPAGE_GetWindow_0
    932              MULTIPAGE_Obj* pObj;
    933              WM_LOCK();
    934              pObj = MULTIPAGE_H2P(hObj);
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
    935              MULTIPAGE_ASSERT_IS_VALID_PTR(pObj);
    936              if (pObj) {
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD008             BEQ.N    ??MULTIPAGE_GetWindow_0
    937                if ((int)Index < pObj->Handles.NumItems) {
   \   00000012   0x8D41             LDRH     R1,[R0, #+42]
   \   00000014   0x428C             CMP      R4,R1
   \   00000016   0xDA05             BGE.N    ??MULTIPAGE_GetWindow_0
    938                  MULTIPAGE_PAGE* pPage;
    939                  pPage = (MULTIPAGE_PAGE*) GUI_ARRAY_GetpItem(&pObj->Handles, Index);
   \   00000018   0x4621             MOV      R1,R4
   \   0000001A   0x302A             ADDS     R0,R0,#+42
   \   0000001C   0x.... 0x....      BL       GUI_ARRAY_GetpItem
    940                  r = pPage->hWin;
   \   00000020   0xF9B0 0x5000      LDRSH    R5,[R0, #+0]
    941                }
    942              }
    943              WM_UNLOCK();
    944            }
    945            return r;
   \                     ??MULTIPAGE_GetWindow_0: (+1)
   \   00000024   0x4628             MOV      R0,R5
   \   00000026   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    946          }
    947          
    948          /*********************************************************************
    949          *
    950          *       MULTIPAGE_IsPageEnabled
    951          */

   \                                 In section .text, align 2, keep-with-next
    952          int MULTIPAGE_IsPageEnabled(MULTIPAGE_Handle hObj, unsigned Index) {
   \                     MULTIPAGE_IsPageEnabled: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
    953            int r = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    954            if (hObj) {
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD007             BEQ.N    ??MULTIPAGE_IsPageEnabled_0
    955              MULTIPAGE_Obj* pObj;
    956              WM_LOCK();
    957              pObj = MULTIPAGE_H2P(hObj);
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
    958              MULTIPAGE_ASSERT_IS_VALID_PTR(pObj);
    959              if (pObj) {
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD003             BEQ.N    ??MULTIPAGE_IsPageEnabled_0
    960                r = _GetEnable(pObj, Index);
   \   00000012   0x4621             MOV      R1,R4
   \   00000014   0x.... 0x....      BL       _GetEnable
   \   00000018   0x4605             MOV      R5,R0
    961              }
    962              WM_UNLOCK();
    963            }
    964            return r;
   \                     ??MULTIPAGE_IsPageEnabled_0: (+1)
   \   0000001A   0x4628             MOV      R0,R5
   \   0000001C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    965          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x00555555         DC32     0x555555

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x........         DC32     _Callback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x........         DC32     MULTIPAGE__DefaultBkColor

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \   00000000   0x........         DC32     _ClientCallback
    966          
    967          #else /* avoid empty object files */
    968          
    969          void MULTIPAGE_C(void);
    970          void MULTIPAGE_C(void){}
    971          
    972          #endif  /* #if GUI_WINSUPPORT */
    973          
    974          
    975          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   MULTIPAGE_AddPage
        40   -> GUI_ALLOC_h2p
        40   -> GUI_ARRAY_AddItem
        40   -> GUI_ARRAY_GetpItem
        40   -> MULTIPAGE_SelectPage
        40   -> WM_AttachWindowAt
        40   -> memcpy
        40   -> strlen
      40   MULTIPAGE_CreateEx
        40   -> GUI_ALLOC_h2p
        40   -> WIDGET__Init
        40   -> WM_CreateWindowAsChild
        40   -> _CalcClientRect
        40   -> _UpdatePositions
      24   MULTIPAGE_DeletePage
        24   -> GUI_ALLOC_h2p
        24   -> GUI_ARRAY_DeleteItem
        24   -> GUI_ARRAY_GetpItem
         0   -> WM_DeleteWindow
        24   -> _ShowPage
        24   -> _UpdatePositions
      16   MULTIPAGE_DisablePage
        16   -> GUI_ALLOC_h2p
         0   -> WM_InvalidateWindow
        16   -> _SetEnable
      16   MULTIPAGE_EnablePage
        16   -> GUI_ALLOC_h2p
         0   -> WM_InvalidateWindow
        16   -> _SetEnable
       8   MULTIPAGE_GetSelection
         8   -> GUI_ALLOC_h2p
      16   MULTIPAGE_GetWindow
        16   -> GUI_ALLOC_h2p
        16   -> GUI_ARRAY_GetpItem
      16   MULTIPAGE_IsPageEnabled
        16   -> GUI_ALLOC_h2p
        16   -> _GetEnable
      16   MULTIPAGE_SelectPage
        16   -> GUI_ALLOC_h2p
        16   -> _GetEnable
        16   -> _ShowPage
         0   -> _UpdatePositions
      24   MULTIPAGE_SetAlign
        24   -> GUI_ALLOC_h2p
        24   -> WM_MoveTo
        24   -> _CalcClientRect
        24   -> _UpdatePositions
      16   MULTIPAGE_SetBkColor
        16   -> GUI_ALLOC_h2p
         0   -> WM_InvalidateWindow
      16   MULTIPAGE_SetFont
        16   -> GUI_ALLOC_h2p
         0   -> _UpdatePositions
      32   MULTIPAGE_SetText
        32   -> GUI_ALLOC_h2p
        32   -> GUI_ARRAY_GetpItem
        32   -> GUI_ARRAY_SetItem
        32   -> _UpdatePositions
        32   -> memcpy
        32   -> strlen
      16   MULTIPAGE_SetTextColor
        16   -> GUI_ALLOC_h2p
         0   -> WM_InvalidateWindow
      48   _AddScrollbar
        48   -> SCROLLBAR_Create
        48   -> WIDGET_SetEffect
        48   -> WM_GetScrollbarH
        48   -> WM_MoveChildTo
        48   -> WM_SetSize
      16   _CalcBorderRect
        16   -> GUI_GetYSizeOfFont
        16   -> WM__GetClientRectWin
      16   _CalcClientRect
        16   -> GUI_GetYSizeOfFont
        16   -> WIDGET__GetInsideRect
      24   _Callback
        24   -> GUI_ALLOC_h2p
        24   -> GUI_ARRAY_Delete
        24   -> SCROLLBAR_GetValue
        24   -> WIDGET_HandleActive
        24   -> WIDGET_SetEffect
         0   -> WM_DefaultProc
        24   -> WM_GetId
        24   -> WM_GetScrollbarH
         0   -> WM_InvalidateWindow
         0   -> _CalcClientRect
         0   -> _OnTouch
         0   -> _Paint
         0   -> _UpdatePositions
      40   _ClickedOnMultipage
        40   -> MULTIPAGE_SelectPage
        40   -> WM_NotifyParent
        40   -> _GetPagePosX
        40   -> _GetPageSizeX
        40   -> _GetTextRect
      16   _ClientCallback
        16   -> GUI_ALLOC_h2p
         0   -> GUI_Clear
        16   -> LCD_SetBkColor
         0   -> WM_BringToTop
         0   -> WM_DefaultProc
        16   -> WM_GetParent
        16   -> WM_SetFocus
       8   _DeleteScrollbar
         8   -> WM_DeleteWindow
         8   -> WM_GetScrollbarH
      32   _DrawTextItem
        32   -> GUI_DispStringAt
        32   -> GUI_DrawVLine
        32   -> GUI__ReduceRect
        32   -> LCD_SetBkColor
        32   -> LCD_SetColor
        32   -> WIDGET__EFFECT_DrawUpRect
        32   -> WIDGET__FillRectEx
        32   -> __aeabi_memcpy
       8   _GetEnable
         8   -> GUI_ARRAY_GetpItem
      24   _GetPagePosX
        24   -> _GetPageSizeX
      16   _GetPageSizeX
        16   -> GUI_ARRAY_GetpItem
        16   -> GUI_GetStringDistX
        16   -> GUI_SetFont
      24   _GetTextRect
        24   -> GUI_GetYSizeOfFont
        24   -> _CalcBorderRect
        24   -> _GetTextWidth
       0   _GetTextWidth
         0   -> _GetPagePosX
      32   _OnTouch
        32   -- Indirect call
        32   -> GUI_ALLOC_h2p
        32   -> WM_BringToTop
        32   -> WM_GetWindowOrgX
        32   -> WM_GetWindowOrgY
         0   -> WM_NotifyParent
        32   -> WM_Screen2hWinEx
        32   -> _ClickedOnMultipage
      64   _Paint
        64   -> GUI_ARRAY_GetpItem
        64   -> GUI_GetStringDistX
        64   -> GUI_SetFont
        64   -> WIDGET__EFFECT_DrawUpRect
        64   -> WM_SetUserClipRect
        64   -> _CalcBorderRect
        64   -> _DrawTextItem
        64   -> _GetPagePosX
        64   -> _GetTextRect
       8   _SetEnable
         8   -> GUI_ARRAY_GetpItem
      16   _SetScrollbar
        16   -> SCROLLBAR_SetNumItems
        16   -> SCROLLBAR_SetPageSize
         0   -> SCROLLBAR_SetValue
        16   -> WM_GetScrollbarH
      24   _ShowPage
        24   -> GUI_ALLOC_h2p
        24   -> GUI_ARRAY_GetpItem
        24   -> WM_HideWindow
        24   -> WM_SetFocus
        24   -> WM_ShowWindow
      48   _UpdatePositions
        48   -> GUI_GetYSizeOfFont
        48   -> WM_InvalidateWindow
        48   -> WM_MoveChildTo
        48   -> WM_SetSize
        48   -> _AddScrollbar
        48   -> _CalcBorderRect
        48   -> _CalcClientRect
        48   -> _DeleteScrollbar
        48   -> _GetPageSizeX
        48   -> _GetTextRect
        48   -> _GetTextWidth
        48   -> _SetScrollbar


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
     202  MULTIPAGE_AddPage
     156  MULTIPAGE_CreateEx
     124  MULTIPAGE_DeletePage
      38  MULTIPAGE_DisablePage
      38  MULTIPAGE_EnablePage
      22  MULTIPAGE_GetSelection
      40  MULTIPAGE_GetWindow
      30  MULTIPAGE_IsPageEnabled
      64  MULTIPAGE_SelectPage
      68  MULTIPAGE_SetAlign
      42  MULTIPAGE_SetBkColor
      38  MULTIPAGE_SetFont
     128  MULTIPAGE_SetText
      42  MULTIPAGE_SetTextColor
      24  MULTIPAGE__DefaultBkColor
          MULTIPAGE__DefaultTextColor
          MULTIPAGE__pDefaultFont
          MULTIPAGE__DefaultAlign
      94  _AddScrollbar
      48  _CalcBorderRect
      48  _CalcClientRect
     186  _Callback
     150  _ClickedOnMultipage
      84  _ClientCallback
      24  _DeleteScrollbar
     278  _DrawTextItem
      30  _GetEnable
      32  _GetPagePosX
      40  _GetPageSizeX
     108  _GetTextRect
       4  _GetTextWidth
     138  _OnTouch
     190  _Paint
      38  _SetEnable
      48  _SetScrollbar
      84  _ShowPage
     240  _UpdatePositions

 
    24 bytes in section .data
 2 912 bytes in section .text
 
 2 912 bytes of CODE memory
    24 bytes of DATA memory

Errors: none
Warnings: none
