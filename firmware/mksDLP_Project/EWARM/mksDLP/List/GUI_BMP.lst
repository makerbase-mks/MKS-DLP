###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  10:58:04
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Core\GUI_BMP.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Core\GUI_BMP.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\GUI_BMP.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\GUI_BMP.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Core\GUI_BMP.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              µC/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : GUI_BMP.c
     16          Purpose     : Implementation of GUI_BMP... functions
     17          ---------------------------END-OF-HEADER------------------------------
     18          */
     19          
     20          #include <stdlib.h>
     21          
     22          #include "GUI_Private.h"
     23          
     24          /*********************************************************************
     25          *
     26          *       Static functions
     27          *
     28          **********************************************************************
     29          */
     30          /*********************************************************************
     31          *
     32          *       _GetStep
     33          */

   \                                 In section .text, align 2, keep-with-next
     34          static int _GetStep(int * pYSize, int * pY) {
     35            if (*pYSize > 0) {
   \                     _GetStep: (+1)
   \   00000000   0x6802             LDR      R2,[R0, #+0]
   \   00000002   0x2A01             CMP      R2,#+1
   \   00000004   0xDB04             BLT.N    ??_GetStep_0
     36              *pY = *pYSize - 1;
   \   00000006   0x1E50             SUBS     R0,R2,#+1
   \   00000008   0x6008             STR      R0,[R1, #+0]
     37              return -1;
   \   0000000A   0xF04F 0x30FF      MOV      R0,#-1
   \   0000000E   0x4770             BX       LR
     38            } else if (*pYSize < 0) {
   \                     ??_GetStep_0: (+1)
   \   00000010   0x2A00             CMP      R2,#+0
   \   00000012   0xD505             BPL.N    ??_GetStep_1
     39              *pYSize = -*pYSize;
   \   00000014   0x4252             RSBS     R2,R2,#+0
   \   00000016   0x6002             STR      R2,[R0, #+0]
     40              *pY = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x6008             STR      R0,[R1, #+0]
     41              return 1;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x4770             BX       LR
     42            } else {
     43              return 0;
   \                     ??_GetStep_1: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x4770             BX       LR               ;; return
     44            }
     45          }
     46          
     47          /*********************************************************************
     48          *
     49          *       _DrawBitmap_Pal
     50          */

   \                                 In section .text, align 2, keep-with-next
     51          static int _DrawBitmap_Pal(const U8 * pData, int x0, int y0, int XSize, int YSize, int Bpp, int NumColors) {
   \                     _DrawBitmap_Pal: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4616             MOV      R6,R2
   \   0000000C   0x461F             MOV      R7,R3
     52            int i, y, Step;
     53            int BytesPerLine = 0;
   \   0000000E   0xF04F 0x0800      MOV      R8,#+0
     54            Step = _GetStep(&YSize, &y);
   \   00000012   0xA906             ADD      R1,SP,#+24
   \   00000014   0xA810             ADD      R0,SP,#+64
   \   00000016   0x.... 0x....      BL       _GetStep
   \   0000001A   0x4681             MOV      R9,R0
     55            if (!Step) {
   \   0000001C   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000020   0xD101             BNE.N    ??_DrawBitmap_Pal_0
     56              return 1;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xE04B             B.N      ??_DrawBitmap_Pal_1
     57            }
     58            for (i = 0; i < NumColors; i++) {
   \                     ??_DrawBitmap_Pal_0: (+1)
   \   00000026   0x46C2             MOV      R10,R8
   \   00000028   0xF8DD 0xB048      LDR      R11,[SP, #+72]
   \   0000002C   0xE010             B.N      ??_DrawBitmap_Pal_2
     59              U8 r, g, b;
     60              b = *(pData);
   \                     ??_DrawBitmap_Pal_3: (+1)
   \   0000002E   0xF814 0x0B01      LDRB     R0,[R4], #+1
     61              g = *(pData + 1);
   \   00000032   0xF814 0x1B01      LDRB     R1,[R4], #+1
     62              r = *(pData + 2);
   \   00000036   0xF814 0x2B02      LDRB     R2,[R4], #+2
     63              pData += 4;
     64              LCD__aConvTable[i] = LCD_Color2Index(((U32)b << 16) | (g << 8) | r);
   \   0000003A   0x0209             LSLS     R1,R1,#+8
   \   0000003C   0xEA41 0x4000      ORR      R0,R1,R0, LSL #+16
   \   00000040   0x4310             ORRS     R0,R2,R0
   \   00000042   0x.... 0x....      BL       LCD_Color2Index
   \   00000046   0x....             LDR.N    R1,??DataTable1
   \   00000048   0xF821 0x001A      STRH     R0,[R1, R10, LSL #+1]
     65            }
   \   0000004C   0xF10A 0x0A01      ADD      R10,R10,#+1
   \                     ??_DrawBitmap_Pal_2: (+1)
   \   00000050   0x45DA             CMP      R10,R11
   \   00000052   0xDBEC             BLT.N    ??_DrawBitmap_Pal_3
   \   00000054   0xF8DD 0xA044      LDR      R10,[SP, #+68]
     66            switch (Bpp) {
   \   00000058   0x4650             MOV      R0,R10
   \   0000005A   0x2801             CMP      R0,#+1
   \   0000005C   0xD004             BEQ.N    ??_DrawBitmap_Pal_4
   \   0000005E   0x2804             CMP      R0,#+4
   \   00000060   0xD008             BEQ.N    ??_DrawBitmap_Pal_5
   \   00000062   0x2808             CMP      R0,#+8
   \   00000064   0xD00C             BEQ.N    ??_DrawBitmap_Pal_6
   \   00000066   0xE023             B.N      ??_DrawBitmap_Pal_7
     67              case 1:
     68                BytesPerLine = ((XSize + 31) >> 5) << 2;
   \                     ??_DrawBitmap_Pal_4: (+1)
   \   00000068   0xF107 0x001F      ADD      R0,R7,#+31
   \   0000006C   0x1140             ASRS     R0,R0,#+5
   \   0000006E   0xEA4F 0x0880      LSL      R8,R0,#+2
     69                break;
   \   00000072   0xE01D             B.N      ??_DrawBitmap_Pal_7
     70              case 4:
     71                BytesPerLine = (((XSize << 2) + 31) >> 5) << 2;
   \                     ??_DrawBitmap_Pal_5: (+1)
   \   00000074   0x00B8             LSLS     R0,R7,#+2
   \   00000076   0x301F             ADDS     R0,R0,#+31
   \   00000078   0x1140             ASRS     R0,R0,#+5
   \   0000007A   0xEA4F 0x0880      LSL      R8,R0,#+2
     72                break;
   \   0000007E   0xE017             B.N      ??_DrawBitmap_Pal_7
     73              case 8:
     74                BytesPerLine = ((XSize +  3) >> 2) << 2;
   \                     ??_DrawBitmap_Pal_6: (+1)
   \   00000080   0x1CF8             ADDS     R0,R7,#+3
   \   00000082   0xF020 0x0803      BIC      R8,R0,#0x3
     75                break;
   \   00000086   0xE013             B.N      ??_DrawBitmap_Pal_7
     76            }
     77            for (; (y < YSize) && (y >= 0); y += Step) {
     78              LCD_DrawBitmap(x0, y0 + y, XSize, 1, 1, 1, Bpp, XSize, pData, LCD__aConvTable);
   \                     ??_DrawBitmap_Pal_8: (+1)
   \   00000088   0x....             LDR.N    R0,??DataTable1
   \   0000008A   0x9005             STR      R0,[SP, #+20]
   \   0000008C   0x9404             STR      R4,[SP, #+16]
   \   0000008E   0x9703             STR      R7,[SP, #+12]
   \   00000090   0xF8CD 0xA008      STR      R10,[SP, #+8]
   \   00000094   0x2001             MOVS     R0,#+1
   \   00000096   0x9001             STR      R0,[SP, #+4]
   \   00000098   0x9000             STR      R0,[SP, #+0]
   \   0000009A   0x4603             MOV      R3,R0
   \   0000009C   0x463A             MOV      R2,R7
   \   0000009E   0x9806             LDR      R0,[SP, #+24]
   \   000000A0   0x1981             ADDS     R1,R0,R6
   \   000000A2   0x4628             MOV      R0,R5
   \   000000A4   0x.... 0x....      BL       LCD_DrawBitmap
     79              pData += BytesPerLine;
   \   000000A8   0x4444             ADD      R4,R8,R4
     80            }
   \   000000AA   0x9806             LDR      R0,[SP, #+24]
   \   000000AC   0x4448             ADD      R0,R9,R0
   \   000000AE   0x9006             STR      R0,[SP, #+24]
   \                     ??_DrawBitmap_Pal_7: (+1)
   \   000000B0   0x9806             LDR      R0,[SP, #+24]
   \   000000B2   0x9910             LDR      R1,[SP, #+64]
   \   000000B4   0x4288             CMP      R0,R1
   \   000000B6   0xDA01             BGE.N    ??_DrawBitmap_Pal_9
   \   000000B8   0x2800             CMP      R0,#+0
   \   000000BA   0xD5E5             BPL.N    ??_DrawBitmap_Pal_8
     81            return 0;
   \                     ??_DrawBitmap_Pal_9: (+1)
   \   000000BC   0x2000             MOVS     R0,#+0
   \                     ??_DrawBitmap_Pal_1: (+1)
   \   000000BE   0xB007             ADD      SP,SP,#+28
   \   000000C0   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
     82          }
     83          
     84          /*********************************************************************
     85          *
     86          *       _DrawBitmap_24bpp
     87          */

   \                                 In section .text, align 2, keep-with-next
     88          static int _DrawBitmap_24bpp(const U8 * pData, int x0, int y0, int XSize, int YSize) {
   \                     _DrawBitmap_24bpp: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4616             MOV      R6,R2
   \   0000000C   0x461F             MOV      R7,R3
     89            int x, y, BytesPerLine, Step;
     90            Step = _GetStep(&YSize, &y);
   \   0000000E   0xA900             ADD      R1,SP,#+0
   \   00000010   0xA80A             ADD      R0,SP,#+40
   \   00000012   0x.... 0x....      BL       _GetStep
   \   00000016   0x4680             MOV      R8,R0
     91            if (!Step) {
   \   00000018   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000001C   0xD101             BNE.N    ??_DrawBitmap_24bpp_0
     92              return 1;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xE02C             B.N      ??_DrawBitmap_24bpp_1
     93            }
     94            BytesPerLine = ((24 * XSize + 31) >> 5) << 2;
   \                     ??_DrawBitmap_24bpp_0: (+1)
   \   00000022   0xEB07 0x0047      ADD      R0,R7,R7, LSL #+1
   \   00000026   0x00C0             LSLS     R0,R0,#+3
   \   00000028   0x301F             ADDS     R0,R0,#+31
   \   0000002A   0x1140             ASRS     R0,R0,#+5
   \   0000002C   0xEA4F 0x0980      LSL      R9,R0,#+2
   \   00000030   0xE01A             B.N      ??_DrawBitmap_24bpp_2
     95            for (; (y < YSize) && (y >= 0); y += Step) {
     96              for (x = 0; x < XSize; x++) {
     97                const U8 * pColor = pData + 3 * x;
   \                     ??_DrawBitmap_24bpp_3: (+1)
   \   00000032   0xEB0A 0x004A      ADD      R0,R10,R10, LSL #+1
   \   00000036   0x1900             ADDS     R0,R0,R4
     98                U8 r, g, b;
     99                b = *(pColor);
    100                g = *(pColor + 1);
    101                r = *(pColor + 2);
    102                LCD_SetPixelIndex(x0 + x, y0 + y, LCD_Color2Index(((U32)b << 16) | (g << 8) | r));
   \   00000038   0x7801             LDRB     R1,[R0, #+0]
   \   0000003A   0x7842             LDRB     R2,[R0, #+1]
   \   0000003C   0x0212             LSLS     R2,R2,#+8
   \   0000003E   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   00000042   0x7880             LDRB     R0,[R0, #+2]
   \   00000044   0x4308             ORRS     R0,R0,R1
   \   00000046   0x.... 0x....      BL       LCD_Color2Index
   \   0000004A   0x4602             MOV      R2,R0
   \   0000004C   0x9800             LDR      R0,[SP, #+0]
   \   0000004E   0x1981             ADDS     R1,R0,R6
   \   00000050   0xEB0A 0x0005      ADD      R0,R10,R5
   \   00000054   0x.... 0x....      BL       LCD_SetPixelIndex
    103              }
   \   00000058   0xF10A 0x0A01      ADD      R10,R10,#+1
   \                     ??_DrawBitmap_24bpp_4: (+1)
   \   0000005C   0x45BA             CMP      R10,R7
   \   0000005E   0xDBE8             BLT.N    ??_DrawBitmap_24bpp_3
    104              pData += BytesPerLine;
   \   00000060   0x444C             ADD      R4,R9,R4
   \   00000062   0x9800             LDR      R0,[SP, #+0]
   \   00000064   0x4440             ADD      R0,R8,R0
   \   00000066   0x9000             STR      R0,[SP, #+0]
   \                     ??_DrawBitmap_24bpp_2: (+1)
   \   00000068   0x9800             LDR      R0,[SP, #+0]
   \   0000006A   0x990A             LDR      R1,[SP, #+40]
   \   0000006C   0x4288             CMP      R0,R1
   \   0000006E   0xDA04             BGE.N    ??_DrawBitmap_24bpp_5
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD402             BMI.N    ??_DrawBitmap_24bpp_5
   \   00000074   0xF04F 0x0A00      MOV      R10,#+0
   \   00000078   0xE7F0             B.N      ??_DrawBitmap_24bpp_4
    105            }
    106            return 0;
   \                     ??_DrawBitmap_24bpp_5: (+1)
   \   0000007A   0x2000             MOVS     R0,#+0
   \                     ??_DrawBitmap_24bpp_1: (+1)
   \   0000007C   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
    107          }
    108          
    109          /*********************************************************************
    110          *
    111          *       Public code
    112          *
    113          **********************************************************************
    114          */
    115          /*********************************************************************
    116          *
    117          *       GUI_BMP_GetXSize
    118          */

   \                                 In section .text, align 2, keep-with-next
    119          int GUI_BMP_GetXSize(const void * pBMP) {
   \                     GUI_BMP_GetXSize: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    120            const U8 * pSrc = (const U8 *)pBMP;
    121            if (!pBMP) {
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD101             BNE.N    ??GUI_BMP_GetXSize_0
    122              return 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xBD02             POP      {R1,PC}
    123            }
    124            pSrc += 18;                   /* skip rest of BITMAPFILEHEADER */
   \                     ??GUI_BMP_GetXSize_0: (+1)
   \   0000000A   0xF200 0x0012      ADDW     R0,R0,#+18
   \   0000000E   0x9000             STR      R0,[SP, #+0]
    125            return GUI__Read32(&pSrc);
   \   00000010   0xA800             ADD      R0,SP,#+0
   \   00000012   0x.... 0x....      BL       GUI__Read32
   \   00000016   0xBD02             POP      {R1,PC}          ;; return
    126          }
    127          
    128          /*********************************************************************
    129          *
    130          *       GUI_BMP_GetYSize
    131          */

   \                                 In section .text, align 2, keep-with-next
    132          int GUI_BMP_GetYSize(const void * pBMP) {
   \                     GUI_BMP_GetYSize: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    133            const U8 * pSrc = (const U8 *)pBMP;
    134            if (!pBMP) {
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD101             BNE.N    ??GUI_BMP_GetYSize_0
    135              return 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xBD02             POP      {R1,PC}
    136            }
    137            pSrc += 22;
   \                     ??GUI_BMP_GetYSize_0: (+1)
   \   0000000A   0xF200 0x0016      ADDW     R0,R0,#+22
   \   0000000E   0x9000             STR      R0,[SP, #+0]
    138            return labs((int)GUI__Read32(&pSrc));
   \   00000010   0xA800             ADD      R0,SP,#+0
   \   00000012   0x.... 0x....      BL       GUI__Read32
   \   00000016   0x.... 0x....      BL       labs
   \   0000001A   0xBD02             POP      {R1,PC}          ;; return
    139          }
    140          
    141          /*********************************************************************
    142          *
    143          *       GUI_BMP_Draw
    144          */

   \                                 In section .text, align 2, keep-with-next
    145          int GUI_BMP_Draw(const void * pBMP, int x0, int y0) {
   \                     GUI_BMP_Draw: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x460C             MOV      R4,R1
   \   00000008   0x4615             MOV      R5,R2
    146            #if (GUI_WINSUPPORT)
    147              GUI_RECT r;
    148            #endif
    149            int Ret = 0;
   \   0000000A   0x2600             MOVS     R6,#+0
    150            I32 Width, Height;
    151            U16 BitCount, Type;
    152            U32 ClrUsed, Compression;
    153            int NumColors;
    154            const U8 * pSrc = (const U8 *)pBMP;
   \   0000000C   0x9003             STR      R0,[SP, #+12]
    155            Type        = GUI__Read16(&pSrc); /* get type from BITMAPFILEHEADER */
   \   0000000E   0xA803             ADD      R0,SP,#+12
   \   00000010   0x.... 0x....      BL       GUI__Read16
   \   00000014   0x4607             MOV      R7,R0
    156            pSrc += 12;                   /* skip rest of BITMAPFILEHEADER */
    157            /* get values from BITMAPINFOHEADER */
    158            pSrc += 4;
   \   00000016   0x9803             LDR      R0,[SP, #+12]
   \   00000018   0x3010             ADDS     R0,R0,#+16
   \   0000001A   0x9003             STR      R0,[SP, #+12]
    159            Width       = GUI__Read32(&pSrc);
   \   0000001C   0xA803             ADD      R0,SP,#+12
   \   0000001E   0x.... 0x....      BL       GUI__Read32
   \   00000022   0x4680             MOV      R8,R0
    160            Height      = GUI__Read32(&pSrc);
   \   00000024   0xA803             ADD      R0,SP,#+12
   \   00000026   0x.... 0x....      BL       GUI__Read32
   \   0000002A   0x4681             MOV      R9,R0
    161            pSrc += 2;
   \   0000002C   0x9803             LDR      R0,[SP, #+12]
   \   0000002E   0x1C80             ADDS     R0,R0,#+2
   \   00000030   0x9003             STR      R0,[SP, #+12]
    162            BitCount    = GUI__Read16(&pSrc);
   \   00000032   0xA803             ADD      R0,SP,#+12
   \   00000034   0x.... 0x....      BL       GUI__Read16
   \   00000038   0x9004             STR      R0,[SP, #+16]
    163            Compression = GUI__Read32(&pSrc);
   \   0000003A   0xA803             ADD      R0,SP,#+12
   \   0000003C   0x.... 0x....      BL       GUI__Read32
   \   00000040   0x4682             MOV      R10,R0
    164            pSrc += 12;
   \   00000042   0x9803             LDR      R0,[SP, #+12]
   \   00000044   0x300C             ADDS     R0,R0,#+12
   \   00000046   0x9003             STR      R0,[SP, #+12]
    165            ClrUsed     = GUI__Read32(&pSrc);
   \   00000048   0xA803             ADD      R0,SP,#+12
   \   0000004A   0x.... 0x....      BL       GUI__Read32
    166            pSrc += 4;
   \   0000004E   0x9903             LDR      R1,[SP, #+12]
   \   00000050   0x1D09             ADDS     R1,R1,#+4
   \   00000052   0x9103             STR      R1,[SP, #+12]
    167            /* calculate number of colors */
    168            switch (BitCount) {
   \   00000054   0x9904             LDR      R1,[SP, #+16]
   \   00000056   0x2901             CMP      R1,#+1
   \   00000058   0xD006             BEQ.N    ??GUI_BMP_Draw_0
   \   0000005A   0x2904             CMP      R1,#+4
   \   0000005C   0xD007             BEQ.N    ??GUI_BMP_Draw_1
   \   0000005E   0x2908             CMP      R1,#+8
   \   00000060   0xD008             BEQ.N    ??GUI_BMP_Draw_2
   \   00000062   0x2918             CMP      R1,#+24
   \   00000064   0xD009             BEQ.N    ??GUI_BMP_Draw_3
   \   00000066   0xE01F             B.N      ??GUI_BMP_Draw_4
    169              case 0:   return 1; /* biBitCount = 0 (JPEG format) not supported. Please convert image ! */
    170              case 1:   NumColors = 2;   break;
   \                     ??GUI_BMP_Draw_0: (+1)
   \   00000068   0xF04F 0x0B02      MOV      R11,#+2
   \   0000006C   0xE006             B.N      ??GUI_BMP_Draw_5
    171              case 4:   NumColors = 16;  break;
   \                     ??GUI_BMP_Draw_1: (+1)
   \   0000006E   0xF04F 0x0B10      MOV      R11,#+16
   \   00000072   0xE003             B.N      ??GUI_BMP_Draw_5
    172              case 8:   NumColors = 256; break;
   \                     ??GUI_BMP_Draw_2: (+1)
   \   00000074   0xF44F 0x7B80      MOV      R11,#+256
   \   00000078   0xE000             B.N      ??GUI_BMP_Draw_5
    173              case 24:  NumColors = 0;   break;
   \                     ??GUI_BMP_Draw_3: (+1)
   \   0000007A   0x46B3             MOV      R11,R6
    174              default:
    175                return 1; /* biBitCount should be 1, 4, 8 or 24 */
    176            }
    177            if (NumColors && ClrUsed) {
   \                     ??GUI_BMP_Draw_5: (+1)
   \   0000007C   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000080   0xD002             BEQ.N    ??GUI_BMP_Draw_6
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD000             BEQ.N    ??GUI_BMP_Draw_6
    178              NumColors = ClrUsed;
   \   00000086   0x4683             MOV      R11,R0
    179            }
    180            /* check validity of bmp */
    181            if ((NumColors > LCD_MAX_LOG_COLORS) ||
    182                (Type != 0x4d42)                 || /* 'BM' */
    183                (Compression)                    || /* only uncompressed bitmaps */
    184                (Width  > 1024)                  ||
    185                (Height > 1024)) {
   \                     ??GUI_BMP_Draw_6: (+1)
   \   00000088   0xF5BB 0x7F80      CMP      R11,#+256
   \   0000008C   0xDC0C             BGT.N    ??GUI_BMP_Draw_4
   \   0000008E   0xF644 0x5042      MOVW     R0,#+19778
   \   00000092   0x4287             CMP      R7,R0
   \   00000094   0xD108             BNE.N    ??GUI_BMP_Draw_4
   \   00000096   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000009A   0xD105             BNE.N    ??GUI_BMP_Draw_4
   \   0000009C   0xF240 0x4001      MOVW     R0,#+1025
   \   000000A0   0x4580             CMP      R8,R0
   \   000000A2   0xDA01             BGE.N    ??GUI_BMP_Draw_4
   \   000000A4   0x4581             CMP      R9,R0
   \   000000A6   0xDB01             BLT.N    ??GUI_BMP_Draw_7
    186              return 1;
   \                     ??GUI_BMP_Draw_4: (+1)
   \   000000A8   0x2001             MOVS     R0,#+1
   \   000000AA   0xE041             B.N      ??GUI_BMP_Draw_8
    187            }
    188            /* start output */
    189            GUI_LOCK();
    190            #if (GUI_WINSUPPORT)
    191              WM_ADDORG(x0,y0);
   \                     ??GUI_BMP_Draw_7: (+1)
   \   000000AC   0x....             LDR.N    R0,??DataTable1_1
   \   000000AE   0x6C01             LDR      R1,[R0, #+64]
   \   000000B0   0x190C             ADDS     R4,R1,R4
   \   000000B2   0x6C40             LDR      R0,[R0, #+68]
   \   000000B4   0x1945             ADDS     R5,R0,R5
    192              r.x1 = (r.x0 = x0) + Width - 1;
   \   000000B6   0x4620             MOV      R0,R4
   \   000000B8   0xF8AD 0x0014      STRH     R0,[SP, #+20]
   \   000000BC   0xF8BD 0x0014      LDRH     R0,[SP, #+20]
   \   000000C0   0x4440             ADD      R0,R8,R0
   \   000000C2   0x1E40             SUBS     R0,R0,#+1
   \   000000C4   0xF8AD 0x0018      STRH     R0,[SP, #+24]
    193              r.y1 = (r.y0 = y0) + Height - 1;
   \   000000C8   0x4628             MOV      R0,R5
   \   000000CA   0xF8AD 0x0016      STRH     R0,[SP, #+22]
   \   000000CE   0xF8BD 0x0016      LDRH     R0,[SP, #+22]
   \   000000D2   0x4448             ADD      R0,R9,R0
   \   000000D4   0x1E40             SUBS     R0,R0,#+1
   \   000000D6   0xF8AD 0x001A      STRH     R0,[SP, #+26]
    194              WM_ITERATE_START(&r) {
   \   000000DA   0xA805             ADD      R0,SP,#+20
   \   000000DC   0x.... 0x....      BL       WM__InitIVRSearch
   \   000000E0   0x2800             CMP      R0,#+0
   \   000000E2   0xD024             BEQ.N    ??GUI_BMP_Draw_9
    195            #endif
    196            /* Show bitmap */
    197            switch (BitCount) {
   \                     ??GUI_BMP_Draw_10: (+1)
   \   000000E4   0x9804             LDR      R0,[SP, #+16]
   \   000000E6   0x2801             CMP      R0,#+1
   \   000000E8   0xD006             BEQ.N    ??GUI_BMP_Draw_11
   \   000000EA   0x2804             CMP      R0,#+4
   \   000000EC   0xD004             BEQ.N    ??GUI_BMP_Draw_11
   \   000000EE   0x2808             CMP      R0,#+8
   \   000000F0   0xD002             BEQ.N    ??GUI_BMP_Draw_11
   \   000000F2   0x2818             CMP      R0,#+24
   \   000000F4   0xD00E             BEQ.N    ??GUI_BMP_Draw_12
   \   000000F6   0xE016             B.N      ??GUI_BMP_Draw_13
    198              case 1:
    199              case 4:
    200              case 8:
    201                Ret = _DrawBitmap_Pal(pSrc, x0, y0, Width, Height, BitCount, NumColors);
   \                     ??GUI_BMP_Draw_11: (+1)
   \   000000F8   0xF8CD 0xB008      STR      R11,[SP, #+8]
   \   000000FC   0x9804             LDR      R0,[SP, #+16]
   \   000000FE   0x9001             STR      R0,[SP, #+4]
   \   00000100   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \   00000104   0x4643             MOV      R3,R8
   \   00000106   0x462A             MOV      R2,R5
   \   00000108   0x4621             MOV      R1,R4
   \   0000010A   0x9803             LDR      R0,[SP, #+12]
   \   0000010C   0x.... 0x....      BL       _DrawBitmap_Pal
   \   00000110   0x4606             MOV      R6,R0
    202                break;
   \   00000112   0xE008             B.N      ??GUI_BMP_Draw_13
    203              case 24:
    204                Ret = _DrawBitmap_24bpp(pSrc, x0, y0, Width, Height);
   \                     ??GUI_BMP_Draw_12: (+1)
   \   00000114   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \   00000118   0x4643             MOV      R3,R8
   \   0000011A   0x462A             MOV      R2,R5
   \   0000011C   0x4621             MOV      R1,R4
   \   0000011E   0x9803             LDR      R0,[SP, #+12]
   \   00000120   0x.... 0x....      BL       _DrawBitmap_24bpp
   \   00000124   0x4606             MOV      R6,R0
    205                break;
    206            }
    207            #if (GUI_WINSUPPORT)
    208              } WM_ITERATE_END();
   \                     ??GUI_BMP_Draw_13: (+1)
   \   00000126   0x.... 0x....      BL       WM__GetNextIVR
   \   0000012A   0x2800             CMP      R0,#+0
   \   0000012C   0xD1DA             BNE.N    ??GUI_BMP_Draw_10
    209            #endif
    210            GUI_UNLOCK();
    211            return Ret;
   \                     ??GUI_BMP_Draw_9: (+1)
   \   0000012E   0x4630             MOV      R0,R6
   \                     ??GUI_BMP_Draw_8: (+1)
   \   00000130   0xB007             ADD      SP,SP,#+28
   \   00000132   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    212          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     LCD__aConvTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x........         DC32     GUI_Context
    213          
    214          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      64   GUI_BMP_Draw
        64   -> GUI__Read16
        64   -> GUI__Read32
        64   -> WM__GetNextIVR
        64   -> WM__InitIVRSearch
        64   -> _DrawBitmap_24bpp
        64   -> _DrawBitmap_Pal
       8   GUI_BMP_GetXSize
         8   -> GUI__Read32
       8   GUI_BMP_GetYSize
         8   -> GUI__Read32
         8   -> labs
      40   _DrawBitmap_24bpp
        40   -> LCD_Color2Index
        40   -> LCD_SetPixelIndex
        40   -> _GetStep
      64   _DrawBitmap_Pal
        64   -> LCD_Color2Index
        64   -> LCD_DrawBitmap
        64   -> _GetStep
       0   _GetStep


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
     310  GUI_BMP_Draw
      24  GUI_BMP_GetXSize
      28  GUI_BMP_GetYSize
     128  _DrawBitmap_24bpp
     196  _DrawBitmap_Pal
      36  _GetStep

 
 730 bytes in section .text
 
 730 bytes of CODE memory

Errors: none
Warnings: none
