###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  10:59:07
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\LCDDriver\LCDWin.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\LCDDriver\LCDWin.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\LCDWin.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\LCDWin.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\LCDDriver\LCDWin.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              µC/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : LCDWin.C
     16          Purpose     : Driver for Simulator under Windows
     17          ----------------------------------------------------------------------
     18          Version-Date---Author-Explanation
     19          ----------------------------------------------------------------------
     20          2.00a   031007 JE     a) LCD_L0_Init changed, filling not needed at
     21                                   this point
     22          2.00a   030613 JE     a) Parameter of SETPIXEL checked in debug version
     23                                b) _DrawBitLine2bpp and _DrawBitLine4bpp reworked
     24          2.00    010402 RS     a) LCD_GetDevCaps removed from driver
     25                                   (now LCD.c)
     26          1.30c   000529 JE     a) Interface changed
     27          1.30b   000428 RS     a) DIB class eliminated
     28                                b) Internal cleanups, support for high color
     29          1.30a   000417 RS     a) Major cleanup in DIB class
     30          1.30    000309 RS     a) Interface change for emWIn V1.30
     31                                   (LCD_L0_SetLUTEntry, LCD_GetDevCap)
     32          1.10a   000121 RS     a) RECTHEIGHT, RECTWIDTH modified in order to
     33                                   fix bug which would at some time prevent
     34          												 displaying the first line of the display.
     35          1.10.00 000110 RS     a) Modifications in order to make it easy to
     36                                   implement driver in any windows program
     37          1.04.02 991118 RS     a) additional assertion added
     38                                   LCD_MAX_LOG_COLORS
     39          1.04.01 991018 RS     a) Support for LCD_FIXEDPALETTE added
     40                                   with Anitaliasing enabled
     41          1.04.00 991013 JE/RS  a) Support for LCD_FIXEDPALETTE added
     42                                b) Driver now accepts the same LCDConf.h as
     43          											   the embedded system
     44          											c) Bugfix for ..
     45          1.02.02 990831 RS     a) Small optimization added for 16-color bitmaps
     46          1.02.01 990726 RS     a) Transparency support for 16-color bitmpas
     47                                   added
     48          1.02.00 990212 RS     a) New interface version 1.02 supported
     49          1.00    990118 RS     First release
     50          ----------------------------------------------------------------------
     51          Known problems or limitations with current version
     52          ----------------------------------------------------------------------
     53          ---------------------------END-OF-HEADER------------------------------
     54          */
     55          
     56          #if defined(WIN32) && !defined(LCD_SIMCONTROLLER)
     57          
     58          #include <windows.h>
     59          #include "LCD.h"
     60          #include "LCD_Private.h"              /* include LCDConf.h */
     61          #include "LCDSIM.h"
     62          #include "GUI_Private.h"
     63          
     64          #include "memory.h"
     65          
     66          /*********************************************************************
     67          *
     68          *       Defines
     69          *
     70          **********************************************************************
     71          */
     72          
     73          #if LCD_BITSPERPIXEL <= 8
     74            #define PIXELINDEX U8
     75          #else
     76            #define PIXELINDEX WORD
     77          #endif
     78          
     79          #ifdef WIN32
     80            #ifndef ASSERT
     81              #define ASSERT(Val) \
     82              if (!(Val)) \
     83                MessageBox(NULL,"...in file "__FILE__,"Assertion failed...",MB_OK);
     84            #endif
     85          #endif
     86          
     87          #ifdef LCD_ASSERT
     88            #undef LCD_ASSERT
     89          #endif
     90          #define LCD_ASSERT(v) ASSERT(v)
     91          
     92          #ifndef LCD_DISPLAY_INDEX
     93            #define LCD_DISPLAY_INDEX 0
     94          #endif
     95          
     96          /*********************************************************************
     97          *
     98          *       Macros for internal use
     99          */
    100          #ifdef _DEBUG
    101          static int _CheckBound(unsigned int c) {
    102            unsigned int NumColors = LCD_BITSPERPIXEL > 8 ? 0xffff : (1 << LCD_BITSPERPIXEL) - 1;
    103            if (c > NumColors) {
    104              GUI_DEBUG_ERROROUT("LCDWin::SETPIXEL: parameters out of bounds");
    105              return 1;
    106            }
    107            return 0;
    108          }
    109          
    110            #define SETPIXEL(x, y, c) \
    111              if (!_CheckBound(c)) { \
    112                LCDSIM_SetPixelIndex(x, y, c, LCD_DISPLAY_INDEX); \
    113              }
    114          #else
    115            #define SETPIXEL(x, y, c) LCDSIM_SetPixelIndex(x, y, c, LCD_DISPLAY_INDEX)
    116          #endif
    117          #define XORPIXEL(x, y)    _XorPixel(x,y)
    118          
    119          /*********************************************************************
    120          *
    121          *       Static code
    122          *
    123          **********************************************************************
    124          */
    125          
    126          /*********************************************************************
    127          *
    128          *       _XorPixel
    129          */
    130          static void _XorPixel(int x, int y) {
    131            unsigned int Index = LCD_L0_GetPixelIndex(x,y);
    132            LCDSIM_SetPixelIndex(x, y, LCD_NUM_COLORS-1-Index, LCD_DISPLAY_INDEX);
    133          }
    134          
    135          /*********************************************************************
    136          *
    137          *       _DrawBitLine1BPP
    138          */
    139          static void _DrawBitLine1BPP(int x, int y, U8 const*p, int Diff, int xsize, const LCD_PIXELINDEX*pTrans) {
    140            LCD_PIXELINDEX Index0 = *(pTrans+0);
    141            LCD_PIXELINDEX Index1 = *(pTrans+1);
    142            x+=Diff;
    143            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS|LCD_DRAWMODE_XOR)) {
    144            case 0:    /* Write mode */
    145              do {
    146                LCDSIM_SetPixelIndex(x++,y, (*p & (0x80>>Diff)) ? Index1 : Index0, LCD_DISPLAY_INDEX);
    147          			if (++Diff==8) {
    148                  Diff=0;
    149          				p++;
    150          			}
    151          		} while (--xsize);
    152              break;
    153            case LCD_DRAWMODE_TRANS:
    154              do {
    155            		if (*p & (0x80>>Diff))
    156                  LCDSIM_SetPixelIndex(x,y, Index1, LCD_DISPLAY_INDEX);
    157                x++;
    158          			if (++Diff==8) {
    159                  Diff=0;
    160          				p++;
    161          			}
    162          		} while (--xsize);
    163              break;
    164            case LCD_DRAWMODE_XOR:;
    165              do {
    166            		if (*p & (0x80>>Diff)) {
    167                  int Pixel = LCDSIM_GetPixelIndex(x,y, LCD_DISPLAY_INDEX);
    168                  LCDSIM_SetPixelIndex(x,y, LCD_NUM_COLORS-1-Pixel, LCD_DISPLAY_INDEX);
    169                }
    170                x++;
    171          			if (++Diff==8) {
    172                  Diff=0;
    173          				p++;
    174          			}
    175          		} while (--xsize);
    176              break;
    177          	}
    178          }
    179          
    180          /*********************************************************************
    181          *
    182          *       _DrawBitLine2BPP
    183          */
    184          #if (LCD_MAX_LOG_COLORS > 2)
    185          static void _DrawBitLine2BPP(int x, int y, U8 const * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
    186            LCD_PIXELINDEX Pixels = *p;
    187            int CurrentPixel = Diff;
    188            x += Diff;
    189            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
    190              case 0:
    191                if (pTrans) {
    192                  do {
    193                    int Shift = (3 - CurrentPixel) << 1;
    194                    int Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
    195                    LCD_PIXELINDEX PixelIndex = *(pTrans + Index);
    196                    SETPIXEL(x++, y, PixelIndex);
    197                    if (++CurrentPixel == 4) {
    198                      CurrentPixel = 0;
    199                      Pixels = *(++p);
    200                    }
    201          		    } while (--xsize);
    202                } else {
    203                  do {
    204                    int Shift = (3 - CurrentPixel) << 1;
    205                    int Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
    206                    SETPIXEL(x++, y, Index);
    207                    if (++CurrentPixel == 4) {
    208                      CurrentPixel = 0;
    209                      Pixels = *(++p);
    210                    }
    211          		    } while (--xsize);
    212                }
    213                break;
    214              case LCD_DRAWMODE_TRANS:
    215                if (pTrans) {
    216                  do {
    217                    int Shift = (3 - CurrentPixel) << 1;
    218                    int Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
    219                    if (Index) {
    220                      LCD_PIXELINDEX PixelIndex = *(pTrans + Index);
    221                      SETPIXEL(x, y, PixelIndex);
    222                    }
    223                    x++;
    224                    if (++CurrentPixel == 4) {
    225                      CurrentPixel = 0;
    226                      Pixels = *(++p);
    227                    }
    228          		    } while (--xsize);
    229                } else {
    230                  do {
    231                    int Shift = (3 - CurrentPixel) << 1;
    232                    int Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
    233                    if (Index) {
    234                      SETPIXEL(x, y, Index);
    235                    }
    236                    x++;
    237                    if (++CurrentPixel == 4) {
    238                      CurrentPixel = 0;
    239                      Pixels = *(++p);
    240                    }
    241          		    } while (--xsize);
    242                }
    243                break;
    244            }
    245          }
    246          #endif
    247          
    248          /*********************************************************************
    249          *
    250          *       _DrawBitLine4BPP
    251          */
    252          #if (LCD_MAX_LOG_COLORS > 4)
    253          static void _DrawBitLine4BPP(int x, int y, U8 const * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
    254            LCD_PIXELINDEX Pixels = *p;
    255            int CurrentPixel = Diff;
    256            x += Diff;
    257            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
    258              case 0:
    259                if (pTrans) {
    260                  do {
    261                    int Shift = (1 - CurrentPixel) << 2;
    262                    int Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
    263                    LCD_PIXELINDEX PixelIndex = *(pTrans + Index);
    264                    SETPIXEL(x++, y, PixelIndex);
    265                    if (++CurrentPixel == 2) {
    266                      CurrentPixel = 0;
    267                      Pixels = *(++p);
    268                    }
    269          		    } while (--xsize);
    270                } else {
    271                  do {
    272                    int Shift = (1 - CurrentPixel) << 2;
    273                    int Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
    274                    SETPIXEL(x++, y, Index);
    275                    if (++CurrentPixel == 2) {
    276                      CurrentPixel = 0;
    277                      Pixels = *(++p);
    278                    }
    279          		    } while (--xsize);
    280                }
    281                break;
    282              case LCD_DRAWMODE_TRANS:
    283                if (pTrans) {
    284                  do {
    285                    int Shift = (1 - CurrentPixel) << 2;
    286                    int Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
    287                    if (Index) {
    288                      LCD_PIXELINDEX PixelIndex = *(pTrans + Index);
    289                      SETPIXEL(x, y, PixelIndex);
    290                    }
    291                    x++;
    292                    if (++CurrentPixel == 2) {
    293                      CurrentPixel = 0;
    294                      Pixels = *(++p);
    295                    }
    296          		    } while (--xsize);
    297                } else {
    298                  do {
    299                    int Shift = (1 - CurrentPixel) << 2;
    300                    int Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
    301                    if (Index) {
    302                      SETPIXEL(x, y, Index);
    303                    }
    304                    x++;
    305                    if (++CurrentPixel == 2) {
    306                      CurrentPixel = 0;
    307                      Pixels = *(++p);
    308                    }
    309          		    } while (--xsize);
    310                }
    311                break;
    312            }
    313          }
    314          #endif
    315          
    316          /*********************************************************************
    317          *
    318          *       _DrawBitLine8BPP
    319          */
    320          #if (LCD_MAX_LOG_COLORS > 16)
    321          static void _DrawBitLine8BPP(int x, int y, U8 const*p, int xsize, const LCD_PIXELINDEX*pTrans) {
    322            LCD_PIXELINDEX pixel;
    323            if ((GUI_Context.DrawMode & LCD_DRAWMODE_TRANS)==0) {
    324              if (pTrans) {
    325                for (;xsize > 0; xsize--,x++,p++) {
    326                  pixel = *p;
    327                  SETPIXEL(x, y, *(pTrans+pixel));
    328                }
    329              } else {
    330                for (;xsize > 0; xsize--,x++,p++) {
    331                  SETPIXEL(x, y, *p);
    332                }
    333              }
    334            } else {   /* Handle transparent bitmap */
    335              if (pTrans) {
    336                for (; xsize > 0; xsize--, x++, p++) {
    337                  pixel = *p;
    338                  if (pixel) {
    339                    SETPIXEL(x+0, y, *(pTrans+pixel));
    340                  }
    341                }
    342              } else {
    343                for (; xsize > 0; xsize--, x++, p++) {
    344                  pixel = *p;
    345                  if (pixel) {
    346                    SETPIXEL(x+0, y, pixel);
    347                  }
    348                }
    349              }
    350            }
    351          }
    352          #endif
    353          
    354          /*********************************************************************
    355          *
    356          *       _DrawBitLine16BPP
    357          */
    358          #if (LCD_BITSPERPIXEL > 8)
    359          static void _DrawBitLine16BPP(int x, int y, U16 const*p, int xsize, const LCD_PIXELINDEX*pTrans) {
    360            LCD_PIXELINDEX pixel;
    361            if ((GUI_Context.DrawMode & LCD_DRAWMODE_TRANS)==0) {
    362              if (pTrans) {
    363                for (;xsize > 0; xsize--,x++,p++) {
    364                  pixel = *p;
    365                  SETPIXEL(x, y, *(pTrans+pixel));
    366                }
    367              } else {
    368                for (;xsize > 0; xsize--,x++,p++) {
    369                  SETPIXEL(x, y, *p);
    370                }
    371              }
    372            } else {   /* Handle transparent bitmap */
    373              if (pTrans) {
    374                for (; xsize > 0; xsize--, x++, p++) {
    375                  pixel = *p;
    376                  if (pixel) {
    377                    SETPIXEL(x+0, y, *(pTrans+pixel));
    378                  }
    379                }
    380              } else {
    381                for (; xsize > 0; xsize--, x++, p++) {
    382                  pixel = *p;
    383                  if (pixel) {
    384                    SETPIXEL(x+0, y, pixel);
    385                  }
    386                }
    387              }
    388            }
    389          }
    390          #endif
    391          
    392          /*********************************************************************
    393          *
    394          *       Exported code
    395          *
    396          **********************************************************************
    397          */
    398          
    399          /*********************************************************************
    400          *
    401          *       LCD_L0_DrawPixel
    402          *
    403          *  Purpose:  Writes 1 pixel into the display.
    404          */
    405          void LCD_L0_DrawPixel(int x, int y) {
    406            if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
    407              XORPIXEL(x, y);
    408            } else {
    409              SETPIXEL(x, y, LCD_COLORINDEX);
    410            }
    411          }
    412          
    413          /*********************************************************************
    414          *
    415          *       LCD_L0_DrawHLine
    416          */
    417          void LCD_L0_DrawHLine(int x0, int y,  int x1) {
    418            if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
    419              for (;x0 <= x1; x0++) {
    420                XORPIXEL(x0, y);
    421              }
    422            } else {
    423              for (;x0 <= x1; x0++) {
    424                SETPIXEL(x0, y, LCD_COLORINDEX);
    425              }
    426            }
    427          }
    428          
    429          /*********************************************************************
    430          *
    431          *       LCD_L0_DrawVLine
    432          */
    433          void LCD_L0_DrawVLine(int x, int y0,  int y1) {
    434            if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
    435              while (y0 <= y1) {
    436                XORPIXEL(x, y0);
    437                y0++;
    438              }
    439            } else {
    440              while (y0 <= y1) {
    441                SETPIXEL(x, y0, LCD_COLORINDEX);
    442                y0++;
    443              }
    444            }
    445          }
    446          
    447          /*********************************************************************
    448          *
    449          *       LCD_L0_FillRect
    450          */
    451          void LCD_L0_FillRect(int x0, int y0, int x1, int y1) {
    452            for (; y0 <= y1; y0++) {
    453              LCD_L0_DrawHLine(x0,y0, x1);
    454            }
    455          }
    456          
    457          /*********************************************************************
    458          *
    459          *       LCD_L0_DrawBitmap
    460          */
    461          void LCD_L0_DrawBitmap(int x0, int y0,
    462                                 int xsize, int ysize,
    463                                 int BitsPerPixel, 
    464                                 int BytesPerLine,
    465                                 const U8* pData, int Diff,
    466                                 const LCD_PIXELINDEX* pTrans)
    467          {
    468            int i;
    469            /*
    470               Use DrawBitLineXBPP
    471            */
    472            for (i=0; i<ysize; i++) {
    473              switch (BitsPerPixel) {
    474              case 1:
    475                _DrawBitLine1BPP(x0, i+y0, pData, Diff, xsize, pTrans);
    476                break;
    477              #if (LCD_MAX_LOG_COLORS > 2)
    478                case 2:
    479                  _DrawBitLine2BPP(x0, i+y0, pData, Diff, xsize, pTrans);
    480                  break;
    481              #endif
    482              #if (LCD_MAX_LOG_COLORS > 4)
    483                case 4:
    484                  _DrawBitLine4BPP(x0, i+y0, pData, Diff, xsize, pTrans);
    485                  break;
    486              #endif
    487              #if (LCD_MAX_LOG_COLORS > 16)
    488                case 8:
    489                  _DrawBitLine8BPP(x0, i+y0, pData, xsize, pTrans);
    490                  break;
    491              #endif
    492              #if (LCD_BITSPERPIXEL > 8)
    493                case 16:
    494                  _DrawBitLine16BPP(x0, i+y0, (const U16 *)pData, xsize, pTrans);
    495                  break;
    496              #endif
    497              }
    498              pData += BytesPerLine;
    499            }
    500          }
    501          
    502          /*********************************************************************
    503          *
    504          *       LCD_L0_DrawBitmap
    505          *
    506          *  Purpose:
    507          *    Sets the original position of the virtual display.
    508          *    Has no function at this point with the PC-driver.
    509          */
    510          void LCD_L0_SetOrg(int x, int y) {
    511            GUI_USE_PARA(x);
    512            GUI_USE_PARA(y);
    513          }
    514          
    515          /*********************************************************************
    516          *
    517          *       Support for verification
    518          *
    519          *  Purpose:
    520          *    The following routines are implemented, but have no functionility
    521          *    at this point. The reason is that these functions are supposed
    522          *    to supervise the hardware, which for obvious reasons can not be
    523          *    done in a simulation.
    524          */
    525          #if LCD_VERIFY
    526          int  LCD_GetErrStat(void) {
    527            return 0;
    528          }
    529          void LCD_ClrErrStat(void) {
    530          }
    531          int  LCD_GetErrCnt (void) {
    532            return 0;
    533          }
    534          #endif  
    535          
    536          /*********************************************************************
    537          *
    538          *       LCD_On
    539          *       LCD_Off
    540          *
    541          *  (Not supported in Simulation)
    542          */
    543          void LCD_Off          (void) {}
    544          void LCD_On           (void) {}
    545          
    546          /*********************************************************************
    547          *
    548          *       LCD_L0_SetLUTEntry
    549          */
    550          void LCD_L0_SetLUTEntry(U8 Pos, LCD_COLOR color) {
    551            LCDSIM_SetLUTEntry(Pos, color, LCD_DISPLAY_INDEX);
    552          }
    553          
    554          /*********************************************************************
    555          *
    556          *       LCD_L0_Init
    557          */
    558          int  LCD_L0_Init(void) {
    559          	return 0;
    560          }
    561          
    562          int  LCD_L0_CheckInit(void) {
    563            return 0;
    564          } 
    565          
    566          /*********************************************************************
    567          *
    568          *       LCD_L0_ReInit
    569          *
    570          *  Purpose:
    571          *    This routine is supplied for compatibility and interchangability of
    572          *    "C"-sources with embedded versions of the driver. It has no real
    573          *    effect in the PC-version as there is simply no need to re-initialize
    574          *    the LCD since it is just simulated anyhow.
    575          */
    576          void LCD_L0_ReInit       (void) {}
    577          
    578          unsigned LCD_L0_GetPixelIndex(int x, int y)  {
    579            return LCDSIM_GetPixelIndex(x,y, LCD_DISPLAY_INDEX);
    580          }
    581          
    582          /*********************************************************************
    583          *
    584          *       LCD_L0_XorPixel
    585          *
    586          *  Purpose:
    587          *    Inverts 1 pixel of the display.
    588          */
    589          void LCD_L0_XorPixel(int x, int y) {
    590            XORPIXEL(x, y);
    591          }
    592          
    593          /*********************************************************************
    594          *
    595          *       LCD_L0_SetPixelIndex
    596          *
    597          *  Purpose:
    598          *    Writes 1 pixel into the display.
    599          */
    600          void LCD_L0_SetPixelIndex(int x, int y, int ColorIndex) {
    601            SETPIXEL(x, y, ColorIndex);
    602          }
    603          
    604          #else
    605            void LCDWin_c(void);

   \                                 In section .text, align 2, keep-with-next
    606            void LCDWin_c(void) { } /* avoid empty object files */
   \                     LCDWin_c: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    607          #endif /* defined(WIN32) && defined(LCD_USE_WINSIM) */
    608          
    609          
    610          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   LCDWin_c


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       2  LCDWin_c

 
 2 bytes in section .text
 
 2 bytes of CODE memory

Errors: none
Warnings: none
