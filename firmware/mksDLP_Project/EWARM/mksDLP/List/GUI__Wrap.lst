###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  10:58:02
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Core\GUI__Wrap.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Core\GUI__Wrap.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\GUI__Wrap.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\GUI__Wrap.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Core\GUI__Wrap.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              µC/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : GUI__WRAP.c
     16          Purpose     : Implementation of wrap routines
     17          ---------------------------END-OF-HEADER------------------------------
     18          */
     19          
     20          #include "GUI_Protected.h"
     21          
     22          /*********************************************************************
     23          *
     24          *       static code
     25          *
     26          **********************************************************************
     27          */
     28          /*********************************************************************
     29          *
     30          *       _IsLineEnd
     31          */

   \                                 In section .text, align 2, keep-with-next
     32          static int _IsLineEnd(U16 Char) {
     33            if (!Char || (Char == '\n')) {
   \                     _IsLineEnd: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD001             BEQ.N    ??_IsLineEnd_0
   \   00000004   0x280A             CMP      R0,#+10
   \   00000006   0xD101             BNE.N    ??_IsLineEnd_1
     34              return 1;
   \                     ??_IsLineEnd_0: (+1)
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x4770             BX       LR
     35            }
     36            return 0;
   \                     ??_IsLineEnd_1: (+1)
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return
     37          }
     38          
     39          /*********************************************************************
     40          *
     41          *       _GetWordWrap
     42          */

   \                                 In section .text, align 2, keep-with-next
     43          static int _GetWordWrap(const char GUI_UNI_PTR * s, int xSize) {
   \                     _GetWordWrap: (+1)
   \   00000000   0xE92D 0x43F1      PUSH     {R0,R4-R9,LR}
   \   00000004   0x460C             MOV      R4,R1
     44            int xDist = 0, NumChars = 0, WordWrap = 0;
   \   00000006   0x2500             MOVS     R5,#+0
   \   00000008   0x462E             MOV      R6,R5
   \   0000000A   0x462F             MOV      R7,R5
     45            U16 Char, PrevChar = 0;
   \   0000000C   0x46A8             MOV      R8,R5
   \   0000000E   0xE000             B.N      ??_GetWordWrap_0
     46            while (1) {
     47              Char = GUI_UC__GetCharCodeInc(&s);   /* Similar to:  *s++ */
     48              /* Let's first check if the line end is reached. In this case we are done. */
     49              if (_IsLineEnd(Char)) {
     50                WordWrap = NumChars;
     51                break;
     52              }
     53              /* If current character is a space, we found a wrap position */
     54              if ((Char == ' ') && (Char != PrevChar)) {
     55                WordWrap = NumChars;
     56              }
     57              PrevChar = Char;
     58              xDist += GUI_GetCharDistX(Char);
     59              if ((xDist <= xSize) || (NumChars == 0)) {
     60                NumChars++;
   \                     ??_GetWordWrap_1: (+1)
   \   00000010   0x1C76             ADDS     R6,R6,#+1
     61              } else {
   \                     ??_GetWordWrap_0: (+1)
   \   00000012   0xA800             ADD      R0,SP,#+0
   \   00000014   0x.... 0x....      BL       GUI_UC__GetCharCodeInc
   \   00000018   0x4681             MOV      R9,R0
   \   0000001A   0x.... 0x....      BL       _IsLineEnd
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD001             BEQ.N    ??_GetWordWrap_2
   \   00000022   0x4637             MOV      R7,R6
   \   00000024   0xE00E             B.N      ??_GetWordWrap_3
   \                     ??_GetWordWrap_2: (+1)
   \   00000026   0xF1B9 0x0F20      CMP      R9,#+32
   \   0000002A   0xD102             BNE.N    ??_GetWordWrap_4
   \   0000002C   0x45C1             CMP      R9,R8
   \   0000002E   0xD000             BEQ.N    ??_GetWordWrap_4
   \   00000030   0x4637             MOV      R7,R6
   \                     ??_GetWordWrap_4: (+1)
   \   00000032   0x46C8             MOV      R8,R9
   \   00000034   0x4648             MOV      R0,R9
   \   00000036   0x.... 0x....      BL       GUI_GetCharDistX
   \   0000003A   0x1945             ADDS     R5,R0,R5
   \   0000003C   0x42AC             CMP      R4,R5
   \   0000003E   0xDAE7             BGE.N    ??_GetWordWrap_1
   \   00000040   0x2E00             CMP      R6,#+0
   \   00000042   0xD0E5             BEQ.N    ??_GetWordWrap_1
     62                break;
     63              }
     64            }
     65            if (!WordWrap) {
   \                     ??_GetWordWrap_3: (+1)
   \   00000044   0x2F00             CMP      R7,#+0
   \   00000046   0xD100             BNE.N    ??_GetWordWrap_5
     66              WordWrap = NumChars;
   \   00000048   0x4637             MOV      R7,R6
     67            }
     68            return WordWrap;
   \                     ??_GetWordWrap_5: (+1)
   \   0000004A   0x4638             MOV      R0,R7
   \   0000004C   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
     69          }
     70          
     71          /*********************************************************************
     72          *
     73          *       _GetCharWrap
     74          */

   \                                 In section .text, align 2, keep-with-next
     75          static int _GetCharWrap(const char GUI_UNI_PTR * s, int xSize) {
   \                     _GetCharWrap: (+1)
   \   00000000   0xB5F1             PUSH     {R0,R4-R7,LR}
   \   00000002   0x460C             MOV      R4,R1
     76            int xDist = 0, NumChars = 0;
   \   00000004   0x2500             MOVS     R5,#+0
   \   00000006   0x462E             MOV      R6,R5
   \   00000008   0xE000             B.N      ??_GetCharWrap_0
     77            U16 Char;
     78            while ((Char = GUI_UC__GetCharCodeInc(&s)) != 0) {
     79              xDist += GUI_GetCharDistX(Char);
     80              if ((NumChars && (xDist > xSize)) || (Char == '\n')) {
     81                break;
     82              }
     83              NumChars++;
   \                     ??_GetCharWrap_1: (+1)
   \   0000000A   0x1C76             ADDS     R6,R6,#+1
   \                     ??_GetCharWrap_0: (+1)
   \   0000000C   0xA800             ADD      R0,SP,#+0
   \   0000000E   0x.... 0x....      BL       GUI_UC__GetCharCodeInc
   \   00000012   0x0007             MOVS     R7,R0
   \   00000014   0xD008             BEQ.N    ??_GetCharWrap_2
   \   00000016   0x.... 0x....      BL       GUI_GetCharDistX
   \   0000001A   0x1945             ADDS     R5,R0,R5
   \   0000001C   0x2E00             CMP      R6,#+0
   \   0000001E   0xD001             BEQ.N    ??_GetCharWrap_3
   \   00000020   0x42AC             CMP      R4,R5
   \   00000022   0xDB01             BLT.N    ??_GetCharWrap_2
   \                     ??_GetCharWrap_3: (+1)
   \   00000024   0x2F0A             CMP      R7,#+10
   \   00000026   0xD1F0             BNE.N    ??_GetCharWrap_1
     84            }
     85            return NumChars;
   \                     ??_GetCharWrap_2: (+1)
   \   00000028   0x4630             MOV      R0,R6
   \   0000002A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
     86          }
     87          
     88          /*********************************************************************
     89          *
     90          *       _GetNoWrap
     91          */

   \                                 In section .text, align 2, keep-with-next
     92          static int _GetNoWrap(const char GUI_UNI_PTR * s) {
     93            return GUI__GetLineNumChars(s, 0x7FFF);
   \                     _GetNoWrap: (+1)
   \   00000000   0xF647 0x71FF      MOVW     R1,#+32767
   \   00000004   0x.... 0x....      B.W      GUI__GetLineNumChars
     94          }
     95          
     96          /*********************************************************************
     97          *
     98          *       puplic code
     99          *
    100          **********************************************************************
    101          */
    102          /*********************************************************************
    103          *
    104          *       GUI__WrapGetNumCharsDisp
    105          *
    106          * Returns:
    107          *  Number of characters to display in the line.
    108          *  Trailing spaces and line end character are
    109          *  not counted
    110          */

   \                                 In section .text, align 2, keep-with-next
    111          int GUI__WrapGetNumCharsDisp(const char GUI_UNI_PTR * pText, int xSize, GUI_WRAPMODE WrapMode) {
    112            int r;
    113            switch (WrapMode) {
   \                     GUI__WrapGetNumCharsDisp: (+1)
   \   00000000   0x2A01             CMP      R2,#+1
   \   00000002   0xD002             BEQ.N    ??GUI__WrapGetNumCharsDisp_0
   \   00000004   0x2A02             CMP      R2,#+2
   \   00000006   0xD001             BEQ.N    ??GUI__WrapGetNumCharsDisp_1
   \   00000008   0xE001             B.N      ??GUI__WrapGetNumCharsDisp_2
    114            case GUI_WRAPMODE_WORD:
    115              r = _GetWordWrap(pText, xSize);
   \                     ??GUI__WrapGetNumCharsDisp_0: (+1)
   \   0000000A   0x....             B.N      _GetWordWrap
    116              break;
    117            case GUI_WRAPMODE_CHAR:
    118              r = _GetCharWrap(pText, xSize);
   \                     ??GUI__WrapGetNumCharsDisp_1: (+1)
   \   0000000C   0x....             B.N      _GetCharWrap
    119              break;
    120            default:
    121              r = _GetNoWrap(pText);
   \                     ??GUI__WrapGetNumCharsDisp_2: (+1)
   \   0000000E   0x....             B.N      _GetNoWrap
    122            }
    123            return r;
    124          }
    125          
    126          /*********************************************************************
    127          *
    128          *       GUI__WrapGetNumCharsToNextLine
    129          */

   \                                 In section .text, align 2, keep-with-next
    130          int GUI__WrapGetNumCharsToNextLine(const char GUI_UNI_PTR * pText, int xSize, GUI_WRAPMODE WrapMode) {
   \                     GUI__WrapGetNumCharsToNextLine: (+1)
   \   00000000   0xB531             PUSH     {R0,R4,R5,LR}
   \   00000002   0x4614             MOV      R4,R2
    131            int NumChars;
    132            U16 Char;
    133            NumChars = GUI__WrapGetNumCharsDisp(pText, xSize, WrapMode);
   \   00000004   0x.... 0x....      BL       GUI__WrapGetNumCharsDisp
   \   00000008   0x4605             MOV      R5,R0
    134            pText   += GUI_UC__NumChars2NumBytes(pText, NumChars);
   \   0000000A   0x4629             MOV      R1,R5
   \   0000000C   0x9800             LDR      R0,[SP, #+0]
   \   0000000E   0x.... 0x....      BL       GUI_UC__NumChars2NumBytes
   \   00000012   0x9900             LDR      R1,[SP, #+0]
   \   00000014   0x1840             ADDS     R0,R0,R1
   \   00000016   0x9000             STR      R0,[SP, #+0]
    135            Char     = GUI_UC__GetCharCodeInc(&pText);
   \   00000018   0xA800             ADD      R0,SP,#+0
   \   0000001A   0x.... 0x....      BL       GUI_UC__GetCharCodeInc
    136            if (Char == '\n') {
   \   0000001E   0x280A             CMP      R0,#+10
   \   00000020   0xD101             BNE.N    ??GUI__WrapGetNumCharsToNextLine_0
    137              NumChars++;
   \   00000022   0x1C6D             ADDS     R5,R5,#+1
   \   00000024   0xE008             B.N      ??GUI__WrapGetNumCharsToNextLine_1
    138            } else {
    139              if (WrapMode == GUI_WRAPMODE_WORD) {
   \                     ??GUI__WrapGetNumCharsToNextLine_0: (+1)
   \   00000026   0x2C01             CMP      R4,#+1
   \   00000028   0xD106             BNE.N    ??GUI__WrapGetNumCharsToNextLine_1
   \   0000002A   0xE003             B.N      ??GUI__WrapGetNumCharsToNextLine_2
    140                while (Char == ' ') {
    141                  NumChars++;
   \                     ??GUI__WrapGetNumCharsToNextLine_3: (+1)
   \   0000002C   0x1C6D             ADDS     R5,R5,#+1
    142                  Char = GUI_UC__GetCharCodeInc(&pText);
   \   0000002E   0xA800             ADD      R0,SP,#+0
   \   00000030   0x.... 0x....      BL       GUI_UC__GetCharCodeInc
    143                }
   \                     ??GUI__WrapGetNumCharsToNextLine_2: (+1)
   \   00000034   0x2820             CMP      R0,#+32
   \   00000036   0xD0F9             BEQ.N    ??GUI__WrapGetNumCharsToNextLine_3
    144              }
    145            }
    146            return NumChars;
   \                     ??GUI__WrapGetNumCharsToNextLine_1: (+1)
   \   00000038   0x4628             MOV      R0,R5
   \   0000003A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    147          }
    148          
    149          /*********************************************************************
    150          *
    151          *       GUI__WrapGetNumBytesToNextLine
    152          */

   \                                 In section .text, align 2, keep-with-next
    153          int GUI__WrapGetNumBytesToNextLine(const char GUI_UNI_PTR * pText, int xSize, GUI_WRAPMODE WrapMode) {
   \                     GUI__WrapGetNumBytesToNextLine: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    154            int NumChars, NumBytes;
    155            NumChars = GUI__WrapGetNumCharsToNextLine(pText, xSize, WrapMode);
   \   00000004   0x.... 0x....      BL       GUI__WrapGetNumCharsToNextLine
    156            NumBytes = GUI_UC__NumChars2NumBytes(pText, NumChars);
    157            return NumBytes;
   \   00000008   0x4601             MOV      R1,R0
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0xE8BD 0x4010      POP      {R4,LR}
   \   00000010   0x.... 0x....      B.W      GUI_UC__NumChars2NumBytes
    158          }
    159          
    160          /*************************** End of file ****************************/
    161          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   GUI__WrapGetNumBytesToNextLine
         0   -> GUI_UC__NumChars2NumBytes
         8   -> GUI__WrapGetNumCharsToNextLine
       0   GUI__WrapGetNumCharsDisp
         0   -> _GetCharWrap
         0   -> _GetNoWrap
         0   -> _GetWordWrap
      16   GUI__WrapGetNumCharsToNextLine
        16   -> GUI_UC__GetCharCodeInc
        16   -> GUI_UC__NumChars2NumBytes
        16   -> GUI__WrapGetNumCharsDisp
      24   _GetCharWrap
        24   -> GUI_GetCharDistX
        24   -> GUI_UC__GetCharCodeInc
       0   _GetNoWrap
         0   -> GUI__GetLineNumChars
      32   _GetWordWrap
        32   -> GUI_GetCharDistX
        32   -> GUI_UC__GetCharCodeInc
        32   -> _IsLineEnd
       0   _IsLineEnd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      20  GUI__WrapGetNumBytesToNextLine
      16  GUI__WrapGetNumCharsDisp
      60  GUI__WrapGetNumCharsToNextLine
      44  _GetCharWrap
       8  _GetNoWrap
      80  _GetWordWrap
      16  _IsLineEnd

 
 244 bytes in section .text
 
 244 bytes of CODE memory

Errors: none
Warnings: none
