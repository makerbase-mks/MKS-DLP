///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM       16/Jul/2019  17:00:12
// Copyright 1999-2014 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\User\ui\QRENCODE\QR_Encode.c
//    Command line =  
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\User\ui\QRENCODE\QR_Encode.c
//        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
//        MKS_DLP_BOARD -D TFT35 -lC
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
//        --diag_suppress Pa050 -o
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
//        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
//        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
//        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
//        7.0\arm\INC\c\DLib_Config_Full.h" -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/ConvertColor\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/ConvertMono\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/Core\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/Font\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/AntiAlias\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/GUIDemo\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/LCDDriver\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/MemDev\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/MultiLayer\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/Widget\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/WM\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI_X\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/Config\
//        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
//        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
//        Workbench 7.0\arm\CMSIS\Include\"
//    List file    =  
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\QR_Encode.s
//
///////////////////////////////////////////////////////////////////////////////

        RTMODEL "__SystemLibrary", "DLib"
        RTMODEL "__dlib_file_descriptor", "1"
        AAPCS BASE,INTERWORK,VFP
        PRESERVE8
        REQUIRE8

        #define SHT_PROGBITS 0x1

        EXTERN memmove
        EXTERN memset
        EXTERN strlen

        PUBLIC AlphabetToBinaly
        PUBLIC ChineseToBinaly
        PUBLIC CountPenalty
        PUBLIC EncodeData
        PUBLIC EncodeSourceData
        PUBLIC FormatModule
        PUBLIC GetBitLength
        PUBLIC GetEncodeVersion
        PUBLIC GetRSCodeWord
        PUBLIC IsAlphabetData
        PUBLIC IsChineseData
        PUBLIC IsKanjiData
        PUBLIC IsNumeralData
        PUBLIC KanjiToBinaly
        PUBLIC Print_2DCode
        PUBLIC QR_VersonInfo
        PUBLIC SetAlignmentPattern
        PUBLIC SetBitStream
        PUBLIC SetCodeWordPattern
        PUBLIC SetFinderPattern
        PUBLIC SetFormatInfoPattern
        PUBLIC SetFunctionModule
        PUBLIC SetMaskingPattern
        PUBLIC SetVersionPattern
        PUBLIC byExpToInt
        PUBLIC byIntToExp
        PUBLIC byRSExp
        PUBLIC byRSExp10
        PUBLIC byRSExp13
        PUBLIC byRSExp15
        PUBLIC byRSExp16
        PUBLIC byRSExp17
        PUBLIC byRSExp18
        PUBLIC byRSExp20
        PUBLIC byRSExp22
        PUBLIC byRSExp24
        PUBLIC byRSExp26
        PUBLIC byRSExp28
        PUBLIC byRSExp30
        PUBLIC byRSExp32
        PUBLIC byRSExp34
        PUBLIC byRSExp36
        PUBLIC byRSExp38
        PUBLIC byRSExp40
        PUBLIC byRSExp42
        PUBLIC byRSExp44
        PUBLIC byRSExp46
        PUBLIC byRSExp48
        PUBLIC byRSExp50
        PUBLIC byRSExp52
        PUBLIC byRSExp54
        PUBLIC byRSExp56
        PUBLIC byRSExp58
        PUBLIC byRSExp60
        PUBLIC byRSExp62
        PUBLIC byRSExp64
        PUBLIC byRSExp66
        PUBLIC byRSExp68
        PUBLIC byRSExp7
        PUBLIC m_bAutoExtent
        PUBLIC m_byAllCodeWord
        PUBLIC m_byBlockMode
        PUBLIC m_byDataCodeWord
        PUBLIC m_byModuleData
        PUBLIC m_byRSWork
        PUBLIC m_nBlockLength
        PUBLIC m_nLevel
        PUBLIC m_nMaskingNo
        PUBLIC m_nSymbleSize
        PUBLIC m_nVersion
        PUBLIC m_ncAllCodeWord
        PUBLIC m_ncDataBlock
        PUBLIC m_ncDataCodeWordBit
        PUBLIC nIndicatorLen8Bit
        PUBLIC nIndicatorLenAlphabet
        PUBLIC nIndicatorLenKanji
        PUBLIC nIndicatorLenNumeral
        
          CFI Names cfiNames0
          CFI StackFrame CFA R13 DATA
          CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
          CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, R13:32, R14:32
          CFI Resource D0:64, D1:64, D2:64, D3:64, D4:64, D5:64, D6:64, D7:64
          CFI Resource D8:64, D9:64, D10:64, D11:64, D12:64, D13:64, D14:64
          CFI Resource D15:64
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 4
          CFI ReturnAddress R14 CODE
          CFI CFA R13+0
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R12 Undefined
          CFI R14 SameValue
          CFI D0 Undefined
          CFI D1 Undefined
          CFI D2 Undefined
          CFI D3 Undefined
          CFI D4 Undefined
          CFI D5 Undefined
          CFI D6 Undefined
          CFI D7 Undefined
          CFI D8 SameValue
          CFI D9 SameValue
          CFI D10 SameValue
          CFI D11 SameValue
          CFI D12 SameValue
          CFI D13 SameValue
          CFI D14 SameValue
          CFI D15 SameValue
          CFI EndCommon cfiCommon0
        
// E:\DLP_Proj\DLP_source\branches\DLP_opensource\User\ui\QRENCODE\QR_Encode.c
//    1 #include "string.h"
//    2 #include <integer.h>
//    3 //#include "stm32f40x.h"
//    4 #include "stm32f4xx.h"
//    5 
//    6 typedef signed char bool;
//    7 
//    8 #include "QR_Encode.h"
//    9 //二维码生成原理详见 http://coolshell.cn/articles/10590.html#jtss-tsina
//   10 
//   11 
//   12 
//   13 //P28 表9 QR码符号各版本的纠错特效
//   14 const QR_VERSIONINFO QR_VersonInfo[] = {{0}, // Ver.0
//   15 										 { 1, // Ver.1
//   16 										    26,   19,   16,   13,    9,
//   17 										   0,   0,   0,   0,   0,   0,   0,
//   18 										   1,  26,  19,
//   19 										   1,  26,  16,
//   20 										   1,  26,  13,
//   21 										   1,  26,   9,
//   22 										   0,   0,   0,
//   23 										   0,   0,   0,
//   24 										   0,   0,   0,
//   25 										   0,   0,   0},
//   26 										 { 2, // Ver.2
//   27 										    44,   34,   28,   22,   16,
//   28 										   1,  18,   0,   0,   0,   0,   0,
//   29 										   1,  44,  34,
//   30 										   1,  44,  28,
//   31 										   1,  44,  22,
//   32 										   1,  44,  16,
//   33 										   0,   0,   0,
//   34 										   0,   0,   0,
//   35 										   0,   0,   0,
//   36 										   0,   0,   0},
//   37 										 { 3, // Ver.3
//   38 										    70,   55,   44,   34,   26,
//   39 										   1,  22,   0,   0,   0,   0,   0,
//   40 										   1,  70,  55,
//   41 										   1,  70,  44,
//   42 										   2,  35,  17,
//   43 										   2,  35,  13,
//   44 										   0,   0,   0,
//   45 										   0,   0,   0,
//   46 										   0,   0,   0,
//   47 										   0,   0,   0},
//   48 										 { 4, // Ver.4
//   49 										   100,   80,   64,   48,   36,
//   50 										   1,  26,   0,   0,   0,   0,   0,
//   51 										   1, 100,  80,
//   52 										   2,  50,  32,
//   53 										   2,  50,  24,
//   54 										   4,  25,   9,
//   55 										   0,   0,   0,
//   56 										   0,   0,   0,
//   57 										   0,   0,   0,
//   58 										   0,   0,   0},
//   59 										 { 5, // Ver.5
//   60 										   134,  108,   86,   62,   46,
//   61 										   1,  30,   0,   0,   0,   0,   0,
//   62 										   1, 134, 108,
//   63 										   2,  67,  43,
//   64 										   2,  33,  15,
//   65 										   2,  33,  11,
//   66 										   0,   0,   0,
//   67 										   0,   0,   0,
//   68 										   2,  34,  16,
//   69 										   2,  34,  12},
//   70 										 { 6, // Ver.6
//   71 										   172,  136,  108,   76,   60,
//   72 										   1,  34,   0,   0,   0,   0,   0,
//   73 										   2,  86,  68,
//   74 										   4,  43,  27,
//   75 										   4,  43,  19,
//   76 										   4,  43,  15,
//   77 										   0,   0,   0,
//   78 										   0,   0,   0,
//   79 										   0,   0,   0,
//   80 										   0,   0,   0},
//   81 										 { 7, // Ver.7
//   82 										   196,  156,  124,   88,   66,
//   83 										   2,  22,  38,   0,   0,   0,   0,
//   84 										   2,  98,  78,
//   85 										   4,  49,  31,
//   86 										   2,  32,  14,
//   87 										   4,  39,  13,
//   88 										   0,   0,   0,
//   89 										   0,   0,   0,
//   90 										   4,  33,  15,
//   91 										   1,  40,  14},
//   92 										 { 8, // Ver.8
//   93 										   242,  194,  154,  110,   86,
//   94 										   2,  24,  42,   0,   0,   0,   0,
//   95 										   2, 121,  97,
//   96 										   2,  60,  38,
//   97 										   4,  40,  18,
//   98 										   4,  40,  14,
//   99 										   0,   0,   0,
//  100 										   2,  61,  39,
//  101 										   2,  41,  19,
//  102 										   2,  41,  15},
//  103 										 { 9, // Ver.9
//  104 										   292,  232,  182,  132,  100,
//  105 										   2,  26,  46,   0,   0,   0,   0,
//  106 										   2, 146, 116,
//  107 										   3,  58,  36,
//  108 										   4,  36,  16,
//  109 										   4,  36,  12,
//  110 										   0,   0,   0,
//  111 										   2,  59,  37,
//  112 										   4,  37,  17,
//  113 										   4,  37,  13},
//  114 										 {10, // Ver.10
//  115 										   346,  274,  216,  154,  122,
//  116 										   2,  28,  50,   0,   0,   0,   0,
//  117 										   2,  86,  68,
//  118 										   4,  69,  43,
//  119 										   6,  43,  19,
//  120 										   6,  43,  15,
//  121 										   2,  87,  69,
//  122 										   1,  70,  44,
//  123 										   2,  44,  20,
//  124 										   2,  44,  16},
//  125 										 {11, // Ver.11
//  126 										   404,  324,  254,  180,  140,
//  127 										   2,  30,  54,   0,   0,   0,   0,
//  128 										   4, 101,  81,
//  129 										   1,  80,  50,
//  130 										   4,  50,  22,
//  131 										   3,  36,  12,
//  132 										   0,   0,   0,
//  133 										   4,  81,  51,
//  134 										   4,  51,  23,
//  135 										   8,  37,  13},
//  136 										 {12, // Ver.12
//  137 										   466,  370,  290,  206,  158,
//  138 										   2,  32,  58,   0,   0,   0,   0,
//  139 										   2, 116,  92,
//  140 										   6,  58,  36,
//  141 										   4,  46,  20,
//  142 										   7,  42,  14,
//  143 										   2, 117,  93,
//  144 										   2,  59,  37,
//  145 										   6,  47,  21,
//  146 										   4,  43,  15},
//  147 										 {13, // Ver.13
//  148 										   532,  428,  334,  244,  180,
//  149 										   2,  34,  62,   0,   0,   0,   0,
//  150 										   4, 133, 107,
//  151 										   8,  59,  37,
//  152 										   8,  44,  20,
//  153 										  12,  33,  11,
//  154 										   0,   0,   0,
//  155 										   1,  60,  38,
//  156 										   4,  45,  21,
//  157 										   4,  34,  12},
//  158 										 {14, // Ver.14
//  159 										   581,  461,  365,  261,  197,
//  160 										   3,  26,  46,  66,   0,   0,   0,
//  161 										   3, 145, 115,
//  162 										   4,  64,  40,
//  163 										  11,  36,  16,
//  164 										  11,  36,  12,
//  165 										   1, 146, 116,
//  166 										   5,  65,  41,
//  167 										   5,  37,  17,
//  168 										   5,  37,  13},
//  169 										 {15, // Ver.15
//  170 										   655,  523,  415,  295,  223,
//  171 										   3,  26,  48,  70,   0,   0,   0,
//  172 										   5, 109,  87,
//  173 										   5,  65,  41,
//  174 										   5,  54,  24,
//  175 										  11,  36,  12,
//  176 										   1, 110,  88,
//  177 										   5,  66,  42,
//  178 										   7,  55,  25,
//  179 										   7,  37,  13},
//  180 										 {16, // Ver.16
//  181 										   733,  589,  453,  325,  253,
//  182 										   3,  26,  50,  74,   0,   0,   0,
//  183 										   5, 122,  98,
//  184 										   7,  73,  45,
//  185 										  15,  43,  19,
//  186 										   3,  45,  15,
//  187 										   1, 123,  99,
//  188 										   3,  74,  46,
//  189 										   2,  44,  20,
//  190 										  13,  46,  16},
//  191 										 {17, // Ver.17
//  192 										   815,  647,  507,  367,  283,
//  193 										   3,  30,  54,  78,   0,   0,   0,
//  194 										   1, 135, 107,
//  195 										  10,  74,  46,
//  196 										   1,  50,  22,
//  197 										   2,  42,  14,
//  198 										   5, 136, 108,
//  199 										   1,  75,  47,
//  200 										  15,  51,  23,
//  201 										  17,  43,  15},
//  202 										 {18, // Ver.18
//  203 										   901,  721,  563,  397,  313,
//  204 										   3,  30,  56,  82,   0,   0,   0,
//  205 										   5, 150, 120,
//  206 										   9,  69,  43,
//  207 										  17,  50,  22,
//  208 										   2,  42,  14,
//  209 										   1, 151, 121,
//  210 										   4,  70,  44,
//  211 										   1,  51,  23,
//  212 										  19,  43,  15},
//  213 										 {19, // Ver.19
//  214 										   991,  795,  627,  445,  341,
//  215 										   3,  30,  58,  86,   0,   0,   0,
//  216 										   3, 141, 113,
//  217 										   3,  70,  44,
//  218 										  17,  47,  21,
//  219 										   9,  39,  13,
//  220 										   4, 142, 114,
//  221 										  11,  71,  45,
//  222 										   4,  48,  22,
//  223 										  16,  40,  14},
//  224 										 {20, // Ver.20
//  225 										  1085,  861,  669,  485,  385,
//  226 										   3,  34,  62,  90,   0,   0,   0,
//  227 										   3, 135, 107,
//  228 										   3,  67,  41,
//  229 										  15,  54,  24,
//  230 										  15,  43,  15,
//  231 										   5, 136, 108,
//  232 										  13,  68,  42,
//  233 										   5,  55,  25,
//  234 										  10,  44,  16},
//  235 										 {21, // Ver.21
//  236 										  1156,  932,  714,  512,  406,
//  237 										   4,  28,  50,  72,  94,   0,   0,
//  238 										   4, 144, 116,
//  239 										  17,  68,  42,
//  240 										  17,  50,  22,
//  241 										  19,  46,  16,
//  242 										   4, 145, 117,
//  243 										   0,   0,   0,
//  244 										   6,  51,  23,
//  245 										   6,  47,  17},
//  246 										 {22, // Ver.22
//  247 										  1258, 1006,  782,  568,  442,
//  248 										   4,  26,  50,  74,  98,   0,   0,
//  249 										   2, 139, 111,
//  250 										  17,  74,  46,
//  251 										   7,  54,  24,
//  252 										  34,  37,  13,
//  253 										   7, 140, 112,
//  254 										   0,   0,   0,
//  255 										  16,  55,  25,
//  256 										   0,   0,   0},
//  257 										 {23, // Ver.23
//  258 										  1364, 1094,  860,  614,  464,
//  259 										   4,  30,  54,  78, 102,   0,   0,
//  260 										   4, 151, 121,
//  261 										   4,  75,  47,
//  262 										  11,  54,  24,
//  263 										  16,  45,  15,
//  264 										   5, 152, 122,
//  265 										  14,  76,  48,
//  266 										  14,  55,  25,
//  267 										  14,  46,  16},
//  268 										 {24, // Ver.24
//  269 										  1474, 1174,  914,  664,  514,
//  270 										   4,  28,  54,  80, 106,   0,   0,
//  271 										   6, 147, 117,
//  272 										   6,  73,  45,
//  273 										  11,  54,  24,
//  274 										  30,  46,  16,
//  275 										   4, 148, 118,
//  276 										  14,  74,  46,
//  277 										  16,  55,  25,
//  278 										   2,  47,  17},
//  279 										 {25, // Ver.25
//  280 										  1588, 1276, 1000,  718,  538,
//  281 										   4,  32,  58,  84, 110,   0,   0,
//  282 										   8, 132, 106,
//  283 										   8,  75,  47,
//  284 										   7,  54,  24,
//  285 										  22,  45,  15,
//  286 										   4, 133, 107,
//  287 										  13,  76,  48,
//  288 										  22,  55,  25,
//  289 										  13,  46,  16},
//  290 										 {26, // Ver.26
//  291 										  1706, 1370, 1062,  754,  596,
//  292 										   4,  30,  58,  86, 114,   0,   0,
//  293 										  10, 142, 114,
//  294 										  19,  74,  46,
//  295 										  28,  50,  22,
//  296 										  33,  46,  16,
//  297 										   2, 143, 115,
//  298 										   4,  75,  47,
//  299 										   6,  51,  23,
//  300 										   4,  47,  17},
//  301 										 {27, // Ver.27
//  302 										  1828, 1468, 1128,  808,  628,
//  303 										   4,  34,  62,  90, 118,   0,   0,
//  304 										   8, 152, 122,
//  305 										  22,  73,  45,
//  306 										   8,  53,  23,
//  307 										  12,  45,  15,
//  308 										   4, 153, 123,
//  309 										   3,  74,  46,
//  310 										  26,  54,  24,
//  311 										  28,  46,  16},
//  312 										 {28, // Ver.28
//  313 										  1921, 1531, 1193,  871,  661,
//  314 										   5,  26,  50,  74,  98, 122,   0,
//  315 										   3, 147, 117,
//  316 										   3,  73,  45,
//  317 										   4,  54,  24,
//  318 										  11,  45,  15,
//  319 										  10, 148, 118,
//  320 										  23,  74,  46,
//  321 										  31,  55,  25,
//  322 										  31,  46,  16},
//  323 										 {29, // Ver.29
//  324 										  2051, 1631, 1267,  911,  701,
//  325 										   5,  30,  54,  78, 102, 126,   0,
//  326 										   7, 146, 116,
//  327 										  21,  73,  45,
//  328 										   1,  53,  23,
//  329 										  19,  45,  15,
//  330 										   7, 147, 117,
//  331 										   7,  74,  46,
//  332 										  37,  54,  24,
//  333 										  26,  46,  16},
//  334 										 {30, // Ver.30
//  335 										  2185, 1735, 1373,  985,  745,
//  336 										   5,  26,  52,  78, 104, 130,   0,
//  337 										   5, 145, 115,
//  338 										  19,  75,  47,
//  339 										  15,  54,  24,
//  340 										  23,  45,  15,
//  341 										  10, 146, 116,
//  342 										  10,  76,  48,
//  343 										  25,  55,  25,
//  344 										  25,  46,  16},
//  345 										 {31, // Ver.31
//  346 										  2323, 1843, 1455, 1033,  793,
//  347 										   5,  30,  56,  82, 108, 134,   0,
//  348 										  13, 145, 115,
//  349 										   2,  74,  46,
//  350 										  42,  54,  24,
//  351 										  23,  45,  15,
//  352 										   3, 146, 116,
//  353 										  29,  75,  47,
//  354 										   1,  55,  25,
//  355 										  28,  46,  16},
//  356 										 {32, // Ver.32
//  357 										  2465, 1955, 1541, 1115,  845,
//  358 										   5,  34,  60,  86, 112, 138,   0,
//  359 										  17, 145, 115,
//  360 										  10,  74,  46,
//  361 										  10,  54,  24,
//  362 										  19,  45,  15,
//  363 										   0,   0,   0,
//  364 										  23,  75,  47,
//  365 										  35,  55,  25,
//  366 										  35,  46,  16},
//  367 										 {33, // Ver.33
//  368 										  2611, 2071, 1631, 1171,  901,
//  369 										   5,  30,  58,  86, 114, 142,   0,
//  370 										  17, 145, 115,
//  371 										  14,  74,  46,
//  372 										  29,  54,  24,
//  373 										  11,  45,  15,
//  374 										   1, 146, 116,
//  375 										  21,  75,  47,
//  376 										  19,  55,  25,
//  377 										  46,  46,  16},
//  378 										 {34, // Ver.34
//  379 										  2761, 2191, 1725, 1231,  961,
//  380 										   5,  34,  62,  90, 118, 146,   0,
//  381 										  13, 145, 115,
//  382 										  14,  74,  46,
//  383 										  44,  54,  24,
//  384 										  59,  46,  16,
//  385 										   6, 146, 116,
//  386 										  23,  75,  47,
//  387 										   7,  55,  25,
//  388 										   1,  47,  17},
//  389 										 {35, // Ver.35
//  390 										  2876, 2306, 1812, 1286,  986,
//  391 										   6,  30,  54,  78, 102, 126, 150,
//  392 										  12, 151, 121,
//  393 										  12,  75,  47,
//  394 										  39,  54,  24,
//  395 										  22,  45,  15,
//  396 										   7, 152, 122,
//  397 										  26,  76,  48,
//  398 										  14,  55,  25,
//  399 										  41,  46,  16},
//  400 										 {36, // Ver.36
//  401 										  3034, 2434, 1914, 1354, 1054,
//  402 										   6,  24,  50,  76, 102, 128, 154,
//  403 										   6, 151, 121,
//  404 										   6,  75,  47,
//  405 										  46,  54,  24,
//  406 										   2,  45,  15,
//  407 										  14, 152, 122,
//  408 										  34,  76,  48,
//  409 										  10,  55,  25,
//  410 										  64,  46,  16},
//  411 										 {37, // Ver.37
//  412 										  3196, 2566, 1992, 1426, 1096,
//  413 										   6,  28,  54,  80, 106, 132, 158,
//  414 										  17, 152, 122,
//  415 										  29,  74,  46,
//  416 										  49,  54,  24,
//  417 										  24,  45,  15,
//  418 										   4, 153, 123,
//  419 										  14,  75,  47,
//  420 										  10,  55,  25,
//  421 										  46,  46,  16},
//  422 										 {38, // Ver.38
//  423 										  3362, 2702, 2102, 1502, 1142,
//  424 										   6,  32,  58,  84, 110, 136, 162,
//  425 										   4, 152, 122,
//  426 										  13,  74,  46,
//  427 										  48,  54,  24,
//  428 										  42,  45,  15,
//  429 										  18, 153, 123,
//  430 										  32,  75,  47,
//  431 										  14,  55,  25,
//  432 										  32,  46,  16},
//  433 										 {39, // Ver.39
//  434 										  3532, 2812, 2216, 1582, 1222,
//  435 										   6,  26,  54,  82, 110, 138, 166,
//  436 										  20, 147, 117,
//  437 										  40,  75,  47,
//  438 										  43,  54,  24,
//  439 										  10,  45,  15,
//  440 										   4, 148, 118,
//  441 										   7,  76,  48,
//  442 										  22,  55,  25,
//  443 										  67,  46,  16},
//  444 										 {40, // Ver.40
//  445 										  3706, 2956, 2334, 1666, 1276,
//  446 										   6,  30,  58,  86, 114, 142, 170,
//  447 										  19, 148, 118,
//  448 										  18,  75,  47,
//  449 										  34,  54,  24,
//  450 										  20,  45,  15,
//  451 										   6, 149, 119,
//  452 										  31,  76,  48,
//  453 										  34,  55,  25,
//  454 										  61,  46,  16}
//  455 										 
//  456 										  
//  457 };
//  458 
//  459 // GF(2^8) 指数2系数――本源多项式
//  460 /////////////////////////////////////////////////////////////////////////////
//  461 const BYTE byExpToInt[] = {  1,   2,   4,   8,  16,  32,  64, 128,  29,  58, 116, 232, 205, 135,  19,  38,
//  462 							 76, 152,  45,  90, 180, 117, 234, 201, 143,   3,   6,  12,  24,  48,  96, 192,
//  463 							157,  39,  78, 156,  37,  74, 148,  53, 106, 212, 181, 119, 238, 193, 159,  35,
//  464 							 70, 140,   5,  10,  20,  40,  80, 160,  93, 186, 105, 210, 185, 111, 222, 161,
//  465 							 95, 190,  97, 194, 153,  47,  94, 188, 101, 202, 137,  15,  30,  60, 120, 240,
//  466 							253, 231, 211, 187, 107, 214, 177, 127, 254, 225, 223, 163,  91, 182, 113, 226,
//  467 							217, 175,  67, 134,  17,  34,  68, 136,  13,  26,  52, 104, 208, 189, 103, 206,
//  468 							129,  31,  62, 124, 248, 237, 199, 147,  59, 118, 236, 197, 151,  51, 102, 204,
//  469 							133,  23,  46,  92, 184, 109, 218, 169,  79, 158,  33,  66, 132,  21,  42,  84,
//  470 							168,  77, 154,  41,  82, 164,  85, 170,  73, 146,  57, 114, 228, 213, 183, 115,
//  471 							230, 209, 191,  99, 198, 145,  63, 126, 252, 229, 215, 179, 123, 246, 241, 255,
//  472 							227, 219, 171,  75, 150,  49,  98, 196, 149,  55, 110, 220, 165,  87, 174,  65,
//  473 							130,  25,  50, 100, 200, 141,   7,  14,  28,  56, 112, 224, 221, 167,  83, 166,
//  474 							 81, 162,  89, 178, 121, 242, 249, 239, 195, 155,  43,  86, 172,  69, 138,   9,
//  475 							 18,  36,  72, 144,  61, 122, 244, 245, 247, 243, 251, 235, 203, 139,  11,  22,
//  476 							 44,  88, 176, 125, 250, 233, 207, 131,  27,  54, 108, 216, 173,  71, 142,   1};
//  477 // GF(2^8) 系数2指数――本源多项式 
//  478 /////////////////////////////////////////////////////////////////////////////
//  479 const BYTE byIntToExp[] = {  0,   0,   1,  25,   2,  50,  26, 198,   3, 223,  51, 238,  27, 104, 199,  75,
//  480 							  4, 100, 224,  14,  52, 141, 239, 129,  28, 193, 105, 248, 200,   8,  76, 113,
//  481 							  5, 138, 101,  47, 225,  36,  15,  33,  53, 147, 142, 218, 240,  18, 130,  69,
//  482 							 29, 181, 194, 125, 106,  39, 249, 185, 201, 154,   9, 120,  77, 228, 114, 166,
//  483 							  6, 191, 139,  98, 102, 221,  48, 253, 226, 152,  37, 179,  16, 145,  34, 136,
//  484 							 54, 208, 148, 206, 143, 150, 219, 189, 241, 210,  19,  92, 131,  56,  70,  64,
//  485 							 30,  66, 182, 163, 195,  72, 126, 110, 107,  58,  40,  84, 250, 133, 186,  61,
//  486 							202,  94, 155, 159,  10,  21, 121,  43,  78, 212, 229, 172, 115, 243, 167,  87,
//  487 							  7, 112, 192, 247, 140, 128,  99,  13, 103,  74, 222, 237,  49, 197, 254,  24,
//  488 							227, 165, 153, 119,  38, 184, 180, 124,  17,  68, 146, 217,  35,  32, 137,  46,
//  489 							 55,  63, 209,  91, 149, 188, 207, 205, 144, 135, 151, 178, 220, 252, 190,  97,
//  490 							242,  86, 211, 171,  20,  42,  93, 158, 132,  60,  57,  83,  71, 109,  65, 162,
//  491 							 31,  45,  67, 216, 183, 123, 164, 118, 196,  23,  73, 236, 127,  12, 111, 246,
//  492 							108, 161,  59,  82,  41, 157,  85, 170, 251,  96, 134, 177, 187, 204,  62,  90,
//  493 							203,  89,  95, 176, 156, 169, 160,  81,  11, 245,  22, 235, 122, 117,  44, 215,
//  494 							 79, 174, 213, 233, 230, 231, 173, 232, 116, 214, 244, 234, 168,  80,  88, 175};
//  495 
//  496 //纠错码字的生成多项式 //P53 附录A
//  497 //这是加罗瓦域2^8以    100011101         表示主模块多项式：
//  498 //X^8+X^4+X^3+X^2+1
//  499 /////////////////////////////////////////////////////////////////////////////

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  500 const BYTE byRSExp7[]  = {87, 229, 146, 149, 238, 102,  21};
byRSExp7:
        DC8 87, 229, 146, 149, 238, 102, 21, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  501 const BYTE byRSExp10[] = {251,  67,  46,  61, 118,  70,  64,  94,  32,  45};
byRSExp10:
        DC8 251, 67, 46, 61, 118, 70, 64, 94, 32, 45, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  502 const BYTE byRSExp13[] = { 74, 152, 176, 100,  86, 100, 106, 104, 130, 218, 206, 140,  78};
byRSExp13:
        DC8 74, 152, 176, 100, 86, 100, 106, 104, 130, 218, 206, 140, 78
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  503 const BYTE byRSExp15[] = {  8, 183,  61,  91, 202,  37,  51,  58,  58, 237, 140, 124,   5,  99, 105};
byRSExp15:
        DC8 8, 183, 61, 91, 202, 37, 51, 58, 58, 237, 140, 124, 5, 99, 105, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  504 const BYTE byRSExp16[] = {120, 104, 107, 109, 102, 161,  76,   3,  91, 191, 147, 169, 182, 194, 225, 120};
byRSExp16:
        DC8 120, 104, 107, 109, 102, 161, 76, 3, 91, 191, 147, 169, 182, 194
        DC8 225, 120

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  505 const BYTE byRSExp17[] = { 43, 139, 206,  78,  43, 239, 123, 206, 214, 147,  24,  99, 150,  39, 243, 163, 136};
byRSExp17:
        DC8 43, 139, 206, 78, 43, 239, 123, 206, 214, 147, 24, 99, 150, 39, 243
        DC8 163, 136, 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  506 const BYTE byRSExp18[] = {215, 234, 158,  94, 184,  97, 118, 170,  79, 187, 152, 148, 252, 179,   5,  98,  96, 153};
byRSExp18:
        DC8 215, 234, 158, 94, 184, 97, 118, 170, 79, 187, 152, 148, 252, 179
        DC8 5, 98, 96, 153, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  507 const BYTE byRSExp20[] = { 17,  60,  79,  50,  61, 163,  26, 187, 202, 180, 221, 225,  83, 239, 156, 164, 212, 212, 188, 190};
byRSExp20:
        DC8 17, 60, 79, 50, 61, 163, 26, 187, 202, 180, 221, 225, 83, 239, 156
        DC8 164, 212, 212, 188, 190

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  508 const BYTE byRSExp22[] = {210, 171, 247, 242,  93, 230,  14, 109, 221,  53, 200,  74,   8, 172,  98,  80, 219, 134, 160, 105,
byRSExp22:
        DC8 210, 171, 247, 242, 93, 230, 14, 109, 221, 53, 200, 74, 8, 172, 98
        DC8 80, 219, 134, 160, 105, 165, 231, 0, 0
//  509 						   165, 231};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  510 const BYTE byRSExp24[] = {229, 121, 135,  48, 211, 117, 251, 126, 159, 180, 169, 152, 192, 226, 228, 218, 111,   0, 117, 232,
byRSExp24:
        DC8 229, 121, 135, 48, 211, 117, 251, 126, 159, 180, 169, 152, 192, 226
        DC8 228, 218, 111, 0, 117, 232, 87, 96, 227, 21
//  511 						    87,  96, 227,  21};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  512 const BYTE byRSExp26[] = {173, 125, 158,   2, 103, 182, 118,  17, 145, 201, 111,  28, 165,  53, 161,  21, 245, 142,  13, 102,
byRSExp26:
        DC8 173, 125, 158, 2, 103, 182, 118, 17, 145, 201, 111, 28, 165, 53
        DC8 161, 21, 245, 142, 13, 102, 48, 227, 153, 145, 218, 70, 0, 0
//  513 						    48, 227, 153, 145, 218,  70};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  514 const BYTE byRSExp28[] = {168, 223, 200, 104, 224, 234, 108, 180, 110, 190, 195, 147, 205,  27, 232, 201,  21,  43, 245,  87,
byRSExp28:
        DC8 168, 223, 200, 104, 224, 234, 108, 180, 110, 190, 195, 147, 205, 27
        DC8 232, 201, 21, 43, 245, 87, 42, 195, 212, 119, 242, 37, 9, 123
//  515 						    42, 195, 212, 119, 242,  37,   9, 123};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  516 const BYTE byRSExp30[] = { 41, 173, 145, 152, 216,  31, 179, 182,  50,  48, 110,  86, 239,  96, 222, 125,  42, 173, 226, 193,
byRSExp30:
        DC8 41, 173, 145, 152, 216, 31, 179, 182, 50, 48, 110, 86, 239, 96, 222
        DC8 125, 42, 173, 226, 193, 224, 130, 156, 37, 251, 216, 238, 40, 192
        DC8 180, 0, 0
//  517 						   224, 130, 156,  37, 251, 216, 238,  40, 192, 180};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  518 const BYTE byRSExp32[] = { 10,   6, 106, 190, 249, 167,   4,  67, 209, 138, 138,  32, 242, 123,  89,  27, 120, 185,  80, 156,
byRSExp32:
        DC8 10, 6, 106, 190, 249, 167, 4, 67, 209, 138, 138, 32, 242, 123, 89
        DC8 27, 120, 185, 80, 156, 38, 69, 171, 60, 28, 222, 80, 52, 254, 185
        DC8 220, 241
//  519 						    38,  69, 171,  60,  28, 222,  80,  52, 254, 185, 220, 241};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  520 const BYTE byRSExp34[] = {111,  77, 146,  94,  26,  21, 108,  19, 105,  94, 113, 193,  86, 140, 163, 125,  58, 158, 229, 239,
byRSExp34:
        DC8 111, 77, 146, 94, 26, 21, 108, 19, 105, 94, 113, 193, 86, 140, 163
        DC8 125, 58, 158, 229, 239, 218, 103, 56, 70, 114, 61, 183, 129, 167
        DC8 13, 98, 62, 129, 51, 0, 0
//  521 						   218, 103,  56,  70, 114,  61, 183, 129, 167,  13,  98,  62, 129,  51};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  522 const BYTE byRSExp36[] = {200, 183,  98,  16, 172,  31, 246, 234,  60, 152, 115,   0, 167, 152, 113, 248, 238, 107,  18,  63,
byRSExp36:
        DC8 200, 183, 98, 16, 172, 31, 246, 234, 60, 152, 115, 0, 167, 152, 113
        DC8 248, 238, 107, 18, 63, 218, 37, 87, 210, 105, 177, 120, 74, 121
        DC8 196, 117, 251, 113, 233, 30, 120
//  523 						   218,  37,  87, 210, 105, 177, 120,  74, 121, 196, 117, 251, 113, 233,  30, 120};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  524 const BYTE byRSExp38[] = {159,  34,  38, 228, 230,  59, 243,  95,  49, 218, 176, 164,  20,  65,  45, 111,  39,  81,  49, 118,
byRSExp38:
        DC8 159, 34, 38, 228, 230, 59, 243, 95, 49, 218, 176, 164, 20, 65, 45
        DC8 111, 39, 81, 49, 118, 113, 222, 193, 250, 242, 168, 217, 41, 164
        DC8 247, 177, 30, 238, 18, 120, 153, 60, 193, 0, 0
//  525 						   113, 222, 193, 250, 242, 168, 217,  41, 164, 247, 177,  30, 238,  18, 120, 153,  60, 193};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  526 const BYTE byRSExp40[] = { 59, 116,  79, 161, 252,  98, 128, 205, 128, 161, 247,  57, 163,  56, 235, 106,  53,  26, 187, 174,
byRSExp40:
        DC8 59, 116, 79, 161, 252, 98, 128, 205, 128, 161, 247, 57, 163, 56
        DC8 235, 106, 53, 26, 187, 174, 226, 104, 170, 7, 175, 35, 181, 114, 88
        DC8 41, 47, 163, 125, 134, 72, 20, 232, 53, 35, 15
//  527 						   226, 104, 170,   7, 175,  35, 181, 114,  88,  41,  47, 163, 125, 134,  72,  20, 232,  53,  35,  15};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  528 const BYTE byRSExp42[] = {250, 103, 221, 230,  25,  18, 137, 231,   0,   3,  58, 242, 221, 191, 110,  84, 230,   8, 188, 106,
byRSExp42:
        DC8 250, 103, 221, 230, 25, 18, 137, 231, 0, 3, 58, 242, 221, 191, 110
        DC8 84, 230, 8, 188, 106, 96, 147, 15, 131, 139, 34, 101, 223, 39, 101
        DC8 213, 199, 237, 254, 201, 123, 171, 162, 194, 117, 50, 96, 0, 0
//  529 						    96, 147,  15, 131, 139,  34, 101, 223,  39, 101, 213, 199, 237, 254, 201, 123, 171, 162, 194, 117,
//  530 						    50,  96};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  531 const BYTE byRSExp44[] = {190,   7,  61, 121,  71, 246,  69,  55, 168, 188,  89, 243, 191,  25,  72, 123,   9, 145,  14, 247,
byRSExp44:
        DC8 190, 7, 61, 121, 71, 246, 69, 55, 168, 188, 89, 243, 191, 25, 72
        DC8 123, 9, 145, 14, 247, 1, 238, 44, 78, 143, 62, 224, 126, 118, 114
        DC8 68, 163, 52, 194, 217, 147, 204, 169, 37, 130, 113, 102, 73, 181
//  532 						     1, 238,  44,  78, 143,  62, 224, 126, 118, 114,  68, 163,  52, 194, 217, 147, 204, 169,  37, 130,
//  533 						   113, 102,  73, 181};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  534 const BYTE byRSExp46[] = {112,  94,  88, 112, 253, 224, 202, 115, 187,  99,  89,   5,  54, 113, 129,  44,  58,  16, 135, 216,
byRSExp46:
        DC8 112, 94, 88, 112, 253, 224, 202, 115, 187, 99, 89, 5, 54, 113, 129
        DC8 44, 58, 16, 135, 216, 169, 211, 36, 1, 4, 96, 60, 241, 73, 104, 234
        DC8 8, 249, 245, 119, 174, 52, 25, 157, 224, 43, 202, 223, 19, 82, 15
        DC8 0, 0
//  535 						   169, 211,  36,   1,   4,  96,  60, 241,  73, 104, 234,   8, 249, 245, 119, 174,  52,  25, 157, 224,
//  536 						    43, 202, 223,  19,  82,  15};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  537 const BYTE byRSExp48[] = {228,  25, 196, 130, 211, 146,  60,  24, 251,  90,  39, 102, 240,  61, 178,  63,  46, 123, 115,  18,
byRSExp48:
        DC8 228, 25, 196, 130, 211, 146, 60, 24, 251, 90, 39, 102, 240, 61, 178
        DC8 63, 46, 123, 115, 18, 221, 111, 135, 160, 182, 205, 107, 206, 95
        DC8 150, 120, 184, 91, 21, 247, 156, 140, 238, 191, 11, 94, 227, 84, 50
        DC8 163, 39, 34, 108
//  538 						   221, 111, 135, 160, 182, 205, 107, 206,  95, 150, 120, 184,  91,  21, 247, 156, 140, 238, 191,  11,
//  539 						    94, 227,  84,  50, 163,  39,  34, 108};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  540 const BYTE byRSExp50[] = {232, 125, 157, 161, 164,   9, 118,  46, 209,  99, 203, 193,  35,   3, 209, 111, 195, 242, 203, 225,
byRSExp50:
        DC8 232, 125, 157, 161, 164, 9, 118, 46, 209, 99, 203, 193, 35, 3, 209
        DC8 111, 195, 242, 203, 225, 46, 13, 32, 160, 126, 209, 130, 160, 242
        DC8 215, 242, 75, 77, 42, 189, 32, 113, 65, 124, 69, 228, 114, 235, 175
        DC8 124, 170, 215, 232, 133, 205, 0, 0
//  541 						    46,  13,  32, 160, 126, 209, 130, 160, 242, 215, 242,  75,  77,  42, 189,  32, 113,  65, 124,  69,
//  542 						   228, 114, 235, 175, 124, 170, 215, 232, 133, 205};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  543 const BYTE byRSExp52[] = {116,  50,  86, 186,  50, 220, 251,  89, 192,  46,  86, 127, 124,  19, 184, 233, 151, 215,  22,  14,
byRSExp52:
        DC8 116, 50, 86, 186, 50, 220, 251, 89, 192, 46, 86, 127, 124, 19, 184
        DC8 233, 151, 215, 22, 14, 59, 145, 37, 242, 203, 134, 254, 89, 190, 94
        DC8 59, 65, 124, 113, 100, 233, 235, 121, 22, 76, 86, 97, 39, 242, 200
        DC8 220, 101, 33, 239, 254, 116, 51
//  544 						    59, 145,  37, 242, 203, 134, 254,  89, 190,  94,  59,  65, 124, 113, 100, 233, 235, 121,  22,  76,
//  545 						    86,  97,  39, 242, 200, 220, 101,  33, 239, 254, 116,  51};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  546 const BYTE byRSExp54[] = {183,  26, 201,  87, 210, 221, 113,  21,  46,  65,  45,  50, 238, 184, 249, 225, 102,  58, 209, 218,
byRSExp54:
        DC8 183, 26, 201, 87, 210, 221, 113, 21, 46, 65, 45, 50, 238, 184, 249
        DC8 225, 102, 58, 209, 218, 109, 165, 26, 95, 184, 192, 52, 245, 35
        DC8 254, 238, 175, 172, 79, 123, 25, 122, 43, 120, 108, 215, 80, 128
        DC8 201, 235, 8, 153, 59, 101, 31, 198, 76, 31, 156, 0, 0
//  547 						   109, 165,  26,  95, 184, 192,  52, 245,  35, 254, 238, 175, 172,  79, 123,  25, 122,  43, 120, 108,
//  548 						   215,  80, 128, 201, 235,   8, 153,  59, 101,  31, 198,  76,  31, 156};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  549 const BYTE byRSExp56[] = {106, 120, 107, 157, 164, 216, 112, 116,   2,  91, 248, 163,  36, 201, 202, 229,   6, 144, 254, 155,
byRSExp56:
        DC8 106, 120, 107, 157, 164, 216, 112, 116, 2, 91, 248, 163, 36, 201
        DC8 202, 229, 6, 144, 254, 155, 135, 208, 170, 209, 12, 139, 127, 142
        DC8 182, 249, 177, 174, 190, 28, 10, 85, 239, 184, 101, 124, 152, 206
        DC8 96, 23, 163, 61, 27, 196, 247, 151, 154, 202, 207, 20, 61, 10
//  550 						   135, 208, 170, 209,  12, 139, 127, 142, 182, 249, 177, 174, 190,  28,  10,  85, 239, 184, 101, 124,
//  551 						   152, 206,  96,  23, 163,  61,  27, 196, 247, 151, 154, 202, 207,  20,  61,  10};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  552 const BYTE byRSExp58[] = { 82, 116,  26, 247,  66,  27,  62, 107, 252, 182, 200, 185, 235,  55, 251, 242, 210, 144, 154, 237,
byRSExp58:
        DC8 82, 116, 26, 247, 66, 27, 62, 107, 252, 182, 200, 185, 235, 55, 251
        DC8 242, 210, 144, 154, 237, 176, 141, 192, 248, 152, 249, 206, 85, 253
        DC8 142, 65, 165, 125, 23, 24, 30, 122, 240, 214, 6, 129, 218, 29, 145
        DC8 127, 134, 206, 245, 117, 29, 41, 63, 159, 142, 233, 125, 148, 123
        DC8 0, 0
//  553 						   176, 141, 192, 248, 152, 249, 206,  85, 253, 142,  65, 165, 125,  23,  24,  30, 122, 240, 214,   6,
//  554 						   129, 218,  29, 145, 127, 134, 206, 245, 117,  29,  41,  63, 159, 142, 233, 125, 148, 123};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  555 const BYTE byRSExp60[] = {107, 140,  26,  12,   9, 141, 243, 197, 226, 197, 219,  45, 211, 101, 219, 120,  28, 181, 127,   6,
byRSExp60:
        DC8 107, 140, 26, 12, 9, 141, 243, 197, 226, 197, 219, 45, 211, 101
        DC8 219, 120, 28, 181, 127, 6, 100, 247, 2, 205, 198, 57, 115, 219, 101
        DC8 109, 160, 82, 37, 38, 238, 49, 160, 209, 121, 86, 11, 124, 30, 181
        DC8 84, 25, 194, 87, 65, 102, 190, 220, 70, 27, 209, 16, 89, 7, 33, 240
//  556 						   100, 247,   2, 205, 198,  57, 115, 219, 101, 109, 160,  82,  37,  38, 238,  49, 160, 209, 121,  86,
//  557 						    11, 124,  30, 181,  84,  25, 194,  87,  65, 102, 190, 220,  70,  27, 209,  16,  89,   7,  33, 240};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  558 const BYTE byRSExp62[] = { 65, 202, 113,  98,  71, 223, 248, 118, 214,  94,   0, 122,  37,  23,   2, 228,  58, 121,   7, 105,
byRSExp62:
        DC8 65, 202, 113, 98, 71, 223, 248, 118, 214, 94, 0, 122, 37, 23, 2
        DC8 228, 58, 121, 7, 105, 135, 78, 243, 118, 70, 76, 223, 89, 72, 50
        DC8 70, 111, 194, 17, 212, 126, 181, 35, 221, 117, 235, 11, 229, 149
        DC8 147, 123, 213, 40, 115, 6, 200, 100, 26, 246, 182, 218, 127, 215
        DC8 36, 186, 110, 106, 0, 0
//  559 						   135,  78, 243, 118,  70,  76, 223,  89,  72,  50,  70, 111, 194,  17, 212, 126, 181,  35, 221, 117,
//  560 						   235,  11, 229, 149, 147, 123, 213,  40, 115,   6, 200, 100,  26, 246, 182, 218, 127, 215,  36, 186,
//  561 						   110, 106};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  562 const BYTE byRSExp64[] = { 45,  51, 175,   9,   7, 158, 159,  49,  68, 119,  92, 123, 177, 204, 187, 254, 200,  78, 141, 149,
byRSExp64:
        DC8 45, 51, 175, 9, 7, 158, 159, 49, 68, 119, 92, 123, 177, 204, 187
        DC8 254, 200, 78, 141, 149, 119, 26, 127, 53, 160, 93, 199, 212, 29, 24
        DC8 145, 156, 208, 150, 218, 209, 4, 216, 91, 47, 184, 146, 47, 140
        DC8 195, 195, 125, 242, 238, 63, 99, 108, 140, 230, 242, 31, 204, 11
        DC8 178, 243, 217, 156, 213, 231
//  563 						   119,  26, 127,  53, 160,  93, 199, 212,  29,  24, 145, 156, 208, 150, 218, 209,   4, 216,  91,  47,
//  564 						   184, 146,  47, 140, 195, 195, 125, 242, 238,  63,  99, 108, 140, 230, 242,  31, 204,  11, 178, 243,
//  565 						   217, 156, 213, 231};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  566 const BYTE byRSExp66[] = {  5, 118, 222, 180, 136, 136, 162,  51,  46, 117,  13, 215,  81,  17, 139, 247, 197, 171,  95, 173,
byRSExp66:
        DC8 5, 118, 222, 180, 136, 136, 162, 51, 46, 117, 13, 215, 81, 17, 139
        DC8 247, 197, 171, 95, 173, 65, 137, 178, 68, 111, 95, 101, 41, 72, 214
        DC8 169, 197, 95, 7, 44, 154, 77, 111, 236, 40, 121, 143, 63, 87, 80
        DC8 253, 240, 126, 217, 77, 34, 232, 106, 50, 168, 82, 76, 146, 67, 106
        DC8 171, 25, 132, 93, 45, 105, 0, 0
//  567 						    65, 137, 178,  68, 111,  95, 101,  41,  72, 214, 169, 197,  95,   7,  44, 154,  77, 111, 236,  40,
//  568 						   121, 143,  63,  87,  80, 253, 240, 126, 217,  77,  34, 232, 106,  50, 168,  82,  76, 146,  67, 106,
//  569 						   171,  25, 132,  93,  45, 105};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  570 const BYTE byRSExp68[] = {247, 159, 223,  33, 224,  93,  77,  70,  90, 160,  32, 254,  43, 150,  84, 101, 190, 205, 133,  52,
byRSExp68:
        DC8 247, 159, 223, 33, 224, 93, 77, 70, 90, 160, 32, 254, 43, 150, 84
        DC8 101, 190, 205, 133, 52, 60, 202, 165, 220, 203, 151, 93, 84, 15, 84
        DC8 253, 173, 160, 89, 227, 52, 199, 97, 95, 231, 52, 177, 41, 125, 137
        DC8 241, 166, 225, 118, 2, 54, 32, 82, 215, 175, 198, 43, 238, 235, 27
        DC8 101, 184, 127, 3, 5, 8, 163, 238
//  571 						    60, 202, 165, 220, 203, 151,  93,  84,  15,  84, 253, 173, 160,  89, 227,  52, 199,  97,  95, 231,
//  572 						    52, 177,  41, 125, 137, 241, 166, 225, 118,   2,  54,  32,  82, 215, 175, 198,  43, 238, 235,  27,
//  573 						   101, 184, 127,   3,   5,   8, 163, 238};
//  574 

        SECTION `.data`:DATA:REORDER:NOROOT(2)
//  575 const BYTE *byRSExp[] = {NULL,      NULL,      NULL,      NULL,      NULL,      NULL,      NULL,      byRSExp7,  NULL,      NULL,
byRSExp:
        DATA
        DC32 0H, 0H, 0H, 0H, 0H, 0H, 0H, byRSExp7, 0H, 0H, byRSExp10, 0H, 0H
        DC32 byRSExp13, 0H, byRSExp15, byRSExp16, byRSExp17, byRSExp18, 0H
        DC32 byRSExp20, 0H, byRSExp22, 0H, byRSExp24, 0H, byRSExp26, 0H
        DC32 byRSExp28, 0H, byRSExp30, 0H, byRSExp32, 0H, byRSExp34, 0H
        DC32 byRSExp36, 0H, byRSExp38, 0H, byRSExp40, 0H, byRSExp42, 0H
        DC32 byRSExp44, 0H, byRSExp46, 0H, byRSExp48, 0H, byRSExp50, 0H
        DC32 byRSExp52, 0H, byRSExp54, 0H, byRSExp56, 0H, byRSExp58, 0H
        DC32 byRSExp60, 0H, byRSExp62, 0H, byRSExp64, 0H, byRSExp66, 0H
        DC32 byRSExp68
//  576 							byRSExp10, NULL,      NULL,      byRSExp13, NULL,      byRSExp15, byRSExp16, byRSExp17, byRSExp18, NULL,
//  577 							byRSExp20, NULL,      byRSExp22, NULL,      byRSExp24, NULL,      byRSExp26, NULL,      byRSExp28, NULL,
//  578 							byRSExp30, NULL,      byRSExp32, NULL,      byRSExp34, NULL,      byRSExp36, NULL,      byRSExp38, NULL,
//  579 							byRSExp40, NULL,      byRSExp42, NULL,      byRSExp44, NULL,      byRSExp46, NULL,      byRSExp48, NULL,
//  580 							byRSExp50, NULL,      byRSExp52, NULL,      byRSExp54, NULL,      byRSExp56, NULL,      byRSExp58, NULL,
//  581 							byRSExp60, NULL,      byRSExp62, NULL,      byRSExp64, NULL,      byRSExp66, NULL,      byRSExp68};
//  582 
//  583 const BYTE nIndicatorLenNumeral[]  = {10, 12, 14};
//  584 const BYTE nIndicatorLenAlphabet[] = { 9, 11, 13};
//  585 const BYTE nIndicatorLen8Bit[]	   = { 8, 16, 16};
//  586 const BYTE nIndicatorLenKanji[]	   = { 8, 10, 12};
//  587 

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  588 int m_nSymbleSize;
m_nSymbleSize:
        DS8 4
//  589 BYTE m_byModuleData[MAX_MODULESIZE][MAX_MODULESIZE];
//  590 
//  591 int m_ncDataCodeWordBit;
m_ncDataCodeWordBit:
        DS8 4
//  592 BYTE m_byDataCodeWord[MAX_DATACODEWORD];
//  593 
//  594 int m_ncDataBlock;
//  595 BYTE m_byBlockMode[MAX_DATACODEWORD];
//  596 BYTE m_nBlockLength[MAX_DATACODEWORD];
//  597 
//  598 int m_ncAllCodeWord; 
m_ncAllCodeWord:
        DS8 4
//  599 BYTE m_byAllCodeWord[MAX_ALLCODEWORD]; 
//  600 BYTE m_byRSWork[MAX_CODEBLOCK];
//  601 
//  602 int m_nLevel;	
m_nLevel:
        DS8 4
//  603 int m_nVersion;	
m_nVersion:
        DS8 4
//  604 bool m_bAutoExtent;	
//  605 int m_nMaskingNo;
m_nMaskingNo:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
m_byModuleData:
        DS8 444

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
m_byDataCodeWord:
        DS8 400

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
m_byBlockMode:
        DS8 400
m_nBlockLength:
        DS8 400
m_ncDataBlock:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
m_byAllCodeWord:
        DS8 400

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
m_byRSWork:
        DS8 156

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
m_bAutoExtent:
        DS8 1
//  606 
//  607 //编码数据
//  608 //lpsSource 源数据

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function EncodeData
        THUMB
//  609 bool EncodeData(char *lpsSource)
//  610 {
EncodeData:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
        SUB      SP,SP,#+28
          CFI CFA R13+64
        MOV      R8,R0
//  611 	int i, j, nVersion=1, bAutoExtent=1, ncSource;
//  612 	int ncLength, nEncodeVersion, ncDataCodeWord, ncTerminater;
//  613 	BYTE byPaddingCode = 0xec;
        MOVS     R7,#+236
//  614 	int nDataCwIndex = 0, ncBlock1, ncBlock2, ncBlockSum; 
        MOVS     R4,#+0
//  615 	int nBlockNo = 0, ncDataCw1, ncDataCw2;
        MOV      R5,R4
//  616 	int ncRSCw1, ncRSCw2;
//  617 
//  618 	ncSource = 0;
//  619 	m_nLevel = 0;
        LDR.W    R6,??DataTable45
        MOV      R0,R4
        STR      R0,[R6, #+12]
//  620 	m_nMaskingNo = 0;
        STR      R0,[R6, #+20]
//  621 
//  622 	ncLength = ncSource > 0 ? ncSource : strlen(lpsSource);//计算要编码的数据的长度
        MOV      R0,R8
          CFI FunCall strlen
        BL       strlen
//  623 	//uprintf("ncLength = %d\n",ncLength);
//  624 	if (ncLength == 0)
        CMP      R0,#+0
        BEQ.N    ??EncodeData_0
//  625 		return FALSE; 
//  626 
//  627 	nEncodeVersion = GetEncodeVersion(nVersion, lpsSource, ncLength);//计算编码数据需要的版本
        MOV      R2,R0
        MOV      R1,R8
        MOVS     R0,#+1
          CFI FunCall GetEncodeVersion
        BL       GetEncodeVersion
//  628 	//uprintf("nEncodeVersion = %d\n",nEncodeVersion);
//  629 	if (nEncodeVersion == 0)
        CMP      R0,#+0
        BEQ.N    ??EncodeData_0
//  630 		return FALSE; 
//  631 
//  632 	if (nVersion == 0)
//  633 	{
//  634 		m_nVersion = nEncodeVersion;
//  635 	}
//  636 	else
//  637 	{
//  638 		if (nEncodeVersion <= nVersion)
        CMP      R0,#+2
        BGE.N    ??EncodeData_1
//  639 		{
//  640 			m_nVersion = nVersion;
        MOVS     R0,#+1
        STR      R0,[R6, #+16]
//  641 		}
//  642 		else
//  643 		{
//  644 			if (bAutoExtent)
//  645 				m_nVersion = nEncodeVersion; 
//  646 			else
//  647 				return FALSE; 
//  648 		}
//  649 	}
//  650 	//uprintf("m_nVersion = %d\n",m_nVersion);
//  651 	
//  652 	ncDataCodeWord = QR_VersonInfo[m_nVersion].ncDataCodeWord[m_nLevel];
??EncodeData_2:
        MOV      R8,#+74
        LDR.W    R9,??DataTable45_1
        LDR      R0,[R6, #+16]
        MLA      R10,R8,R0,R9
        LDR      R0,[R6, #+12]
        ADD      R0,R10,R0, LSL #+1
        LDRH     R0,[R0, #+4]
        STR      R0,[SP, #+4]
//  653 
//  654 	ncTerminater = min(4, (ncDataCodeWord * 8) - m_ncDataCodeWordBit);
        LDR      R0,[R6, #+4]
        LDR      R1,[SP, #+4]
        RSB      R2,R0,R1, LSL #+3
        CMP      R2,#+5
        BLT.N    ??EncodeData_3
        MOVS     R2,#+4
        B.N      ??EncodeData_3
??EncodeData_1:
        STR      R0,[R6, #+16]
        B.N      ??EncodeData_2
??EncodeData_0:
        MOV      R0,R4
        B.N      ??EncodeData_4
//  655 
//  656 	if (ncTerminater > 0)
??EncodeData_3:
        CMP      R2,#+1
        BLT.N    ??EncodeData_5
//  657 		m_ncDataCodeWordBit = SetBitStream(m_ncDataCodeWordBit, 0, ncTerminater);
        MOV      R1,R4
          CFI FunCall SetBitStream
        BL       SetBitStream
        STR      R0,[R6, #+4]
//  658 
//  659 	for (i = (m_ncDataCodeWordBit + 7) / 8; i < ncDataCodeWord; ++i)
??EncodeData_5:
        LDR      R0,[R6, #+4]
        ADDS     R0,R0,#+7
        ASRS     R1,R0,#+2
        ADD      R0,R0,R1, LSR #+29
        ASRS     R0,R0,#+3
        B.N      ??EncodeData_6
//  660 	{
//  661 		m_byDataCodeWord[i] = byPaddingCode;
//  662 
//  663 		byPaddingCode = (BYTE)(byPaddingCode == 0xec ? 0x11 : 0xec);
??EncodeData_7:
        MOVS     R7,#+236
??EncodeData_8:
        ADDS     R0,R0,#+1
??EncodeData_6:
        LDR      R1,[SP, #+4]
        CMP      R0,R1
        BGE.N    ??EncodeData_9
        LDR.W    R1,??DataTable45_2
        STRB     R7,[R0, R1]
        CMP      R7,#+236
        BNE.N    ??EncodeData_7
        MOVS     R7,#+17
        B.N      ??EncodeData_8
//  664 	}
//  665 
//  666 	m_ncAllCodeWord = QR_VersonInfo[m_nVersion].ncAllCodeWord;
??EncodeData_9:
        LDRH     R2,[R10, #+2]
        STR      R2,[R6, #+8]
//  667 	memset(m_byAllCodeWord, 0, m_ncAllCodeWord);
        LDR.W    R7,??DataTable45_3
        MOV      R1,R4
        MOV      R0,R7
          CFI FunCall memset
        BL       memset
//  668 
//  669 	ncBlock1 = QR_VersonInfo[m_nVersion].RS_BlockInfo1[m_nLevel].ncRSBlock;
        LDR      R0,[R6, #+12]
        ADD      R1,R0,R0, LSL #+1
        LDR      R0,[R6, #+16]
        MLA      R0,R8,R0,R9
        ADD      R0,R0,R1, LSL #+1
        LDRH     R1,[R0, #+26]
        STR      R1,[SP, #+12]
//  670 	ncBlock2 = QR_VersonInfo[m_nVersion].RS_BlockInfo2[m_nLevel].ncRSBlock;
        LDRH     R1,[R0, #+50]
        STR      R1,[SP, #+8]
//  671 	ncBlockSum = ncBlock1 + ncBlock2;
        LDR      R1,[SP, #+12]
        LDR      R2,[SP, #+8]
        ADD      R8,R2,R1
//  672 
//  673 	ncDataCw1 = QR_VersonInfo[m_nVersion].RS_BlockInfo1[m_nLevel].ncDataCodeWord;
        LDRH     R9,[R0, #+30]
//  674 	ncDataCw2 = QR_VersonInfo[m_nVersion].RS_BlockInfo2[m_nLevel].ncDataCodeWord;
        LDRH     R1,[R0, #+54]
        STR      R1,[SP, #+0]
//  675 
//  676 	for (i = 0; i < ncBlock1; ++i)
        MOV      R2,R4
        B.N      ??EncodeData_10
//  677 	{
//  678 		for (j = 0; j < ncDataCw1; ++j)
//  679 		{
//  680 			m_byAllCodeWord[(ncBlockSum * j) + nBlockNo] = m_byDataCodeWord[nDataCwIndex++];
??EncodeData_11:
        MLA      R3,R1,R8,R5
        LDR.W    R12,??DataTable45_2
        LDRB     R12,[R4, R12]
        STRB     R12,[R3, R7]
        ADDS     R4,R4,#+1
//  681 		}
        ADDS     R1,R1,#+1
??EncodeData_12:
        CMP      R1,R9
        BLT.N    ??EncodeData_11
//  682 
//  683 		++nBlockNo;
        ADDS     R5,R5,#+1
        ADDS     R2,R2,#+1
??EncodeData_10:
        LDR      R1,[SP, #+12]
        CMP      R2,R1
        BGE.N    ??EncodeData_13
        MOVS     R1,#+0
        B.N      ??EncodeData_12
//  684 	}
//  685 
//  686 	for (i = 0; i < ncBlock2; ++i)
??EncodeData_13:
        MOVS     R2,#+0
        B.N      ??EncodeData_14
//  687 	{
//  688 		for (j = 0; j < ncDataCw2; ++j)
//  689 		{
//  690 			if (j < ncDataCw1)
//  691 			{
//  692 				m_byAllCodeWord[(ncBlockSum * j) + nBlockNo] = m_byDataCodeWord[nDataCwIndex++];
//  693 			}
//  694 			else
//  695 			{
//  696 				m_byAllCodeWord[(ncBlockSum * ncDataCw1) + i]  = m_byDataCodeWord[nDataCwIndex++];
//  697 			}	
//  698 		}
//  699 
//  700 		++nBlockNo;
??EncodeData_15:
        ADDS     R5,R5,#+1
        ADDS     R2,R2,#+1
??EncodeData_14:
        LDR      R1,[SP, #+8]
        CMP      R2,R1
        BGE.N    ??EncodeData_16
        MOVS     R1,#+0
        B.N      ??EncodeData_17
??EncodeData_18:
        MLA      R12,R9,R8,R2
        STRB     R3,[R12, R7]
??EncodeData_19:
        ADDS     R1,R1,#+1
??EncodeData_17:
        LDR      R3,[SP, #+0]
        CMP      R1,R3
        BGE.N    ??EncodeData_15
        LDR.W    R3,??DataTable45_2
        LDRB     R3,[R4, R3]
        ADDS     R4,R4,#+1
        CMP      R1,R9
        BGE.N    ??EncodeData_18
        MLA      R12,R1,R8,R5
        STRB     R3,[R12, R7]
        B.N      ??EncodeData_19
//  701 	}
//  702 
//  703 	ncRSCw1 = QR_VersonInfo[m_nVersion].RS_BlockInfo1[m_nLevel].ncAllCodeWord - ncDataCw1;
??EncodeData_16:
        LDRH     R1,[R0, #+28]
        SUB      R1,R1,R9
        STR      R1,[SP, #+20]
//  704 	ncRSCw2 = QR_VersonInfo[m_nVersion].RS_BlockInfo2[m_nLevel].ncAllCodeWord - ncDataCw2;
        LDRH     R0,[R0, #+52]
        LDR      R1,[SP, #+0]
        SUBS     R0,R0,R1
        STR      R0,[SP, #+16]
//  705 
//  706 	nDataCwIndex = 0;
        MOVS     R4,#+0
//  707 	nBlockNo = 0;
        MOV      R5,R4
//  708 
//  709 	for (i = 0; i < ncBlock1; ++i)
        MOV      R10,R4
        LDR.W    R11,??DataTable46
        B.N      ??EncodeData_20
//  710 	{
//  711 		memset(m_byRSWork, 0, sizeof(m_byRSWork));
//  712 
//  713 		memmove(m_byRSWork, m_byDataCodeWord + nDataCwIndex, ncDataCw1);
//  714 
//  715 		GetRSCodeWord(m_byRSWork, ncDataCw1, ncRSCw1);
//  716 
//  717 		for (j = 0; j < ncRSCw1; ++j)
//  718 		{
//  719 			m_byAllCodeWord[ncDataCodeWord + (ncBlockSum * j) + nBlockNo] = m_byRSWork[j];
??EncodeData_21:
        LDR      R0,[SP, #+4]
        MLA      R0,R1,R8,R0
        ADDS     R0,R5,R0
        LDRB     R2,[R1, R11]
        STRB     R2,[R0, R7]
//  720 		}
        ADDS     R1,R1,#+1
??EncodeData_22:
        LDR      R0,[SP, #+20]
        CMP      R1,R0
        BLT.N    ??EncodeData_21
//  721 
//  722 		nDataCwIndex += ncDataCw1;
        ADD      R4,R9,R4
//  723 		++nBlockNo;
        ADDS     R5,R5,#+1
        ADD      R10,R10,#+1
??EncodeData_20:
        LDR      R0,[SP, #+12]
        CMP      R10,R0
        BGE.N    ??EncodeData_23
        MOVS     R2,#+153
        MOVS     R1,#+0
        MOV      R0,R11
          CFI FunCall memset
        BL       memset
        MOV      R2,R9
        LDR.W    R0,??DataTable45_2
        ADDS     R1,R4,R0
        MOV      R0,R11
          CFI FunCall memmove
        BL       memmove
        LDR      R2,[SP, #+20]
        MOV      R1,R9
        MOV      R0,R11
          CFI FunCall GetRSCodeWord
        BL       GetRSCodeWord
        MOVS     R1,#+0
        B.N      ??EncodeData_22
//  724 	}
//  725 
//  726 	for (i = 0; i < ncBlock2; ++i)
??EncodeData_23:
        MOV      R9,#+0
        B.N      ??EncodeData_24
//  727 	{
//  728 		memset(m_byRSWork, 0, sizeof(m_byRSWork));
//  729 
//  730 		memmove(m_byRSWork, m_byDataCodeWord + nDataCwIndex, ncDataCw2);
//  731 
//  732 		GetRSCodeWord(m_byRSWork, ncDataCw2, ncRSCw2);
//  733 
//  734 		for (j = 0; j < ncRSCw2; ++j)
//  735 		{
//  736 			m_byAllCodeWord[ncDataCodeWord + (ncBlockSum * j) + nBlockNo] = m_byRSWork[j];
??EncodeData_25:
        LDR      R0,[SP, #+4]
        MLA      R0,R1,R8,R0
        ADDS     R0,R5,R0
        LDRB     R2,[R1, R11]
        STRB     R2,[R0, R7]
//  737 		}
        ADDS     R1,R1,#+1
??EncodeData_26:
        LDR      R0,[SP, #+16]
        CMP      R1,R0
        BLT.N    ??EncodeData_25
//  738 
//  739 		nDataCwIndex += ncDataCw2;
        LDR      R0,[SP, #+0]
        ADDS     R4,R0,R4
//  740 		++nBlockNo;
        ADDS     R5,R5,#+1
        ADD      R9,R9,#+1
??EncodeData_24:
        LDR      R0,[SP, #+8]
        CMP      R9,R0
        BGE.N    ??EncodeData_27
        MOVS     R2,#+153
        MOVS     R1,#+0
        MOV      R0,R11
          CFI FunCall memset
        BL       memset
        LDR      R2,[SP, #+0]
        LDR.W    R0,??DataTable45_2
        ADDS     R1,R4,R0
        MOV      R0,R11
          CFI FunCall memmove
        BL       memmove
        LDR      R2,[SP, #+16]
        LDR      R1,[SP, #+0]
        MOV      R0,R11
          CFI FunCall GetRSCodeWord
        BL       GetRSCodeWord
        MOVS     R1,#+0
        B.N      ??EncodeData_26
//  741 	}
//  742 
//  743 	m_nSymbleSize = m_nVersion * 4 + 17;
??EncodeData_27:
        LDR      R0,[R6, #+16]
        LSLS     R0,R0,#+2
        ADDS     R0,R0,#+17
        STR      R0,[R6, #+0]
//  744 
//  745 	FormatModule();
          CFI FunCall FormatModule
        BL       FormatModule
//  746 
//  747 	return TRUE;
        MOVS     R0,#+1
??EncodeData_4:
        ADD      SP,SP,#+28
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
          CFI EndBlock cfiBlock0
//  748 }
//  749 //每个版本长度字段的位数
//  750 //nVersion	版本
//  751 //lpsSource	源数据
//  752 //ncLength	长度
//  753 /*
//  754 Number of bits per length field
//  755 Encoding		Ver.1C9		10C26		27C40
//  756 Numeric			10			12			14
//  757 Alphanumeric	9			11			13
//  758 Byte			8			16			16
//  759 Kanji			8			10			12 
//  760 */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function GetEncodeVersion
        THUMB
//  761 int GetEncodeVersion(int nVersion, char *lpsSource, int ncLength)
//  762 {
GetEncodeVersion:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        MOV      R4,R1
        MOV      R5,R2
//  763 	int nVerGroup = nVersion >= 27 ? QR_VRESION_L : (nVersion >= 10 ? QR_VRESION_M : QR_VRESION_S);
        CMP      R0,#+27
        BLT.N    ??GetEncodeVersion_0
        MOVS     R6,#+2
        B.N      ??GetEncodeVersion_1
??GetEncodeVersion_0:
        CMP      R0,#+10
        BLT.N    ??GetEncodeVersion_2
        MOVS     R6,#+1
        B.N      ??GetEncodeVersion_1
??GetEncodeVersion_2:
        MOVS     R6,#+0
        B.N      ??GetEncodeVersion_1
//  764 	int i, j;
//  765 
//  766 	for (i = nVerGroup; i <= QR_VRESION_L; ++i)
??GetEncodeVersion_3:
        ADDS     R6,R6,#+1
??GetEncodeVersion_1:
        CMP      R6,#+3
        BGE.N    ??GetEncodeVersion_4
//  767 	{
//  768 		if (EncodeSourceData(lpsSource, ncLength, i))
        MOV      R2,R6
        MOV      R1,R5
        MOV      R0,R4
          CFI FunCall EncodeSourceData
        BL       EncodeSourceData
        CMP      R0,#+0
        BEQ.N    ??GetEncodeVersion_3
//  769 		{
//  770 			if (i == QR_VRESION_S)
        CMP      R6,#+0
        BNE.N    ??GetEncodeVersion_5
//  771 			{
//  772 				for (j = 1; j <= 9; ++j)
        MOVS     R0,#+1
        LDR.W    R7,??DataTable45_1
??GetEncodeVersion_6:
        CMP      R0,#+10
        BGE.N    ??GetEncodeVersion_3
//  773 				{
//  774 					if ((m_ncDataCodeWordBit + 7) / 8 <= QR_VersonInfo[j].ncDataCodeWord[m_nLevel])
        LDR.W    R1,??DataTable45
        LDR      R2,[R1, #+4]
        ADDS     R2,R2,#+7
        LDR      R1,[R1, #+12]
        MOVS     R3,#+74
        MLA      R3,R3,R0,R7
        ADD      R1,R3,R1, LSL #+1
        LDRH     R1,[R1, #+4]
        ASRS     R3,R2,#+2
        ADD      R2,R2,R3, LSR #+29
        CMP      R1,R2, ASR #+3
        BGE.N    ??GetEncodeVersion_7
//  775 						return j;
//  776 				}
        ADDS     R0,R0,#+1
        B.N      ??GetEncodeVersion_6
//  777 			}
//  778 			else if (i == QR_VRESION_M)
??GetEncodeVersion_5:
        CMP      R6,#+1
        BNE.N    ??GetEncodeVersion_8
//  779 			{
//  780 				for (j = 10; j <= 26; ++j)
        MOVS     R0,#+10
        LDR.W    R7,??DataTable45_1
??GetEncodeVersion_9:
        CMP      R0,#+27
        BGE.N    ??GetEncodeVersion_3
//  781 				{
//  782 					if ((m_ncDataCodeWordBit + 7) / 8 <= QR_VersonInfo[j].ncDataCodeWord[m_nLevel])
        LDR.W    R1,??DataTable45
        LDR      R2,[R1, #+4]
        ADDS     R2,R2,#+7
        LDR      R1,[R1, #+12]
        MOVS     R3,#+74
        MLA      R3,R3,R0,R7
        ADD      R1,R3,R1, LSL #+1
        LDRH     R1,[R1, #+4]
        ASRS     R3,R2,#+2
        ADD      R2,R2,R3, LSR #+29
        CMP      R1,R2, ASR #+3
        BGE.N    ??GetEncodeVersion_7
//  783 						return j;
//  784 				}
        ADDS     R0,R0,#+1
        B.N      ??GetEncodeVersion_9
//  785 			}
//  786 			else if (i == QR_VRESION_L)
??GetEncodeVersion_8:
        CMP      R6,#+2
        BNE.N    ??GetEncodeVersion_3
//  787 			{
//  788 				for (j = 27; j <= 40; ++j)
        MOVS     R0,#+27
        LDR.W    R7,??DataTable45_1
        B.N      ??GetEncodeVersion_10
??GetEncodeVersion_11:
        ADDS     R0,R0,#+1
??GetEncodeVersion_10:
        CMP      R0,#+41
        BGE.N    ??GetEncodeVersion_3
//  789 				{
//  790 					if ((m_ncDataCodeWordBit + 7) / 8 <= QR_VersonInfo[j].ncDataCodeWord[m_nLevel])
        LDR.W    R1,??DataTable45
        LDR      R2,[R1, #+4]
        ADDS     R2,R2,#+7
        LDR      R1,[R1, #+12]
        MOVS     R3,#+74
        MLA      R3,R3,R0,R7
        ADD      R1,R3,R1, LSL #+1
        LDRH     R1,[R1, #+4]
        ASRS     R3,R2,#+2
        ADD      R2,R2,R3, LSR #+29
        CMP      R1,R2, ASR #+3
        BLT.N    ??GetEncodeVersion_11
//  791 						return j;
        POP      {R1,R4-R7,PC}
//  792 				}
//  793 			}
//  794 		}
//  795 	}
//  796 	return 0;
??GetEncodeVersion_4:
        MOVS     R0,#+0
??GetEncodeVersion_7:
        POP      {R1,R4-R7,PC}    ;; return
          CFI EndBlock cfiBlock1
//  797 }
//  798 //模式指标，编码模式
//  799 //lpsSource 源数据
//  800 //ncLength	数据长度
//  801 //nVerGroup	版本组
//  802 //bool EncodeSourceData(char *lpsSource, int ncLength, int nVerGroup)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function EncodeSourceData
        THUMB
//  803 int EncodeSourceData(char *lpsSource, int ncLength, int nVerGroup)
//  804 {
EncodeSourceData:
        PUSH     {R2,R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        SUB      SP,SP,#+24
          CFI CFA R13+64
        MOV      R4,R0
        MOV      R9,R1
//  805 	int i, j;
//  806 	int ncSrcBits, ncDstBits;
//  807 	int nBlock = 0;
        MOVS     R6,#+0
//  808 	int ncComplete = 0; 
        MOV      R7,R6
//  809 	WORD wBinCode;
//  810 
//  811 	memset(m_nBlockLength, 0, sizeof(m_nBlockLength));
        LDR.W    R5,??DataTable48
        MOV      R2,#+400
        MOV      R1,R6
        ADD      R0,R5,#+400
          CFI FunCall memset
        BL       memset
//  812 
//  813 	for (m_ncDataBlock = i = 0; i < ncLength; ++i)
        MOV      R8,R6
        MOV      R0,R6
        STR      R0,[R5, #+800]
        B.N      ??EncodeSourceData_0
//  814 	{
//  815 		BYTE byMode;
//  816 
//  817 		if (i < ncLength - 1 && IsKanjiData(lpsSource[i], lpsSource[i + 1]))
//  818 			byMode = QR_MODE_KANJI;				//日文
//  819 		//else if(i < ncLength - 1 && IsChineseData(lpsSource[i], lpsSource[i + 1]))
//  820 			//byMode = QR_MODE_CHINESE;			//中文
//  821 		else if (IsNumeralData(lpsSource[i]))	
//  822 			byMode = QR_MODE_NUMERAL;			//数字
//  823 		else if (IsAlphabetData(lpsSource[i]))
//  824 			byMode = QR_MODE_ALPHABET;			//字符
//  825 		else
//  826 			byMode = QR_MODE_8BIT;				//字节
??EncodeSourceData_1:
        MOVS     R0,#+2
//  827 
//  828 		if (i == 0)
??EncodeSourceData_2:
        CMP      R8,#+0
        BNE.N    ??EncodeSourceData_3
//  829 			m_byBlockMode[0] = byMode;			//
        STRB     R0,[R5, #+0]
//  830 
//  831 		if (m_byBlockMode[m_ncDataBlock] != byMode)//如果前后两个数据的模式不一样
??EncodeSourceData_3:
        LDR      R1,[R5, #+800]
        LDRB     R2,[R1, R5]
        CMP      R2,R0
        BEQ.N    ??EncodeSourceData_4
//  832 			m_byBlockMode[++m_ncDataBlock] = byMode;
        ADDS     R1,R1,#+1
        STR      R1,[R5, #+800]
        STRB     R0,[R1, R5]
//  833 
//  834 		++m_nBlockLength[m_ncDataBlock];
??EncodeSourceData_4:
        LDR      R1,[R5, #+800]
        ADDS     R1,R1,R5
        LDRB     R2,[R1, #+400]
        ADDS     R2,R2,#+1
        STRB     R2,[R1, #+400]
//  835 
//  836 		if (byMode == QR_MODE_KANJI)//如果是日文模式，那么前后2个字节为一个汉字
        CMP      R0,#+3
        BNE.N    ??EncodeSourceData_5
//  837 		{
//  838 			++m_nBlockLength[m_ncDataBlock];
        ADDS     R0,R2,#+1
        STRB     R0,[R1, #+400]
//  839 			++i;
        ADD      R8,R8,#+1
//  840 		}
??EncodeSourceData_5:
        ADD      R8,R8,#+1
??EncodeSourceData_0:
        CMP      R8,R9
        BGE.N    ??EncodeSourceData_6
        SUB      R0,R9,#+1
        CMP      R8,R0
        BGE.N    ??EncodeSourceData_7
        ADD      R0,R8,R4
        LDRB     R1,[R0, #+1]
        LDRB     R0,[R8, R4]
          CFI FunCall IsKanjiData
        BL       IsKanjiData
        CMP      R0,#+0
        BEQ.N    ??EncodeSourceData_7
        MOVS     R0,#+3
        B.N      ??EncodeSourceData_2
??EncodeSourceData_7:
        LDRB     R0,[R8, R4]
          CFI FunCall IsNumeralData
        BL       IsNumeralData
        CMP      R0,#+0
        BEQ.N    ??EncodeSourceData_8
        MOV      R0,R6
        B.N      ??EncodeSourceData_2
??EncodeSourceData_8:
        LDRB     R0,[R8, R4]
          CFI FunCall IsAlphabetData
        BL       IsAlphabetData
        CMP      R0,#+0
        BEQ.N    ??EncodeSourceData_1
        MOVS     R0,#+1
        B.N      ??EncodeSourceData_2
//  841 	}
//  842 
//  843 	++m_ncDataBlock;
??EncodeSourceData_6:
        LDR      R0,[R5, #+800]
        ADDS     R0,R0,#+1
        STR      R0,[R5, #+800]
        B.N      ??EncodeSourceData_9
//  844 
//  845 	while (nBlock < m_ncDataBlock - 1)
//  846 	{
//  847 		int ncJoinFront, ncJoinBehind; 
//  848 		int nJoinPosition = 0; 
//  849 
//  850 		if ((m_byBlockMode[nBlock] == QR_MODE_NUMERAL  && m_byBlockMode[nBlock + 1] == QR_MODE_ALPHABET) ||
//  851 			(m_byBlockMode[nBlock] == QR_MODE_ALPHABET && m_byBlockMode[nBlock + 1] == QR_MODE_NUMERAL))
//  852 		{//如果前后2个数据块为字母和数字，可以合并成字母数字模式(字母模式包含了数字)  计算数据位流
//  853 			ncSrcBits = GetBitLength(m_byBlockMode[nBlock], m_nBlockLength[nBlock], nVerGroup) +
//  854 						GetBitLength(m_byBlockMode[nBlock + 1], m_nBlockLength[nBlock + 1], nVerGroup);
//  855 
//  856 			ncDstBits = GetBitLength(QR_MODE_ALPHABET, m_nBlockLength[nBlock] + m_nBlockLength[nBlock + 1], nVerGroup);
//  857 
//  858 			if (ncSrcBits > ncDstBits)
//  859 			{//如果合并前大于合并后长度
//  860 				if (nBlock >= 1 && m_byBlockMode[nBlock - 1] == QR_MODE_8BIT)
//  861 				{//判断之前的数据块是不是8bit模式，如果是的话合并数据(必须要有3个数据块以上判断)
//  862 					ncJoinFront = GetBitLength(QR_MODE_8BIT, m_nBlockLength[nBlock - 1] + m_nBlockLength[nBlock], nVerGroup) +
//  863 								  GetBitLength(m_byBlockMode[nBlock + 1], m_nBlockLength[nBlock + 1], nVerGroup);
//  864 
//  865 					if (ncJoinFront > ncDstBits + GetBitLength(QR_MODE_8BIT, m_nBlockLength[nBlock - 1], nVerGroup))
//  866 						ncJoinFront = 0; //如果合并后的数据超过长度 非法
//  867 				}
//  868 				else
//  869 					ncJoinFront = 0;//不满足合并的条件
//  870 
//  871 				if (nBlock < m_ncDataBlock - 2 && m_byBlockMode[nBlock + 2] == QR_MODE_8BIT)
//  872 				{//如果后面的数据块为8bit模式，合并数据(必须要有3个数据块以上判断)
//  873 					ncJoinBehind = GetBitLength(m_byBlockMode[nBlock], m_nBlockLength[nBlock], nVerGroup) +
//  874 								   GetBitLength(QR_MODE_8BIT, m_nBlockLength[nBlock + 1] + m_nBlockLength[nBlock + 2], nVerGroup);
//  875 
//  876 					if (ncJoinBehind > ncDstBits + GetBitLength(QR_MODE_8BIT, m_nBlockLength[nBlock + 2], nVerGroup))
//  877 						ncJoinBehind = 0; //如果合并后的数据超过长度 非法
//  878 				}
//  879 				else
//  880 					ncJoinBehind = 0;//不满足合并的条件
//  881 
//  882 				if (ncJoinFront != 0 && ncJoinBehind != 0)//前后的数据块合并后都不为0
//  883 				{
//  884 					nJoinPosition = (ncJoinFront < ncJoinBehind) ? -1 : 1;//位置的标记，如果前面的小于后面的为-1；大于等于为1
//  885 				}
//  886 				else
//  887 				{//如果有一个或者都为0		如果前面不为0为-1；后面不为0为1  否则为0
//  888 					nJoinPosition = (ncJoinFront != 0) ? -1 : ((ncJoinBehind != 0) ? 1 : 0);
//  889 				}
//  890 
//  891 				if (nJoinPosition != 0)
//  892 				{//如果合并后的数据不为0
//  893 					if (nJoinPosition == -1)//前面有数据
//  894 					{
//  895 						m_nBlockLength[nBlock - 1] += m_nBlockLength[nBlock];
//  896 
//  897 						for (i = nBlock; i < m_ncDataBlock - 1; ++i)
//  898 						{
//  899 							m_byBlockMode[i]  = m_byBlockMode[i + 1];
//  900 							m_nBlockLength[i] = m_nBlockLength[i + 1];
//  901 						}
//  902 					}
//  903 					else
//  904 					{//后面有数据
//  905 						m_byBlockMode[nBlock + 1] = QR_MODE_8BIT;//后面数据块为8BIT模式，将新的数据块模式定义成8BIT
//  906 						m_nBlockLength[nBlock + 1] += m_nBlockLength[nBlock + 2];//长度
//  907 
//  908 						for (i = nBlock + 2; i < m_ncDataBlock - 1; ++i)
//  909 						{
//  910 							m_byBlockMode[i]  = m_byBlockMode[i + 1];
//  911 							m_nBlockLength[i] = m_nBlockLength[i + 1];
//  912 						}
//  913 					}
//  914 
//  915 					--m_ncDataBlock;
//  916 				}
//  917 				else
//  918 				{//合并后数据异常，或者不满足合并条件
//  919 					if (nBlock < m_ncDataBlock - 2 && m_byBlockMode[nBlock + 2] == QR_MODE_ALPHABET)
//  920 					{//如果后面一块数据也是字母数字，合并数据
//  921 						m_nBlockLength[nBlock + 1] += m_nBlockLength[nBlock + 2];
//  922 
//  923 						for (i = nBlock + 2; i < m_ncDataBlock - 1; ++i)
//  924 						{
//  925 							m_byBlockMode[i]  = m_byBlockMode[i + 1];
//  926 							m_nBlockLength[i] = m_nBlockLength[i + 1];
//  927 						}
//  928 
//  929 						--m_ncDataBlock;
//  930 					}
//  931 					//设置新数据块为字母数字
//  932 					m_byBlockMode[nBlock] = QR_MODE_ALPHABET;
//  933 					m_nBlockLength[nBlock] += m_nBlockLength[nBlock + 1];
//  934 
//  935 					for (i = nBlock + 1; i < m_ncDataBlock - 1; ++i)
//  936 					{
//  937 						m_byBlockMode[i]  = m_byBlockMode[i + 1];
//  938 						m_nBlockLength[i] = m_nBlockLength[i + 1];
//  939 					}
//  940 
//  941 					--m_ncDataBlock;
//  942 					//如果前面一块数据也是字母数字，合并数据
//  943 					if (nBlock >= 1 && m_byBlockMode[nBlock - 1] == QR_MODE_ALPHABET)
//  944 					{
//  945 						m_nBlockLength[nBlock - 1] += m_nBlockLength[nBlock];
//  946 
//  947 						for (i = nBlock; i < m_ncDataBlock - 1; ++i)
//  948 						{
//  949 							m_byBlockMode[i]  = m_byBlockMode[i + 1];
//  950 							m_nBlockLength[i] = m_nBlockLength[i + 1];
//  951 						}
//  952 
//  953 						--m_ncDataBlock;
//  954 					}
//  955 				}
//  956 
//  957 				continue;
//  958 			}
//  959 		}
//  960 
//  961 		++nBlock; 
??EncodeSourceData_10:
        ADDS     R6,R6,#+1
??EncodeSourceData_9:
        LDR      R0,[R5, #+800]
        SUBS     R0,R0,#+1
        STR      R0,[SP, #+12]
        CMP      R6,R0
        BGE.W    ??EncodeSourceData_11
        MOV      R8,R7
        LDRB     R0,[R6, R5]
        STRB     R0,[SP, #+0]
        CMP      R0,#+0
        BNE.N    ??EncodeSourceData_12
        ADDS     R0,R6,R5
        LDRB     R0,[R0, #+1]
        CMP      R0,#+1
        BEQ.N    ??EncodeSourceData_13
??EncodeSourceData_12:
        LDRB     R0,[SP, #+0]
        CMP      R0,#+1
        BNE.N    ??EncodeSourceData_10
        ADDS     R0,R6,R5
        LDRB     R0,[R0, #+1]
        CMP      R0,#+0
        BNE.N    ??EncodeSourceData_10
??EncodeSourceData_13:
        ADDS     R0,R6,R5
        ADDW     R0,R0,#+399
        STR      R0,[SP, #+8]
        LDRB     R0,[R0, #+1]
        STRB     R0,[SP, #+5]
        STR      R0,[SP, #+16]
        LDR      R2,[SP, #+24]
        MOV      R1,R0
        LDRB     R0,[SP, #+0]
          CFI FunCall GetBitLength
        BL       GetBitLength
        MOV      R10,R0
        LDR      R0,[SP, #+8]
        LDRB     R0,[R0, #+2]
        STRB     R0,[SP, #+4]
        MOV      R9,R0
        LDR      R2,[SP, #+24]
        MOV      R1,R9
        ADDS     R0,R6,R5
        LDRB     R0,[R0, #+1]
          CFI FunCall GetBitLength
        BL       GetBitLength
        ADD      R11,R0,R10
        LDR      R2,[SP, #+24]
        LDR      R0,[SP, #+16]
        ADD      R1,R9,R0
        MOVS     R0,#+1
          CFI FunCall GetBitLength
        BL       GetBitLength
        MOV      R10,R0
        CMP      R10,R11
        BGE.N    ??EncodeSourceData_10
        CMP      R6,#+1
        BLT.N    ??EncodeSourceData_14
        ADDS     R0,R6,R5
        LDRB     R0,[R0, #-1]
        CMP      R0,#+2
        BNE.N    ??EncodeSourceData_14
        LDR      R2,[SP, #+24]
        ADDS     R0,R6,R5
        LDRB     R0,[R0, #+399]
        LDR      R1,[SP, #+16]
        UXTAB    R1,R1,R0
        MOVS     R0,#+2
          CFI FunCall GetBitLength
        BL       GetBitLength
        MOV      R11,R0
        LDR      R2,[SP, #+24]
        MOV      R1,R9
        ADDS     R0,R6,R5
        LDRB     R0,[R0, #+1]
          CFI FunCall GetBitLength
        BL       GetBitLength
        ADD      R11,R0,R11
        LDR      R2,[SP, #+24]
        ADDS     R0,R6,R5
        LDRB     R1,[R0, #+399]
        MOVS     R0,#+2
          CFI FunCall GetBitLength
        BL       GetBitLength
        ADD      R0,R0,R10
        CMP      R0,R11
        BGE.N    ??EncodeSourceData_15
        MOV      R11,R7
        B.N      ??EncodeSourceData_15
??EncodeSourceData_14:
        MOV      R11,R7
??EncodeSourceData_15:
        LDR      R0,[R5, #+800]
        SUBS     R0,R0,#+2
        STR      R0,[SP, #+20]
        CMP      R6,R0
        BGE.N    ??EncodeSourceData_16
        ADDS     R0,R6,R5
        ADDS     R0,R0,#+1
        LDRB     R0,[R0, #+1]
        CMP      R0,#+2
        BNE.N    ??EncodeSourceData_16
        LDR      R2,[SP, #+24]
        LDR      R1,[SP, #+16]
        LDRB     R0,[SP, #+0]
          CFI FunCall GetBitLength
        BL       GetBitLength
        LDR      R1,[SP, #+8]
        LDRB     R1,[R1, #+3]
        STR      R1,[SP, #+16]
        STR      R0,[SP, #+0]
        LDR      R2,[SP, #+24]
        LDR      R0,[SP, #+16]
        ADD      R1,R0,R9
        MOVS     R0,#+2
          CFI FunCall GetBitLength
        BL       GetBitLength
        LDR      R1,[SP, #+0]
        ADD      R9,R0,R1
        LDR      R2,[SP, #+24]
        LDR      R1,[SP, #+16]
        MOVS     R0,#+2
          CFI FunCall GetBitLength
        BL       GetBitLength
        ADD      R0,R0,R10
        CMP      R0,R9
        BGE.N    ??EncodeSourceData_17
        MOV      R9,R7
        B.N      ??EncodeSourceData_17
??EncodeSourceData_16:
        MOV      R9,R7
??EncodeSourceData_17:
        CMP      R11,#+0
        BEQ.N    ??EncodeSourceData_18
        CMP      R9,#+0
        BEQ.N    ??EncodeSourceData_18
        CMP      R11,R9
        BGE.N    ??EncodeSourceData_19
        MOV      R8,#-1
        B.N      ??EncodeSourceData_20
??EncodeSourceData_19:
        MOV      R8,#+1
        B.N      ??EncodeSourceData_20
??EncodeSourceData_18:
        CMP      R11,#+0
        BEQ.N    ??EncodeSourceData_21
        MOV      R8,#-1
        B.N      ??EncodeSourceData_20
??EncodeSourceData_21:
        CMP      R9,#+0
        BEQ.N    ??EncodeSourceData_20
        MOV      R8,#+1
??EncodeSourceData_20:
        CMP      R8,#+0
        BEQ.N    ??EncodeSourceData_22
        CMN      R8,#+1
        BNE.N    ??EncodeSourceData_23
        ADDS     R0,R6,R5
        LDRB     R0,[R0, #+399]
        LDRB     R1,[SP, #+5]
        ADDS     R0,R1,R0
        ADDS     R1,R6,R5
        STRB     R0,[R1, #+399]
        MOV      R8,R6
??EncodeSourceData_24:
        LDR      R0,[SP, #+12]
        CMP      R8,R0
        BGE.W    ??EncodeSourceData_25
        ADD      R0,R8,R5
        LDRB     R0,[R0, #+1]
        STRB     R0,[R8, R5]
        ADD      R0,R8,R5
        LDRB     R0,[R0, #+401]
        ADD      R1,R8,R5
        STRB     R0,[R1, #+400]
        ADD      R8,R8,#+1
        B.N      ??EncodeSourceData_24
??EncodeSourceData_23:
        MOVS     R0,#+2
        ADDS     R1,R6,R5
        STRB     R0,[R1, #+1]
        LDRB     R0,[SP, #+4]
        LDR      R1,[SP, #+8]
        LDRB     R1,[R1, #+3]
        ADDS     R0,R1,R0
        LDR      R1,[SP, #+8]
        STRB     R0,[R1, #+2]
        ADD      R8,R6,#+2
??EncodeSourceData_26:
        LDR      R0,[SP, #+12]
        CMP      R8,R0
        BGE.N    ??EncodeSourceData_25
        ADD      R0,R8,R5
        LDRB     R0,[R0, #+1]
        STRB     R0,[R8, R5]
        ADD      R0,R8,R5
        LDRB     R0,[R0, #+401]
        ADD      R1,R8,R5
        STRB     R0,[R1, #+400]
        ADD      R8,R8,#+1
        B.N      ??EncodeSourceData_26
??EncodeSourceData_22:
        LDR      R0,[SP, #+20]
        CMP      R6,R0
        BGE.N    ??EncodeSourceData_27
        ADDS     R0,R6,R5
        ADDS     R0,R0,#+1
        LDRB     R0,[R0, #+1]
        CMP      R0,#+1
        BNE.N    ??EncodeSourceData_27
        LDRB     R0,[SP, #+4]
        LDR      R1,[SP, #+8]
        LDRB     R1,[R1, #+3]
        ADDS     R0,R1,R0
        LDR      R1,[SP, #+8]
        STRB     R0,[R1, #+2]
        ADD      R8,R6,#+2
        B.N      ??EncodeSourceData_28
??EncodeSourceData_29:
        ADD      R0,R8,R5
        LDRB     R0,[R0, #+1]
        STRB     R0,[R8, R5]
        ADD      R0,R8,R5
        LDRB     R0,[R0, #+401]
        ADD      R1,R8,R5
        STRB     R0,[R1, #+400]
        ADD      R8,R8,#+1
??EncodeSourceData_28:
        LDR      R0,[SP, #+12]
        CMP      R8,R0
        BLT.N    ??EncodeSourceData_29
        STR      R0,[R5, #+800]
??EncodeSourceData_27:
        MOVS     R0,#+1
        STRB     R0,[R6, R5]
        LDR      R0,[SP, #+8]
        LDRB     R0,[R0, #+1]
        LDR      R1,[SP, #+8]
        LDRB     R1,[R1, #+2]
        ADDS     R0,R1,R0
        LDR      R1,[SP, #+8]
        STRB     R0,[R1, #+1]
        ADD      R8,R6,#+1
        B.N      ??EncodeSourceData_30
??EncodeSourceData_31:
        ADD      R0,R8,R5
        LDRB     R0,[R0, #+1]
        STRB     R0,[R8, R5]
        ADD      R0,R8,R5
        LDRB     R0,[R0, #+401]
        ADD      R1,R8,R5
        STRB     R0,[R1, #+400]
        ADD      R8,R8,#+1
??EncodeSourceData_30:
        LDR      R0,[R5, #+800]
        SUBS     R0,R0,#+1
        CMP      R8,R0
        BLT.N    ??EncodeSourceData_31
        STR      R0,[R5, #+800]
        CMP      R6,#+1
        BLT.W    ??EncodeSourceData_9
        ADDS     R1,R6,R5
        LDRB     R1,[R1, #-1]
        CMP      R1,#+1
        BNE.W    ??EncodeSourceData_9
        ADDS     R1,R6,R5
        LDRB     R1,[R1, #+399]
        LDR      R2,[SP, #+8]
        LDRB     R2,[R2, #+1]
        ADDS     R1,R2,R1
        ADDS     R2,R6,R5
        STRB     R1,[R2, #+399]
        MOV      R8,R6
        B.N      ??EncodeSourceData_32
??EncodeSourceData_33:
        ADD      R1,R8,R5
        LDRB     R1,[R1, #+1]
        STRB     R1,[R8, R5]
        ADD      R1,R8,R5
        LDRB     R1,[R1, #+401]
        ADD      R2,R8,R5
        STRB     R1,[R2, #+400]
        ADD      R8,R8,#+1
??EncodeSourceData_32:
        SUBS     R1,R0,#+1
        CMP      R8,R1
        BLT.N    ??EncodeSourceData_33
??EncodeSourceData_25:
        LDR      R0,[R5, #+800]
        SUBS     R0,R0,#+1
        STR      R0,[R5, #+800]
        B.N      ??EncodeSourceData_9
//  962 	}
//  963 
//  964 	nBlock = 0;
??EncodeSourceData_11:
        MOV      R6,R7
        B.N      ??EncodeSourceData_34
//  965 
//  966 	while (nBlock < m_ncDataBlock - 1)
//  967 	{//合并2个部分数据
//  968 		ncSrcBits = GetBitLength(m_byBlockMode[nBlock], m_nBlockLength[nBlock], nVerGroup)
//  969 					+ GetBitLength(m_byBlockMode[nBlock + 1], m_nBlockLength[nBlock + 1], nVerGroup);
//  970 
//  971 		ncDstBits = GetBitLength(QR_MODE_8BIT, m_nBlockLength[nBlock] + m_nBlockLength[nBlock + 1], nVerGroup);
//  972 
//  973 		if (nBlock >= 1 && m_byBlockMode[nBlock - 1] == QR_MODE_8BIT)//前一数据块为BIT模式
//  974 			ncDstBits -= (4 + nIndicatorLen8Bit[nVerGroup]);
//  975 
//  976 		if (nBlock < m_ncDataBlock - 2 && m_byBlockMode[nBlock + 2] == QR_MODE_8BIT)
//  977 			ncDstBits -= (4 + nIndicatorLen8Bit[nVerGroup]);
//  978 		
//  979 		if (ncSrcBits > ncDstBits)
//  980 		{//如果合并后数据增加，前一块数据是8bit数据
//  981 			if (nBlock >= 1 && m_byBlockMode[nBlock - 1] == QR_MODE_8BIT)
//  982 			{
//  983 				m_nBlockLength[nBlock - 1] += m_nBlockLength[nBlock];
//  984 
//  985 				for (i = nBlock; i < m_ncDataBlock - 1; ++i)
//  986 				{
//  987 					m_byBlockMode[i]  = m_byBlockMode[i + 1];
//  988 					m_nBlockLength[i] = m_nBlockLength[i + 1];
//  989 				}
//  990 
//  991 				--m_ncDataBlock;
//  992 				--nBlock;
//  993 			}
//  994 
//  995 			if (nBlock < m_ncDataBlock - 2 && m_byBlockMode[nBlock + 2] == QR_MODE_8BIT)
//  996 			{//数据块+2也是8bit
//  997 				m_nBlockLength[nBlock + 1] += m_nBlockLength[nBlock + 2];
//  998 
//  999 				for (i = nBlock + 2; i < m_ncDataBlock - 1; ++i)
// 1000 				{
// 1001 					m_byBlockMode[i]  = m_byBlockMode[i + 1];
// 1002 					m_nBlockLength[i] = m_nBlockLength[i + 1];
// 1003 				}
// 1004 
// 1005 				--m_ncDataBlock;
// 1006 			}
// 1007 			//设置新的数据块为8BIT模式
// 1008 			m_byBlockMode[nBlock] = QR_MODE_8BIT;
// 1009 			m_nBlockLength[nBlock] += m_nBlockLength[nBlock + 1];
// 1010 
// 1011 			for (i = nBlock + 1; i < m_ncDataBlock - 1; ++i)
// 1012 			{
// 1013 				m_byBlockMode[i]  = m_byBlockMode[i + 1];
// 1014 				m_nBlockLength[i] = m_nBlockLength[i + 1];
// 1015 			}
// 1016 
// 1017 			--m_ncDataBlock;
// 1018 
// 1019 			if (nBlock >= 1)
// 1020 				--nBlock;
// 1021 
// 1022 			continue;
// 1023 		}
// 1024 
// 1025 		++nBlock; 
??EncodeSourceData_35:
        ADDS     R6,R6,#+1
??EncodeSourceData_34:
        LDR      R8,[R5, #+800]
        SUB      R9,R8,#+1
        CMP      R6,R9
        BGE.W    ??EncodeSourceData_36
        ADDS     R0,R6,R5
        ADDW     R0,R0,#+399
        STR      R0,[SP, #+0]
        LDRB     R10,[R0, #+1]
        LDR      R2,[SP, #+24]
        MOV      R1,R10
        LDRB     R0,[R6, R5]
          CFI FunCall GetBitLength
        BL       GetBitLength
        MOV      R11,R0
        LDR      R2,[SP, #+24]
        LDR      R0,[SP, #+0]
        LDRB     R1,[R0, #+2]
        ADDS     R0,R6,R5
        LDRB     R0,[R0, #+1]
          CFI FunCall GetBitLength
        BL       GetBitLength
        ADD      R11,R0,R11
        LDR      R2,[SP, #+24]
        LDR      R0,[SP, #+0]
        LDRB     R0,[R0, #+2]
        ADD      R1,R10,R0
        MOVS     R0,#+2
          CFI FunCall GetBitLength
        BL       GetBitLength
        MOV      R10,R0
        CMP      R6,#+1
        BLT.N    ??EncodeSourceData_37
        ADDS     R0,R6,R5
        LDRB     R0,[R0, #-1]
        CMP      R0,#+2
        BNE.N    ??EncodeSourceData_37
        LDR      R0,[SP, #+24]
        ADR.W    R1,nIndicatorLen8Bit
        LDRB     R0,[R0, R1]
        SUB      R0,R10,R0
        SUB      R10,R0,#+4
??EncodeSourceData_37:
        SUB      R0,R8,#+2
        CMP      R6,R0
        BGE.N    ??EncodeSourceData_38
        ADDS     R0,R6,R5
        LDRB     R0,[R0, #+2]
        CMP      R0,#+2
        BNE.N    ??EncodeSourceData_38
        LDR      R0,[SP, #+24]
        ADR.W    R1,nIndicatorLen8Bit
        LDRB     R0,[R0, R1]
        SUB      R0,R10,R0
        SUB      R10,R0,#+4
??EncodeSourceData_38:
        CMP      R10,R11
        BGE.N    ??EncodeSourceData_35
        CMP      R6,#+1
        BLT.N    ??EncodeSourceData_39
        ADDS     R0,R6,R5
        LDRB     R0,[R0, #-1]
        CMP      R0,#+2
        BNE.N    ??EncodeSourceData_39
        ADDS     R0,R6,R5
        LDRB     R0,[R0, #+399]
        LDR      R1,[SP, #+0]
        LDRB     R1,[R1, #+1]
        ADDS     R0,R1,R0
        ADDS     R1,R6,R5
        STRB     R0,[R1, #+399]
        MOV      R8,R6
        B.N      ??EncodeSourceData_40
??EncodeSourceData_41:
        ADD      R0,R8,R5
        LDRB     R0,[R0, #+1]
        STRB     R0,[R8, R5]
        ADD      R0,R8,R5
        LDRB     R0,[R0, #+401]
        ADD      R1,R8,R5
        STRB     R0,[R1, #+400]
        ADD      R8,R8,#+1
??EncodeSourceData_40:
        CMP      R8,R9
        BLT.N    ??EncodeSourceData_41
        STR      R9,[R5, #+800]
        SUBS     R6,R6,#+1
??EncodeSourceData_39:
        LDR      R0,[R5, #+800]
        SUBS     R1,R0,#+2
        CMP      R6,R1
        BGE.N    ??EncodeSourceData_42
        ADDS     R1,R6,R5
        LDRB     R1,[R1, #+2]
        CMP      R1,#+2
        BNE.N    ??EncodeSourceData_42
        ADDS     R1,R6,R5
        ADD      R1,R1,#+400
        LDRB     R2,[R1, #+1]
        LDRB     R3,[R1, #+2]
        ADDS     R2,R3,R2
        STRB     R2,[R1, #+1]
        ADD      R8,R6,#+2
        B.N      ??EncodeSourceData_43
??EncodeSourceData_44:
        ADD      R1,R8,R5
        LDRB     R1,[R1, #+1]
        STRB     R1,[R8, R5]
        ADD      R1,R8,R5
        LDRB     R1,[R1, #+401]
        ADD      R2,R8,R5
        STRB     R1,[R2, #+400]
        ADD      R8,R8,#+1
??EncodeSourceData_43:
        SUBS     R1,R0,#+1
        CMP      R8,R1
        BLT.N    ??EncodeSourceData_44
        STR      R1,[R5, #+800]
??EncodeSourceData_42:
        MOVS     R0,#+2
        STRB     R0,[R6, R5]
        ADDS     R0,R6,R5
        LDRB     R0,[R0, #+400]
        ADDS     R1,R6,R5
        ADD      R1,R1,#+400
        LDRB     R1,[R1, #+1]
        ADDS     R0,R1,R0
        ADDS     R1,R6,R5
        STRB     R0,[R1, #+400]
        ADD      R8,R6,#+1
        B.N      ??EncodeSourceData_45
??EncodeSourceData_46:
        ADD      R0,R8,R5
        LDRB     R0,[R0, #+1]
        STRB     R0,[R8, R5]
        ADD      R0,R8,R5
        LDRB     R0,[R0, #+401]
        ADD      R1,R8,R5
        STRB     R0,[R1, #+400]
        ADD      R8,R8,#+1
??EncodeSourceData_45:
        LDR      R0,[R5, #+800]
        SUBS     R0,R0,#+1
        CMP      R8,R0
        BLT.N    ??EncodeSourceData_46
        STR      R0,[R5, #+800]
        CMP      R6,#+1
        BLT.W    ??EncodeSourceData_34
        SUBS     R6,R6,#+1
        B.N      ??EncodeSourceData_34
// 1026 	}
// 1027 
// 1028 	m_ncDataCodeWordBit = 0; 
??EncodeSourceData_36:
        LDR.W    R6,??DataTable45
        MOV      R0,R7
        STR      R0,[R6, #+4]
// 1029 
// 1030 	memset(m_byDataCodeWord, 0, MAX_DATACODEWORD);
        MOV      R2,#+400
        MOV      R1,R0
        LDR.W    R0,??DataTable45_2
          CFI FunCall memset
        BL       memset
// 1031 
// 1032 	for (i = 0; i < m_ncDataBlock && m_ncDataCodeWordBit != -1; ++i)
        MOV      R0,R7
        STR      R0,[SP, #+8]
        B.N      ??EncodeSourceData_47
// 1033 	{
// 1034 		if (m_byBlockMode[i] == QR_MODE_NUMERAL)
// 1035 		{//如果数据块是数字模式
// 1036 			m_ncDataCodeWordBit = SetBitStream(m_ncDataCodeWordBit, 1, 4); 
// 1037 
// 1038 			m_ncDataCodeWordBit = SetBitStream(m_ncDataCodeWordBit, (WORD)m_nBlockLength[i], nIndicatorLenNumeral[nVerGroup]);
// 1039 
// 1040 			for (j = 0; j < m_nBlockLength[i]; j += 3)
// 1041 			{
// 1042 				if (j < m_nBlockLength[i] - 2)
// 1043 				{
// 1044 					wBinCode = (WORD)(((lpsSource[ncComplete + j]	  - '0') * 100) +
// 1045 									  ((lpsSource[ncComplete + j + 1] - '0') * 10) +
// 1046 									   (lpsSource[ncComplete + j + 2] - '0'));
// 1047 
// 1048 					m_ncDataCodeWordBit = SetBitStream(m_ncDataCodeWordBit, wBinCode, 10);
// 1049 				}
// 1050 				else if (j == m_nBlockLength[i] - 2)
// 1051 				{
// 1052 					wBinCode = (WORD)(((lpsSource[ncComplete + j] - '0') * 10) +
// 1053 									   (lpsSource[ncComplete + j + 1] - '0'));
// 1054 
// 1055 					m_ncDataCodeWordBit = SetBitStream(m_ncDataCodeWordBit, wBinCode, 7);
// 1056 				}
// 1057 				else if (j == m_nBlockLength[i] - 1)
// 1058 				{
// 1059 					wBinCode = (WORD)(lpsSource[ncComplete + j] - '0');
// 1060 
// 1061 					m_ncDataCodeWordBit = SetBitStream(m_ncDataCodeWordBit, wBinCode, 4);
// 1062 				}
// 1063 			}
// 1064 
// 1065 			ncComplete += m_nBlockLength[i];
// 1066 		}
// 1067 
// 1068 		else if (m_byBlockMode[i] == QR_MODE_ALPHABET)
// 1069 		{
// 1070 			m_ncDataCodeWordBit = SetBitStream(m_ncDataCodeWordBit, 2, 4);
// 1071 
// 1072 			m_ncDataCodeWordBit = SetBitStream(m_ncDataCodeWordBit, (WORD)m_nBlockLength[i], nIndicatorLenAlphabet[nVerGroup]);
// 1073 
// 1074 			for (j = 0; j < m_nBlockLength[i]; j += 2)
// 1075 			{
// 1076 				if (j < m_nBlockLength[i] - 1)
// 1077 				{
// 1078 					wBinCode = (WORD)((AlphabetToBinaly(lpsSource[ncComplete + j]) * 45) +
// 1079 									   AlphabetToBinaly(lpsSource[ncComplete + j + 1]));
// 1080 
// 1081 					m_ncDataCodeWordBit = SetBitStream(m_ncDataCodeWordBit, wBinCode, 11);
// 1082 				}
// 1083 				else
// 1084 				{
// 1085 					wBinCode = (WORD)AlphabetToBinaly(lpsSource[ncComplete + j]);
// 1086 
// 1087 					m_ncDataCodeWordBit = SetBitStream(m_ncDataCodeWordBit, wBinCode, 6);
// 1088 				}
// 1089 			}
// 1090 
// 1091 			ncComplete += m_nBlockLength[i];
// 1092 		}
// 1093 
// 1094 		else if (m_byBlockMode[i] == QR_MODE_8BIT)
// 1095 		{
// 1096 			m_ncDataCodeWordBit = SetBitStream(m_ncDataCodeWordBit, 4, 4);
// 1097 
// 1098 			m_ncDataCodeWordBit = SetBitStream(m_ncDataCodeWordBit, (WORD)m_nBlockLength[i], nIndicatorLen8Bit[nVerGroup]);
// 1099 
// 1100 			for (j = 0; j < m_nBlockLength[i]; ++j)
// 1101 			{
// 1102 				m_ncDataCodeWordBit = SetBitStream(m_ncDataCodeWordBit, (WORD)lpsSource[ncComplete + j], 8);
// 1103 			}
// 1104 
// 1105 			ncComplete += m_nBlockLength[i];
// 1106 		}
// 1107 		else// if(m_byBlockMode[i] == QR_MODE_KANJI)
// 1108 		{//日本模式
// 1109 			m_ncDataCodeWordBit = SetBitStream(m_ncDataCodeWordBit, 8, 4);
// 1110 
// 1111 			m_ncDataCodeWordBit = SetBitStream(m_ncDataCodeWordBit, (WORD)(m_nBlockLength[i] / 2), nIndicatorLenKanji[nVerGroup]);
// 1112 
// 1113 			for (j = 0; j < m_nBlockLength[i] / 2; ++j)
// 1114 			{
// 1115 				WORD wBinCode = KanjiToBinaly((WORD)(((BYTE)lpsSource[ncComplete + (j * 2)] << 8) + (BYTE)lpsSource[ncComplete + (j * 2) + 1]));
??EncodeSourceData_48:
        ADD      R0,R7,R9, LSL #+1
        LDRSB    R1,[R0, R4]
        UXTB     R1,R1
        LSLS     R1,R1,#+8
        ADDS     R0,R0,R4
        LDRSB    R0,[R0, #+1]
        UXTAB    R0,R1,R0
        UXTH     R0,R0
          CFI FunCall KanjiToBinaly
        BL       KanjiToBinaly
// 1116 
// 1117 				m_ncDataCodeWordBit = SetBitStream(m_ncDataCodeWordBit, wBinCode, 13);
        MOVS     R2,#+13
        MOV      R1,R0
        LDR      R0,[R6, #+4]
          CFI FunCall SetBitStream
        BL       SetBitStream
        STR      R0,[R6, #+4]
// 1118 			}
        ADD      R9,R9,#+1
??EncodeSourceData_49:
        CMP      R9,R10
        BLT.N    ??EncodeSourceData_48
// 1119 
// 1120 			ncComplete += m_nBlockLength[i];
??EncodeSourceData_50:
        UXTAB    R7,R7,R8
        LDR      R0,[SP, #+8]
        ADDS     R0,R0,#+1
        STR      R0,[SP, #+8]
??EncodeSourceData_47:
        LDR      R0,[R6, #+4]
        LDR      R1,[SP, #+8]
        LDR      R2,[R5, #+800]
        CMP      R1,R2
        BGE.W    ??EncodeSourceData_51
        CMN      R0,#+1
        BEQ.W    ??EncodeSourceData_51
        ADDS     R1,R1,R5
        LDRB     R8,[R1, #+400]
        LDR      R1,[SP, #+8]
        LDRB     R1,[R1, R5]
        CMP      R1,#+0
        BNE.N    ??EncodeSourceData_52
        MOVS     R2,#+4
        MOVS     R1,#+1
          CFI FunCall SetBitStream
        BL       SetBitStream
        STR      R0,[R6, #+4]
        LDR      R1,[SP, #+24]
        ADR.W    R2,nIndicatorLenNumeral
        LDRB     R2,[R1, R2]
        MOV      R1,R8
          CFI FunCall SetBitStream
        BL       SetBitStream
        STR      R0,[R6, #+4]
        MOV      R9,#+0
        B.N      ??EncodeSourceData_53
??EncodeSourceData_54:
        SUBS     R0,R1,#+1
        CMP      R9,R0
        BNE.N    ??EncodeSourceData_55
        MOVS     R2,#+4
        ADD      R0,R9,R7
        LDRSB    R0,[R0, R4]
        SUB      R1,R0,#+48
        UXTH     R1,R1
        LDR      R0,[R6, #+4]
          CFI FunCall SetBitStream
        BL       SetBitStream
        STR      R0,[R6, #+4]
??EncodeSourceData_55:
        ADD      R9,R9,#+3
??EncodeSourceData_53:
        MOV      R1,R8
        CMP      R9,R1
        BGE.N    ??EncodeSourceData_50
        SUBS     R0,R1,#+2
        CMP      R9,R0
        BGE.N    ??EncodeSourceData_56
        ADD      R1,R9,R7
        ADDS     R0,R1,R4
        MOVS     R2,#+10
        LDRSB    R1,[R1, R4]
        MOVS     R3,#+100
        LDRSB    R12,[R0, #+1]
        ADD      LR,R12,R12, LSL #+2
        LSL      R12,LR,#+1
        SMLABB   R1,R3,R1,R12
        LDRSB    R0,[R0, #+2]
        SXTAB    R0,R1,R0
        MOVW     R1,#+5328
        SUBS     R1,R0,R1
        UXTH     R1,R1
        LDR      R0,[R6, #+4]
          CFI FunCall SetBitStream
        BL       SetBitStream
        STR      R0,[R6, #+4]
        B.N      ??EncodeSourceData_55
??EncodeSourceData_56:
        BNE.N    ??EncodeSourceData_54
        ADD      R1,R9,R7
        MOVS     R2,#+7
        LDRSB    R0,[R1, R4]
        ADD      R3,R0,R0, LSL #+2
        LSLS     R0,R3,#+1
        ADDS     R1,R1,R4
        LDRSB    R1,[R1, #+1]
        SXTAB    R0,R0,R1
        SUB      R1,R0,#+528
        UXTH     R1,R1
        LDR      R0,[R6, #+4]
          CFI FunCall SetBitStream
        BL       SetBitStream
        STR      R0,[R6, #+4]
        B.N      ??EncodeSourceData_55
??EncodeSourceData_52:
        CMP      R1,#+1
        BNE.N    ??EncodeSourceData_57
        MOVS     R2,#+4
        MOVS     R1,#+2
          CFI FunCall SetBitStream
        BL       SetBitStream
        STR      R0,[R6, #+4]
        LDR      R1,[SP, #+24]
        ADR.W    R2,nIndicatorLenAlphabet
        LDRB     R2,[R1, R2]
        MOV      R1,R8
          CFI FunCall SetBitStream
        BL       SetBitStream
        STR      R0,[R6, #+4]
        MOV      R9,#+0
        B.N      ??EncodeSourceData_58
??EncodeSourceData_59:
          CFI FunCall AlphabetToBinaly
        BL       AlphabetToBinaly
        MOV      R1,R0
        MOVS     R2,#+6
        MOV      R0,R11
          CFI FunCall SetBitStream
        BL       SetBitStream
        STR      R0,[R6, #+4]
??EncodeSourceData_60:
        ADD      R9,R9,#+2
??EncodeSourceData_58:
        MOV      R1,R8
        CMP      R9,R1
        BGE.W    ??EncodeSourceData_50
        ADD      R10,R9,R7
        LDRSB    R0,[R10, R4]
        LDR      R11,[R6, #+4]
        SUBS     R1,R1,#+1
        CMP      R9,R1
        UXTB     R0,R0
        BGE.N    ??EncodeSourceData_59
          CFI FunCall AlphabetToBinaly
        BL       AlphabetToBinaly
        MOVS     R1,#+45
        STR      R0,[SP, #+0]
        STR      R1,[SP, #+4]
        ADD      R0,R10,R4
        LDRB     R0,[R0, #+1]
          CFI FunCall AlphabetToBinaly
        BL       AlphabetToBinaly
        LDR      R1,[SP, #+4]
        LDR      R2,[SP, #+0]
        MLA      R1,R1,R2,R0
        MOVS     R2,#+11
        UXTH     R1,R1
        MOV      R0,R11
          CFI FunCall SetBitStream
        BL       SetBitStream
        STR      R0,[R6, #+4]
        B.N      ??EncodeSourceData_60
??EncodeSourceData_57:
        CMP      R1,#+2
        BNE.N    ??EncodeSourceData_61
        MOVS     R2,#+4
        MOV      R1,R2
          CFI FunCall SetBitStream
        BL       SetBitStream
        STR      R0,[R6, #+4]
        LDR      R1,[SP, #+24]
        ADR.W    R2,nIndicatorLen8Bit
        LDRB     R2,[R1, R2]
        MOV      R1,R8
          CFI FunCall SetBitStream
        BL       SetBitStream
        STR      R0,[R6, #+4]
        MOV      R9,#+0
??EncodeSourceData_62:
        CMP      R9,R8
        BGE.W    ??EncodeSourceData_50
        MOVS     R2,#+8
        ADD      R0,R9,R7
        LDRSB    R1,[R0, R4]
        UXTH     R1,R1
        LDR      R0,[R6, #+4]
          CFI FunCall SetBitStream
        BL       SetBitStream
        STR      R0,[R6, #+4]
        ADD      R9,R9,#+1
        B.N      ??EncodeSourceData_62
??EncodeSourceData_61:
        MOVS     R2,#+4
        MOVS     R1,#+8
          CFI FunCall SetBitStream
        BL       SetBitStream
        STR      R0,[R6, #+4]
        LSR      R10,R8,#+1
        LDR      R1,[SP, #+24]
        ADR.W    R2,nIndicatorLenKanji
        LDRB     R2,[R1, R2]
        MOV      R1,R10
          CFI FunCall SetBitStream
        BL       SetBitStream
        STR      R0,[R6, #+4]
        MOV      R9,#+0
        B.N      ??EncodeSourceData_49
// 1121 		}
// 1122 //		else
// 1123 //		{//中文模式
// 1124 //			m_ncDataCodeWordBit = SetBitStream(m_ncDataCodeWordBit, 8, 4);
// 1125 
// 1126 //			m_ncDataCodeWordBit = SetBitStream(m_ncDataCodeWordBit, (WORD)(m_nBlockLength[i] / 2), nIndicatorLenKanji[nVerGroup]);
// 1127 
// 1128 //			for (j = 0; j < m_nBlockLength[i] / 2; ++j)
// 1129 //			{
// 1130 //				WORD wBinCode = ChineseToBinaly((WORD)(((BYTE)lpsSource[ncComplete + (j * 2)] << 8) + (BYTE)lpsSource[ncComplete + (j * 2) + 1]));
// 1131 
// 1132 //				m_ncDataCodeWordBit = SetBitStream(m_ncDataCodeWordBit, wBinCode, 13);
// 1133 //			}
// 1134 
// 1135 //			ncComplete += m_nBlockLength[i];
// 1136 //		}
// 1137 	}
// 1138 
// 1139 	return (m_ncDataCodeWordBit != -1);
??EncodeSourceData_51:
        CMN      R0,#+1
        BEQ.N    ??EncodeSourceData_63
        MOVS     R0,#+1
        B.N      ??EncodeSourceData_64
??EncodeSourceData_63:
        MOVS     R0,#+0
??EncodeSourceData_64:
        ADD      SP,SP,#+28
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
          CFI EndBlock cfiBlock2
// 1140 	//return TRUE;
// 1141 }
// 1142 //获取bit长度

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function GetBitLength
          CFI NoCalls
        THUMB
// 1143 int GetBitLength(BYTE nMode, int ncData, int nVerGroup)
// 1144 {
// 1145 	int ncBits = 0;
// 1146 
// 1147 	switch (nMode)
GetBitLength:
        CMP      R0,#+0
        BEQ.N    ??GetBitLength_0
        CMP      R0,#+2
        BEQ.N    ??GetBitLength_1
        BCC.N    ??GetBitLength_2
        B.N      ??GetBitLength_3
// 1148 	{
// 1149 	case QR_MODE_NUMERAL:
// 1150 		ncBits = 4 + nIndicatorLenNumeral[nVerGroup] + (10 * (ncData / 3));
??GetBitLength_0:
        MOVS     R0,#+3
        SDIV     R3,R1,R0
        ADR.W    R0,nIndicatorLenNumeral
        LDRB     R0,[R2, R0]
        ADD      R2,R3,R3, LSL #+2
        ADDS     R0,R0,R2, LSL #+1
        ADDS     R0,R0,#+4
// 1151 		switch (ncData % 3)
        ADD      R2,R3,R3, LSL #+1
        SUBS     R1,R1,R2
        CMP      R1,#+1
        BEQ.N    ??GetBitLength_4
        CMP      R1,#+2
        BEQ.N    ??GetBitLength_5
        BX       LR
// 1152 		{
// 1153 			case 1:
// 1154 				ncBits += 4;
??GetBitLength_4:
        ADDS     R0,R0,#+4
// 1155 				break;
        BX       LR
// 1156 			case 2:
// 1157 				ncBits += 7;
??GetBitLength_5:
        ADDS     R0,R0,#+7
// 1158 				break;
        BX       LR
// 1159 			default:
// 1160 				break;
// 1161 		}
// 1162 
// 1163 		break;
// 1164 
// 1165 	case QR_MODE_ALPHABET:
// 1166 		ncBits = 4 + nIndicatorLenAlphabet[nVerGroup] + (11 * (ncData / 2)) + (6 * (ncData % 2));
??GetBitLength_2:
        ADD      R0,R1,R1, LSR #+31
        ASRS     R0,R0,#+1
        ADR.W    R3,nIndicatorLenAlphabet
        LDRB     R2,[R2, R3]
        MOVS     R3,#+11
        MULS     R3,R3,R0
        ADDS     R2,R3,R2
        SUB      R0,R1,R0, LSL #+1
        ADD      R1,R0,R0, LSL #+1
        ADD      R0,R2,R1, LSL #+1
        ADDS     R0,R0,#+4
// 1167 		break;
        BX       LR
// 1168 
// 1169 	case QR_MODE_8BIT:
// 1170 		ncBits = 4 + nIndicatorLen8Bit[nVerGroup] + (8 * ncData);
??GetBitLength_1:
        ADR.W    R0,nIndicatorLen8Bit
        LDRB     R0,[R2, R0]
        ADDS     R0,R0,R1, LSL #+3
        ADDS     R0,R0,#+4
// 1171 		break;
        BX       LR
// 1172 
// 1173 	default:
// 1174 		//ncBits = 4 + nIndicatorLenKanji[nVerGroup] + (13 * (ncData / 2));//本程序写法？
// 1175 		ncBits = 4 + nIndicatorLenKanji[nVerGroup] + (13 * ncData);//文档算法
??GetBitLength_3:
        ADR.W    R0,nIndicatorLenKanji
        LDRB     R0,[R2, R0]
        MOVS     R2,#+13
        MULS     R1,R2,R1
        ADDS     R0,R1,R0
        ADDS     R0,R0,#+4
// 1176 		break;
// 1177 	}
// 1178 
// 1179 	return ncBits;
        BX       LR               ;; return
          CFI EndBlock cfiBlock3
// 1180 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
nIndicatorLenNumeral:
        DC8 10, 12, 14, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
nIndicatorLenAlphabet:
        DC8 9, 11, 13, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
nIndicatorLen8Bit:
        DC8 8, 16, 16, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
nIndicatorLenKanji:
        DC8 8, 10, 12, 0
// 1181 //设置bit流

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function SetBitStream
          CFI NoCalls
        THUMB
// 1182 int SetBitStream(int nIndex, WORD wData, int ncData)
// 1183 {
SetBitStream:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
// 1184 	int i;
// 1185 
// 1186 	if (nIndex == -1 || nIndex + ncData > MAX_DATACODEWORD * 8)
        CMN      R0,#+1
        BEQ.N    ??SetBitStream_0
        ADDS     R3,R2,R0
        CMP      R3,#+3200
        BLE.N    ??SetBitStream_1
// 1187 		return -1;
??SetBitStream_0:
        MOV      R0,#-1
        B.N      ??SetBitStream_2
// 1188 
// 1189 	for (i = 0; i < ncData; ++i)
??SetBitStream_1:
        MOVS     R4,#+0
        LDR.W    R12,??DataTable45_2
        B.N      ??SetBitStream_3
// 1190 	{
// 1191 		if (wData & (1 << (ncData - i - 1)))
??SetBitStream_4:
        MOVS     R5,#+1
        SUBS     R6,R2,R4
        SUBS     R6,R6,#+1
        LSL      R6,R5,R6
        MOV      R7,R1
        TST      R7,R6
        BEQ.N    ??SetBitStream_5
// 1192 		{
// 1193 			m_byDataCodeWord[(nIndex + i) / 8] |= 1 << (7 - ((nIndex + i) % 8));
        ADDS     R6,R4,R0
        ASRS     R7,R6,#+2
        ADD      R7,R6,R7, LSR #+29
        ASRS     R7,R7,#+3
        LDRB     LR,[R7, R12]
        SUB      R8,R6,R7, LSL #+3
        RSB      R8,R8,#+7
        LSL      R5,R5,R8
        ORR      R5,R5,LR
        STRB     R5,[R7, R12]
// 1194 		}
// 1195 	}
??SetBitStream_5:
        ADDS     R4,R4,#+1
??SetBitStream_3:
        CMP      R4,R2
        BLT.N    ??SetBitStream_4
// 1196 
// 1197 	return nIndex + ncData;
        MOV      R0,R3
??SetBitStream_2:
        POP      {R4-R8,PC}       ;; return
          CFI EndBlock cfiBlock4
// 1198 }
// 1199 //是不是数字编码信息
// 1200 //是返回TRUE，否返回FALSE

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock5 Using cfiCommon0
          CFI Function IsNumeralData
          CFI NoCalls
        THUMB
// 1201 bool IsNumeralData(unsigned char c)
// 1202 {
// 1203 	if (c >= '0' && c <= '9')
IsNumeralData:
        SUBS     R0,R0,#+48
        CMP      R0,#+10
        BCS.N    ??IsNumeralData_0
// 1204 		return TRUE;
        MOVS     R0,#+1
        BX       LR
// 1205 
// 1206 	return FALSE;
??IsNumeralData_0:
        MOVS     R0,#+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock5
// 1207 }
// 1208 //是否是字符编码信息
// 1209 //是返回TRUE，否返回FALSE

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock6 Using cfiCommon0
          CFI Function IsAlphabetData
          CFI NoCalls
        THUMB
// 1210 bool IsAlphabetData(unsigned char c)
// 1211 {
// 1212 	if (c >= '0' && c <= '9')
IsAlphabetData:
        MOV      R1,R0
        SUB      R2,R1,#+48
        CMP      R2,#+10
        BCC.N    ??IsAlphabetData_0
// 1213 		return TRUE;
// 1214 
// 1215 	if (c >= 'A' && c <= 'Z')
        SUBS     R1,R1,#+65
        CMP      R1,#+26
        BCC.N    ??IsAlphabetData_0
// 1216 		return TRUE;
// 1217 
// 1218 	if (c == ' ' || c == '$' || c == '%' || c == '*' || c == '+' || c == '-' || c == '.' || c == '/' || c == ':')
        CMP      R0,#+32
        BEQ.N    ??IsAlphabetData_0
        CMP      R0,#+36
        BEQ.N    ??IsAlphabetData_0
        CMP      R0,#+37
        BEQ.N    ??IsAlphabetData_0
        CMP      R0,#+42
        BEQ.N    ??IsAlphabetData_0
        CMP      R0,#+43
        BEQ.N    ??IsAlphabetData_0
        CMP      R0,#+45
        BEQ.N    ??IsAlphabetData_0
        CMP      R0,#+46
        BEQ.N    ??IsAlphabetData_0
        CMP      R0,#+47
        BEQ.N    ??IsAlphabetData_0
        CMP      R0,#+58
        BNE.N    ??IsAlphabetData_1
// 1219 		return TRUE;
??IsAlphabetData_0:
        MOVS     R0,#+1
        BX       LR
// 1220 
// 1221 	return FALSE;
??IsAlphabetData_1:
        MOVS     R0,#+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock6
// 1222 }
// 1223 //是否中文汉字信息
// 1224 //是返回TRUE，否返回FALSE

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock7 Using cfiCommon0
          CFI Function IsKanjiData
          CFI NoCalls
        THUMB
// 1225 bool IsKanjiData(unsigned char c1, unsigned char c2)
// 1226 {
// 1227 
// 1228 	if (((c1 >= 0x81 && c1 <= 0x9f) || (c1 >= 0xe0 && c1 <= 0xeb)) && (c2 >= 0x40))
IsKanjiData:
        MOV      R2,R0
        SUB      R3,R2,#+129
        CMP      R3,#+31
        BCC.N    ??IsKanjiData_0
        SUBS     R2,R2,#+224
        CMP      R2,#+12
        BCS.N    ??IsKanjiData_1
??IsKanjiData_0:
        CMP      R1,#+64
        BLT.N    ??IsKanjiData_1
// 1229 	{
// 1230 		if ((c1 == 0x9f && c2 > 0xfc) || (c1 == 0xeb && c2 > 0xbf))
        CMP      R0,#+159
        BNE.N    ??IsKanjiData_2
        CMP      R1,#+253
        BGE.N    ??IsKanjiData_1
??IsKanjiData_2:
        CMP      R0,#+235
        BNE.N    ??IsKanjiData_3
        CMP      R1,#+192
        BGE.N    ??IsKanjiData_1
// 1231 			return FALSE;
// 1232 
// 1233 		return TRUE;
??IsKanjiData_3:
        MOVS     R0,#+1
        BX       LR
// 1234 	}
// 1235 	return FALSE;
??IsKanjiData_1:
        MOVS     R0,#+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock7
// 1236 }

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock8 Using cfiCommon0
          CFI Function IsChineseData
          CFI NoCalls
        THUMB
// 1237 bool IsChineseData(unsigned char c1, unsigned char c2)
// 1238 {
// 1239 	//中文模式
// 1240 	if((c1 >= 0xa1 && c1 < 0xaa) || (c1 >= 0xb0 && c1 <= 0xfa))
IsChineseData:
        SUB      R2,R0,#+161
        CMP      R2,#+9
        BCC.N    ??IsChineseData_0
        SUBS     R0,R0,#+176
        CMP      R0,#+75
        BCS.N    ??IsChineseData_1
// 1241 	{
// 1242 		if(c2 >= 0xa1 && c2 <= 0xfe)	return TRUE;
??IsChineseData_0:
        CMP      R1,#+161
        BLT.N    ??IsChineseData_1
        CMP      R1,#+255
        BEQ.N    ??IsChineseData_1
        MOVS     R0,#+1
        BX       LR
// 1243 	}
// 1244 	return FALSE;
??IsChineseData_1:
        MOVS     R0,#+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock8
// 1245 }
// 1246 
// 1247 
// 1248 //字母表信息转化

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock9 Using cfiCommon0
          CFI Function AlphabetToBinaly
          CFI NoCalls
        THUMB
// 1249 BYTE AlphabetToBinaly(unsigned char c)
// 1250 {
// 1251 	if (c >= '0' && c <= '9') return (unsigned char)(c - '0');
AlphabetToBinaly:
        MOV      R1,R0
        SUB      R2,R1,#+48
        CMP      R2,#+10
        BCS.N    ??AlphabetToBinaly_0
        SUBS     R0,R0,#+48
        UXTB     R0,R0
        BX       LR
// 1252 
// 1253 	if (c >= 'A' && c <= 'Z') return (unsigned char)(c - 'A' + 10);
??AlphabetToBinaly_0:
        SUBS     R1,R1,#+65
        CMP      R1,#+26
        BCS.N    ??AlphabetToBinaly_1
        SUBS     R0,R0,#+55
        UXTB     R0,R0
        BX       LR
// 1254 
// 1255 	if (c == ' ') return 36;
??AlphabetToBinaly_1:
        CMP      R0,#+32
        BNE.N    ??AlphabetToBinaly_2
        MOVS     R0,#+36
        BX       LR
// 1256 
// 1257 	if (c == '$') return 37;
??AlphabetToBinaly_2:
        CMP      R0,#+36
        BNE.N    ??AlphabetToBinaly_3
        MOVS     R0,#+37
        BX       LR
// 1258 
// 1259 	if (c == '%') return 38;
??AlphabetToBinaly_3:
        CMP      R0,#+37
        BNE.N    ??AlphabetToBinaly_4
        MOVS     R0,#+38
        BX       LR
// 1260 
// 1261 	if (c == '*') return 39;
??AlphabetToBinaly_4:
        CMP      R0,#+42
        BNE.N    ??AlphabetToBinaly_5
        MOVS     R0,#+39
        BX       LR
// 1262 
// 1263 	if (c == '+') return 40;
??AlphabetToBinaly_5:
        CMP      R0,#+43
        BNE.N    ??AlphabetToBinaly_6
        MOVS     R0,#+40
        BX       LR
// 1264 
// 1265 	if (c == '-') return 41;
??AlphabetToBinaly_6:
        CMP      R0,#+45
        BNE.N    ??AlphabetToBinaly_7
        MOVS     R0,#+41
        BX       LR
// 1266 
// 1267 	if (c == '.') return 42;
??AlphabetToBinaly_7:
        CMP      R0,#+46
        BNE.N    ??AlphabetToBinaly_8
        MOVS     R0,#+42
        BX       LR
// 1268 
// 1269 	if (c == '/') return 43;
??AlphabetToBinaly_8:
        CMP      R0,#+47
        BNE.N    ??AlphabetToBinaly_9
        MOVS     R0,#+43
        BX       LR
// 1270 
// 1271 	return 44;
??AlphabetToBinaly_9:
        MOVS     R0,#+44
        BX       LR               ;; return
          CFI EndBlock cfiBlock9
// 1272 }
// 1273 //日文中文信息转化
// 1274 //日文和汉字的编码会减去一个值。
// 1275 //如：在0X8140 to 0X9FFC中的字符会减去8140，
// 1276 //在0XE040到0XEBBF中的字符要减去0XC140，
// 1277 //然后把结果前两个16进制位拿出来乘以0XC0，
// 1278 //然后再加上后两个16进制位，最后转成13bit的编码。

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock10 Using cfiCommon0
          CFI Function KanjiToBinaly
          CFI NoCalls
        THUMB
// 1279 WORD KanjiToBinaly(WORD wc)
// 1280 {
// 1281 	if (wc >= 0x8140 && wc <= 0x9ffc)
KanjiToBinaly:
        LDR.W    R1,??DataTable55  ;; 0xffff7ec0
        ADDS     R1,R1,R0
        MOVW     R2,#+7869
        CMP      R1,R2
        BCS.N    ??KanjiToBinaly_0
// 1282 		wc -= 0x8140;
        ADD      R0,R0,#+32256
        ADDS     R0,R0,#+192
        B.N      ??KanjiToBinaly_1
// 1283 	else
// 1284 		wc -= 0xc140;
??KanjiToBinaly_0:
        ADD      R0,R0,#+16064
// 1285 
// 1286 	return (WORD)(((wc >> 8) * 0xc0) + (wc & 0x00ff));
??KanjiToBinaly_1:
        UXTH     R0,R0
        LSRS     R1,R0,#+8
        ADD      R2,R1,R1, LSL #+1
        UXTB     R0,R0
        ADD      R0,R0,R2, LSL #+6
        UXTH     R0,R0
        BX       LR               ;; return
          CFI EndBlock cfiBlock10
// 1287 }
// 1288 /*
// 1289 二、中文汉字的与日文汉字转换步骤相似：
// 1290 1、对于第一字节为0xA1~0xAA之间,第二字节在0xA1~0xFE之间字符：
// 1291 a)第一字节减去0xA1；
// 1292 b)上一步结果乘以0x60;
// 1293 c）第二字节减去0xA1;
// 1294 d)将b)步骤的结果加上c步骤的结果;
// 1295 e)将结果转换为13位二进制串。
// 1296 1、对于第一字节为0xB0~0xFA之间,第二字节在0xA1~0xFE之间字符：
// 1297 a)第一字节减去0xA6；
// 1298 b)上一步结果乘以0x60;
// 1299 c）第二字节减去0xA1;
// 1300 d)将b)步骤的结果加上c步骤的结果;
// 1301 e)将结果转换为13位二进制串
// 1302 */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock11 Using cfiCommon0
          CFI Function ChineseToBinaly
          CFI NoCalls
        THUMB
// 1303 WORD ChineseToBinaly(WORD wc)
// 1304 {
// 1305 	if(wc >= 0xa1a1 && wc <= 0xa9fe)
ChineseToBinaly:
        LSRS     R1,R0,#+8
        ADD      R2,R1,R1, LSL #+1
        UXTB     R1,R0
        ADD      R1,R1,R2, LSL #+5
        LDR.W    R2,??DataTable55_1  ;; 0xffff5e5f
        ADDS     R0,R2,R0
        MOVW     R2,#+2142
        CMP      R0,R2
        BCS.N    ??ChineseToBinaly_0
// 1306 	{
// 1307 		return (WORD)((((wc >> 8)-0xa1) * 0x60) + ((wc & 0x00ff)-0xa1));
        MOVW     R0,#+15617
        SUBS     R0,R1,R0
        UXTH     R0,R0
        BX       LR
// 1308 	}
// 1309 	if(wc >= 0xb0a1 && wc <= 0xf9fe)
// 1310 	{
// 1311 		return (WORD)((((wc >> 8)-0xa6) * 0x60) + ((wc & 0x00ff)-0xa1));
// 1312 	}
// 1313 	return (WORD)((((wc >> 8)-0xa6) * 0x60) + ((wc & 0x00ff)-0xa1));
??ChineseToBinaly_0:
        MOVW     R0,#+16097
        SUBS     R0,R1,R0
        UXTH     R0,R0
        BX       LR               ;; return
          CFI EndBlock cfiBlock11
// 1314 }
// 1315 //纠错码

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock12 Using cfiCommon0
          CFI Function GetRSCodeWord
          CFI NoCalls
        THUMB
// 1316 void GetRSCodeWord(BYTE *lpbyRSWork, int ncDataCodeWord, int ncRSCodeWord)
// 1317 {
GetRSCodeWord:
        PUSH     {R4-R7}
          CFI R7 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
// 1318 	int i, j;
// 1319 
// 1320 	for (i = 0; i < ncDataCodeWord ; ++i)
        MOVS     R3,#+0
        ADR.W    R12,byExpToInt
        B.N      ??GetRSCodeWord_0
// 1321 	{
// 1322 		if (lpbyRSWork[0] != 0)
// 1323 		{
// 1324 			BYTE nExpFirst = byIntToExp[lpbyRSWork[0]]; 
// 1325 
// 1326 			for (j = 0; j < ncRSCodeWord; ++j)
// 1327 			{
// 1328 				BYTE nExpElement = (BYTE)(((int)(byRSExp[ncRSCodeWord][j] + nExpFirst)) % 255);
// 1329 
// 1330 				lpbyRSWork[j] = (BYTE)(lpbyRSWork[j + 1] ^ byExpToInt[nExpElement]);
// 1331 			}
// 1332 
// 1333 			for (j = ncRSCodeWord; j < ncDataCodeWord + ncRSCodeWord - 1; ++j)
// 1334 				lpbyRSWork[j] = lpbyRSWork[j + 1];
// 1335 		}
// 1336 		else
// 1337 		{
// 1338 			for (j = 0; j < ncDataCodeWord + ncRSCodeWord - 1; ++j)
// 1339 				lpbyRSWork[j] = lpbyRSWork[j + 1];
??GetRSCodeWord_1:
        ADDS     R5,R4,R0
        LDRB     R5,[R5, #+1]
        STRB     R5,[R4, R0]
        ADDS     R4,R4,#+1
??GetRSCodeWord_2:
        ADDS     R5,R2,R1
        SUBS     R5,R5,#+1
        CMP      R4,R5
        BLT.N    ??GetRSCodeWord_1
??GetRSCodeWord_3:
        ADDS     R3,R3,#+1
??GetRSCodeWord_0:
        CMP      R3,R1
        BGE.N    ??GetRSCodeWord_4
        LDRB     R4,[R0, #+0]
        CMP      R4,#+0
        BEQ.N    ??GetRSCodeWord_5
        ADR.W    R5,byIntToExp
        LDRB     R4,[R4, R5]
        MOVS     R5,#+0
        B.N      ??GetRSCodeWord_6
??GetRSCodeWord_7:
        LDR.W    R6,??DataTable55_2
        LDR      R6,[R6, R2, LSL #+2]
        LDRB     R6,[R5, R6]
        ADDS     R6,R4,R6
        MOVS     R7,#+255
        SDIV     R7,R6,R7
        RSB      R7,R7,R7, LSL #+8
        SUBS     R6,R6,R7
        ADDS     R7,R5,R0
        LDRB     R7,[R7, #+1]
        UXTB     R6,R6
        LDRB     R6,[R6, R12]
        EORS     R6,R6,R7
        STRB     R6,[R5, R0]
        ADDS     R5,R5,#+1
??GetRSCodeWord_6:
        CMP      R5,R2
        BLT.N    ??GetRSCodeWord_7
        MOV      R4,R2
??GetRSCodeWord_8:
        ADDS     R5,R2,R1
        SUBS     R5,R5,#+1
        CMP      R4,R5
        BGE.N    ??GetRSCodeWord_3
        ADDS     R5,R4,R0
        LDRB     R5,[R5, #+1]
        STRB     R5,[R4, R0]
        ADDS     R4,R4,#+1
        B.N      ??GetRSCodeWord_8
??GetRSCodeWord_5:
        MOVS     R4,#+0
        B.N      ??GetRSCodeWord_2
// 1340 		}
// 1341 	}
// 1342 }
??GetRSCodeWord_4:
        POP      {R4-R7}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI CFA R13+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock12

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable45:
        DC32     m_nSymbleSize

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable45_1:
        DC32     QR_VersonInfo

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable45_2:
        DC32     m_byDataCodeWord

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable45_3:
        DC32     m_byAllCodeWord

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
byExpToInt:
        DC8 1, 2, 4, 8, 16, 32, 64, 128, 29, 58, 116, 232, 205, 135, 19, 38, 76
        DC8 152, 45, 90, 180, 117, 234, 201, 143, 3, 6, 12, 24, 48, 96, 192
        DC8 157, 39, 78, 156, 37, 74, 148, 53, 106, 212, 181, 119, 238, 193
        DC8 159, 35, 70, 140, 5, 10, 20, 40, 80, 160, 93, 186, 105, 210, 185
        DC8 111, 222, 161, 95, 190, 97, 194, 153, 47, 94, 188, 101, 202, 137
        DC8 15, 30, 60, 120, 240, 253, 231, 211, 187, 107, 214, 177, 127, 254
        DC8 225, 223, 163, 91, 182, 113, 226, 217, 175, 67, 134, 17, 34, 68
        DC8 136, 13, 26, 52, 104, 208, 189, 103, 206, 129, 31, 62, 124, 248
        DC8 237, 199, 147, 59, 118, 236, 197, 151, 51, 102, 204, 133, 23, 46
        DC8 92, 184, 109, 218, 169, 79, 158, 33, 66, 132, 21, 42, 84, 168, 77
        DC8 154, 41, 82, 164, 85, 170, 73, 146, 57, 114, 228, 213, 183, 115
        DC8 230, 209, 191, 99, 198, 145, 63, 126, 252, 229, 215, 179, 123, 246
        DC8 241, 255, 227, 219, 171, 75, 150, 49, 98, 196, 149, 55, 110, 220
        DC8 165, 87, 174, 65, 130, 25, 50, 100, 200, 141, 7, 14, 28, 56, 112
        DC8 224, 221, 167, 83, 166, 81, 162, 89, 178, 121, 242, 249, 239, 195
        DC8 155, 43, 86, 172, 69, 138, 9, 18, 36, 72, 144, 61, 122, 244, 245
        DC8 247, 243, 251, 235, 203, 139, 11, 22, 44, 88, 176, 125, 250, 233
        DC8 207, 131, 27, 54, 108, 216, 173, 71, 142, 1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
byIntToExp:
        DC8 0, 0, 1, 25, 2, 50, 26, 198, 3, 223, 51, 238, 27, 104, 199, 75, 4
        DC8 100, 224, 14, 52, 141, 239, 129, 28, 193, 105, 248, 200, 8, 76, 113
        DC8 5, 138, 101, 47, 225, 36, 15, 33, 53, 147, 142, 218, 240, 18, 130
        DC8 69, 29, 181, 194, 125, 106, 39, 249, 185, 201, 154, 9, 120, 77, 228
        DC8 114, 166, 6, 191, 139, 98, 102, 221, 48, 253, 226, 152, 37, 179, 16
        DC8 145, 34, 136, 54, 208, 148, 206, 143, 150, 219, 189, 241, 210, 19
        DC8 92, 131, 56, 70, 64, 30, 66, 182, 163, 195, 72, 126, 110, 107, 58
        DC8 40, 84, 250, 133, 186, 61, 202, 94, 155, 159, 10, 21, 121, 43, 78
        DC8 212, 229, 172, 115, 243, 167, 87, 7, 112, 192, 247, 140, 128, 99
        DC8 13, 103, 74, 222, 237, 49, 197, 254, 24, 227, 165, 153, 119, 38
        DC8 184, 180, 124, 17, 68, 146, 217, 35, 32, 137, 46, 55, 63, 209, 91
        DC8 149, 188, 207, 205, 144, 135, 151, 178, 220, 252, 190, 97, 242, 86
        DC8 211, 171, 20, 42, 93, 158, 132, 60, 57, 83, 71, 109, 65, 162, 31
        DC8 45, 67, 216, 183, 123, 164, 118, 196, 23, 73, 236, 127, 12, 111
        DC8 246, 108, 161, 59, 82, 41, 157, 85, 170, 251, 96, 134, 177, 187
        DC8 204, 62, 90, 203, 89, 95, 176, 156, 169, 160, 81, 11, 245, 22, 235
        DC8 122, 117, 44, 215, 79, 174, 213, 233, 230, 231, 173, 232, 116, 214
        DC8 244, 234, 168, 80, 88, 175
// 1343 //格式化数据存放，存在于所有的尺寸中，
// 1344 //详见http://coolshell.cn/articles/10590.html#jtss-tsina

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock13 Using cfiCommon0
          CFI Function FormatModule
        THUMB
// 1345 void FormatModule(void)
// 1346 {
FormatModule:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
// 1347 	int i, j;
// 1348 	int nMinPenalty, nPenalty;
// 1349 
// 1350 	memset(m_byModuleData, 0, sizeof(m_byModuleData));
        LDR.W    R4,??DataTable55_3
        MOVW     R2,#+441
        MOVS     R1,#+0
        MOV      R0,R4
          CFI FunCall memset
        BL       memset
// 1351 
// 1352 	SetFunctionModule();	//首先把回字图案花在三个角上
          CFI FunCall SetFunctionModule
        BL       SetFunctionModule
// 1353 
// 1354 	SetCodeWordPattern();	//
          CFI FunCall SetCodeWordPattern
        BL       SetCodeWordPattern
// 1355 
// 1356 	if (m_nMaskingNo == -1)
        LDR.W    R5,??DataTable55_4
        LDR      R0,[R5, #+20]
        CMN      R0,#+1
        BNE.N    ??FormatModule_0
// 1357 	{
// 1358 		m_nMaskingNo = 0;
        MOVS     R0,#+0
        STR      R0,[R5, #+20]
// 1359 
// 1360 		SetMaskingPattern(m_nMaskingNo); 
          CFI FunCall SetMaskingPattern
        BL       SetMaskingPattern
// 1361 		SetFormatInfoPattern(m_nMaskingNo); 
        MOVS     R0,#+0
          CFI FunCall SetFormatInfoPattern
        BL       SetFormatInfoPattern
// 1362 
// 1363 		nMinPenalty = CountPenalty();
          CFI FunCall CountPenalty
        BL       CountPenalty
        MOV      R6,R0
// 1364 
// 1365 		for (i = 1; i <= 7; ++i)
        MOVS     R7,#+1
        B.N      ??FormatModule_1
// 1366 		{
// 1367 			SetMaskingPattern(i); 
??FormatModule_2:
        MOV      R0,R7
          CFI FunCall SetMaskingPattern
        BL       SetMaskingPattern
// 1368 			SetFormatInfoPattern(i); 
        MOV      R0,R7
          CFI FunCall SetFormatInfoPattern
        BL       SetFormatInfoPattern
// 1369 
// 1370 			nPenalty = CountPenalty();
          CFI FunCall CountPenalty
        BL       CountPenalty
// 1371 
// 1372 			if (nPenalty < nMinPenalty)
        CMP      R0,R6
        BGE.N    ??FormatModule_3
// 1373 			{
// 1374 				nMinPenalty = nPenalty;
        MOV      R6,R0
// 1375 				m_nMaskingNo = i;
        STR      R7,[R5, #+20]
// 1376 			}
// 1377 		}
??FormatModule_3:
        ADDS     R7,R7,#+1
??FormatModule_1:
        CMP      R7,#+8
        BLT.N    ??FormatModule_2
// 1378 	}
// 1379 
// 1380 	SetMaskingPattern(m_nMaskingNo); 
??FormatModule_0:
        LDR      R6,[R5, #+20]
        MOV      R0,R6
          CFI FunCall SetMaskingPattern
        BL       SetMaskingPattern
// 1381 	SetFormatInfoPattern(m_nMaskingNo); 
        MOV      R0,R6
          CFI FunCall SetFormatInfoPattern
        BL       SetFormatInfoPattern
// 1382 
// 1383 	for (i = 0; i < m_nSymbleSize; ++i)
        MOVS     R0,#+0
        B.N      ??FormatModule_4
// 1384 	{
// 1385 		for (j = 0; j < m_nSymbleSize; ++j)
// 1386 		{
// 1387 			m_byModuleData[i][j] = (BYTE)((m_byModuleData[i][j] & 0x11) != 0);
??FormatModule_5:
        MOVS     R1,#+21
        MLA      R1,R1,R0,R4
        LDRB     R2,[R3, R1]
        AND      R7,R2,#0x11
        SUBS     R2,R7,#+1
        SBCS     R2,R2,R2
        MVNS     R2,R2
        LSRS     R2,R2,#+31
        STRB     R2,[R3, R1]
// 1388 		}
        ADDS     R3,R3,#+1
??FormatModule_6:
        CMP      R3,R6
        BLT.N    ??FormatModule_5
        ADDS     R0,R0,#+1
??FormatModule_4:
        LDR      R6,[R5, #+0]
        CMP      R0,R6
        BGE.N    ??FormatModule_7
        MOVS     R3,#+0
        B.N      ??FormatModule_6
// 1389 	}
// 1390 }
??FormatModule_7:
        POP      {R0,R4-R7,PC}    ;; return
          CFI EndBlock cfiBlock13

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable46:
        DC32     m_byRSWork
// 1391 //设置功能性模块信息
// 1392 //Position Detection Pattern	用于标记二维码举行大小
// 1393 //Separators for Postion Detection Patterns	三个就可以标记一个矩形
// 1394 //Timing Patterns也是用于定位的。原因是二维码有40种尺寸，尺寸过大了后需要有根标准线，不然扫描的时候可能会扫歪了
// 1395 //Alignment Patterns 只有Version 2以上（包括Version2）的二维码需要这个东东，同样是为了定位用的。

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock14 Using cfiCommon0
          CFI Function SetFunctionModule
        THUMB
// 1396 void SetFunctionModule(void)
// 1397 {
SetFunctionModule:
        PUSH     {R3-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+32
// 1398 	int i, j;
// 1399 
// 1400 	SetFinderPattern(0, 0);					//三个回字坐标
        MOVS     R1,#+0
        MOV      R0,R1
          CFI FunCall SetFinderPattern
        BL       SetFinderPattern
// 1401 	SetFinderPattern(m_nSymbleSize - 7, 0);	
        LDR.W    R4,??DataTable53
        LDR      R5,[R4, #+0]
        SUBS     R6,R5,#+7
        MOVS     R1,#+0
        MOV      R0,R6
          CFI FunCall SetFinderPattern
        BL       SetFinderPattern
// 1402 	SetFinderPattern(0, m_nSymbleSize - 7);	
        MOV      R1,R6
        MOVS     R0,#+0
          CFI FunCall SetFinderPattern
        BL       SetFinderPattern
// 1403 
// 1404 	for (i = 0; i < 8; ++i)
        MOVS     R1,#+0
        MOVS     R7,#+32
        B.N      ??SetFunctionModule_0
// 1405 	{
// 1406 		m_byModuleData[i][7] = m_byModuleData[7][i] = '\x20';
??SetFunctionModule_1:
        LDR.W    R0,??DataTable55_3
        MOV      R2,R7
        ADDS     R3,R1,R0
        STRB     R2,[R3, #+147]
        MOVS     R3,#+21
        MLA      R2,R3,R1,R0
        MOV      R6,R7
        STRB     R6,[R2, #+7]
// 1407 		m_byModuleData[m_nSymbleSize - 8][i] = m_byModuleData[m_nSymbleSize - 8 + i][7] = '\x20';
        ADDS     R6,R1,R5
        MLA      R12,R3,R6,R0
        STRB     R7,[R12, #-161]
        MLA      R3,R3,R5,R0
        ADDS     R3,R1,R3
        STRB     R7,[R3, #-168]
// 1408 		m_byModuleData[i][m_nSymbleSize - 8] = m_byModuleData[7][m_nSymbleSize - 8 + i] = '\x20';
        MOV      R3,R7
        ADDS     R0,R6,R0
        STRB     R3,[R0, #+139]
        MOV      R0,R3
        ADDS     R2,R5,R2
        STRB     R0,[R2, #-8]
// 1409 	}
        ADDS     R1,R1,#+1
??SetFunctionModule_0:
        CMP      R1,#+8
        BLT.N    ??SetFunctionModule_1
// 1410 
// 1411 	for (i = 0; i < 9; ++i)
        MOVS     R1,#+0
        MOV      R2,R7
        B.N      ??SetFunctionModule_2
// 1412 	{
// 1413 		m_byModuleData[i][8] = m_byModuleData[8][i] = '\x20';
??SetFunctionModule_3:
        LDR.W    R0,??DataTable55_3
        ADDS     R3,R1,R0
        STRB     R2,[R3, #+168]
        MOVS     R3,#+21
        MLA      R0,R3,R1,R0
        STRB     R2,[R0, #+8]
// 1414 	}
        ADDS     R1,R1,#+1
??SetFunctionModule_2:
        CMP      R1,#+9
        BLT.N    ??SetFunctionModule_3
// 1415 
// 1416 	for (i = 0; i < 8; ++i)
        MOVS     R1,#+0
        MOV      R3,R2
        B.N      ??SetFunctionModule_4
// 1417 	{
// 1418 		m_byModuleData[m_nSymbleSize - 8 + i][8] = m_byModuleData[8][m_nSymbleSize - 8 + i] = '\x20';
??SetFunctionModule_5:
        ADDS     R2,R1,R5
        LDR.W    R0,??DataTable55_3
        ADDS     R6,R2,R0
        STRB     R3,[R6, #+160]
        MOVS     R6,#+21
        MLA      R0,R6,R2,R0
        STRB     R3,[R0, #-160]
// 1419 	}
        ADDS     R1,R1,#+1
??SetFunctionModule_4:
        CMP      R1,#+8
        BLT.N    ??SetFunctionModule_5
// 1420 
// 1421 	SetVersionPattern();	//版本信息
          CFI FunCall SetVersionPattern
        BL       SetVersionPattern
// 1422 
// 1423 	for (i = 0; i < QR_VersonInfo[m_nVersion].ncAlignPoint; ++i)
        MOVS     R6,#+0
        B.N      ??SetFunctionModule_6
// 1424 	{
// 1425 		SetAlignmentPattern(QR_VersonInfo[m_nVersion].nAlignPoint[i], 6);//小回字
// 1426 		SetAlignmentPattern(6, QR_VersonInfo[m_nVersion].nAlignPoint[i]);
// 1427 
// 1428 		for (j = 0; j < QR_VersonInfo[m_nVersion].ncAlignPoint; ++j)
// 1429 		{
// 1430 			SetAlignmentPattern(QR_VersonInfo[m_nVersion].nAlignPoint[i], QR_VersonInfo[m_nVersion].nAlignPoint[j]);
??SetFunctionModule_7:
        ADD      R0,R7,R9, LSL #+1
        LDRH     R1,[R0, #+14]
        LDRH     R0,[R8, #+14]
          CFI FunCall SetAlignmentPattern
        BL       SetAlignmentPattern
// 1431 		}
        ADD      R9,R9,#+1
??SetFunctionModule_8:
        LDRH     R0,[R7, #+12]
        CMP      R9,R0
        BLT.N    ??SetFunctionModule_7
        ADDS     R6,R6,#+1
??SetFunctionModule_6:
        LDR      R0,[R4, #+16]
        MOVS     R1,#+74
        ADR.W    R2,QR_VersonInfo
        MLA      R7,R1,R0,R2
        LDRH     R0,[R7, #+12]
        CMP      R6,R0
        BGE.N    ??SetFunctionModule_9
        ADD      R8,R7,R6, LSL #+1
        LDRH     R9,[R8, #+14]
        MOVS     R1,#+6
        MOV      R0,R9
          CFI FunCall SetAlignmentPattern
        BL       SetAlignmentPattern
        MOV      R1,R9
        MOVS     R0,#+6
          CFI FunCall SetAlignmentPattern
        BL       SetAlignmentPattern
        MOV      R9,#+0
        B.N      ??SetFunctionModule_8
// 1432 	}
// 1433 
// 1434 	for (i = 8; i <= m_nSymbleSize - 9; ++i)
??SetFunctionModule_9:
        MOVS     R1,#+8
        B.N      ??SetFunctionModule_10
// 1435 	{
// 1436 		m_byModuleData[i][6] = (i % 2) == 0 ? '\x30' : '\x20';
// 1437 		m_byModuleData[6][i] = (i % 2) == 0 ? '\x30' : '\x20';
??SetFunctionModule_11:
        MOVS     R2,#+32
??SetFunctionModule_12:
        ADDS     R0,R1,R0
        STRB     R2,[R0, #+126]
        ADDS     R1,R1,#+1
??SetFunctionModule_10:
        SUB      R0,R5,#+9
        CMP      R0,R1
        BLT.N    ??SetFunctionModule_13
        ADD      R0,R1,R1, LSR #+31
        ASRS     R0,R0,#+1
        SUBS     R2,R1,R0, LSL #+1
        BNE.N    ??SetFunctionModule_14
        MOVS     R3,#+48
        B.N      ??SetFunctionModule_15
??SetFunctionModule_14:
        MOVS     R3,#+32
??SetFunctionModule_15:
        LDR.W    R0,??DataTable55_3
        MOVS     R4,#+21
        MLA      R4,R4,R1,R0
        STRB     R3,[R4, #+6]
        CMP      R2,#+0
        BNE.N    ??SetFunctionModule_11
        MOVS     R2,#+48
        B.N      ??SetFunctionModule_12
// 1438 	}
// 1439 }
??SetFunctionModule_13:
        POP      {R0,R4-R9,PC}    ;; return
          CFI EndBlock cfiBlock14
// 1440 //设置大回字信息
// 1441 // O X X X X X X X
// 1442 // O X O O O O O X
// 1443 // O X O X X X O X
// 1444 // O X O X X X O X
// 1445 // O X O X X X O X
// 1446 // O X O O O O O X
// 1447 // O X X X X X X X

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock15 Using cfiCommon0
          CFI Function SetFinderPattern
          CFI NoCalls
        THUMB
// 1448 void SetFinderPattern(int x, int y)
// 1449 {
SetFinderPattern:
        PUSH     {R4-R7}
          CFI R7 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
// 1450 	static BYTE byPattern[] = {0x7f,  
// 1451 							   0x41,  
// 1452 							   0x5d,  
// 1453 							   0x5d, 
// 1454 							   0x5d, 
// 1455 							   0x41,  
// 1456 							   0x7f}; 
// 1457 	int i, j;
// 1458 
// 1459 	for (i = 0; i < 7; ++i)
        MOVS     R2,#+0
        MOVS     R7,#+21
        LDR.W    R12,??DataTable55_3
        B.N      ??SetFinderPattern_0
??SetFinderPattern_1:
        ADDS     R2,R2,#+1
??SetFinderPattern_0:
        CMP      R2,#+7
        BGE.N    ??SetFinderPattern_2
// 1460 	{
// 1461 		for (j = 0; j < 7; ++j)
        MOVS     R3,#+0
        B.N      ??SetFinderPattern_3
// 1462 		{
// 1463 			m_byModuleData[x + j][y + i] = (byPattern[i] & (1 << (6 - j))) ? '\x30' : '\x20'; 
??SetFinderPattern_4:
        MOVS     R4,#+32
??SetFinderPattern_5:
        ADDS     R5,R2,R1
        ADDS     R6,R3,R0
        MLA      R6,R7,R6,R12
        STRB     R4,[R5, R6]
        ADDS     R3,R3,#+1
??SetFinderPattern_3:
        CMP      R3,#+7
        BGE.N    ??SetFinderPattern_1
        LDR.W    R4,??DataTable55_5
        LDRB     R4,[R2, R4]
        MOVS     R5,#+1
        RSB      R6,R3,#+6
        LSLS     R5,R5,R6
        TST      R4,R5
        BEQ.N    ??SetFinderPattern_4
        MOVS     R4,#+48
        B.N      ??SetFinderPattern_5
// 1464 		}
// 1465 	}
// 1466 }
??SetFinderPattern_2:
        POP      {R4-R7}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI CFA R13+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock15

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48:
        DC32     m_byBlockMode

        SECTION `.data`:DATA:REORDER:NOROOT(2)
??byPattern:
        DATA
        DC8 127, 65, 93, 93, 93, 65, 127, 0
// 1467 //设置小回字信息
// 1468 //Alignment Patterns 只有Version 2以上（包括Version2）的二维码需要这个东东，同样是为了定位用的。
// 1469 //Alignment Patterns是除了3个大的回字，较小的回字
// 1470 // O O O X X X X X
// 1471 // O O O X O O O X
// 1472 // O O O X O X O X
// 1473 // O O O X O O O X
// 1474 // O O O X X X X X

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock16 Using cfiCommon0
          CFI Function SetAlignmentPattern
          CFI NoCalls
        THUMB
// 1475 void SetAlignmentPattern(int x, int y)
// 1476 {
SetAlignmentPattern:
        PUSH     {R4-R7}
          CFI R7 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
// 1477 	static BYTE byPattern[] = {0x1f,  
// 1478 							   0x11,  
// 1479 							   0x15, 
// 1480 							   0x11,  
// 1481 							   0x1f}; 
// 1482 	int i, j;
// 1483 
// 1484 	if (m_byModuleData[x][y] & 0x20)
        MOVS     R2,#+21
        LDR.W    R3,??DataTable55_3
        MLA      R4,R2,R0,R3
        LDRB     R4,[R1, R4]
        LSLS     R4,R4,#+26
        BMI.N    ??SetAlignmentPattern_0
// 1485 		return; 
// 1486 
// 1487 	x -= 2; y -= 2; 
        SUBS     R0,R0,#+2
        SUBS     R1,R1,#+2
// 1488 
// 1489 	for (i = 0; i < 5; ++i)
        MOVS     R4,#+0
        B.N      ??SetAlignmentPattern_1
??SetAlignmentPattern_2:
        ADDS     R4,R4,#+1
??SetAlignmentPattern_1:
        CMP      R4,#+5
        BGE.N    ??SetAlignmentPattern_0
// 1490 	{
// 1491 		for (j = 0; j < 5; ++j)
        MOVS     R5,#+0
        B.N      ??SetAlignmentPattern_3
// 1492 		{
// 1493 			m_byModuleData[x + j][y + i] = (byPattern[i] & (1 << (4 - j))) ? '\x30' : '\x20'; 
??SetAlignmentPattern_4:
        MOVS     R6,#+32
??SetAlignmentPattern_5:
        ADDS     R7,R4,R1
        ADD      R12,R5,R0
        MLA      R12,R2,R12,R3
        STRB     R6,[R7, R12]
        ADDS     R5,R5,#+1
??SetAlignmentPattern_3:
        CMP      R5,#+5
        BGE.N    ??SetAlignmentPattern_2
        LDR.W    R6,??DataTable55_6
        LDRB     R6,[R4, R6]
        MOVS     R7,#+1
        RSB      R12,R5,#+4
        LSL      R7,R7,R12
        TST      R6,R7
        BEQ.N    ??SetAlignmentPattern_4
        MOVS     R6,#+48
        B.N      ??SetAlignmentPattern_5
// 1494 		}
// 1495 	}
// 1496 }
??SetAlignmentPattern_0:
        POP      {R4-R7}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI CFA R13+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock16

        SECTION `.data`:DATA:REORDER:NOROOT(2)
??byPattern_1:
        DATA
        DC8 31, 17, 21, 17, 31, 0, 0, 0
// 1497 //设置版本，在 >= Version 7以上，需要预留两块3 x 6的区域存放一些版本信息。

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock17 Using cfiCommon0
          CFI Function SetVersionPattern
          CFI NoCalls
        THUMB
// 1498 void SetVersionPattern(void)
// 1499 {
// 1500 	int i, j;
// 1501 	int nVerData;
// 1502 
// 1503 	if (m_nVersion <= 6)//在 >= Version 7以上，需要预留两块3 x 6的区域存放一些版本信息。
SetVersionPattern:
        LDR.W    R0,??DataTable53
        LDR      R1,[R0, #+16]
        CMP      R1,#+7
        BGE.N    ??SetVersionPattern_0
        BX       LR
// 1504 		return;
// 1505 
// 1506 	nVerData = m_nVersion << 12;
??SetVersionPattern_0:
        PUSH     {R4-R7}
          CFI R7 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        LSLS     R1,R1,#+12
        MOV      R2,R1
// 1507 
// 1508 	for (i = 0; i < 6; ++i)
        MOVS     R3,#+0
        B.N      ??SetVersionPattern_1
// 1509 	{
// 1510 		if (nVerData & (1 << (17 - i)))
??SetVersionPattern_2:
        RSB      R4,R3,#+17
        ASR      R4,R2,R4
        LSLS     R4,R4,#+31
        BPL.N    ??SetVersionPattern_3
// 1511 		{
// 1512 			nVerData ^= (0x1f25 << (5 - i));
        MOVW     R4,#+7973
        RSB      R5,R3,#+5
        LSLS     R4,R4,R5
        EORS     R2,R4,R2
// 1513 		}
// 1514 	}
??SetVersionPattern_3:
        ADDS     R3,R3,#+1
??SetVersionPattern_1:
        CMP      R3,#+6
        BLT.N    ??SetVersionPattern_2
// 1515 
// 1516 	nVerData += m_nVersion << 12;
        ADDS     R1,R1,R2
// 1517 
// 1518 	for (i = 0; i < 6; ++i)
        MOVS     R2,#+0
        MOVS     R6,#+21
        LDR.W    R7,??DataTable55_3
        B.N      ??SetVersionPattern_4
??SetVersionPattern_5:
        ADDS     R2,R2,#+1
??SetVersionPattern_4:
        CMP      R2,#+6
        BGE.N    ??SetVersionPattern_6
// 1519 	{
// 1520 		for (j = 0; j < 3; ++j)
        MOVS     R3,#+0
        B.N      ??SetVersionPattern_7
// 1521 		{
// 1522 			m_byModuleData[m_nSymbleSize - 11 + j][i] = m_byModuleData[i][m_nSymbleSize - 11 + j] =
// 1523 			(nVerData & (1 << (i * 3 + j))) ? '\x30' : '\x20';
??SetVersionPattern_8:
        MOVS     R4,#+32
??SetVersionPattern_9:
        LDR      R5,[R0, #+0]
        ADDS     R5,R3,R5
        MLA      R12,R6,R2,R7
        ADD      R12,R5,R12
        STRB     R4,[R12, #-11]
        MLA      R5,R6,R5,R7
        ADDS     R5,R2,R5
        STRB     R4,[R5, #-231]
        ADDS     R3,R3,#+1
??SetVersionPattern_7:
        CMP      R3,#+3
        BGE.N    ??SetVersionPattern_5
        ADD      R4,R2,R2, LSL #+1
        ADDS     R4,R3,R4
        ASR      R4,R1,R4
        LSLS     R4,R4,#+31
        BPL.N    ??SetVersionPattern_8
        MOVS     R4,#+48
        B.N      ??SetVersionPattern_9
// 1524 		}
// 1525 	}
// 1526 }
??SetVersionPattern_6:
        POP      {R4-R7}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI CFA R13+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock17
// 1527 //如果你以为我们可以开始画图，你就错了。
// 1528 //二维码的混乱技术还没有玩完，它还要把数据码和纠错码的各个codewords交替放在一起。
// 1529 //如何交替呢，规则如下：
// 1530 //对于数据码：把每个块的第一个codewords先拿出来按顺度排列好，
// 1531 //然后再取第一块的第二个，如此类推。如：上述示例中的Data Codewords如下

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock18 Using cfiCommon0
          CFI Function SetCodeWordPattern
          CFI NoCalls
        THUMB
// 1532 void SetCodeWordPattern(void)
// 1533 {
SetCodeWordPattern:
        PUSH     {R4-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
// 1534 	int x = m_nSymbleSize;
        LDR.N    R1,??DataTable53
        LDR      R2,[R1, #+0]
        MOV      R12,R2
// 1535 	int y = m_nSymbleSize - 1;
        SUBS     R3,R2,#+1
        MOV      R6,R3
// 1536 
// 1537 	int nCoef_x = 1; 
        MOVS     R5,#+1
// 1538 	int nCoef_y = 1; 
        MOV      R7,R5
// 1539 
// 1540 	int i, j;
// 1541 
// 1542 	for (i = 0; i < m_ncAllCodeWord; ++i)
        MOVS     R4,#+0
        B.N      ??SetCodeWordPattern_0
??SetCodeWordPattern_1:
        ADDS     R4,R4,#+1
??SetCodeWordPattern_0:
        LDR      R0,[R1, #+8]
        CMP      R4,R0
        BGE.N    ??SetCodeWordPattern_2
// 1543 	{
// 1544 		for (j = 0; j < 8; ++j)
        MOV      LR,#+0
        B.N      ??SetCodeWordPattern_3
// 1545 		{
// 1546 			do
// 1547 			{
// 1548 				x += nCoef_x;
// 1549 				nCoef_x *= -1;
// 1550 
// 1551 				if (nCoef_x < 0)
// 1552 				{
// 1553 					y += nCoef_y;
// 1554 
// 1555 					if (y < 0 || y == m_nSymbleSize)
// 1556 					{
// 1557 						y = (y < 0) ? 0 : m_nSymbleSize - 1;
// 1558 						nCoef_y *= -1;
// 1559 
// 1560 						x -= 2;
// 1561 
// 1562 						if (x == 6) 
// 1563 							--x;
// 1564 					}
// 1565 				}
// 1566 			}
// 1567 			while (m_byModuleData[x][y] & 0x20); 
// 1568 
// 1569 			m_byModuleData[x][y] = (m_byAllCodeWord[i] & (1 << (7 - j))) ? '\x02' : '\x00';
??SetCodeWordPattern_4:
        MOVS     R0,#+0
??SetCodeWordPattern_5:
        STRB     R0,[R6, R8]
        ADD      LR,LR,#+1
??SetCodeWordPattern_3:
        CMP      LR,#+8
        BGE.N    ??SetCodeWordPattern_1
??SetCodeWordPattern_6:
        ADD      R12,R5,R12
        RSBS     R5,R5,#+0
        BPL.N    ??SetCodeWordPattern_7
        ADDS     R6,R7,R6
        BMI.N    ??SetCodeWordPattern_8
        CMP      R6,R2
        BNE.N    ??SetCodeWordPattern_7
??SetCodeWordPattern_8:
        CMP      R6,#+0
        BPL.N    ??SetCodeWordPattern_9
        MOVS     R6,#+0
        B.N      ??SetCodeWordPattern_10
??SetCodeWordPattern_9:
        MOV      R6,R3
??SetCodeWordPattern_10:
        RSBS     R7,R7,#+0
        SUB      R12,R12,#+2
        CMP      R12,#+6
        BNE.N    ??SetCodeWordPattern_7
        MOV      R12,#+5
??SetCodeWordPattern_7:
        MOVS     R0,#+21
        LDR.W    R8,??DataTable55_3
        MLA      R8,R0,R12,R8
        LDRB     R0,[R6, R8]
        LSLS     R0,R0,#+26
        BMI.N    ??SetCodeWordPattern_6
        LDR.W    R0,??DataTable55_7
        LDRB     R0,[R4, R0]
        MOV      R9,#+1
        RSB      R10,LR,#+7
        LSL      R9,R9,R10
        TST      R0,R9
        BEQ.N    ??SetCodeWordPattern_4
        MOVS     R0,#+2
        B.N      ??SetCodeWordPattern_5
// 1570 		}
// 1571 	}
// 1572 }
??SetCodeWordPattern_2:
        POP      {R4-R10,PC}      ;; return
          CFI EndBlock cfiBlock18
// 1573 //设置遮蔽信息

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock19 Using cfiCommon0
          CFI Function SetMaskingPattern
          CFI NoCalls
        THUMB
// 1574 void SetMaskingPattern(int nPatternNo)
// 1575 {
SetMaskingPattern:
        PUSH     {R4-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+20
// 1576 	int i, j;
// 1577 	bool bMask;
// 1578 	for (i = 0; i < m_nSymbleSize; ++i)
        MOVS     R1,#+0
        B.N      ??SetMaskingPattern_1
??SetMaskingPattern_2:
        ADDS     R1,R1,#+1
??SetMaskingPattern_1:
        LDR.N    R2,??DataTable53
        LDR      R2,[R2, #+0]
        CMP      R1,R2
        BGE.W    ??SetMaskingPattern_3
// 1579 	{
// 1580 		for (j = 0; j < m_nSymbleSize; ++j)
        MOVS     R3,#+0
        B.N      ??SetMaskingPattern_4
// 1581 		{
// 1582 			if (! (m_byModuleData[j][i] & 0x20)) 
// 1583 			{
// 1584 				switch (nPatternNo)
// 1585 				{
// 1586 				case 0:
// 1587 					bMask = ((i + j) % 2 == 0)?TRUE:FALSE;
// 1588 					break;
// 1589 
// 1590 				case 1:
// 1591 					bMask = (i % 2 == 0)?TRUE:FALSE;
// 1592 					break;
// 1593 
// 1594 				case 2:
// 1595 					bMask = (j % 3 == 0)?TRUE:FALSE;
// 1596 					break;
// 1597 
// 1598 				case 3:
// 1599 					bMask = ((i + j) % 3 == 0)?TRUE:FALSE;
// 1600 					break;
// 1601 
// 1602 				case 4:
// 1603 					bMask = (((i / 2) + (j / 3)) % 2 == 0)?TRUE:FALSE;
// 1604 					break;
// 1605 
// 1606 				case 5:
// 1607 					bMask = (((i * j) % 2) + ((i * j) % 3) == 0)?TRUE:FALSE;
// 1608 					break;
// 1609 
// 1610 				case 6:
// 1611 					bMask = ((((i * j) % 2) + ((i * j) % 3)) % 2 == 0)?TRUE:FALSE;
// 1612 					break;
// 1613 
// 1614 				default: 
// 1615 					bMask = ((((i * j) % 3) + ((i + j) % 2)) % 2 == 0)?TRUE:FALSE;
// 1616 					break;
// 1617 				}
// 1618 
// 1619 				m_byModuleData[j][i] = (BYTE)((m_byModuleData[j][i] & 0xfe) | (((m_byModuleData[j][i] & 0x02) > 1) ^ bMask));
??SetMaskingPattern_5:
        MOVS     R6,#+0
??SetMaskingPattern_6:
        AND      R5,R5,#0xFE
        EORS     R6,R7,R6
        ORRS     R5,R6,R5
        STRB     R5,[R1, R4]
??SetMaskingPattern_7:
        ADDS     R3,R3,#+1
??SetMaskingPattern_4:
        CMP      R3,R2
        BGE.N    ??SetMaskingPattern_2
        MOVS     R4,#+21
        LDR.W    R5,??DataTable55_3
        MLA      R4,R4,R3,R5
        LDRB     R5,[R1, R4]
        LSLS     R6,R5,#+26
        BMI.N    ??SetMaskingPattern_7
        MOV      R6,R0
        CMP      R6,#+6
        BHI.N    ??SetMaskingPattern_8
        TBB      [PC, R6]
        DATA
??SetMaskingPattern_0:
        DC8      0x4,0xF,0x19,0x24
        DC8      0x30,0x41,0x54,0x0
        THUMB
??SetMaskingPattern_9:
        ADDS     R6,R3,R1
        ADD      R7,R6,R6, LSR #+31
        ASRS     R7,R7,#+1
        SUB      R6,R6,R7, LSL #+1
        MOV      R7,R6
        SUBS     R7,R7,#+1
        SBCS     R7,R7,R7
        LSRS     R7,R7,#+31
        B.N      ??SetMaskingPattern_10
??SetMaskingPattern_11:
        ADD      R6,R1,R1, LSR #+31
        ASRS     R6,R6,#+1
        SUB      R6,R1,R6, LSL #+1
        MOV      R7,R6
        SUBS     R7,R7,#+1
        SBCS     R7,R7,R7
        LSRS     R7,R7,#+31
        B.N      ??SetMaskingPattern_10
??SetMaskingPattern_12:
        MOVS     R6,#+3
        SDIV     R6,R3,R6
        ADD      R6,R6,R6, LSL #+1
        SUBS     R6,R3,R6
        MOV      R7,R6
        SUBS     R7,R7,#+1
        SBCS     R7,R7,R7
        LSRS     R7,R7,#+31
        B.N      ??SetMaskingPattern_10
??SetMaskingPattern_13:
        ADDS     R6,R3,R1
        MOVS     R7,#+3
        SDIV     R7,R6,R7
        ADD      R7,R7,R7, LSL #+1
        SUBS     R6,R6,R7
        MOV      R7,R6
        SUBS     R7,R7,#+1
        SBCS     R7,R7,R7
        LSRS     R7,R7,#+31
        B.N      ??SetMaskingPattern_10
??SetMaskingPattern_14:
        ADD      R6,R1,R1, LSR #+31
        MOVS     R7,#+3
        SDIV     R7,R3,R7
        ADD      R6,R7,R6, ASR #+1
        ADD      R7,R6,R6, LSR #+31
        ASRS     R7,R7,#+1
        SUB      R6,R6,R7, LSL #+1
        MOV      R7,R6
        SUBS     R7,R7,#+1
        SBCS     R7,R7,R7
        LSRS     R7,R7,#+31
        B.N      ??SetMaskingPattern_10
??SetMaskingPattern_15:
        MUL      R6,R3,R1
        ADD      R7,R6,R6, LSR #+31
        SUB      R7,R6,R7, ASR #+1
        MOV      R12,#+3
        SDIV     R6,R6,R12
        ADD      R6,R6,R6, LSL #+1
        RSB      R6,R6,R7, LSL #+1
        MOV      R7,R6
        SUBS     R7,R7,#+1
        SBCS     R7,R7,R7
        LSRS     R7,R7,#+31
        B.N      ??SetMaskingPattern_10
??SetMaskingPattern_16:
        MUL      R6,R3,R1
        ADD      R7,R6,R6, LSR #+31
        SUB      R7,R6,R7, ASR #+1
        MOV      R12,#+3
        SDIV     R12,R6,R12
        ADD      R12,R12,R12, LSL #+1
        RSB      LR,R12,R7, LSL #+1
        ADD      LR,LR,LR, LSR #+31
        SUB      R7,R7,LR, ASR #+1
        RSB      R7,R12,R7, LSL #+1
        SUBS     R7,R7,#+1
        SBCS     R7,R7,R7
        LSRS     R7,R7,#+31
        B.N      ??SetMaskingPattern_10
??SetMaskingPattern_8:
        MUL      R7,R3,R1
        ADDS     R6,R3,R1
        MOV      R12,#+3
        SDIV     R12,R7,R12
        ADD      R12,R12,R12, LSL #+1
        SUB      R7,R7,R12
        ADDS     R7,R1,R7
        ADDS     R7,R3,R7
        ADD      R12,R6,R6, LSR #+31
        ASR      R12,R12,#+1
        SUB      LR,R7,R12, LSL #+1
        ADD      LR,LR,LR, LSR #+31
        ADD      R12,R12,LR, ASR #+1
        SUB      R7,R7,R12, LSL #+1
        SUBS     R7,R7,#+1
        SBCS     R7,R7,R7
        LSRS     R7,R7,#+31
??SetMaskingPattern_10:
        AND      R6,R5,#0x2
        CMP      R6,#+2
        BLT.W    ??SetMaskingPattern_5
        MOVS     R6,#+1
        B.N      ??SetMaskingPattern_6
// 1620 			}
// 1621 		}
// 1622 	}
// 1623 }
??SetMaskingPattern_3:
        POP      {R4-R7,PC}       ;; return
          CFI EndBlock cfiBlock19
// 1624 //设置格式化信息 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock20 Using cfiCommon0
          CFI Function SetFormatInfoPattern
          CFI NoCalls
        THUMB
// 1625 void SetFormatInfoPattern(int nPatternNo)
// 1626 {
SetFormatInfoPattern:
        PUSH     {R4-R6}
          CFI R6 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
// 1627 	int nFormatInfo;
// 1628 	int i;
// 1629 	int nFormatData;
// 1630 
// 1631 	switch (m_nLevel)
        LDR.N    R1,??DataTable53
        LDR      R2,[R1, #+12]
        CMP      R2,#+0
        BEQ.N    ??SetFormatInfoPattern_0
        CMP      R2,#+2
        BEQ.N    ??SetFormatInfoPattern_1
        BCS.N    ??SetFormatInfoPattern_2
// 1632 	{
// 1633 	case QR_LEVEL_M:
// 1634 		nFormatInfo = 0x00; 
        MOVS     R2,#+0
// 1635 		break;
        B.N      ??SetFormatInfoPattern_3
// 1636 
// 1637 	case QR_LEVEL_L:
// 1638 		nFormatInfo = 0x08; 
??SetFormatInfoPattern_0:
        MOVS     R2,#+8
// 1639 		break;
        B.N      ??SetFormatInfoPattern_3
// 1640 
// 1641 	case QR_LEVEL_Q:
// 1642 		nFormatInfo = 0x18; 
??SetFormatInfoPattern_1:
        MOVS     R2,#+24
// 1643 		break;
        B.N      ??SetFormatInfoPattern_3
// 1644 
// 1645 	default: 
// 1646 		nFormatInfo = 0x10; 
??SetFormatInfoPattern_2:
        MOVS     R2,#+16
// 1647 		break;
// 1648 	}
// 1649 
// 1650 	nFormatInfo += nPatternNo;
??SetFormatInfoPattern_3:
        ADDS     R0,R0,R2
// 1651 
// 1652 	nFormatData = nFormatInfo << 10;
        LSLS     R0,R0,#+10
        MOV      R2,R0
// 1653 
// 1654 	for (i = 0; i < 5; ++i)
        MOVS     R3,#+0
        B.N      ??SetFormatInfoPattern_4
// 1655 	{
// 1656 		if (nFormatData & (1 << (14 - i)))
??SetFormatInfoPattern_5:
        RSB      R4,R3,#+14
        ASR      R4,R2,R4
        LSLS     R4,R4,#+31
        BPL.N    ??SetFormatInfoPattern_6
// 1657 		{
// 1658 			nFormatData ^= (0x0537 << (4 - i)); 
        MOVW     R4,#+1335
        RSB      R5,R3,#+4
        LSLS     R4,R4,R5
        EORS     R2,R4,R2
// 1659 		}
// 1660 	}
??SetFormatInfoPattern_6:
        ADDS     R3,R3,#+1
??SetFormatInfoPattern_4:
        CMP      R3,#+5
        BLT.N    ??SetFormatInfoPattern_5
// 1661 
// 1662 	nFormatData += nFormatInfo << 10;
// 1663 
// 1664 	nFormatData ^= 0x5412;
        ADDS     R0,R0,R2
        EOR      R0,R0,#0x5400
        EOR      R0,R0,#0x12
// 1665 
// 1666 	for (i = 0; i <= 5; ++i)
        MOVS     R3,#+0
        B.N      ??SetFormatInfoPattern_7
// 1667 		m_byModuleData[8][i] = (nFormatData & (1 << i)) ? '\x30' : '\x20';
??SetFormatInfoPattern_8:
        MOVS     R4,#+32
??SetFormatInfoPattern_9:
        ADDS     R2,R3,R2
        STRB     R4,[R2, #+168]
        ADDS     R3,R3,#+1
??SetFormatInfoPattern_7:
        LDR.W    R2,??DataTable55_3
        CMP      R3,#+6
        BGE.N    ??SetFormatInfoPattern_10
        ASR      R4,R0,R3
        LSLS     R4,R4,#+31
        BPL.N    ??SetFormatInfoPattern_8
        MOVS     R4,#+48
        B.N      ??SetFormatInfoPattern_9
// 1668 
// 1669 	m_byModuleData[8][7] = (nFormatData & (1 << 6)) ? '\x30' : '\x20';
??SetFormatInfoPattern_10:
        ADDW     R3,R2,#+155
        LSLS     R4,R0,#+25
        BPL.N    ??SetFormatInfoPattern_11
        MOVS     R4,#+48
        STRB     R4,[R3, #+20]
        B.N      ??SetFormatInfoPattern_12
??SetFormatInfoPattern_11:
        MOVS     R4,#+32
        STRB     R4,[R3, #+20]
// 1670 	m_byModuleData[8][8] = (nFormatData & (1 << 7)) ? '\x30' : '\x20';
??SetFormatInfoPattern_12:
        LSLS     R4,R0,#+24
        BPL.N    ??SetFormatInfoPattern_13
        MOVS     R4,#+48
        STRB     R4,[R3, #+21]
        B.N      ??SetFormatInfoPattern_14
??SetFormatInfoPattern_13:
        MOVS     R4,#+32
        STRB     R4,[R3, #+21]
// 1671 	m_byModuleData[7][8] = (nFormatData & (1 << 8)) ? '\x30' : '\x20';
??SetFormatInfoPattern_14:
        LSLS     R3,R0,#+23
        BPL.N    ??SetFormatInfoPattern_15
        MOVS     R3,#+48
        STRB     R3,[R2, #+155]
        B.N      ??SetFormatInfoPattern_16
??SetFormatInfoPattern_15:
        MOVS     R3,#+32
        STRB     R3,[R2, #+155]
// 1672 
// 1673 	for (i = 9; i <= 14; ++i)
??SetFormatInfoPattern_16:
        MOVS     R3,#+9
        B.N      ??SetFormatInfoPattern_17
// 1674 		m_byModuleData[14 - i][8] = (nFormatData & (1 << i)) ? '\x30' : '\x20';
??SetFormatInfoPattern_18:
        MOVS     R4,#+32
??SetFormatInfoPattern_19:
        MVN      R5,#+20
        MLA      R5,R5,R3,R2
        STRB     R4,[R5, #+302]
        ADDS     R3,R3,#+1
??SetFormatInfoPattern_17:
        CMP      R3,#+15
        BGE.N    ??SetFormatInfoPattern_20
        ASR      R4,R0,R3
        LSLS     R4,R4,#+31
        BPL.N    ??SetFormatInfoPattern_18
        MOVS     R4,#+48
        B.N      ??SetFormatInfoPattern_19
// 1675 
// 1676 	for (i = 0; i <= 7; ++i)
??SetFormatInfoPattern_20:
        MOVS     R3,#+0
        MOVS     R6,#+21
        B.N      ??SetFormatInfoPattern_21
// 1677 		m_byModuleData[m_nSymbleSize - 1 - i][8] = (nFormatData & (1 << i)) ? '\x30' : '\x20';
??SetFormatInfoPattern_22:
        MOVS     R4,#+32
??SetFormatInfoPattern_23:
        LDR      R5,[R1, #+0]
        SUBS     R5,R5,#+1
        SUBS     R5,R5,R3
        MLA      R5,R6,R5,R2
        STRB     R4,[R5, #+8]
        ADDS     R3,R3,#+1
??SetFormatInfoPattern_21:
        CMP      R3,#+8
        BGE.N    ??SetFormatInfoPattern_24
        ASR      R4,R0,R3
        LSLS     R4,R4,#+31
        BPL.N    ??SetFormatInfoPattern_22
        MOVS     R4,#+48
        B.N      ??SetFormatInfoPattern_23
// 1678 
// 1679 	m_byModuleData[8][m_nSymbleSize - 8] = '\x30';
??SetFormatInfoPattern_24:
        LDR      R1,[R1, #+0]
        MOVS     R3,#+48
        ADDS     R4,R1,R2
        STRB     R3,[R4, #+160]
// 1680 
// 1681 	for (i = 8; i <= 14; ++i)
        MOVS     R3,#+8
        B.N      ??SetFormatInfoPattern_25
// 1682 		m_byModuleData[8][m_nSymbleSize - 15 + i] = (nFormatData & (1 << i)) ? '\x30' : '\x20';
??SetFormatInfoPattern_26:
        MOVS     R4,#+32
??SetFormatInfoPattern_27:
        ADDS     R5,R3,R1
        ADDS     R5,R5,R2
        STRB     R4,[R5, #+153]
        ADDS     R3,R3,#+1
??SetFormatInfoPattern_25:
        CMP      R3,#+15
        BGE.N    ??SetFormatInfoPattern_28
        ASR      R4,R0,R3
        LSLS     R4,R4,#+31
        BPL.N    ??SetFormatInfoPattern_26
        MOVS     R4,#+48
        B.N      ??SetFormatInfoPattern_27
// 1683 }
??SetFormatInfoPattern_28:
        POP      {R4-R6}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI CFA R13+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock20

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable53:
        DC32     m_nSymbleSize
// 1684 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock21 Using cfiCommon0
          CFI Function CountPenalty
          CFI NoCalls
        THUMB
// 1685 int CountPenalty(void)
// 1686 {
CountPenalty:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
// 1687 	int nPenalty = 0;
        MOVS     R2,#+0
// 1688 	int i, j, k;
// 1689 	int nCount = 0, s_nCount;
        MOV      R0,R2
// 1690 
// 1691 	for (i = 0; i < m_nSymbleSize; ++i)
        MOV      R7,R0
        B.N      ??CountPenalty_0
??CountPenalty_1:
        ADDS     R7,R7,#+1
??CountPenalty_0:
        LDR.W    R1,??DataTable55_4
        LDR      R1,[R1, #+0]
        CMP      R7,R1
        BGE.N    ??CountPenalty_2
// 1692 	{
// 1693 		for (j = 0; j < m_nSymbleSize - 4; ++j)
        MOV      R3,R0
        B.N      ??CountPenalty_3
// 1694 		{
// 1695 			int nCount = 1;
// 1696 
// 1697 			for (k = j + 1; k < m_nSymbleSize; k++)
// 1698 			{
// 1699 				if (((m_byModuleData[i][j] & 0x11) == 0) == ((m_byModuleData[i][k] & 0x11) == 0))
// 1700 					++nCount;
??CountPenalty_4:
        ADD      R12,R12,#+1
        ADDS     R6,R6,#+1
??CountPenalty_5:
        CMP      R6,R1
        BGE.N    ??CountPenalty_6
        MOVS     R4,#+21
        LDR.W    R5,??DataTable55_3
        MLA      R4,R4,R7,R5
        LDRB     R5,[R3, R4]
        AND      LR,R5,#0x11
        SUBS     R5,LR,#+1
        SBCS     R5,R5,R5
        LSRS     R5,R5,#+31
        LDRB     R4,[R6, R4]
        AND      LR,R4,#0x11
        SUBS     R4,LR,#+1
        SBCS     R4,R4,R4
        CMP      R5,R4, LSR #+31
        BEQ.N    ??CountPenalty_4
// 1701 				else
// 1702 					break;
// 1703 			}
// 1704 
// 1705 			if (nCount >= 5)
??CountPenalty_6:
        CMP      R12,#+5
        BLT.N    ??CountPenalty_7
// 1706 			{
// 1707 				nPenalty += 3 + (nCount - 5);
        SUB      R3,R12,#+2
        ADDS     R2,R3,R2
// 1708 			}
// 1709 
// 1710 			j = k - 1;
??CountPenalty_7:
        MOV      R3,R6
??CountPenalty_3:
        SUBS     R4,R1,#+4
        CMP      R3,R4
        BGE.N    ??CountPenalty_1
        MOV      R12,#+1
        ADDS     R6,R3,#+1
        B.N      ??CountPenalty_5
// 1711 		}
// 1712 	}
// 1713 
// 1714 	for (i = 0; i < m_nSymbleSize; ++i)
??CountPenalty_2:
        MOV      R7,R0
        B.N      ??CountPenalty_8
??CountPenalty_9:
        ADDS     R7,R7,#+1
??CountPenalty_8:
        CMP      R7,R1
        BGE.N    ??CountPenalty_10
// 1715 	{
// 1716 		for (j = 0; j < m_nSymbleSize - 4; ++j)
        MOV      R3,R0
        B.N      ??CountPenalty_11
// 1717 		{
// 1718 			int nCount = 1;
// 1719 
// 1720 			for (k = j + 1; k < m_nSymbleSize; k++)
// 1721 			{
// 1722 				if (((m_byModuleData[j][i] & 0x11) == 0) == ((m_byModuleData[k][i] & 0x11) == 0))
// 1723 					++nCount;
??CountPenalty_12:
        ADD      R12,R12,#+1
        ADDS     R6,R6,#+1
??CountPenalty_13:
        CMP      R6,R1
        BGE.N    ??CountPenalty_14
        MOVS     R4,#+21
        LDR.W    R5,??DataTable55_3
        MLA      LR,R4,R3,R5
        LDRB     LR,[R7, LR]
        AND      R8,LR,#0x11
        SUBS     LR,R8,#+1
        SBC      LR,LR,LR
        LSR      LR,LR,#+31
        MLA      R4,R4,R6,R5
        LDRB     R4,[R7, R4]
        AND      R5,R4,#0x11
        SUBS     R4,R5,#+1
        SBCS     R4,R4,R4
        CMP      LR,R4, LSR #+31
        BEQ.N    ??CountPenalty_12
// 1724 				else
// 1725 					break;
// 1726 			}
// 1727 
// 1728 			if (nCount >= 5)
??CountPenalty_14:
        CMP      R12,#+5
        BLT.N    ??CountPenalty_15
// 1729 			{
// 1730 				nPenalty += 3 + (nCount - 5);
        SUB      R3,R12,#+2
        ADDS     R2,R3,R2
// 1731 			}
// 1732 
// 1733 			j = k - 1;
??CountPenalty_15:
        MOV      R3,R6
??CountPenalty_11:
        SUBS     R4,R1,#+4
        CMP      R3,R4
        BGE.N    ??CountPenalty_9
        MOV      R12,#+1
        ADDS     R6,R3,#+1
        B.N      ??CountPenalty_13
// 1734 		}
// 1735 	}
// 1736 
// 1737 	for (i = 0; i < m_nSymbleSize - 1; ++i)
??CountPenalty_10:
        MOV      R6,R0
        SUBS     R7,R1,#+1
        B.N      ??CountPenalty_16
// 1738 	{
// 1739 		for (j = 0; j < m_nSymbleSize - 1; ++j)
// 1740 		{
// 1741 			if ((((m_byModuleData[i][j] & 0x11) == 0) == ((m_byModuleData[i + 1][j]		& 0x11) == 0)) &&
// 1742 				(((m_byModuleData[i][j] & 0x11) == 0) == ((m_byModuleData[i]	[j + 1] & 0x11) == 0)) &&
// 1743 				(((m_byModuleData[i][j] & 0x11) == 0) == ((m_byModuleData[i + 1][j + 1] & 0x11) == 0)))
??CountPenalty_17:
        MOVS     R4,#+21
        LDR.N    R5,??DataTable55_3
        MLA      R4,R4,R6,R5
        LDRB     R5,[R3, R4]
        AND      R12,R5,#0x11
        SUBS     R5,R12,#+1
        SBCS     R5,R5,R5
        LSRS     R5,R5,#+31
        ADD      R12,R3,R4
        LDRB     R12,[R12, #+21]
        AND      LR,R12,#0x11
        SUBS     R12,LR,#+1
        SBC      R12,R12,R12
        CMP      R5,R12, LSR #+31
        BNE.N    ??CountPenalty_18
        LDRB     R5,[R3, R4]
        AND      R12,R5,#0x11
        SUBS     R5,R12,#+1
        SBCS     R5,R5,R5
        LSRS     R5,R5,#+31
        ADD      R12,R3,R4
        LDRB     R12,[R12, #+1]
        AND      LR,R12,#0x11
        SUBS     R12,LR,#+1
        SBC      R12,R12,R12
        CMP      R5,R12, LSR #+31
        BNE.N    ??CountPenalty_18
        LDRB     R5,[R3, R4]
        AND      R12,R5,#0x11
        SUBS     R5,R12,#+1
        SBCS     R5,R5,R5
        LSRS     R5,R5,#+31
        ADDS     R4,R3,R4
        LDRB     R4,[R4, #+22]
        AND      R12,R4,#0x11
        SUBS     R4,R12,#+1
        SBCS     R4,R4,R4
        CMP      R5,R4, LSR #+31
        BNE.N    ??CountPenalty_18
// 1744 			{
// 1745 				nPenalty += 3;
        ADDS     R2,R2,#+3
// 1746 			}
// 1747 		}
??CountPenalty_18:
        ADDS     R3,R3,#+1
??CountPenalty_19:
        CMP      R3,R7
        BLT.N    ??CountPenalty_17
        ADDS     R6,R6,#+1
??CountPenalty_16:
        CMP      R6,R7
        BGE.N    ??CountPenalty_20
        MOV      R3,R0
        B.N      ??CountPenalty_19
// 1748 	}
// 1749 
// 1750 	for (i = 0; i < m_nSymbleSize; ++i)
??CountPenalty_20:
        MOV      R6,R0
        MOV      R12,#+17
        B.N      ??CountPenalty_21
// 1751 	{
// 1752 		for (j = 0; j < m_nSymbleSize - 6; ++j)
// 1753 		{
// 1754 			if (((j == 0) ||				 (! (m_byModuleData[i][j - 1] & 0x11))) && //   V{O
// 1755 											 (   m_byModuleData[i][j]     & 0x11)   && //  - 1
// 1756 											 (! (m_byModuleData[i][j + 1] & 0x11))  && //  - 1
// 1757 											 (   m_byModuleData[i][j + 2] & 0x11)   && //  
// 1758 											 (   m_byModuleData[i][j + 3] & 0x11)   && //  3
// 1759 											 (   m_byModuleData[i][j + 4] & 0x11)   && //  
// 1760 											 (! (m_byModuleData[i][j + 5] & 0x11))  && //  - 1
// 1761 											 (   m_byModuleData[i][j + 6] & 0x11)   && //  - 1
// 1762 				((j == m_nSymbleSize - 7) || (! (m_byModuleData[i][j + 7] & 0x11))))   //   V{O
??CountPenalty_22:
        MOVS     R4,#+21
        LDR.N    R5,??DataTable55_3
        MLA      R4,R4,R6,R5
        CMP      R3,#+0
        BEQ.N    ??CountPenalty_23
        ADDS     R5,R3,R4
        SUBS     R5,R5,#+4
        LDRB     R5,[R5, #+3]
        MOV      R7,R12
        TST      R5,R7
        BNE.N    ??CountPenalty_24
??CountPenalty_23:
        LDRB     R5,[R3, R4]
        MOV      R7,R12
        TST      R5,R7
        BEQ.N    ??CountPenalty_24
        ADDS     R5,R3,R4
        LDRB     R5,[R5, #+1]
        TST      R5,R7
        BNE.N    ??CountPenalty_24
        ADDS     R5,R3,R4
        ADDS     R5,R5,#+1
        LDRB     R7,[R5, #+1]
        TST      R7,R12
        BEQ.N    ??CountPenalty_24
        LDRB     R7,[R5, #+2]
        TST      R7,R12
        BEQ.N    ??CountPenalty_24
        LDRB     R7,[R5, #+3]
        TST      R7,R12
        BEQ.N    ??CountPenalty_24
        LDRB     R7,[R5, #+4]
        TST      R7,R12
        BNE.N    ??CountPenalty_24
        LDRB     R7,[R5, #+5]
        TST      R7,R12
        BEQ.N    ??CountPenalty_24
        SUBS     R7,R1,#+7
        CMP      R3,R7
        BEQ.N    ??CountPenalty_25
        LDRB     R7,[R5, #+6]
        TST      R7,R12
        BNE.N    ??CountPenalty_24
// 1763 			{
// 1764 				if (((j < 2 || ! (m_byModuleData[i][j - 2] & 0x11)) && 
// 1765 					 (j < 3 || ! (m_byModuleData[i][j - 3] & 0x11)) &&
// 1766 					 (j < 4 || ! (m_byModuleData[i][j - 4] & 0x11))) ||
// 1767 					((j >= m_nSymbleSize - 8  || ! (m_byModuleData[i][j + 8]  & 0x11)) &&
// 1768 					 (j >= m_nSymbleSize - 9  || ! (m_byModuleData[i][j + 9]  & 0x11)) &&
// 1769 					 (j >= m_nSymbleSize - 10 || ! (m_byModuleData[i][j + 10] & 0x11))))
??CountPenalty_25:
        CMP      R3,#+2
        BLT.N    ??CountPenalty_26
        ADDS     R7,R3,R4
        SUBS     R7,R7,#+4
        LDRB     R7,[R7, #+2]
        TST      R7,R12
        BNE.N    ??CountPenalty_27
??CountPenalty_26:
        CMP      R3,#+3
        BLT.N    ??CountPenalty_28
        ADDS     R7,R3,R4
        SUBS     R7,R7,#+4
        LDRB     R7,[R7, #+1]
        TST      R7,R12
        BNE.N    ??CountPenalty_27
??CountPenalty_28:
        CMP      R3,#+4
        BLT.N    ??CountPenalty_29
        ADDS     R4,R3,R4
        LDRB     R4,[R4, #-4]
        MOV      R7,R12
        TST      R4,R7
        BEQ.N    ??CountPenalty_29
??CountPenalty_27:
        SUB      R4,R1,#+8
        CMP      R3,R4
        BGE.N    ??CountPenalty_30
        LDRB     R4,[R5, #+7]
        MOV      R7,R12
        TST      R4,R7
        BNE.N    ??CountPenalty_24
??CountPenalty_30:
        SUB      R4,R1,#+9
        CMP      R3,R4
        BGE.N    ??CountPenalty_31
        LDRB     R4,[R5, #+8]
        MOV      R7,R12
        TST      R4,R7
        BNE.N    ??CountPenalty_24
??CountPenalty_31:
        SUB      R4,R1,#+10
        CMP      R3,R4
        BGE.N    ??CountPenalty_29
        LDRB     R4,[R5, #+9]
        MOV      R5,R12
        TST      R4,R5
        BNE.N    ??CountPenalty_24
// 1770 				{
// 1771 					nPenalty += 40;
??CountPenalty_29:
        ADDS     R2,R2,#+40
// 1772 				}
// 1773 			}
// 1774 		}
??CountPenalty_24:
        ADDS     R3,R3,#+1
??CountPenalty_32:
        SUBS     R4,R1,#+6
        CMP      R3,R4
        BLT.N    ??CountPenalty_22
        ADDS     R6,R6,#+1
??CountPenalty_21:
        CMP      R6,R1
        BGE.N    ??CountPenalty_33
        MOV      R3,R0
        B.N      ??CountPenalty_32
// 1775 	}
// 1776 
// 1777 	for (i = 0; i < m_nSymbleSize; ++i)
??CountPenalty_33:
        MOV      R6,R0
        B.N      ??CountPenalty_34
// 1778 	{
// 1779 		for (j = 0; j < m_nSymbleSize - 6; ++j)
// 1780 		{
// 1781 			if (((j == 0) ||				 (! (m_byModuleData[j - 1][i] & 0x11))) && //   V{O
// 1782 											 (   m_byModuleData[j]    [i] & 0x11)   && //  - 1
// 1783 											 (! (m_byModuleData[j + 1][i] & 0x11))  && //  - 1
// 1784 											 (   m_byModuleData[j + 2][i] & 0x11)   && //  
// 1785 											 (   m_byModuleData[j + 3][i] & 0x11)   && //  3
// 1786 											 (   m_byModuleData[j + 4][i] & 0x11)   && //  
// 1787 											 (! (m_byModuleData[j + 5][i] & 0x11))  && //  - 1
// 1788 											 (   m_byModuleData[j + 6][i] & 0x11)   && //  - 1
// 1789 				((j == m_nSymbleSize - 7) || (! (m_byModuleData[j + 7][i] & 0x11))))   //   V{O
??CountPenalty_35:
        MOVS     R4,#+21
        LDR.N    R5,??DataTable55_3
        MLA      R4,R4,R3,R5
        CMP      R3,#+0
        BEQ.N    ??CountPenalty_36
        ADDS     R5,R6,R4
        LDRB     R5,[R5, #-21]
        MOV      R7,R12
        TST      R5,R7
        BNE.N    ??CountPenalty_37
??CountPenalty_36:
        LDRB     R5,[R6, R4]
        MOV      R7,R12
        TST      R5,R7
        BEQ.N    ??CountPenalty_37
        ADDS     R5,R6,R4
        LDRB     R5,[R5, #+21]
        TST      R5,R7
        BNE.N    ??CountPenalty_37
        ADDS     R5,R6,R4
        LDRB     R5,[R5, #+42]
        TST      R5,R7
        BEQ.N    ??CountPenalty_37
        ADDS     R5,R6,R4
        LDRB     R5,[R5, #+63]
        TST      R5,R7
        BEQ.N    ??CountPenalty_37
        ADDS     R5,R6,R4
        LDRB     R5,[R5, #+84]
        TST      R5,R7
        BEQ.N    ??CountPenalty_37
        ADDS     R5,R6,R4
        LDRB     R5,[R5, #+105]
        TST      R5,R7
        BNE.N    ??CountPenalty_37
        ADDS     R5,R6,R4
        LDRB     R5,[R5, #+126]
        TST      R5,R7
        BEQ.N    ??CountPenalty_37
        SUBS     R5,R1,#+7
        CMP      R3,R5
        BEQ.N    ??CountPenalty_38
        ADDS     R5,R6,R4
        LDRB     R5,[R5, #+147]
        TST      R5,R7
        BNE.N    ??CountPenalty_37
// 1790 			{
// 1791 				if (((j < 2 || ! (m_byModuleData[j - 2][i] & 0x11)) && 
// 1792 					 (j < 3 || ! (m_byModuleData[j - 3][i] & 0x11)) &&
// 1793 					 (j < 4 || ! (m_byModuleData[j - 4][i] & 0x11))) ||
// 1794 					((j >= m_nSymbleSize - 8  || ! (m_byModuleData[j + 8][i]  & 0x11)) &&
// 1795 					 (j >= m_nSymbleSize - 9  || ! (m_byModuleData[j + 9][i]  & 0x11)) &&
// 1796 					 (j >= m_nSymbleSize - 10 || ! (m_byModuleData[j + 10][i] & 0x11))))
??CountPenalty_38:
        CMP      R3,#+2
        BLT.N    ??CountPenalty_39
        ADDS     R5,R6,R4
        LDRB     R5,[R5, #-42]
        TST      R5,R7
        BNE.N    ??CountPenalty_40
??CountPenalty_39:
        CMP      R3,#+3
        BLT.N    ??CountPenalty_41
        ADDS     R5,R6,R4
        LDRB     R5,[R5, #-63]
        TST      R5,R7
        BNE.N    ??CountPenalty_40
??CountPenalty_41:
        CMP      R3,#+4
        BLT.N    ??CountPenalty_42
        ADDS     R5,R6,R4
        LDRB     R5,[R5, #-84]
        TST      R5,R7
        BEQ.N    ??CountPenalty_42
??CountPenalty_40:
        SUB      R5,R1,#+8
        CMP      R3,R5
        BGE.N    ??CountPenalty_43
        ADDS     R5,R6,R4
        LDRB     R5,[R5, #+168]
        TST      R5,R7
        BNE.N    ??CountPenalty_37
??CountPenalty_43:
        SUB      R5,R1,#+9
        CMP      R3,R5
        BGE.N    ??CountPenalty_44
        ADDS     R5,R6,R4
        LDRB     R5,[R5, #+189]
        TST      R5,R7
        BNE.N    ??CountPenalty_37
??CountPenalty_44:
        SUB      R5,R1,#+10
        CMP      R3,R5
        BGE.N    ??CountPenalty_42
        ADDS     R4,R6,R4
        LDRB     R4,[R4, #+210]
        MOV      R5,R7
        TST      R4,R5
        BNE.N    ??CountPenalty_37
// 1797 				{
// 1798 					nPenalty += 40;
??CountPenalty_42:
        ADDS     R2,R2,#+40
// 1799 				}
// 1800 			}
// 1801 		}
??CountPenalty_37:
        ADDS     R3,R3,#+1
??CountPenalty_45:
        SUBS     R4,R1,#+6
        CMP      R3,R4
        BLT.N    ??CountPenalty_35
        ADDS     R6,R6,#+1
??CountPenalty_34:
        CMP      R6,R1
        BGE.N    ??CountPenalty_46
        MOV      R3,R0
        B.N      ??CountPenalty_45
// 1802 	}
// 1803 
// 1804 	for (i = 0; i < m_nSymbleSize; ++i)
??CountPenalty_46:
        MOV      R4,R0
        B.N      ??CountPenalty_47
// 1805 	{
// 1806 		for (j = 0; j < m_nSymbleSize; ++j)
// 1807 		{
// 1808 			if (! (m_byModuleData[i][j] & 0x11))
??CountPenalty_48:
        MOVS     R5,#+21
        LDR.N    R6,??DataTable55_3
        MLA      R5,R5,R4,R6
        LDRB     R5,[R3, R5]
        MOV      R6,R12
        TST      R5,R6
        BNE.N    ??CountPenalty_49
// 1809 			{
// 1810 				++nCount;
        ADDS     R0,R0,#+1
// 1811 			}
// 1812 		}
??CountPenalty_49:
        ADDS     R3,R3,#+1
??CountPenalty_50:
        CMP      R3,R1
        BLT.N    ??CountPenalty_48
        ADDS     R4,R4,#+1
??CountPenalty_47:
        CMP      R4,R1
        BGE.N    ??CountPenalty_51
        MOVS     R3,#+0
        B.N      ??CountPenalty_50
// 1813 	}
// 1814 	
// 1815 	if( (50 - ((nCount * 100) / (m_nSymbleSize * m_nSymbleSize))) > 0)
??CountPenalty_51:
        MOVS     R3,#+100
        MULS     R0,R3,R0
        MULS     R1,R1,R1
        SDIV     R0,R0,R1
        RSB      R1,R0,#+50
        CMP      R1,#+1
        BGE.N    ??CountPenalty_52
// 1816 		s_nCount = 50 - ((nCount * 100) / (m_nSymbleSize * m_nSymbleSize));
// 1817 	else
// 1818 		s_nCount = 0 - (50 - ((nCount * 100) / (m_nSymbleSize * m_nSymbleSize)));
        SUB      R1,R0,#+50
// 1819 	nPenalty += (s_nCount / 5) * 10;
// 1820 
// 1821 	return nPenalty;
??CountPenalty_52:
        MOVS     R0,#+5
        SDIV     R0,R1,R0
        ADD      R1,R0,R0, LSL #+2
        ADD      R0,R2,R1, LSL #+1
        POP      {R4-R8,PC}       ;; return
          CFI EndBlock cfiBlock21
// 1822 }
// 1823 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock22 Using cfiCommon0
          CFI Function Print_2DCode
          CFI NoCalls
        THUMB
// 1824 void Print_2DCode(void)
// 1825 {
Print_2DCode:
        PUSH     {R4-R6}
          CFI R6 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
// 1826 	int i,j,k,x,y,z,size,mod;
// 1827 	BYTE bit_h,bit_v,print_num;//print_buff[1024];
// 1828 	BYTE print_buff[256];
// 1829 
// 1830 //--	SendCmd(3, 0x1b, 0x4a, 25);
// 1831 	
// 1832 	bit_h = 4;
// 1833 	bit_v = 2;
// 1834 
// 1835 	size = m_nSymbleSize/bit_v;
        LDR.N    R0,??DataTable55_4
        LDR      R0,[R0, #+0]
        ADD      R1,R0,R0, LSR #+31
        ASRS     R1,R1,#+1
// 1836 	mod = m_nSymbleSize%bit_v;
        SUB      R2,R0,R1, LSL #+1
// 1837 
// 1838 	print_num = bit_h * m_nSymbleSize;
        LSLS     R3,R0,#+2
        UXTB     R3,R3
// 1839 	
// 1840 	for(i=0; i<size; i++)
        MOVS     R4,#+0
        B.N      ??Print_2DCode_0
// 1841 	{	
// 1842 		print_buff[0] = 0x1b;
// 1843 		print_buff[1] = 0x2a;
// 1844 		print_buff[2] = print_num;
// 1845 		print_buff[3] = 0x00;
// 1846 		x = 4;
// 1847 	
// 1848 		for(j=0;j<m_nSymbleSize;j++)
// 1849 		{	
// 1850 			k = i*bit_v;			
// 1851 			if(m_byModuleData[j][k] == 1 && m_byModuleData[j][k+1] == 1)
// 1852 			{
// 1853 				print_buff[x] = 0xFF;
// 1854 				x++;
// 1855 			}
// 1856 			else if(m_byModuleData[j][k] == 1 && m_byModuleData[j][k+1] == 0)
// 1857 			{
// 1858 				print_buff[x] = 0xF0;
// 1859 				x++;
// 1860 			}
// 1861 			else if(m_byModuleData[j][k] == 0 && m_byModuleData[j][k+1] == 1)
// 1862 			{
// 1863 				print_buff[x] = 0x0F;
// 1864 				x++;
// 1865 			}
// 1866 			else
// 1867 			{
// 1868 				print_buff[x] = 0x00;
// 1869 				x++;
// 1870 			}
// 1871 			k = k+2;
// 1872 				
// 1873 			for(y=0; y<(bit_h-1); y++)
// 1874 			{  
// 1875 				print_buff[x] = print_buff[x-1];
// 1876 				x++;
// 1877 			}
// 1878 		}
// 1879 		
// 1880 		for(z=0;z<(print_num+4);z++);
??Print_2DCode_1:
        ADDS     R5,R5,#+1
??Print_2DCode_2:
        CMP      R5,R6
        BLT.N    ??Print_2DCode_1
        ADDS     R4,R4,#+1
??Print_2DCode_0:
        CMP      R4,R1
        BGE.N    ??Print_2DCode_3
        MOVS     R5,#+0
        B.N      ??Print_2DCode_4
??Print_2DCode_5:
        ADDS     R6,R6,#+1
??Print_2DCode_6:
        CMP      R6,#+3
        BLT.N    ??Print_2DCode_5
        ADDS     R5,R5,#+1
??Print_2DCode_4:
        CMP      R5,R0
        BGE.N    ??Print_2DCode_7
        MOVS     R6,#+0
        B.N      ??Print_2DCode_6
??Print_2DCode_7:
        MOVS     R5,#+0
        ADDS     R6,R3,#+4
        B.N      ??Print_2DCode_2
// 1881 //--		ser_send_char(1,print_buff[z]);
// 1882 		
// 1883 //--		SendCmd(3, 0x1b, 0x4a, 0);	
// 1884 	}
// 1885 	
// 1886 	if(mod !=0)
??Print_2DCode_3:
        CMP      R2,#+0
        BEQ.N    ??Print_2DCode_8
// 1887 	{
// 1888 		print_buff[0] = 0x1b;
// 1889 		print_buff[1] = 0x2a;
// 1890 		print_buff[2] = print_num;
// 1891 		print_buff[3] = 0x00;
// 1892 		x = 4;
// 1893 		
// 1894 		for(j=0;j<m_nSymbleSize;j++)
        MOVS     R5,#+0
        B.N      ??Print_2DCode_9
// 1895 		{
// 1896 			i = size * bit_v;				
// 1897 			if(m_byModuleData[j][i] == 1)
// 1898 			{
// 1899 				print_buff[x] = 0xF0;
// 1900 				x++;
// 1901 			}
// 1902 			else
// 1903 			{
// 1904 				print_buff[x] = 0x00;
// 1905 				x++;
// 1906 			}	
// 1907 				
// 1908 			for(y=0; y<(bit_h-1); y++)
// 1909 			{
// 1910 				print_buff[x] = print_buff[x-1];
// 1911 				x++;	
??Print_2DCode_10:
        ADDS     R6,R6,#+1
??Print_2DCode_11:
        CMP      R6,#+3
        BLT.N    ??Print_2DCode_10
        ADDS     R5,R5,#+1
??Print_2DCode_9:
        CMP      R5,R0
        BGE.N    ??Print_2DCode_12
        MOVS     R6,#+0
        B.N      ??Print_2DCode_11
// 1912 			}
// 1913 		}
// 1914 
// 1915 		for(z=0;z<(print_num+4);z++);
??Print_2DCode_12:
        MOVS     R5,#+0
        ADDS     R0,R3,#+4
        B.N      ??Print_2DCode_13
??Print_2DCode_14:
        ADDS     R5,R5,#+1
??Print_2DCode_13:
        CMP      R5,R0
        BLT.N    ??Print_2DCode_14
// 1916 //--		ser_send_char(1,print_buff[z]);
// 1917 		
// 1918 //--		SendCmd(3, 0x1b, 0x4a, 0);
// 1919 	}
// 1920 
// 1921 //--	SendCmd(3, 0x1b, 0x4a, 25);
// 1922 }
??Print_2DCode_8:
        POP      {R4-R6}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI CFA R13+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock22

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable55:
        DC32     0xffff7ec0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable55_1:
        DC32     0xffff5e5f

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable55_2:
        DC32     byRSExp

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable55_3:
        DC32     m_byModuleData

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable55_4:
        DC32     m_nSymbleSize

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable55_5:
        DC32     ??byPattern

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable55_6:
        DC32     ??byPattern_1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable55_7:
        DC32     m_byAllCodeWord

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
QR_VersonInfo:
        DC16 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC16 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 26, 19, 16, 13, 9
        DC16 0, 0, 0, 0, 0, 0, 0, 1, 26, 19, 1, 26, 16, 1, 26, 13, 1, 26, 9, 0
        DC16 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 44, 34, 28, 22, 16, 1, 18, 0
        DC16 0, 0, 0, 0, 1, 44, 34, 1, 44, 28, 1, 44, 22, 1, 44, 16, 0, 0, 0, 0
        DC16 0, 0, 0, 0, 0, 0, 0, 0, 3, 70, 55, 44, 34, 26, 1, 22, 0, 0, 0, 0
        DC16 0, 1, 70, 55, 1, 70, 44, 2, 35, 17, 2, 35, 13, 0, 0, 0, 0, 0, 0, 0
        DC16 0, 0, 0, 0, 0, 4, 100, 80, 64, 48, 36, 1, 26, 0, 0, 0, 0, 0, 1
        DC16 100, 80, 2, 50, 32, 2, 50, 24, 4, 25, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC16 0, 0, 0, 5, 134, 108, 86, 62, 46, 1, 30, 0, 0, 0, 0, 0, 1, 134
        DC16 108, 2, 67, 43, 2, 33, 15, 2, 33, 11, 0, 0, 0, 0, 0, 0, 2, 34, 16
        DC16 2, 34, 12, 6, 172, 136, 108, 76, 60, 1, 34, 0, 0, 0, 0, 0, 2, 86
        DC16 68, 4, 43, 27, 4, 43, 19, 4, 43, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC16 0, 0, 7, 196, 156, 124, 88, 66, 2, 22, 38, 0, 0, 0, 0, 2, 98, 78
        DC16 4, 49, 31, 2, 32, 14, 4, 39, 13, 0, 0, 0, 0, 0, 0, 4, 33, 15, 1
        DC16 40, 14, 8, 242, 194, 154, 110, 86, 2, 24, 42, 0, 0, 0, 0, 2, 121
        DC16 97, 2, 60, 38, 4, 40, 18, 4, 40, 14, 0, 0, 0, 2, 61, 39, 2, 41, 19
        DC16 2, 41, 15, 9, 292, 232, 182, 132, 100, 2, 26, 46, 0, 0, 0, 0, 2
        DC16 146, 116, 3, 58, 36, 4, 36, 16, 4, 36, 12, 0, 0, 0, 2, 59, 37, 4
        DC16 37, 17, 4, 37, 13, 10, 346, 274, 216, 154, 122, 2, 28, 50, 0, 0, 0
        DC16 0, 2, 86, 68, 4, 69, 43, 6, 43, 19, 6, 43, 15, 2, 87, 69, 1, 70
        DC16 44, 2, 44, 20, 2, 44, 16, 11, 404, 324, 254, 180, 140, 2, 30, 54
        DC16 0, 0, 0, 0, 4, 101, 81, 1, 80, 50, 4, 50, 22, 3, 36, 12, 0, 0, 0
        DC16 4, 81, 51, 4, 51, 23, 8, 37, 13, 12, 466, 370, 290, 206, 158, 2
        DC16 32, 58, 0, 0, 0, 0, 2, 116, 92, 6, 58, 36, 4, 46, 20, 7, 42, 14, 2
        DC16 117, 93, 2, 59, 37, 6, 47, 21, 4, 43, 15, 13, 532, 428, 334, 244
        DC16 180, 2, 34, 62, 0, 0, 0, 0, 4, 133, 107, 8, 59, 37, 8, 44, 20, 12
        DC16 33, 11, 0, 0, 0, 1, 60, 38, 4, 45, 21, 4, 34, 12, 14, 581, 461
        DC16 365, 261, 197, 3, 26, 46, 66, 0, 0, 0, 3, 145, 115, 4, 64, 40, 11
        DC16 36, 16, 11, 36, 12, 1, 146, 116, 5, 65, 41, 5, 37, 17, 5, 37, 13
        DC16 15, 655, 523, 415, 295, 223, 3, 26, 48, 70, 0, 0, 0, 5, 109, 87, 5
        DC16 65, 41, 5, 54, 24, 11, 36, 12, 1, 110, 88, 5, 66, 42, 7, 55, 25, 7
        DC16 37, 13, 16, 733, 589, 453, 325, 253, 3, 26, 50, 74, 0, 0, 0, 5
        DC16 122, 98, 7, 73, 45, 15, 43, 19, 3, 45, 15, 1, 123, 99, 3, 74, 46
        DC16 2, 44, 20, 13, 46, 16, 17, 815, 647, 507, 367, 283, 3, 30, 54, 78
        DC16 0, 0, 0, 1, 135, 107, 10, 74, 46, 1, 50, 22, 2, 42, 14, 5, 136
        DC16 108, 1, 75, 47, 15, 51, 23, 17, 43, 15, 18, 901, 721, 563, 397
        DC16 313, 3, 30, 56, 82, 0, 0, 0, 5, 150, 120, 9, 69, 43, 17, 50, 22, 2
        DC16 42, 14, 1, 151, 121, 4, 70, 44, 1, 51, 23, 19, 43, 15, 19, 991
        DC16 795, 627, 445, 341, 3, 30, 58, 86, 0, 0, 0, 3, 141, 113, 3, 70, 44
        DC16 17, 47, 21, 9, 39, 13, 4, 142, 114, 11, 71, 45, 4, 48, 22, 16, 40
        DC16 14, 20, 1085, 861, 669, 485, 385, 3, 34, 62, 90, 0, 0, 0, 3, 135
        DC16 107, 3, 67, 41, 15, 54, 24, 15, 43, 15, 5, 136, 108, 13, 68, 42, 5
        DC16 55, 25, 10, 44, 16, 21, 1156, 932, 714, 512, 406, 4, 28, 50, 72
        DC16 94, 0, 0, 4, 144, 116, 17, 68, 42, 17, 50, 22, 19, 46, 16, 4, 145
        DC16 117, 0, 0, 0, 6, 51, 23, 6, 47, 17, 22, 1258, 1006, 782, 568, 442
        DC16 4, 26, 50, 74, 98, 0, 0, 2, 139, 111, 17, 74, 46, 7, 54, 24, 34
        DC16 37, 13, 7, 140, 112, 0, 0, 0, 16, 55, 25, 0, 0, 0, 23, 1364, 1094
        DC16 860, 614, 464, 4, 30, 54, 78, 102, 0, 0, 4, 151, 121, 4, 75, 47
        DC16 11, 54, 24, 16, 45, 15, 5, 152, 122, 14, 76, 48, 14, 55, 25, 14
        DC16 46, 16, 24, 1474, 1174, 914, 664, 514, 4, 28, 54, 80, 106, 0, 0, 6
        DC16 147, 117, 6, 73, 45, 11, 54, 24, 30, 46, 16, 4, 148, 118, 14, 74
        DC16 46, 16, 55, 25, 2, 47, 17, 25, 1588, 1276, 1000, 718, 538, 4, 32
        DC16 58, 84, 110, 0, 0, 8, 132, 106, 8, 75, 47, 7, 54, 24, 22, 45, 15
        DC16 4, 133, 107, 13, 76, 48, 22, 55, 25, 13, 46, 16, 26, 1706, 1370
        DC16 1062, 754, 596, 4, 30, 58, 86, 114, 0, 0, 10, 142, 114, 19, 74, 46
        DC16 28, 50, 22, 33, 46, 16, 2, 143, 115, 4, 75, 47, 6, 51, 23, 4, 47
        DC16 17, 27, 1828, 1468, 1128, 808, 628, 4, 34, 62, 90, 118, 0, 0, 8
        DC16 152, 122, 22, 73, 45, 8, 53, 23, 12, 45, 15, 4, 153, 123, 3, 74
        DC16 46, 26, 54, 24, 28, 46, 16, 28, 1921, 1531, 1193, 871, 661, 5, 26
        DC16 50, 74, 98, 122, 0, 3, 147, 117, 3, 73, 45, 4, 54, 24, 11, 45, 15
        DC16 10, 148, 118, 23, 74, 46, 31, 55, 25, 31, 46, 16, 29, 2051, 1631
        DC16 1267, 911, 701, 5, 30, 54, 78, 102, 126, 0, 7, 146, 116, 21, 73
        DC16 45, 1, 53, 23, 19, 45, 15, 7, 147, 117, 7, 74, 46, 37, 54, 24, 26
        DC16 46, 16, 30, 2185, 1735, 1373, 985, 745, 5, 26, 52, 78, 104, 130, 0
        DC16 5, 145, 115, 19, 75, 47, 15, 54, 24, 23, 45, 15, 10, 146, 116, 10
        DC16 76, 48, 25, 55, 25, 25, 46, 16, 31, 2323, 1843, 1455, 1033, 793, 5
        DC16 30, 56, 82, 108, 134, 0, 13, 145, 115, 2, 74, 46, 42, 54, 24, 23
        DC16 45, 15, 3, 146, 116, 29, 75, 47, 1, 55, 25, 28, 46, 16, 32, 2465
        DC16 1955, 1541, 1115, 845, 5, 34, 60, 86, 112, 138, 0, 17, 145, 115
        DC16 10, 74, 46, 10, 54, 24, 19, 45, 15, 0, 0, 0, 23, 75, 47, 35, 55
        DC16 25, 35, 46, 16, 33, 2611, 2071, 1631, 1171, 901, 5, 30, 58, 86
        DC16 114, 142, 0, 17, 145, 115, 14, 74, 46, 29, 54, 24, 11, 45, 15, 1
        DC16 146, 116, 21, 75, 47, 19, 55, 25, 46, 46, 16, 34, 2761, 2191, 1725
        DC16 1231, 961, 5, 34, 62, 90, 118, 146, 0, 13, 145, 115, 14, 74, 46
        DC16 44, 54, 24, 59, 46, 16, 6, 146, 116, 23, 75, 47, 7, 55, 25, 1, 47
        DC16 17, 35, 2876, 2306, 1812, 1286, 986, 6, 30, 54, 78, 102, 126, 150
        DC16 12, 151, 121, 12, 75, 47, 39, 54, 24, 22, 45, 15, 7, 152, 122, 26
        DC16 76, 48, 14, 55, 25, 41, 46, 16, 36, 3034, 2434, 1914, 1354, 1054
        DC16 6, 24, 50, 76, 102, 128, 154, 6, 151, 121, 6, 75, 47, 46, 54, 24
        DC16 2, 45, 15, 14, 152, 122, 34, 76, 48, 10, 55, 25, 64, 46, 16, 37
        DC16 3196, 2566, 1992, 1426, 1096, 6, 28, 54, 80, 106, 132, 158, 17
        DC16 152, 122, 29, 74, 46, 49, 54, 24, 24, 45, 15, 4, 153, 123, 14, 75
        DC16 47, 10, 55, 25, 46, 46, 16, 38, 3362, 2702, 2102, 1502, 1142, 6
        DC16 32, 58, 84, 110, 136, 162, 4, 152, 122, 13, 74, 46, 48, 54, 24, 42
        DC16 45, 15, 18, 153, 123, 32, 75, 47, 14, 55, 25, 32, 46, 16, 39, 3532
        DC16 2812, 2216, 1582, 1222, 6, 26, 54, 82, 110, 138, 166, 20, 147, 117
        DC16 40, 75, 47, 43, 54, 24, 10, 45, 15, 4, 148, 118, 7, 76, 48, 22, 55
        DC16 25, 67, 46, 16, 40, 3706, 2956, 2334, 1666, 1276, 6, 30, 58, 86
        DC16 114, 142, 170, 19, 148, 118, 18, 75, 47, 34, 54, 24, 20, 45, 15, 6
        DC16 149, 119, 31, 76, 48, 34, 55, 25, 61, 46, 16
        DC8 0, 0

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        SECTION __DLIB_PERTHREAD:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        SECTION __DLIB_PERTHREAD_init:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        END
// 
// 2 229 bytes in section .bss
//   292 bytes in section .data
// 1 232 bytes in section .rodata
// 9 336 bytes in section .text
// 
// 9 336 bytes of CODE  memory
// 1 232 bytes of CONST memory
// 2 521 bytes of DATA  memory
//
//Errors: none
//Warnings: none
