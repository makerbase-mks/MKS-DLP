###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  10:59:04
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Core\LCDL0Delta.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Core\LCDL0Delta.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\LCDL0Delta.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\LCDL0Delta.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Core\LCDL0Delta.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              µC/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : LCDL0Delta.c
     16          Purpose     : Link between GUI and LCD_L0... if delta display needs to
     17                        be supported
     18          ---------------------------END-OF-HEADER------------------------------
     19          */
     20          
     21          #include <stddef.h>             /* needed for definition of NULL */
     22          #include "GUI_Private.h"
     23          #include "GUIDebug.h"
     24          #include "LCD_Private.h"        /* private modul definitions & config */
     25          
     26          #if LCD_DELTA_MODE
     27          
     28          /*********************************************************************
     29          *
     30          *       Static data
     31          *
     32          **********************************************************************
     33          */
     34          static       U8             _aPixelData_0[LCD_XSIZE];
     35          static       U8             _aPixelData_1[LCD_XSIZE];
     36          static const GUI_LOGPALETTE _Pal;
     37          static       GUI_BITMAP     _Bm;
     38          static       int            _y;
     39          static       U8             _aRGB[3];
     40          
     41          /*********************************************************************
     42          *
     43          *       Static code
     44          *
     45          **********************************************************************
     46          */
     47          /*********************************************************************
     48          *
     49          *       _SetRGB
     50          */
     51          static void _SetRGB(LCD_PIXELINDEX ColorIndex) {
     52            _aRGB[0] = ColorIndex & 0x00f;
     53            _aRGB[1] = (ColorIndex & 0x0f0) >> 4;
     54            _aRGB[2] = (ColorIndex & 0xf00) >> 8;
     55          }
     56          
     57          /*********************************************************************
     58          *
     59          *       _SetPixel
     60          */
     61          static void _SetPixelIndex(int x, LCD_PIXELINDEX ColorIndex) {
     62            _SetRGB(ColorIndex);
     63            _aPixelData_0[x] = _aRGB[(x + (_y & 1)) % 3];
     64          }
     65          
     66          /*********************************************************************
     67          *
     68          *       _InitBM
     69          */
     70          static void _InitBM(int xsize, int x0) {
     71            _Bm.XSize        = xsize;
     72            _Bm.YSize        = 1;
     73            _Bm.BytesPerLine = xsize;
     74            _Bm.BitsPerPixel = 8;
     75            _Bm.pfDraw       = 0;
     76            _Bm.pData        = &_aPixelData_0[x0];
     77            _Bm.pPal         = &_Pal;
     78            _Bm.pfDraw       = 0;
     79          }
     80          
     81          /*********************************************************************
     82          *
     83          *       _DrawBitLine1BPP
     84          */
     85          static void _DrawBitLine1BPP(int x, U8 const GUI_UNI_PTR * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
     86            int xx;
     87            LCD_PIXELINDEX Index0 = *(pTrans+0);
     88            LCD_PIXELINDEX Index1 = *(pTrans+1);
     89            x += Diff;
     90            xx = x;
     91            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
     92            case 0:
     93              do {
     94                _SetPixelIndex(xx++, (*p & (0x80 >> Diff)) ? Index1 : Index0);
     95          			if (++Diff == 8) {
     96                  Diff = 0;
     97          				p++;
     98          			}
     99          		} while (--xsize);
    100              break;
    101            case LCD_DRAWMODE_TRANS:
    102              do {
    103            		if (*p & (0x80 >> Diff)) {
    104                  _SetPixelIndex(xx, Index1);
    105                } else {
    106                  _SetPixelIndex(xx, LCD_L0_GetPixelIndex(xx, _y));
    107                }
    108                xx++;
    109          			if (++Diff == 8) {
    110                  Diff = 0;
    111          				p++;
    112          			}
    113          		} while (--xsize);
    114              break;
    115            case LCD_DRAWMODE_XOR:;
    116              do {
    117            		if (*p & (0x80 >> Diff)) {
    118                  int Pixel = LCD_L0_GetPixelIndex(xx, _y);
    119                  _SetPixelIndex(xx, LCD_NUM_COLORS - 1 - Pixel);
    120                }
    121                xx++;
    122          			if (++Diff == 8) {
    123                  Diff = 0;
    124          				p++;
    125          			}
    126          		} while (--xsize);
    127              break;
    128          	}
    129            LCD_L0_DrawBitmap(x, _y, _Bm.XSize, 1, _Bm.BitsPerPixel, _Bm.BytesPerLine, _Bm.pData, 0, 0);
    130          }
    131          
    132          /*********************************************************************
    133          *
    134          *       _DrawBitLine2BPP
    135          */
    136          static void _DrawBitLine2BPP(int x, U8 const GUI_UNI_PTR * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
    137            int xx;
    138            LCD_PIXELINDEX Pixels = *p;
    139            int CurrentPixel = Diff;
    140            x += Diff;
    141            xx = x;
    142            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
    143            case 0:
    144              if (pTrans) {
    145                do {
    146                  int Shift = (3 - CurrentPixel) << 1;
    147                  int Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
    148                  LCD_PIXELINDEX PixelIndex = *(pTrans + Index);
    149                  _SetPixelIndex(xx++, PixelIndex);
    150                  if (++CurrentPixel == 4) {
    151                    CurrentPixel = 0;
    152                    Pixels = *(++p);
    153                  }
    154          		  } while (--xsize);
    155              } else {
    156                do {
    157                  int Shift = (3 - CurrentPixel) << 1;
    158                  int Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
    159                  _SetPixelIndex(xx++, Index);
    160                  if (++CurrentPixel == 4) {
    161                    CurrentPixel = 0;
    162                    Pixels = *(++p);
    163                  }
    164          		  } while (--xsize);
    165              }
    166              break;
    167            case LCD_DRAWMODE_TRANS:
    168              if (pTrans) {
    169                do {
    170                  int Shift = (3 - CurrentPixel) << 1;
    171                  int Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
    172                  if (Index) {
    173                    LCD_PIXELINDEX PixelIndex = *(pTrans + Index);
    174                    _SetPixelIndex(xx, PixelIndex);
    175                  } else {
    176                    _SetPixelIndex(xx, LCD_L0_GetPixelIndex(xx, _y));
    177                  }
    178                  xx++;
    179                  if (++CurrentPixel == 4) {
    180                    CurrentPixel = 0;
    181                    Pixels = *(++p);
    182                  }
    183          		  } while (--xsize);
    184              } else {
    185                do {
    186                  int Shift = (3 - CurrentPixel) << 1;
    187                  int Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
    188                  if (Index) {
    189                    _SetPixelIndex(xx, Index);
    190                  } else {
    191                    _SetPixelIndex(xx, LCD_L0_GetPixelIndex(xx, _y));
    192                  }
    193                  xx++;
    194                  if (++CurrentPixel == 4) {
    195                    CurrentPixel = 0;
    196                    Pixels = *(++p);
    197                  }
    198          		  } while (--xsize);
    199              }
    200              break;
    201            }
    202            LCD_L0_DrawBitmap(x, _y, _Bm.XSize, 1, _Bm.BitsPerPixel, _Bm.BytesPerLine, _Bm.pData, 0, 0);
    203          }
    204          
    205          /*********************************************************************
    206          *
    207          *       _DrawBitLine4BPP
    208          */
    209          static void _DrawBitLine4BPP(int x, U8 const GUI_UNI_PTR * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
    210            int xx;
    211            U8 Pixels = *p;
    212            int CurrentPixel = Diff;
    213            x += Diff;
    214            xx = x;
    215            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
    216            case 0:
    217              if (pTrans) {
    218                do {
    219                  int Shift = (1 - CurrentPixel) << 2;
    220                  int Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
    221                  LCD_PIXELINDEX PixelIndex = *(pTrans + Index);
    222                  _SetPixelIndex(xx++, PixelIndex);
    223                  if (++CurrentPixel == 2) {
    224                    CurrentPixel = 0;
    225                    Pixels = *(++p);
    226                  }
    227          		  } while (--xsize);
    228              } else {
    229                do {
    230                  int Shift = (1 - CurrentPixel) << 2;
    231                  int Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
    232                  _SetPixelIndex(xx++, Index);
    233                  if (++CurrentPixel == 2) {
    234                    CurrentPixel = 0;
    235                    Pixels = *(++p);
    236                  }
    237          		  } while (--xsize);
    238              }
    239              break;
    240            case LCD_DRAWMODE_TRANS:
    241              if (pTrans) {
    242                do {
    243                  int Shift = (1 - CurrentPixel) << 2;
    244                  int Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
    245                  if (Index) {
    246                    U8 PixelIndex = *(pTrans + Index);
    247                    _SetPixelIndex(xx, PixelIndex);
    248                  } else {
    249                    _SetPixelIndex(xx, LCD_L0_GetPixelIndex(xx, _y));
    250                  }
    251                  xx++;
    252                  if (++CurrentPixel == 2) {
    253                    CurrentPixel = 0;
    254                    Pixels = *(++p);
    255                  }
    256          		  } while (--xsize);
    257              } else {
    258                do {
    259                  int Shift = (1 - CurrentPixel) << 2;
    260                  int Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
    261                  if (Index) {
    262                    _SetPixelIndex(xx, Index);
    263                  } else {
    264                    _SetPixelIndex(xx, LCD_L0_GetPixelIndex(xx, _y));
    265                  }
    266                  xx++;
    267                  if (++CurrentPixel == 2) {
    268                    CurrentPixel = 0;
    269                    Pixels = *(++p);
    270                  }
    271          		  } while (--xsize);
    272              }
    273              break;
    274            }
    275            LCD_L0_DrawBitmap(x, _y, _Bm.XSize, 1, _Bm.BitsPerPixel, _Bm.BytesPerLine, _Bm.pData, 0, 0);
    276          }
    277          
    278          /*********************************************************************
    279          *
    280          *       _DrawBitLine8BPP
    281          */
    282          static void _DrawBitLine8BPP(int x, U8 const GUI_UNI_PTR * p, int xsize, const LCD_PIXELINDEX * pTrans) {
    283            int xx = x;
    284            LCD_PIXELINDEX Pixel;
    285            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
    286            case 0:
    287              if (pTrans) {
    288                for (; xsize > 0; xsize--, xx++, p++) {
    289                  Pixel = *p;
    290                  _SetPixelIndex(xx, *(pTrans + Pixel));
    291                }
    292              } else {
    293                for (; xsize > 0; xsize--, xx++, p++) {
    294                  _SetPixelIndex(xx, *p);
    295                }
    296              }
    297              break;
    298            case LCD_DRAWMODE_TRANS:
    299              if (pTrans) {
    300                for (; xsize > 0; xsize--, xx++, p++) {
    301                  Pixel = *p;
    302                  if (Pixel) {
    303                    _SetPixelIndex(xx, *(pTrans + Pixel));
    304                  } else {
    305                    _SetPixelIndex(xx, LCD_L0_GetPixelIndex(xx, _y));
    306                  }
    307                }
    308              } else {
    309                for (; xsize > 0; xsize--, xx++, p++) {
    310                  Pixel = *p;
    311                  if (Pixel) {
    312                    _SetPixelIndex(xx, Pixel);
    313                  } else {
    314                    _SetPixelIndex(xx, LCD_L0_GetPixelIndex(xx, _y));
    315                  }
    316                }
    317              }
    318              break;
    319            }
    320            LCD_L0_DrawBitmap(x, _y, _Bm.XSize, 1, _Bm.BitsPerPixel, _Bm.BytesPerLine, _Bm.pData, 0, 0);
    321          }
    322          
    323          /*********************************************************************
    324          *
    325          *       _DrawBitLine16BPP
    326          */
    327          static void _DrawBitLine16BPP(int x, U16 const GUI_UNI_PTR * p, int xsize, const LCD_PIXELINDEX * pTrans) {
    328            int xx = x;
    329            LCD_PIXELINDEX pixel;
    330            if ((GUI_Context.DrawMode & LCD_DRAWMODE_TRANS) == 0) {
    331              if (pTrans) {
    332                for (; xsize > 0; xsize--, xx++, p++) {
    333                  pixel = *p;
    334                  _SetPixelIndex(xx, *(pTrans + pixel));
    335                }
    336              } else {
    337                for (;xsize > 0; xsize--, xx++, p++) {
    338                  _SetPixelIndex(xx, *p);
    339                }
    340              }
    341            } else {
    342              if (pTrans) {
    343                for (; xsize > 0; xsize--, xx++, p++) {
    344                  pixel = *p;
    345                  if (pixel) {
    346                    _SetPixelIndex(xx, *(pTrans + pixel));
    347                  } else {
    348                    _SetPixelIndex(xx, LCD_L0_GetPixelIndex(xx, _y));
    349                  }
    350                }
    351              } else {
    352                for (; xsize > 0; xsize--, xx++, p++) {
    353                  pixel = *p;
    354                  if (pixel) {
    355                    _SetPixelIndex(xx, pixel);
    356                  } else {
    357                    _SetPixelIndex(xx, LCD_L0_GetPixelIndex(xx, _y));
    358                  }
    359                }
    360              }
    361            }
    362            LCD_L0_DrawBitmap(x, _y, _Bm.XSize, 1, _Bm.BitsPerPixel, _Bm.BytesPerLine, _Bm.pData, 0, 0);
    363          }
    364          
    365          /*********************************************************************
    366          *
    367          *       Public code
    368          *
    369          **********************************************************************
    370          */
    371          /*********************************************************************
    372          *
    373          *       LCD_L0_DELTA_DrawBitmap
    374          */
    375          void LCD_L0_DELTA_DrawBitmap(int x0, int y0,
    376                                       int xsize, int ysize,
    377                                       int BitsPerPixel, 
    378                                       int BytesPerLine,
    379                                       const U8 GUI_UNI_PTR * pData, int Diff,
    380                                       const LCD_PIXELINDEX* pTrans)
    381          {
    382            int i;
    383            _InitBM(xsize, x0 + Diff);
    384            for (i = 0; i < ysize; i++) {
    385              _y = i + y0;
    386              switch (BitsPerPixel) {
    387              case 1:
    388                _DrawBitLine1BPP(x0, pData, Diff, xsize, pTrans);
    389                break;
    390              #if (LCD_MAX_LOG_COLORS > 2)
    391                case 2:
    392                  _DrawBitLine2BPP(x0, pData, Diff, xsize, pTrans);
    393                  break;
    394              #endif
    395              #if (LCD_MAX_LOG_COLORS > 4)
    396                case 4:
    397                  _DrawBitLine4BPP(x0, pData, Diff, xsize, pTrans);
    398                  break;
    399              #endif
    400              #if (LCD_MAX_LOG_COLORS > 16)
    401                case 8:
    402                  _DrawBitLine8BPP(x0, pData, xsize, pTrans);
    403                  break;
    404              #endif
    405              #if (LCD_BITSPERPIXEL > 8)
    406                case 16:
    407                  _DrawBitLine16BPP(x0, (const U16 *)pData, xsize, pTrans);
    408                  break;
    409              #endif
    410              }
    411              pData += BytesPerLine;
    412            }
    413          }
    414          
    415          /*********************************************************************
    416          *
    417          *       LCD_L0_DELTA_DrawHLine
    418          */
    419          void LCD_L0_DELTA_DrawHLine(int x0, int y,  int x1) {
    420            if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
    421              for (; x0 <= x1; x0++) {
    422                LCD_L0_XorPixel(x0, y);
    423              }
    424            } else {
    425              LCD_L0_DELTA_FillRect(x0, y, x1, y);
    426            }
    427          }
    428          
    429          /*********************************************************************
    430          *
    431          *       LCD_L0_DELTA_DrawVLine
    432          */
    433          void LCD_L0_DELTA_DrawVLine(int x , int y0,  int y1) {
    434            if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
    435              for (; y0 <= y1; y0++) {
    436                LCD_L0_XorPixel(x, y0);
    437              }
    438            } else {
    439              int aIndex[2];
    440              _SetRGB(LCD_COLORINDEX);
    441              aIndex[0] = x % 3;
    442              aIndex[1] = (x + 1) % 3;
    443              for (; y0 <= y1; y0++) {
    444                LCD_L0_SetPixelIndex(x, y0, _aRGB[aIndex[y0 & 1]]);
    445              }
    446            }
    447          }
    448          
    449          /*********************************************************************
    450          *
    451          *       LCD_L0_DELTA_FillRect
    452          */
    453          void LCD_L0_DELTA_FillRect(int x0, int y0, int x1, int y1) {
    454            if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
    455              for (; y0 <= y1; y0++) {
    456                LCD_L0_DELTA_DrawHLine(x0, y0, x1);
    457              }
    458            } else {
    459              int x, y, aInit_0 = 0, aInit_1 = 0;
    460              _InitBM(x1 - x0 + 1, x0);/**/
    461              _SetRGB(LCD_COLORINDEX);
    462              for (y = y0; y <= y1; y++) {
    463                int Index = y & 1;
    464                if (Index) {
    465                  if (!aInit_1) {
    466                    for (x = x0; x <= x1; x++) {
    467                      _aPixelData_1[x] = _aRGB[(x + 1) % 3];
    468                    }
    469                    aInit_1 = 1;
    470                  }
    471                  LCD_L0_DrawBitmap(x0, y, _Bm.XSize, 1, _Bm.BitsPerPixel, _Bm.BytesPerLine, &_aPixelData_1[x0], 0, 0);
    472                } else {
    473                  if (!aInit_0) {
    474                    for (x = x0; x <= x1; x++) {
    475                      _aPixelData_0[x] = _aRGB[x % 3];
    476                    }
    477                    aInit_0 = 1;
    478                  }
    479                  LCD_L0_DrawBitmap(x0, y, _Bm.XSize, 1, _Bm.BitsPerPixel, _Bm.BytesPerLine, _Bm.pData, 0, 0);
    480               }
    481              }
    482            }
    483          }
    484          
    485          /*********************************************************************
    486          *
    487          *       LCD_L0_DELTA_GetPixelIndex
    488          */
    489          unsigned int LCD_L0_DELTA_GetPixelIndex(int x, int y) {
    490            return LCD_L0_GetPixelIndex(x, y);
    491          }
    492          
    493          /*********************************************************************
    494          *
    495          *       LCD_L0_DELTA_SetPixelIndex
    496          */
    497          void LCD_L0_DELTA_SetPixelIndex(int x, int y, int ColorIndex) {
    498            LCD_L0_SetPixelIndex(x, y, ColorIndex);
    499          }
    500          
    501          /*********************************************************************
    502          *
    503          *       LCD_L0_DELTA_XorPixel
    504          */
    505          void LCD_L0_DELTA_XorPixel(int x, int y) {
    506            LCD_L0_XorPixel(x, y);
    507          }
    508          
    509          #else
    510          
    511          void LCDL0Delta_c(void);

   \                                 In section .text, align 2, keep-with-next
    512          void LCDL0Delta_c(void) { } /* avoid empty object files */
   \                     LCDL0Delta_c: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    513          
    514          #endif
    515          
    516          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   LCDL0Delta_c


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       2  LCDL0Delta_c

 
 2 bytes in section .text
 
 2 bytes of CODE memory

Errors: none
Warnings: none
