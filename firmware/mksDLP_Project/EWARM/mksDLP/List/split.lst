###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        16/Jul/2019  17:00:20
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\User\ui\QRENCODE\split.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\User\ui\QRENCODE\split.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\split.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\split.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\User\ui\QRENCODE\split.c
      1          /*
      2           * qrencode - QR Code encoder
      3           *
      4           * Input data splitter.
      5           * Copyright (C) 2006-2011 Kentaro Fukuchi <kentaro@fukuchi.org>
      6           *
      7           * The following data / specifications are taken from
      8           * "Two dimensional symbol -- QR-code -- Basic Specification" (JIS X0510:2004)
      9           *  or
     10           * "Automatic identification and data capture techniques --
     11           *  QR Code 2005 bar code symbology specification" (ISO/IEC 18004:2006)
     12           *
     13           * This library is free software; you can redistribute it and/or
     14           * modify it under the terms of the GNU Lesser General Public
     15           * License as published by the Free Software Foundation; either
     16           * version 2.1 of the License, or any later version.
     17           *
     18           * This library is distributed in the hope that it will be useful,
     19           * but WITHOUT ANY WARRANTY; without even the implied warranty of
     20           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
     21           * Lesser General Public License for more details.
     22           *
     23           * You should have received a copy of the GNU Lesser General Public
     24           * License along with this library; if not, write to the Free Software
     25           * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
     26           */
     27          
     28          #if HAVE_CONFIG_H
     29          # include "config.h"
     30          #endif
     31          #include <stdlib.h>
     32          #include <string.h>
     33          #include <errno.h>
     34          #include "qrencode.h"
     35          #include "qrinput.h"
     36          #include "qrspec.h"
     37          #include "split.h"
     38          
     39          #define isdigit(__c__) ((unsigned char)((signed char)(__c__) - '0') < 10)//判断是不是数字
     40          #define isalnum(__c__) (QRinput_lookAnTable(__c__) >= 0)	//判断__c__的最高位是不是1，是返回-1，否则查表QRinput_anTable[128]
     41          
     42          #if !HAVE_STRDUP
     43          #undef strdup

   \                                 In section .text, align 2, keep-with-next
     44          char *strdup(const char *s)
     45          {
   \                     strdup: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
     46          	size_t len = strlen(s) + 1;//计算字符串的长度
   \   00000004   0x.... 0x....      BL       strlen
   \   00000008   0x1C45             ADDS     R5,R0,#+1
     47          	void *new = malloc(len);//分配一个新的空间给new
   \   0000000A   0x4628             MOV      R0,R5
   \   0000000C   0x.... 0x....      BL       malloc
     48          	if(new == NULL) return NULL;
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD101             BNE.N    ??strdup_0
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xBD32             POP      {R1,R4,R5,PC}
     49          	return (char *)memcpy(new, s, len);//拷贝s数据到new中
   \                     ??strdup_0: (+1)
   \   00000018   0x462A             MOV      R2,R5
   \   0000001A   0x4621             MOV      R1,R4
   \   0000001C   0xE8BD 0x4038      POP      {R3-R5,LR}
   \   00000020   0x.... 0x....      B.W      memcpy
     50          }
     51          #endif
     52          

   \                                 In section .text, align 2, keep-with-next
     53          static QRencodeMode Split_identifyMode(const char *string, QRencodeMode hint)
     54          {
     55          	unsigned char c, d;
     56          	unsigned int word;
     57          
     58          	c = string[0];
   \                     Split_identifyMode: (+1)
   \   00000000   0xF990 0x2000      LDRSB    R2,[R0, #+0]
   \   00000004   0xB2D2             UXTB     R2,R2
     59          
     60          	if(c == '\0') return QR_MODE_NUL;//如果第一个字符为空，返回错误
   \   00000006   0x2A00             CMP      R2,#+0
   \   00000008   0xD102             BNE.N    ??Split_identifyMode_0
   \   0000000A   0xF04F 0x30FF      MOV      R0,#-1
   \   0000000E   0x4770             BX       LR
     61          	if(isdigit(c)) {
   \                     ??Split_identifyMode_0: (+1)
   \   00000010   0x4613             MOV      R3,R2
   \   00000012   0x3B30             SUBS     R3,R3,#+48
   \   00000014   0xB2DB             UXTB     R3,R3
   \   00000016   0x2B0A             CMP      R3,#+10
   \   00000018   0xDA01             BGE.N    ??Split_identifyMode_1
     62          		return QR_MODE_NUM;//数字模式
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x4770             BX       LR
     63          	} else if(isalnum(c)) {
   \                     ??Split_identifyMode_1: (+1)
   \   0000001E   0x4613             MOV      R3,R2
   \   00000020   0x061B             LSLS     R3,R3,#+24
   \   00000022   0xD502             BPL.N    ??Split_identifyMode_2
   \   00000024   0xF04F 0x33FF      MOV      R3,#-1
   \   00000028   0xE001             B.N      ??Split_identifyMode_3
   \                     ??Split_identifyMode_2: (+1)
   \   0000002A   0x....             LDR.N    R3,??DataTable2
   \   0000002C   0x56D3             LDRSB    R3,[R2, R3]
   \                     ??Split_identifyMode_3: (+1)
   \   0000002E   0x2B00             CMP      R3,#+0
   \   00000030   0xD401             BMI.N    ??Split_identifyMode_4
     64          		return QR_MODE_AN;//字母数字模式
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x4770             BX       LR
     65          	} else if(hint == QR_MODE_KANJI) {
   \                     ??Split_identifyMode_4: (+1)
   \   00000036   0x2903             CMP      R1,#+3
   \   00000038   0xD113             BNE.N    ??Split_identifyMode_5
     66          		d = string[1];
   \   0000003A   0xF990 0x0001      LDRSB    R0,[R0, #+1]
   \   0000003E   0xB2C0             UXTB     R0,R0
     67          		if(d != '\0') {
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD00E             BEQ.N    ??Split_identifyMode_5
     68          			word = ((unsigned int)c << 8) | d;//合并2个字节的数据成一个字
   \   00000044   0xEA40 0x2002      ORR      R0,R0,R2, LSL #+8
     69          			if((word >= 0x8140 && word <= 0x9ffc) || (word >= 0xe040 && word <= 0xebbf)) {
   \   00000048   0x....             LDR.N    R1,??DataTable2_1  ;; 0xffff7ec0
   \   0000004A   0x1809             ADDS     R1,R1,R0
   \   0000004C   0xF641 0x62BD      MOVW     R2,#+7869
   \   00000050   0x4291             CMP      R1,R2
   \   00000052   0xD304             BCC.N    ??Split_identifyMode_6
   \   00000054   0x....             LDR.N    R1,??DataTable2_2  ;; 0xffff1fc0
   \   00000056   0x1808             ADDS     R0,R1,R0
   \   00000058   0xF5B0 0x6F38      CMP      R0,#+2944
   \   0000005C   0xD201             BCS.N    ??Split_identifyMode_5
     70          				return QR_MODE_KANJI;
   \                     ??Split_identifyMode_6: (+1)
   \   0000005E   0x2003             MOVS     R0,#+3
   \   00000060   0x4770             BX       LR
     71          			}
     72          		}
     73          	}
     74          
     75          	return QR_MODE_8;//如果都不是8bit模式
   \                     ??Split_identifyMode_5: (+1)
   \   00000062   0x2002             MOVS     R0,#+2
   \   00000064   0x4770             BX       LR               ;; return
     76          }
     77          
     78          static int Split_eatNum(const char *string, QRinput *input, QRencodeMode hint);
     79          static int Split_eatAn(const char *string, QRinput *input, QRencodeMode hint);
     80          static int Split_eat8(const char *string, QRinput *input, QRencodeMode hint);
     81          static int Split_eatKanji(const char *string, QRinput *input, QRencodeMode hint);
     82          

   \                                 In section .text, align 2, keep-with-next
     83          static int Split_eatNum(const char *string, QRinput *input,QRencodeMode hint)
     84          {
   \                     Split_eatNum: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
     85          	const char *p;
     86          	int ret;
     87          	int run;
     88          	int dif;
     89          	int ln;
     90          	QRencodeMode mode;
     91          
     92          	ln = QRspec_lengthIndicator(QR_MODE_NUM, input->version);
   \   0000000A   0x6829             LDR      R1,[R5, #+0]
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x.... 0x....      BL       QRspec_lengthIndicator
   \   00000012   0x4607             MOV      R7,R0
     93          
     94          	p = string;
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0xE000             B.N      ??Split_eatNum_0
     95          	while(isdigit(*p)) {
     96          		p++;
   \                     ??Split_eatNum_1: (+1)
   \   00000018   0x1C40             ADDS     R0,R0,#+1
     97          	}
   \                     ??Split_eatNum_0: (+1)
   \   0000001A   0xF990 0x1000      LDRSB    R1,[R0, #+0]
   \   0000001E   0x3930             SUBS     R1,R1,#+48
   \   00000020   0xB2C9             UXTB     R1,R1
   \   00000022   0x290A             CMP      R1,#+10
   \   00000024   0xDBF8             BLT.N    ??Split_eatNum_1
     98          	run = p - string;
   \   00000026   0xEBA0 0x0804      SUB      R8,R0,R4
     99          	mode = Split_identifyMode(p, hint);
   \   0000002A   0x4631             MOV      R1,R6
   \   0000002C   0x.... 0x....      BL       Split_identifyMode
   \   00000030   0x4681             MOV      R9,R0
    100          	if(mode == QR_MODE_8) {
   \   00000032   0xF1B9 0x0F02      CMP      R9,#+2
   \   00000036   0xD119             BNE.N    ??Split_eatNum_2
    101          		dif = QRinput_estimateBitsModeNum(run) + 4 + ln
    102          			+ QRinput_estimateBitsMode8(1) /* + 4 + l8 */
    103          			- QRinput_estimateBitsMode8(run + 1) /* - 4 - l8 */;
   \   00000038   0x4640             MOV      R0,R8
   \   0000003A   0x.... 0x....      BL       QRinput_estimateBitsModeNum
   \   0000003E   0x4682             MOV      R10,R0
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x.... 0x....      BL       QRinput_estimateBitsMode8
   \   00000046   0xEB07 0x010A      ADD      R1,R7,R10
   \   0000004A   0x1840             ADDS     R0,R0,R1
   \   0000004C   0xF100 0x0A04      ADD      R10,R0,#+4
   \   00000050   0xF108 0x0001      ADD      R0,R8,#+1
   \   00000054   0x.... 0x....      BL       QRinput_estimateBitsMode8
   \   00000058   0xEBAA 0x0000      SUB      R0,R10,R0
    104          		if(dif > 0) {
   \   0000005C   0x2801             CMP      R0,#+1
   \   0000005E   0xDB05             BLT.N    ??Split_eatNum_2
    105          			return Split_eat8(string, input, hint);
   \   00000060   0x4632             MOV      R2,R6
   \   00000062   0x4629             MOV      R1,R5
   \   00000064   0x4620             MOV      R0,R4
   \   00000066   0xE8BD 0x47F0      POP      {R4-R10,LR}
   \   0000006A   0x....             B.N      Split_eat8
    106          		}
    107          	}
    108          	if(mode == QR_MODE_AN) {
   \                     ??Split_eatNum_2: (+1)
   \   0000006C   0xF1B9 0x0F01      CMP      R9,#+1
   \   00000070   0xD117             BNE.N    ??Split_eatNum_3
    109          		dif = QRinput_estimateBitsModeNum(run) + 4 + ln
    110          			+ QRinput_estimateBitsModeAn(1) /* + 4 + la */
    111          			- QRinput_estimateBitsModeAn(run + 1) /* - 4 - la */;
   \   00000072   0x4640             MOV      R0,R8
   \   00000074   0x.... 0x....      BL       QRinput_estimateBitsModeNum
   \   00000078   0x4681             MOV      R9,R0
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0x.... 0x....      BL       QRinput_estimateBitsModeAn
   \   00000080   0xEB07 0x0109      ADD      R1,R7,R9
   \   00000084   0x1840             ADDS     R0,R0,R1
   \   00000086   0x1D07             ADDS     R7,R0,#+4
   \   00000088   0xF108 0x0001      ADD      R0,R8,#+1
   \   0000008C   0x.... 0x....      BL       QRinput_estimateBitsModeAn
   \   00000090   0x1A38             SUBS     R0,R7,R0
    112          		if(dif > 0) {
   \   00000092   0x2801             CMP      R0,#+1
   \   00000094   0xDB05             BLT.N    ??Split_eatNum_3
    113          			return Split_eatAn(string, input, hint);
   \   00000096   0x4632             MOV      R2,R6
   \   00000098   0x4629             MOV      R1,R5
   \   0000009A   0x4620             MOV      R0,R4
   \   0000009C   0xE8BD 0x47F0      POP      {R4-R10,LR}
   \   000000A0   0x....             B.N      Split_eatAn
    114          		}
    115          	}
    116          
    117          	ret = QRinput_append(input, QR_MODE_NUM, run, (unsigned char *)string);
    118          	if(ret < 0) return -1;
   \                     ??Split_eatNum_3: (+1)
   \   000000A2   0x4623             MOV      R3,R4
   \   000000A4   0x4642             MOV      R2,R8
   \   000000A6   0x2100             MOVS     R1,#+0
   \   000000A8   0x4628             MOV      R0,R5
   \   000000AA   0x.... 0x....      BL       QRinput_append
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD502             BPL.N    ??Split_eatNum_4
   \   000000B2   0xF04F 0x30FF      MOV      R0,#-1
   \   000000B6   0xE000             B.N      ??Split_eatNum_5
    119          
    120          	return run;
   \                     ??Split_eatNum_4: (+1)
   \   000000B8   0x4640             MOV      R0,R8
   \                     ??Split_eatNum_5: (+1)
   \   000000BA   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    121          }
    122          

   \                                 In section .text, align 2, keep-with-next
    123          static int Split_eatAn(const char *string, QRinput *input, QRencodeMode hint)
    124          {
   \                     Split_eatAn: (+1)
   \   00000000   0xE92D 0x4FF4      PUSH     {R2,R4-R11,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
    125          	const char *p, *q;
    126          	int ret;
    127          	int run;
    128          	int dif;
    129          	int la, ln;
    130          
    131          	la = QRspec_lengthIndicator(QR_MODE_AN, input->version);
   \   0000000A   0x6829             LDR      R1,[R5, #+0]
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x.... 0x....      BL       QRspec_lengthIndicator
   \   00000012   0x9000             STR      R0,[SP, #+0]
    132          	ln = QRspec_lengthIndicator(QR_MODE_NUM, input->version);
   \   00000014   0x6829             LDR      R1,[R5, #+0]
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x.... 0x....      BL       QRspec_lengthIndicator
   \   0000001C   0x4606             MOV      R6,R0
    133          
    134          	p = string;
   \   0000001E   0x46A3             MOV      R11,R4
   \   00000020   0x46A0             MOV      R8,R4
   \   00000022   0xE00D             B.N      ??Split_eatAn_0
    135          	while(isalnum(*p)) {
    136          		if(isdigit(*p)) {
    137          			q = p;
    138          			while(isdigit(*q)) {
    139          				q++;
    140          			}
    141          			dif = QRinput_estimateBitsModeAn(p - string) /* + 4 + la */
    142          				+ QRinput_estimateBitsModeNum(q - p) + 4 + ln
    143          				+ (isalnum(*q)?(4 + ln):0)
    144          				- QRinput_estimateBitsModeAn(q - string) /* - 4 - la */;
   \                     ??Split_eatAn_1: (+1)
   \   00000024   0x2100             MOVS     R1,#+0
   \                     ??Split_eatAn_2: (+1)
   \   00000026   0x4448             ADD      R0,R0,R9
   \   00000028   0x1830             ADDS     R0,R6,R0
   \   0000002A   0x1808             ADDS     R0,R1,R0
   \   0000002C   0xF100 0x0904      ADD      R9,R0,#+4
   \   00000030   0xEBAA 0x0008      SUB      R0,R10,R8
   \   00000034   0x.... 0x....      BL       QRinput_estimateBitsModeAn
   \   00000038   0xEBB9 0x0000      SUBS     R0,R9,R0
    145          			if(dif < 0) {
   \   0000003C   0xD432             BMI.N    ??Split_eatAn_3
    146          				break;
    147          			} else {
    148          				p = q;
   \   0000003E   0x46BB             MOV      R11,R7
    149          			}
   \                     ??Split_eatAn_0: (+1)
   \   00000040   0xF99B 0x0000      LDRSB    R0,[R11, #+0]
   \   00000044   0x0601             LSLS     R1,R0,#+24
   \   00000046   0xD502             BPL.N    ??Split_eatAn_4
   \   00000048   0xF04F 0x31FF      MOV      R1,#-1
   \   0000004C   0xE001             B.N      ??Split_eatAn_5
   \                     ??Split_eatAn_4: (+1)
   \   0000004E   0x....             LDR.N    R1,??DataTable2
   \   00000050   0x5641             LDRSB    R1,[R0, R1]
   \                     ??Split_eatAn_5: (+1)
   \   00000052   0x2900             CMP      R1,#+0
   \   00000054   0xD426             BMI.N    ??Split_eatAn_3
   \   00000056   0x3830             SUBS     R0,R0,#+48
   \   00000058   0xB2C0             UXTB     R0,R0
   \   0000005A   0x280A             CMP      R0,#+10
   \   0000005C   0xDA1F             BGE.N    ??Split_eatAn_6
   \   0000005E   0x465F             MOV      R7,R11
   \   00000060   0xE000             B.N      ??Split_eatAn_7
   \                     ??Split_eatAn_8: (+1)
   \   00000062   0x1C7F             ADDS     R7,R7,#+1
   \                     ??Split_eatAn_7: (+1)
   \   00000064   0xF997 0x0000      LDRSB    R0,[R7, #+0]
   \   00000068   0x3830             SUBS     R0,R0,#+48
   \   0000006A   0xB2C0             UXTB     R0,R0
   \   0000006C   0x280A             CMP      R0,#+10
   \   0000006E   0xDBF8             BLT.N    ??Split_eatAn_8
   \   00000070   0xEBAB 0x0008      SUB      R0,R11,R8
   \   00000074   0x.... 0x....      BL       QRinput_estimateBitsModeAn
   \   00000078   0x4681             MOV      R9,R0
   \   0000007A   0x46BA             MOV      R10,R7
   \   0000007C   0xEBAA 0x000B      SUB      R0,R10,R11
   \   00000080   0x.... 0x....      BL       QRinput_estimateBitsModeNum
   \   00000084   0xF997 0x1000      LDRSB    R1,[R7, #+0]
   \   00000088   0x060A             LSLS     R2,R1,#+24
   \   0000008A   0xD502             BPL.N    ??Split_eatAn_9
   \   0000008C   0xF04F 0x31FF      MOV      R1,#-1
   \   00000090   0xE001             B.N      ??Split_eatAn_10
   \                     ??Split_eatAn_9: (+1)
   \   00000092   0x....             LDR.N    R2,??DataTable2
   \   00000094   0x5689             LDRSB    R1,[R1, R2]
   \                     ??Split_eatAn_10: (+1)
   \   00000096   0x2900             CMP      R1,#+0
   \   00000098   0xD4C4             BMI.N    ??Split_eatAn_1
   \   0000009A   0x1D31             ADDS     R1,R6,#+4
   \   0000009C   0xE7C3             B.N      ??Split_eatAn_2
    150          		} else {
    151          			p++;
   \                     ??Split_eatAn_6: (+1)
   \   0000009E   0xF10B 0x0B01      ADD      R11,R11,#+1
   \   000000A2   0xE7CD             B.N      ??Split_eatAn_0
    152          		}
    153          	}
    154          
    155          	run = p - string;
   \                     ??Split_eatAn_3: (+1)
   \   000000A4   0xEBAB 0x0604      SUB      R6,R11,R4
    156          
    157          	if(*p && !isalnum(*p)) {
   \   000000A8   0xF99B 0x0000      LDRSB    R0,[R11, #+0]
   \   000000AC   0x2800             CMP      R0,#+0
   \   000000AE   0xD021             BEQ.N    ??Split_eatAn_11
   \   000000B0   0x0601             LSLS     R1,R0,#+24
   \   000000B2   0xD502             BPL.N    ??Split_eatAn_12
   \   000000B4   0xF04F 0x30FF      MOV      R0,#-1
   \   000000B8   0xE001             B.N      ??Split_eatAn_13
   \                     ??Split_eatAn_12: (+1)
   \   000000BA   0x....             LDR.N    R1,??DataTable2
   \   000000BC   0x5640             LDRSB    R0,[R0, R1]
   \                     ??Split_eatAn_13: (+1)
   \   000000BE   0x2800             CMP      R0,#+0
   \   000000C0   0xD518             BPL.N    ??Split_eatAn_11
    158          		dif = QRinput_estimateBitsModeAn(run) + 4 + la
    159          			+ QRinput_estimateBitsMode8(1) /* + 4 + l8 */
    160          			- QRinput_estimateBitsMode8(run + 1) /* - 4 - l8 */;
   \   000000C2   0x4630             MOV      R0,R6
   \   000000C4   0x.... 0x....      BL       QRinput_estimateBitsModeAn
   \   000000C8   0x4607             MOV      R7,R0
   \   000000CA   0x2001             MOVS     R0,#+1
   \   000000CC   0x.... 0x....      BL       QRinput_estimateBitsMode8
   \   000000D0   0x9900             LDR      R1,[SP, #+0]
   \   000000D2   0x19C9             ADDS     R1,R1,R7
   \   000000D4   0x1840             ADDS     R0,R0,R1
   \   000000D6   0x1D07             ADDS     R7,R0,#+4
   \   000000D8   0x1C70             ADDS     R0,R6,#+1
   \   000000DA   0x.... 0x....      BL       QRinput_estimateBitsMode8
   \   000000DE   0x1A38             SUBS     R0,R7,R0
    161          		if(dif > 0) {
   \   000000E0   0x2801             CMP      R0,#+1
   \   000000E2   0xDB07             BLT.N    ??Split_eatAn_11
    162          			return Split_eat8(string, input, hint);
   \   000000E4   0xF99D 0x2008      LDRSB    R2,[SP, #+8]
   \   000000E8   0x4629             MOV      R1,R5
   \   000000EA   0x4620             MOV      R0,R4
   \   000000EC   0xB003             ADD      SP,SP,#+12
   \   000000EE   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \   000000F2   0x....             B.N      Split_eat8
    163          		}
    164          	}
    165          
    166          	ret = QRinput_append(input, QR_MODE_AN, run, (unsigned char *)string);
    167          	if(ret < 0) return -1;
   \                     ??Split_eatAn_11: (+1)
   \   000000F4   0x4623             MOV      R3,R4
   \   000000F6   0x4632             MOV      R2,R6
   \   000000F8   0x2101             MOVS     R1,#+1
   \   000000FA   0x4628             MOV      R0,R5
   \   000000FC   0x.... 0x....      BL       QRinput_append
   \   00000100   0x2800             CMP      R0,#+0
   \   00000102   0xD502             BPL.N    ??Split_eatAn_14
   \   00000104   0xF04F 0x30FF      MOV      R0,#-1
   \   00000108   0xE000             B.N      ??Split_eatAn_15
    168          
    169          	return run;
   \                     ??Split_eatAn_14: (+1)
   \   0000010A   0x4630             MOV      R0,R6
   \                     ??Split_eatAn_15: (+1)
   \   0000010C   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    170          }
    171          

   \                                 In section .text, align 2, keep-with-next
    172          static int Split_eatKanji(const char *string, QRinput *input, QRencodeMode hint)
    173          {
   \                     Split_eatKanji: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    174          	const char *p;
    175          	int ret;
    176          	int run;
    177          
    178          	p = string;
   \   00000008   0x4627             MOV      R7,R4
   \   0000000A   0xE000             B.N      ??Split_eatKanji_0
    179          	while(Split_identifyMode(p, hint) == QR_MODE_KANJI) {
    180          		p += 2;
   \                     ??Split_eatKanji_1: (+1)
   \   0000000C   0x1CBF             ADDS     R7,R7,#+2
    181          	}
   \                     ??Split_eatKanji_0: (+1)
   \   0000000E   0x4631             MOV      R1,R6
   \   00000010   0x4638             MOV      R0,R7
   \   00000012   0x.... 0x....      BL       Split_identifyMode
   \   00000016   0x2803             CMP      R0,#+3
   \   00000018   0xD0F8             BEQ.N    ??Split_eatKanji_1
    182          	run = p - string;
   \   0000001A   0x1B3E             SUBS     R6,R7,R4
    183          	ret = QRinput_append(input, QR_MODE_KANJI, run, (unsigned char *)string);
    184          	if(ret < 0) return -1;
   \   0000001C   0x4623             MOV      R3,R4
   \   0000001E   0x4632             MOV      R2,R6
   \   00000020   0x2103             MOVS     R1,#+3
   \   00000022   0x4628             MOV      R0,R5
   \   00000024   0x.... 0x....      BL       QRinput_append
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD502             BPL.N    ??Split_eatKanji_2
   \   0000002C   0xF04F 0x30FF      MOV      R0,#-1
   \   00000030   0xBDF2             POP      {R1,R4-R7,PC}
    185          
    186          	return run;
   \                     ??Split_eatKanji_2: (+1)
   \   00000032   0x4630             MOV      R0,R6
   \   00000034   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    187          }
    188          

   \                                 In section .text, align 2, keep-with-next
    189          static int Split_eat8(const char *string, QRinput *input, QRencodeMode hint)
    190          {
   \                     Split_eat8: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x468A             MOV      R10,R1
   \   0000000A   0x4616             MOV      R6,R2
    191          	const char *p, *q;
    192          	QRencodeMode mode;
    193          	int ret;
    194          	int run;
    195          	int dif;
    196          	int la, ln, l8;
    197          	int swcost;
    198          
    199          	la = QRspec_lengthIndicator(QR_MODE_AN, input->version);
   \   0000000C   0xF8DA 0x1000      LDR      R1,[R10, #+0]
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x.... 0x....      BL       QRspec_lengthIndicator
   \   00000016   0x9001             STR      R0,[SP, #+4]
    200          	ln = QRspec_lengthIndicator(QR_MODE_NUM, input->version);
   \   00000018   0xF8DA 0x1000      LDR      R1,[R10, #+0]
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x.... 0x....      BL       QRspec_lengthIndicator
   \   00000022   0x9000             STR      R0,[SP, #+0]
    201          	l8 = QRspec_lengthIndicator(QR_MODE_8, input->version);
   \   00000024   0xF8DA 0x1000      LDR      R1,[R10, #+0]
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0x.... 0x....      BL       QRspec_lengthIndicator
   \   0000002E   0x4683             MOV      R11,R0
    202          
    203          	p = string + 1;
   \   00000030   0x1C65             ADDS     R5,R4,#+1
   \   00000032   0xE014             B.N      ??Split_eat8_0
    204          	while(*p != '\0') {
    205          		mode = Split_identifyMode(p, hint);
    206          		if(mode == QR_MODE_KANJI) {
    207          			break;
    208          		}
    209          		if(mode == QR_MODE_NUM) {
    210          			q = p;
    211          			while(isdigit(*q)) {
    212          				q++;
    213          			}
    214          			if(Split_identifyMode(q, hint) == QR_MODE_8) {
    215          				swcost = 4 + l8;
    216          			} else {
    217          				swcost = 0;
    218          			}
    219          			dif = QRinput_estimateBitsMode8(p - string) /* + 4 + l8 */
    220          				+ QRinput_estimateBitsModeNum(q - p) + 4 + ln
    221          				+ swcost
    222          				- QRinput_estimateBitsMode8(q - string) /* - 4 - l8 */;
    223          			if(dif < 0) {
    224          				break;
    225          			} else {
    226          				p = q;
    227          			}
    228          		} else if(mode == QR_MODE_AN) {
    229          			q = p;
    230          			while(isalnum(*q)) {
    231          				q++;
    232          			}
    233          			if(Split_identifyMode(q, hint) == QR_MODE_8) {
    234          				swcost = 4 + l8;
    235          			} else {
    236          				swcost = 0;
   \                     ??Split_eat8_1: (+1)
   \   00000034   0x2700             MOVS     R7,#+0
    237          			}
    238          			dif = QRinput_estimateBitsMode8(p - string) /* + 4 + l8 */
    239          				+ QRinput_estimateBitsModeAn(q - p) + 4 + la
    240          				+ swcost
    241          				- QRinput_estimateBitsMode8(q - string) /* - 4 - l8 */;
   \                     ??Split_eat8_2: (+1)
   \   00000036   0x1B28             SUBS     R0,R5,R4
   \   00000038   0x.... 0x....      BL       QRinput_estimateBitsMode8
   \   0000003C   0x4680             MOV      R8,R0
   \   0000003E   0xEBA9 0x0005      SUB      R0,R9,R5
   \   00000042   0x.... 0x....      BL       QRinput_estimateBitsModeAn
   \   00000046   0x4440             ADD      R0,R0,R8
   \   00000048   0x9901             LDR      R1,[SP, #+4]
   \   0000004A   0x1808             ADDS     R0,R1,R0
   \   0000004C   0x1838             ADDS     R0,R7,R0
   \   0000004E   0x1D07             ADDS     R7,R0,#+4
   \   00000050   0xEBA9 0x0004      SUB      R0,R9,R4
   \   00000054   0x.... 0x....      BL       QRinput_estimateBitsMode8
   \   00000058   0x1A38             SUBS     R0,R7,R0
    242          			if(dif < 0) {
   \   0000005A   0xD433             BMI.N    ??Split_eat8_3
    243          				break;
    244          			} else {
    245          				p = q;
   \                     ??Split_eat8_4: (+1)
   \   0000005C   0x464D             MOV      R5,R9
    246          			}
   \                     ??Split_eat8_0: (+1)
   \   0000005E   0xF995 0x0000      LDRSB    R0,[R5, #+0]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD02E             BEQ.N    ??Split_eat8_3
   \   00000066   0x4631             MOV      R1,R6
   \   00000068   0x4628             MOV      R0,R5
   \   0000006A   0x.... 0x....      BL       Split_identifyMode
   \   0000006E   0x2803             CMP      R0,#+3
   \   00000070   0xD028             BEQ.N    ??Split_eat8_3
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD132             BNE.N    ??Split_eat8_5
   \   00000076   0x46A9             MOV      R9,R5
   \   00000078   0xE001             B.N      ??Split_eat8_6
   \                     ??Split_eat8_7: (+1)
   \   0000007A   0xF109 0x0901      ADD      R9,R9,#+1
   \                     ??Split_eat8_6: (+1)
   \   0000007E   0xF999 0x0000      LDRSB    R0,[R9, #+0]
   \   00000082   0x3830             SUBS     R0,R0,#+48
   \   00000084   0xB2C0             UXTB     R0,R0
   \   00000086   0x280A             CMP      R0,#+10
   \   00000088   0xDBF7             BLT.N    ??Split_eat8_7
   \   0000008A   0x4631             MOV      R1,R6
   \   0000008C   0x4648             MOV      R0,R9
   \   0000008E   0x.... 0x....      BL       Split_identifyMode
   \   00000092   0x2802             CMP      R0,#+2
   \   00000094   0xD102             BNE.N    ??Split_eat8_8
   \   00000096   0xF10B 0x0704      ADD      R7,R11,#+4
   \   0000009A   0xE000             B.N      ??Split_eat8_9
   \                     ??Split_eat8_8: (+1)
   \   0000009C   0x2700             MOVS     R7,#+0
   \                     ??Split_eat8_9: (+1)
   \   0000009E   0x1B28             SUBS     R0,R5,R4
   \   000000A0   0x.... 0x....      BL       QRinput_estimateBitsMode8
   \   000000A4   0x4680             MOV      R8,R0
   \   000000A6   0xEBA9 0x0005      SUB      R0,R9,R5
   \   000000AA   0x.... 0x....      BL       QRinput_estimateBitsModeNum
   \   000000AE   0x4440             ADD      R0,R0,R8
   \   000000B0   0x9900             LDR      R1,[SP, #+0]
   \   000000B2   0x1808             ADDS     R0,R1,R0
   \   000000B4   0x1838             ADDS     R0,R7,R0
   \   000000B6   0x1D07             ADDS     R7,R0,#+4
   \   000000B8   0xEBA9 0x0004      SUB      R0,R9,R4
   \   000000BC   0x.... 0x....      BL       QRinput_estimateBitsMode8
   \   000000C0   0x1A38             SUBS     R0,R7,R0
   \   000000C2   0xD5CB             BPL.N    ??Split_eat8_4
    247          		} else {
    248          			p++;
    249          		}
    250          	}
    251          
    252          	run = p - string;
   \                     ??Split_eat8_3: (+1)
   \   000000C4   0x1B2D             SUBS     R5,R5,R4
    253          	ret = QRinput_append(input, QR_MODE_8, run, (unsigned char *)string);
    254          	if(ret < 0) return -1;
   \   000000C6   0x4623             MOV      R3,R4
   \   000000C8   0x462A             MOV      R2,R5
   \   000000CA   0x2102             MOVS     R1,#+2
   \   000000CC   0x4650             MOV      R0,R10
   \   000000CE   0x.... 0x....      BL       QRinput_append
   \   000000D2   0x2800             CMP      R0,#+0
   \   000000D4   0xD51E             BPL.N    ??Split_eat8_10
   \   000000D6   0xF04F 0x30FF      MOV      R0,#-1
   \   000000DA   0xE01C             B.N      ??Split_eat8_11
   \                     ??Split_eat8_5: (+1)
   \   000000DC   0x2801             CMP      R0,#+1
   \   000000DE   0xD117             BNE.N    ??Split_eat8_12
   \   000000E0   0x46A9             MOV      R9,R5
   \   000000E2   0xE001             B.N      ??Split_eat8_13
   \                     ??Split_eat8_14: (+1)
   \   000000E4   0xF109 0x0901      ADD      R9,R9,#+1
   \                     ??Split_eat8_13: (+1)
   \   000000E8   0xF999 0x0000      LDRSB    R0,[R9, #+0]
   \   000000EC   0x0601             LSLS     R1,R0,#+24
   \   000000EE   0xD502             BPL.N    ??Split_eat8_15
   \   000000F0   0xF04F 0x30FF      MOV      R0,#-1
   \   000000F4   0xE001             B.N      ??Split_eat8_16
   \                     ??Split_eat8_15: (+1)
   \   000000F6   0x....             LDR.N    R1,??DataTable2
   \   000000F8   0x5640             LDRSB    R0,[R0, R1]
   \                     ??Split_eat8_16: (+1)
   \   000000FA   0x2800             CMP      R0,#+0
   \   000000FC   0xD5F2             BPL.N    ??Split_eat8_14
   \   000000FE   0x4631             MOV      R1,R6
   \   00000100   0x4648             MOV      R0,R9
   \   00000102   0x.... 0x....      BL       Split_identifyMode
   \   00000106   0x2802             CMP      R0,#+2
   \   00000108   0xD194             BNE.N    ??Split_eat8_1
   \   0000010A   0xF10B 0x0704      ADD      R7,R11,#+4
   \   0000010E   0xE792             B.N      ??Split_eat8_2
   \                     ??Split_eat8_12: (+1)
   \   00000110   0x1C6D             ADDS     R5,R5,#+1
   \   00000112   0xE7A4             B.N      ??Split_eat8_0
    255          
    256          	return run;
   \                     ??Split_eat8_10: (+1)
   \   00000114   0x4628             MOV      R0,R5
   \                     ??Split_eat8_11: (+1)
   \   00000116   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    257          }
    258          //分割字符串

   \                                 In section .text, align 2, keep-with-next
    259          static int Split_splitString(const char *string, QRinput *input,
    260          		QRencodeMode hint)
    261          {
   \                     Split_splitString: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0xE000             B.N      ??Split_splitString_0
    262          	int length;
    263          	QRencodeMode mode;
    264          
    265          	if(*string == '\0') return 0;
    266          
    267          	mode = Split_identifyMode(string, hint);//拆分识别模式
    268          	if(mode == QR_MODE_NUM) {
    269          		length = Split_eatNum(string, input, hint);
    270          	} else if(mode == QR_MODE_AN) {
    271          		length = Split_eatAn(string, input, hint);
    272          	} else if(mode == QR_MODE_KANJI && hint == QR_MODE_KANJI) {
    273          		length = Split_eatKanji(string, input, hint);
    274          	} else {
    275          		length = Split_eat8(string, input, hint);
    276          	}
    277          	if(length == 0) return 0;
    278          	if(length < 0) return -1;
    279          	return Split_splitString(&string[length], input, hint);
   \                     ??Split_splitString_1: (+1)
   \   0000000A   0x1904             ADDS     R4,R0,R4
   \                     ??Split_splitString_0: (+1)
   \   0000000C   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD024             BEQ.N    ??Split_splitString_2
   \   00000014   0x4631             MOV      R1,R6
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       Split_identifyMode
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD105             BNE.N    ??Split_splitString_3
   \   00000020   0x4632             MOV      R2,R6
   \   00000022   0x4629             MOV      R1,R5
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       Split_eatNum
   \   0000002A   0xE016             B.N      ??Split_splitString_4
   \                     ??Split_splitString_3: (+1)
   \   0000002C   0x2801             CMP      R0,#+1
   \   0000002E   0xD105             BNE.N    ??Split_splitString_5
   \   00000030   0x4632             MOV      R2,R6
   \   00000032   0x4629             MOV      R1,R5
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0x.... 0x....      BL       Split_eatAn
   \   0000003A   0xE00E             B.N      ??Split_splitString_4
   \                     ??Split_splitString_5: (+1)
   \   0000003C   0x2803             CMP      R0,#+3
   \   0000003E   0xD107             BNE.N    ??Split_splitString_6
   \   00000040   0x2E03             CMP      R6,#+3
   \   00000042   0xD105             BNE.N    ??Split_splitString_6
   \   00000044   0x4632             MOV      R2,R6
   \   00000046   0x4629             MOV      R1,R5
   \   00000048   0x4620             MOV      R0,R4
   \   0000004A   0x.... 0x....      BL       Split_eatKanji
   \   0000004E   0xE004             B.N      ??Split_splitString_4
   \                     ??Split_splitString_6: (+1)
   \   00000050   0x4632             MOV      R2,R6
   \   00000052   0x4629             MOV      R1,R5
   \   00000054   0x4620             MOV      R0,R4
   \   00000056   0x.... 0x....      BL       Split_eat8
   \                     ??Split_splitString_4: (+1)
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD101             BNE.N    ??Split_splitString_7
   \                     ??Split_splitString_2: (+1)
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xBD70             POP      {R4-R6,PC}
   \                     ??Split_splitString_7: (+1)
   \   00000062   0xD5D2             BPL.N    ??Split_splitString_1
   \   00000064   0xF04F 0x30FF      MOV      R0,#-1
   \   00000068   0xBD70             POP      {R4-R6,PC}       ;; return
    280          }
    281          

   \                                 In section .text, align 2, keep-with-next
    282          static char *dupAndToUpper(const char *str, QRencodeMode hint)//QRencodeMode为编码模式
    283          {
   \                     dupAndToUpper: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x460C             MOV      R4,R1
    284          	char *newstr, *p;
    285          	QRencodeMode mode;
    286          
    287          	newstr = strdup(str);//给newstr重新分配缓存
   \   00000004   0x.... 0x....      BL       strdup
   \   00000008   0x0005             MOVS     R5,R0
    288          	if(newstr == NULL) return NULL;
   \   0000000A   0xD101             BNE.N    ??dupAndToUpper_0
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xBD70             POP      {R4-R6,PC}
    289          
    290          	p = newstr;
   \                     ??dupAndToUpper_0: (+1)
   \   00000010   0x462E             MOV      R6,R5
   \   00000012   0xE000             B.N      ??dupAndToUpper_1
    291          	while(*p != '\0') {
    292          		mode = Split_identifyMode(p, hint);//拆分识别模式
    293          		if(mode == QR_MODE_KANJI) {
    294          			p += 2;
   \                     ??dupAndToUpper_2: (+1)
   \   00000014   0x1CB6             ADDS     R6,R6,#+2
    295          		} else {
   \                     ??dupAndToUpper_1: (+1)
   \   00000016   0xF996 0x0000      LDRSB    R0,[R6, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD00F             BEQ.N    ??dupAndToUpper_3
   \   0000001E   0x4621             MOV      R1,R4
   \   00000020   0x4630             MOV      R0,R6
   \   00000022   0x.... 0x....      BL       Split_identifyMode
   \   00000026   0x2803             CMP      R0,#+3
   \   00000028   0xD0F4             BEQ.N    ??dupAndToUpper_2
    296          			if (*p >= 'a' && *p <= 'z') {
   \   0000002A   0xF996 0x0000      LDRSB    R0,[R6, #+0]
   \   0000002E   0xF1A0 0x0161      SUB      R1,R0,#+97
   \   00000032   0x291A             CMP      R1,#+26
   \   00000034   0xD201             BCS.N    ??dupAndToUpper_4
    297          				*p = (char)((int)*p - 32);
   \   00000036   0x3820             SUBS     R0,R0,#+32
   \   00000038   0x7030             STRB     R0,[R6, #+0]
    298          			}
    299          			p++;
   \                     ??dupAndToUpper_4: (+1)
   \   0000003A   0x1C76             ADDS     R6,R6,#+1
   \   0000003C   0xE7EB             B.N      ??dupAndToUpper_1
    300          		}
    301          	}
    302          
    303          	return newstr;
   \                     ??dupAndToUpper_3: (+1)
   \   0000003E   0x4628             MOV      R0,R5
   \   00000040   0xBD70             POP      {R4-R6,PC}       ;; return
    304          }
    305          //分割二位字符串输入
    306          //string：编码的数据
    307          //input：编码数据的输入信息
    308          //hint：编码模式
    309          //casesensitive：是否区分大小写 0不区分(都是小写)

   \                                 In section .text, align 2, keep-with-next
    310          int Split_splitStringToQRinput(const char *string, QRinput *input,
    311          		QRencodeMode hint, int casesensitive)
    312          {
   \                     Split_splitStringToQRinput: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x4615             MOV      R5,R2
    313          	char *newstr;
    314          	int ret;
    315          
    316          	if(string == NULL || *string == '\0') {
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD003             BEQ.N    ??Split_splitStringToQRinput_0
   \   0000000A   0xF990 0x1000      LDRSB    R1,[R0, #+0]
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD106             BNE.N    ??Split_splitStringToQRinput_1
    317          		errno = EINVAL;
   \                     ??Split_splitStringToQRinput_0: (+1)
   \   00000012   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000016   0xF04F 0x31FF      MOV      R1,#-1
   \   0000001A   0x6001             STR      R1,[R0, #+0]
    318          		return -1;
   \   0000001C   0x4608             MOV      R0,R1
   \   0000001E   0xBD70             POP      {R4-R6,PC}
    319          	}
    320          	if(!casesensitive) {
   \                     ??Split_splitStringToQRinput_1: (+1)
   \   00000020   0x2B00             CMP      R3,#+0
   \   00000022   0xD110             BNE.N    ??Split_splitStringToQRinput_2
    321          		newstr = dupAndToUpper(string, hint);
   \   00000024   0x4629             MOV      R1,R5
   \   00000026   0x.... 0x....      BL       dupAndToUpper
   \   0000002A   0x0006             MOVS     R6,R0
    322          		if(newstr == NULL) return -1;
   \   0000002C   0xD102             BNE.N    ??Split_splitStringToQRinput_3
   \   0000002E   0xF04F 0x30FF      MOV      R0,#-1
   \   00000032   0xBD70             POP      {R4-R6,PC}
    323          		ret = Split_splitString(newstr, input, hint);
   \                     ??Split_splitStringToQRinput_3: (+1)
   \   00000034   0x462A             MOV      R2,R5
   \   00000036   0x4621             MOV      R1,R4
   \   00000038   0x.... 0x....      BL       Split_splitString
   \   0000003C   0x4604             MOV      R4,R0
    324          		free(newstr);//dupAndToUpper申请了内存，必须释放
   \   0000003E   0x4630             MOV      R0,R6
   \   00000040   0x.... 0x....      BL       free
   \   00000044   0xE003             B.N      ??Split_splitStringToQRinput_4
    325          	} else {
    326          		ret = Split_splitString(string, input, hint);
   \                     ??Split_splitStringToQRinput_2: (+1)
   \   00000046   0x4621             MOV      R1,R4
   \   00000048   0x.... 0x....      BL       Split_splitString
   \   0000004C   0x4604             MOV      R4,R0
    327          	}
    328          
    329          	return ret;
   \                     ??Split_splitStringToQRinput_4: (+1)
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0xBD70             POP      {R4-R6,PC}       ;; return
    330          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     QRinput_anTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0xFFFF7EC0         DC32     0xffff7ec0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0xFFFF1FC0         DC32     0xffff1fc0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      48   Split_eat8
        48   -> QRinput_append
        48   -> QRinput_estimateBitsMode8
        48   -> QRinput_estimateBitsModeAn
        48   -> QRinput_estimateBitsModeNum
        48   -> QRspec_lengthIndicator
        48   -> Split_identifyMode
      48   Split_eatAn
        48   -> QRinput_append
        48   -> QRinput_estimateBitsMode8
        48   -> QRinput_estimateBitsModeAn
        48   -> QRinput_estimateBitsModeNum
        48   -> QRspec_lengthIndicator
         0   -> Split_eat8
      24   Split_eatKanji
        24   -> QRinput_append
        24   -> Split_identifyMode
      32   Split_eatNum
        32   -> QRinput_append
        32   -> QRinput_estimateBitsMode8
        32   -> QRinput_estimateBitsModeAn
        32   -> QRinput_estimateBitsModeNum
        32   -> QRspec_lengthIndicator
         0   -> Split_eat8
         0   -> Split_eatAn
        32   -> Split_identifyMode
       0   Split_identifyMode
      16   Split_splitString
        16   -> Split_eat8
        16   -> Split_eatAn
        16   -> Split_eatKanji
        16   -> Split_eatNum
        16   -> Split_identifyMode
      16   Split_splitStringToQRinput
        16   -> Split_splitString
        16   -> __aeabi_errno_addr
        16   -> dupAndToUpper
        16   -> free
      16   dupAndToUpper
        16   -> Split_identifyMode
        16   -> strdup
      16   strdup
        16   -> malloc
         0   -> memcpy
        16   -> strlen


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
     282  Split_eat8
     272  Split_eatAn
      54  Split_eatKanji
     190  Split_eatNum
     102  Split_identifyMode
     106  Split_splitString
      82  Split_splitStringToQRinput
      66  dupAndToUpper
      36  strdup

 
 1 202 bytes in section .text
 
 1 202 bytes of CODE memory

Errors: none
Warnings: none
