###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  11:49:04
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\arduino\stm32\cores\arduino\USARTClass.cpp
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\arduino\stm32\cores\arduino\USARTClass.cpp
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --eec++ -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\USARTClass.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\USARTClass.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\arduino\stm32\cores\arduino\USARTClass.cpp
      1          /*
      2            Copyright (c) 2014 Makerbase & Andy Sze(andy.sze.mail@gmail.com)  All right reserved.
      3            Copyright (c) 2011 Arduino.  All right reserved.
      4          
      5            This library is free software; you can redistribute it and/or
      6            modify it under the terms of the GNU Lesser General Public
      7            License as published by the Free Software Foundation; either
      8            version 2.1 of the License, or (at your option) any later version.
      9          
     10            This library is distributed in the hope that it will be useful,
     11            but WITHOUT ANY WARRANTY; without even the implied warranty of
     12            MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
     13            See the GNU Lesser General Public License for more details.
     14          
     15            You should have received a copy of the GNU Lesser General Public
     16            License along with this library; if not, write to the Free Software
     17            Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
     18          */
     19          
     20          #include <stdlib.h>
     21          #include <stdio.h>
     22          #include <string.h>
     23          
     24          #include "USARTClass.h"

   \                                 In section .text, align 2
   \   __code __interwork __softfp Print::Print()
   \                     _ZN5PrintC1Ev: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6041             STR      R1,[R0, #+4]
   \   00000004   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __code __interwork __softfp Stream::Stream()
   \                     _ZN6StreamC1Ev: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x.... 0x....      BL       _ZN5PrintC2Ev
   \   00000008   0xF44F 0x707A      MOV      R0,#+1000
   \   0000000C   0x60A0             STR      R0,[R4, #+8]
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2
   \   __code __interwork __softfp HardwareSerial::HardwareSerial()
   \                     _ZN14HardwareSerialC1Ev: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x.... 0x....      BL       _ZN6StreamC2Ev
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     _Z14NVIC_EnableIRQ9IRQn_Type: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF000 0x021F      AND      R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x0940             LSRS     R0,R0,#+5
   \   0000000A   0x....             LDR.N    R2,??DataTable4  ;; 0xe000e100
   \   0000000C   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   \   00000010   0x4770             BX       LR               ;; return

  #define IS_IWDG_PRESCALER(PRESCALER) (((PRESCALER) == IWDG_Prescaler_4)  || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_iwdg.h",80  Warning[Pe047]: 
          incompatible redefinition of macro "IS_IWDG_PRESCALER" (declared at
          line 209 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_iwdg.h")

  #define IS_IWDG_RELOAD(RELOAD) ((RELOAD) <= 0xFFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_iwdg.h",97  Warning[Pe047]: 
          incompatible redefinition of macro "IS_IWDG_RELOAD" (declared at
          line 222 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_iwdg.h")

  #define IS_FSMC_NORSRAM_BANK(BANK) (((BANK) == FSMC_Bank1_NORSRAM1) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",272  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_NORSRAM_BANK" (declared
          at line 834 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_NAND_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",277  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_NAND_BANK" (declared at
          line 855 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_MUX(MUX) (((MUX) == FSMC_DataAddressMux_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",298  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_MUX" (declared at line
          839 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_MEMORY(MEMORY) (((MEMORY) == FSMC_MemoryType_SRAM) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",311  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_MEMORY" (declared at
          line 842 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_BURSTMODE(STATE) (((STATE) == FSMC_BurstAccessMode_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",336  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_BURSTMODE" (declared at
          line 894 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ASYNWAIT(STATE) (((STATE) == FSMC_AsynchronousWait_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",347  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ASYNWAIT" (declared at
          line 915 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAIT_POLARITY(POLARITY) (((POLARITY) == FSMC_WaitSignalPolarity_Low) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",358  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAIT_POLARITY" (declared
          at line 897 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WRAP_MODE(MODE) (((MODE) == FSMC_WrapMode_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",369  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WRAP_MODE" (declared at
          line 900 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAIT_SIGNAL_ACTIVE(ACTIVE) (((ACTIVE) == FSMC_WaitSignalActive_BeforeWaitState) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",380  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAIT_SIGNAL_ACTIVE"
          (declared at line 903 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WRITE_OPERATION(OPERATION) (((OPERATION) == FSMC_WriteOperation_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",391  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WRITE_OPERATION"
          (declared at line 906 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAITE_SIGNAL(SIGNAL) (((SIGNAL) == FSMC_WaitSignal_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",402  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAITE_SIGNAL" (declared
          at line 909 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_EXTENDED_MODE(MODE) (((MODE) == FSMC_ExtendedMode_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",414  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_EXTENDED_MODE" (declared
          at line 912 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WRITE_BURST(BURST) (((BURST) == FSMC_WriteBurst_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",426  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WRITE_BURST" (declared
          at line 920 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ADDRESS_SETUP_TIME(TIME) ((TIME) <= 0xF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",435  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ADDRESS_SETUP_TIME"
          (declared at line 923 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ADDRESS_HOLD_TIME(TIME) ((TIME) <= 0xF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",443  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ADDRESS_HOLD_TIME"
          (declared at line 925 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_DATASETUP_TIME(TIME) (((TIME) > 0) && ((TIME) <= 0xFF))
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",451  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_DATASETUP_TIME"
          (declared at line 927 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_TURNAROUND_TIME(TIME) ((TIME) <= 0xF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",459  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_TURNAROUND_TIME"
          (declared at line 929 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_CLK_DIV(DIV) ((DIV) <= 0xF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",467  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_CLK_DIV" (declared at
          line 934 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_DATA_LATENCY(LATENCY) ((LATENCY) <= 0xF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",475  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_DATA_LATENCY" (declared
          at line 918 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ACCESS_MODE(MODE) (((MODE) == FSMC_AccessMode_A) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",487  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ACCESS_MODE" (declared
          at line 850 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAIT_FEATURE(FEATURE) (((FEATURE) == FSMC_Waitfeature_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",508  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAIT_FEATURE" (declared
          at line 858 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ECC_STATE(STATE) (((STATE) == FSMC_ECC_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",520  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ECC_STATE" (declared at
          line 864 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ECCPAGE_SIZE(SIZE) (((SIZE) == FSMC_ECCPageSize_256Bytes) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",535  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ECCPAGE_SIZE" (declared
          at line 867 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_TCLR_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",548  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_TCLR_TIME" (declared at
          line 874 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_TAR_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",556  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_TAR_TIME" (declared at
          line 876 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_SETUP_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",564  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_SETUP_TIME" (declared at
          line 878 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAIT_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",572  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAIT_TIME" (declared at
          line 880 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_HOLD_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",580  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_HOLD_TIME" (declared at
          line 882 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_HIZ_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",588  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_HIZ_TIME" (declared at
          line 884 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define FSMC_FLAG_FEMPT                          ((uint32_t)0x00000040)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",613  Warning[Pe047]: 
          incompatible redefinition of macro "FSMC_FLAG_FEMPT" (declared at
          line 530 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

    #define assert_param(expr) ((void)0)        
            ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\stm32f4xx_conf.h",149  Warning[Pe047]: 
          incompatible redefinition of macro "assert_param" (declared at line
          431 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\stm32f4x
          x_hal_conf.h")

   \                                 In section .text, align 2
   \   __code __interwork __softfp USARTClass::operator bool()
   \                     _ZN10USARTClasscvbEv: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x4770             BX       LR               ;; return
     25          #include "Arduino.h"
     26          #include "usart.h"
     27          #include "mks_cfg.h"

  #define UNUSED(x) (void) (x)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\macros.h",101  Warning[Pe047]: 
          incompatible redefinition of macro "UNUSED" (declared at line 87 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_def.h")

  		volatile volatile float desireBedTempBak;
  		         ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Inc\mks_cfg.h",351  Warning[Pe083]: 
          type qualifier specified more than once
     28          
     29          // Constructors ////////////////////////////////////////////////////////////////
     30          

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp USARTClass::subobject USARTClass(USART_TypeDef *, IRQn_Type, uint32_t, RingBuffer *)
   \                     _ZN10USARTClassC2EP13USART_TypeDef9IRQn_TypejP10RingBuffer: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x9C04             LDR      R4,[SP, #+16]
   \   00000006   0x9400             STR      R4,[SP, #+0]
   \   00000008   0x.... 0x....      BL       _ZN10USARTClassC1EP13USART_TypeDef9IRQn_TypejP10RingBuffer
   \   0000000C   0xBD16             POP      {R1,R2,R4,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
     31          USARTClass::USARTClass( USART_TypeDef* pUsart, IRQn_Type dwIrq, uint32_t dwId, RingBuffer* pRx_buffer )
   \                     _ZN10USARTClassC1EP13USART_TypeDef9IRQn_TypejP10RingBuffer: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0x461F             MOV      R7,R3
     32          {
   \   0000000A   0x.... 0x....      BL       _ZN14HardwareSerialC2Ev
   \   0000000E   0x....             LDR.N    R0,??DataTable4_1
   \   00000010   0x6020             STR      R0,[R4, #+0]
     33            _rx_buffer = pRx_buffer ;
   \   00000012   0x9806             LDR      R0,[SP, #+24]
   \   00000014   0x6120             STR      R0,[R4, #+16]
     34          
     35            _pUsart=pUsart ;
   \   00000016   0x6165             STR      R5,[R4, #+20]
     36            _dwIrq=dwIrq ;
   \   00000018   0xF884 0x6028      STRB     R6,[R4, #+40]
     37            _dwId=dwId ;
   \   0000001C   0x62E7             STR      R7,[R4, #+44]
     38          }
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
     39          
     40          // Public Methods //////////////////////////////////////////////////////////////
     41          

   \                                 In section .text, align 2, keep-with-next
     42          void USARTClass::begin( const uint32_t dwBaudRate )
     43          {
   \                     _ZN10USARTClass5beginEj: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
     44          #if 0		//skyblue modidy 2016-11-29
     45          
     46            //Serial
     47            if(_dwId == id_serial)
     48            {
     49              // AFIO clock enable
     50          #if defined (STM32F10X_HD) || (STM32F10X_MD)
     51              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
     52          #elif defined (STM32F40_41xxx)
     53              RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
     54          #endif
     55          
     56              // Enable USART Clock
     57          #if defined (STM32F10X_HD) || (STM32F10X_MD)
     58              RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
     59          #elif defined (STM32F40_41xxx)
     60              RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
     61          #endif
     62          
     63          #if defined (STM32F10X_HD) || (STM32F10X_MD)
     64              // Configure USART Rx as input floating
     65              pinMode(RX, INPUT);
     66          
     67              // Configure USART Tx as alternate function push-pull
     68              pinMode(TX, AF_OUTPUT_PUSHPULL);
     69          #elif defined (STM32F40_41xxx)
     70              // Configure USART Tx as alternate function push-pull
     71              //pinMode(TX, AF_OUTPUT_PUSHPULL);
     72              //pinMode(RX, AF_OUTPUT_PUSHPULL);
     73          
     74              GPIO_InitTypeDef GPIO_InitStructure;
     75              /* Configure USART Tx and Rx as alternate function push-pull */
     76              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
     77              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
     78              GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
     79              GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
     80              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11 | GPIO_Pin_10;
     81          
     82              GPIO_Init(GPIOC, &GPIO_InitStructure);
     83          
     84              GPIO_PinAFConfig(GPIOC, GPIO_PinSource10, GPIO_AF_USART3);
     85              GPIO_PinAFConfig(GPIOC, GPIO_PinSource11, GPIO_AF_USART3);
     86          #endif
     87            }
     88            else if(_dwId == id_serial1)//Serial1
     89            {
     90          #ifdef STM32F10X_HD
     91              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC | RCC_APB2Periph_AFIO, ENABLE);
     92              RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);
     93          #endif
     94          #ifdef STM32F10X_MD
     95              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
     96              RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
     97          #endif
     98              pinMode(RX0, INPUT);
     99              pinMode(TX0, AF_OUTPUT_PUSHPULL);
    100            }
    101            else if(_dwId == id_serial2)//Serial2
    102            {
    103          #ifdef STM32F10X_HD
    104              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD | RCC_APB2Periph_AFIO, ENABLE);
    105              RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
    106          #endif
    107          #ifdef STM32F10X_MD
    108              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_AFIO, ENABLE);
    109              RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
    110          #endif
    111              pinMode(RX1, INPUT);
    112              pinMode(TX1, AF_OUTPUT_PUSHPULL);
    113            }
    114          #ifdef STM32F10X_HD
    115            else if(_dwId == id_serial3)//Serial3
    116            {
    117              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD | RCC_APB2Periph_AFIO, ENABLE);
    118              RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
    119              pinMode(RX2, INPUT);
    120              pinMode(TX2, AF_OUTPUT_PUSHPULL);
    121            }
    122          #endif
    123          	// USART default configuration
    124          	// USART configured as follow:
    125          	// - BaudRate = (set baudRate as 9600 baud)
    126          	// - Word Length = 8 Bits
    127          	// - One Stop Bit
    128          	// - No parity
    129          	// - Hardware flow control disabled (RTS and CTS signals)
    130          	// - Receive and transmit enabled
    131          	USART_InitStructure.USART_BaudRate = dwBaudRate;
    132          	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    133          	USART_InitStructure.USART_StopBits = USART_StopBits_1;
    134          	USART_InitStructure.USART_Parity = USART_Parity_No;
    135          	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    136          	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    137          
    138          	// Configure USART
    139          	USART_Init(_pUsart, &USART_InitStructure);
    140          
    141            NVIC_InitTypeDef NVIC_InitStructure;
    142          
    143            /* Configure the NVIC Preemption Priority Bits */  
    144            //NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);
    145            
    146            /* Enable the USARTy Interrupt */
    147            NVIC_InitStructure.NVIC_IRQChannel = _dwIrq;
    148          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = _dwId;		
    149            NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    150            NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    151            NVIC_Init(&NVIC_InitStructure);
    152          #endif //skyblue modidy 2016-11-29   
    153            /* Enable USART Receive interrupts */
    154            USART_ITConfig(_pUsart, USART_IT_RXNE, ENABLE);
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0xF240 0x5125      MOVW     R1,#+1317
   \   0000000A   0x6960             LDR      R0,[R4, #+20]
   \   0000000C   0x.... 0x....      BL       USART_ITConfig
    155            // Enable UART interrupt in NVIC
    156            NVIC_EnableIRQ( _dwIrq ) ;
   \   00000010   0xF994 0x0028      LDRSB    R0,[R4, #+40]
   \   00000014   0x.... 0x....      BL       _Z14NVIC_EnableIRQ9IRQn_Type
    157          
    158          	// Enable the USART
    159          	USART_Cmd(_pUsart, ENABLE);
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x6960             LDR      R0,[R4, #+20]
   \   0000001C   0xE8BD 0x4010      POP      {R4,LR}
   \   00000020   0x.... 0x....      B.W      USART_Cmd
    160               
    161          }
    162          

   \                                 In section .text, align 2, keep-with-next
    163          void USARTClass::end( void )
    164          {
    165          #if 0		//skyblue modidy 2016-11-29
    166          
    167            // clear any received data
    168            _rx_buffer->_iHead = _rx_buffer->_iTail ;
    169          
    170            // Disable UART interrupt in NVIC
    171            NVIC_DisableIRQ( _dwIrq ) ;
    172          
    173            // Wait for any outstanding data to be sent
    174            flush();
    175            
    176            USART_Cmd(_pUsart, DISABLE);
    177          
    178            if(_dwId == id_serial)//Serial
    179            {
    180              // Disable USART Clock
    181              RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, DISABLE);
    182            }
    183            else if(_dwId == id_serial2)//Serial2
    184            {
    185              RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, DISABLE);
    186            }
    187            else if(_dwId == id_serial3)//Serial3
    188            {
    189              RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, DISABLE);
    190            }
    191            else if(_dwId == id_serial1)//Serial1
    192            {
    193          #ifdef STM32F10X_HD
    194              RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, DISABLE);
    195          #endif
    196          #ifdef STM32F10X_MD
    197              RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, DISABLE);
    198          #endif
    199            }
    200          #endif //skyblue modidy 2016-11-29    
    201          }
   \                     _ZN10USARTClass3endEv: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    202          

   \                                 In section .text, align 2, keep-with-next
    203          int USARTClass::available( void )
    204          {
    205            return (uint32_t)(SERIAL_BUFFER_SIZE + _rx_buffer->_iHead - _rx_buffer->_iTail) % SERIAL_BUFFER_SIZE ;
   \                     _ZN10USARTClass9availableEv: (+1)
   \   00000000   0x6900             LDR      R0,[R0, #+16]
   \   00000002   0x6E01             LDR      R1,[R0, #+96]
   \   00000004   0x3160             ADDS     R1,R1,#+96
   \   00000006   0x6E40             LDR      R0,[R0, #+100]
   \   00000008   0x1A08             SUBS     R0,R1,R0
   \   0000000A   0x2160             MOVS     R1,#+96
   \   0000000C   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   00000010   0xEB01 0x0241      ADD      R2,R1,R1, LSL #+1
   \   00000014   0xEBA0 0x1042      SUB      R0,R0,R2, LSL #+5
   \   00000018   0x4770             BX       LR               ;; return
    206          }
    207          

   \                                 In section .text, align 2, keep-with-next
    208          int USARTClass::peek( void )
    209          {
    210            if ( _rx_buffer->_iHead == _rx_buffer->_iTail )
   \                     _ZN10USARTClass4peekEv: (+1)
   \   00000000   0x6900             LDR      R0,[R0, #+16]
   \   00000002   0x6E41             LDR      R1,[R0, #+100]
   \   00000004   0x6E02             LDR      R2,[R0, #+96]
   \   00000006   0x428A             CMP      R2,R1
   \   00000008   0xD102             BNE.N    ??peek_0
    211              return -1 ;
   \   0000000A   0xF04F 0x30FF      MOV      R0,#-1
   \   0000000E   0x4770             BX       LR
    212            
    213            
    214          
    215            return _rx_buffer->_aucBuffer[_rx_buffer->_iTail] ;
   \                     ??peek_0: (+1)
   \   00000010   0x5C08             LDRB     R0,[R1, R0]
   \   00000012   0x4770             BX       LR               ;; return
    216          }
    217          

   \                                 In section .text, align 2, keep-with-next
    218          int16_t USARTClass::read( void )
    219          {
   \                     _ZN10USARTClass4readEv: (+1)
   \   00000000   0xB410             PUSH     {R4}
    220            // if the head isn't ahead of the tail, we don't have any characters
    221            if ( _rx_buffer->_iHead == _rx_buffer->_iTail )
   \   00000002   0x6901             LDR      R1,[R0, #+16]
   \   00000004   0x6E4A             LDR      R2,[R1, #+100]
   \   00000006   0x6E08             LDR      R0,[R1, #+96]
   \   00000008   0x4290             CMP      R0,R2
   \   0000000A   0xD102             BNE.N    ??read_0
    222              return -1 ;
   \   0000000C   0xF04F 0x30FF      MOV      R0,#-1
   \   00000010   0xE009             B.N      ??read_1
    223          
    224            uint8_t uc = _rx_buffer->_aucBuffer[_rx_buffer->_iTail] ;
   \                     ??read_0: (+1)
   \   00000012   0x5C50             LDRB     R0,[R2, R1]
    225            _rx_buffer->_iTail = (unsigned int)(_rx_buffer->_iTail + 1) % SERIAL_BUFFER_SIZE ;
   \   00000014   0x1C52             ADDS     R2,R2,#+1
   \   00000016   0x2360             MOVS     R3,#+96
   \   00000018   0xFBB2 0xF3F3      UDIV     R3,R2,R3
   \   0000001C   0xEB03 0x0443      ADD      R4,R3,R3, LSL #+1
   \   00000020   0xEBA2 0x1244      SUB      R2,R2,R4, LSL #+5
   \   00000024   0x664A             STR      R2,[R1, #+100]
    226            return uc ;
   \                     ??read_1: (+1)
   \   00000026   0xBC10             POP      {R4}
   \   00000028   0x4770             BX       LR               ;; return
    227          }
    228          

   \                                 In section .text, align 2, keep-with-next
    229          void USARTClass::flush( void )
    230          {
    231          #if 0
    232            // Wait for transmission to complete
    233            while ((_pUsart->US_CSR & US_CSR_TXRDY) != US_CSR_TXRDY)
    234          	;
    235          #endif
    236            _rx_buffer->_iTail = _rx_buffer->_iHead;
   \                     _ZN10USARTClass5flushEv: (+1)
   \   00000000   0x6900             LDR      R0,[R0, #+16]
   \   00000002   0x6E01             LDR      R1,[R0, #+96]
   \   00000004   0x6641             STR      R1,[R0, #+100]
    237          }
   \   00000006   0x4770             BX       LR               ;; return
    238          

   \                                 In section .text, align 2, keep-with-next
    239          size_t USARTClass::write( const uint8_t uc_data )
    240          {
   \                     _ZN10USARTClass5writeEh: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    241          	// Send one byte from USART
    242          	USART_SendData(_pUsart, uc_data);
   \   00000004   0x6960             LDR      R0,[R4, #+20]
   \   00000006   0x.... 0x....      BL       USART_SendData
    243                  
    244          	// Loop until USART DR register is empty
    245          	while(USART_GetFlagStatus(_pUsart, USART_FLAG_TXE) == RESET)
   \                     ??write_0: (+1)
   \   0000000A   0x2180             MOVS     R1,#+128
   \   0000000C   0x6960             LDR      R0,[R4, #+20]
   \   0000000E   0x.... 0x....      BL       USART_GetFlagStatus
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD0F9             BEQ.N    ??write_0
    246          	{
    247          	}
    248          
    249          	return 1;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
    250          } 
    251          

   \                                 In section .text, align 2, keep-with-next
    252          void USARTClass::IrqHandler( void )
    253          {
   \                     _ZN10USARTClass10IrqHandlerEv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    254              if (USART_GetFlagStatus(_pUsart, USART_FLAG_PE) != RESET)  
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x6960             LDR      R0,[R4, #+20]
   \   00000008   0x.... 0x....      BL       USART_GetFlagStatus
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD006             BEQ.N    ??IrqHandler_0
    255             {  
    256                 USART_ReceiveData(_pUsart);  
   \   00000010   0x6960             LDR      R0,[R4, #+20]
   \   00000012   0x.... 0x....      BL       USART_ReceiveData
    257               USART_ClearFlag(_pUsart, USART_FLAG_PE);  
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0x6960             LDR      R0,[R4, #+20]
   \   0000001A   0x.... 0x....      BL       USART_ClearFlag
    258             }  
    259                
    260             if (USART_GetFlagStatus(_pUsart, USART_FLAG_ORE) != RESET)  
   \                     ??IrqHandler_0: (+1)
   \   0000001E   0x2108             MOVS     R1,#+8
   \   00000020   0x6960             LDR      R0,[R4, #+20]
   \   00000022   0x.... 0x....      BL       USART_GetFlagStatus
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD006             BEQ.N    ??IrqHandler_1
    261             {  
    262                 USART_ReceiveData(_pUsart);  
   \   0000002A   0x6960             LDR      R0,[R4, #+20]
   \   0000002C   0x.... 0x....      BL       USART_ReceiveData
    263               USART_ClearFlag(_pUsart, USART_FLAG_ORE);  
   \   00000030   0x2108             MOVS     R1,#+8
   \   00000032   0x6960             LDR      R0,[R4, #+20]
   \   00000034   0x.... 0x....      BL       USART_ClearFlag
    264             }  
    265                
    266              if (USART_GetFlagStatus(_pUsart, USART_FLAG_FE) != RESET)  
   \                     ??IrqHandler_1: (+1)
   \   00000038   0x2102             MOVS     R1,#+2
   \   0000003A   0x6960             LDR      R0,[R4, #+20]
   \   0000003C   0x.... 0x....      BL       USART_GetFlagStatus
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD006             BEQ.N    ??IrqHandler_2
    267             {  
    268                 USART_ReceiveData(_pUsart);  
   \   00000044   0x6960             LDR      R0,[R4, #+20]
   \   00000046   0x.... 0x....      BL       USART_ReceiveData
    269                USART_ClearFlag(_pUsart, USART_FLAG_FE);  
   \   0000004A   0x2102             MOVS     R1,#+2
   \   0000004C   0x6960             LDR      R0,[R4, #+20]
   \   0000004E   0x.... 0x....      BL       USART_ClearFlag
    270             }  
    271          	
    272          	
    273            // Did we receive data ?
    274            if(USART_GetITStatus(_pUsart, USART_IT_RXNE) != RESET)
   \                     ??IrqHandler_2: (+1)
   \   00000052   0xF240 0x5525      MOVW     R5,#+1317
   \   00000056   0x4629             MOV      R1,R5
   \   00000058   0x6960             LDR      R0,[R4, #+20]
   \   0000005A   0x.... 0x....      BL       USART_GetITStatus
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD011             BEQ.N    ??IrqHandler_3
    275            {
    276              /* Read one byte from the receive data register */
    277              uint8_t RxBuffer;
    278              USART_ClearFlag(_pUsart, USART_FLAG_RXNE);  
   \   00000062   0x2120             MOVS     R1,#+32
   \   00000064   0x6960             LDR      R0,[R4, #+20]
   \   00000066   0x.... 0x....      BL       USART_ClearFlag
    279              USART_ClearITPendingBit(_pUsart, USART_IT_RXNE);  
   \   0000006A   0x4629             MOV      R1,R5
   \   0000006C   0x6960             LDR      R0,[R4, #+20]
   \   0000006E   0x.... 0x....      BL       USART_ClearITPendingBit
    280              RxBuffer = USART_ReceiveData(_pUsart);
   \   00000072   0x6960             LDR      R0,[R4, #+20]
   \   00000074   0x.... 0x....      BL       USART_ReceiveData
    281          
    282              _rx_buffer->store_char( RxBuffer ) ;
   \   00000078   0x4601             MOV      R1,R0
   \   0000007A   0xB2C9             UXTB     R1,R1
   \   0000007C   0x6920             LDR      R0,[R4, #+16]
   \   0000007E   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000082   0x.... 0x....      B.W      _ZN10RingBuffer10store_charEh
    283            }
    284          
    285            
    286          #if 0
    287            // Acknowledge errors
    288            if ((status & US_CSR_OVRE) == US_CSR_OVRE ||
    289          		  (status & US_CSR_FRAME) == US_CSR_FRAME)
    290            {
    291          	// TODO: error reporting outside ISR
    292              _pUsart->US_CR |= US_CR_RSTSTA;
    293            }
    294          #endif
    295          
    296          }
   \                     ??IrqHandler_3: (+1)
   \   00000086   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    297          #if 0
    298          
    299          void USARTClass::sdPause( void )
    300          {
    301            int i;
    302            uint8_t GData[16]= "G91\nG1 Z10\nG90\n";
    303            unsigned char homeGcode1[5]="G91\n";      
    304            for(i=0;i<15;i++)
    305                _rx_buffer->store_char(GData[i]) ;
    306              
    307          }
    308          extern int xmov_distance;
    309          extern int ymov_distance;
    310          extern int zmov_distance;
    311          
    312          void USARTClass::sdContinue( void )
    313          {
    314            int i;
    315            
    316            uint8_t GData[17]= "G91\nG1 Z-10\nG90\n";
    317            unsigned char homeGcode1[5]="G91\n";      
    318            for(i=0;i<16;i++)
    319                _rx_buffer->store_char(GData[i]) ;
    320           
    321          }
    322          #endif
    323          extern char codebuff[100];
    324          extern volatile char *codebufpoint;
    325          

   \                                 In section .text, align 2, keep-with-next
    326          void USARTClass::MoremenuCmd(void)
    327          {
   \                     _ZN10USARTClass11MoremenuCmdEv: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
    328          	uint8_t i = 0,j=0;
   \   00000006   0x2500             MOVS     R5,#+0
   \   00000008   0x462E             MOV      R6,R5
    329          	
    330          	if(*(codebufpoint) != '\0')
   \   0000000A   0x....             LDR.N    R7,??DataTable4_2
   \   0000000C   0x6838             LDR      R0,[R7, #+0]
   \   0000000E   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD030             BEQ.N    ??MoremenuCmd_0
    331          	{
    332          		memset(codebuff,0,sizeof(codebuff));
   \   00000016   0x.... 0x....      LDR.W    R8,??DataTable4_3
   \   0000001A   0x2264             MOVS     R2,#+100
   \   0000001C   0x4629             MOV      R1,R5
   \   0000001E   0x4640             MOV      R0,R8
   \   00000020   0x.... 0x....      BL       memset
   \   00000024   0xE006             B.N      ??MoremenuCmd_1
    333          		
    334          		while((*(codebufpoint) != 0x3b)&&(i<=96))//?¨¹¨¢?DD¨°?¡¤?o??a?¨¢¨º?¡¤??¡ê
    335          		{
    336          			codebuff[i] = *codebufpoint;
   \                     ??MoremenuCmd_2: (+1)
   \   00000026   0x7801             LDRB     R1,[R0, #+0]
   \   00000028   0xF805 0x1008      STRB     R1,[R5, R8]
    337          			i++;
   \   0000002C   0x1C6D             ADDS     R5,R5,#+1
   \   0000002E   0xB2ED             UXTB     R5,R5
    338          			codebufpoint++;
   \   00000030   0x1C40             ADDS     R0,R0,#+1
   \   00000032   0x6038             STR      R0,[R7, #+0]
    339          		}
   \                     ??MoremenuCmd_1: (+1)
   \   00000034   0x6838             LDR      R0,[R7, #+0]
   \   00000036   0xF990 0x1000      LDRSB    R1,[R0, #+0]
   \   0000003A   0x293B             CMP      R1,#+59
   \   0000003C   0xD001             BEQ.N    ??MoremenuCmd_3
   \   0000003E   0x2D61             CMP      R5,#+97
   \   00000040   0xDBF1             BLT.N    ??MoremenuCmd_2
    340          		
    341          		codebuff[i] = '\n';
   \                     ??MoremenuCmd_3: (+1)
   \   00000042   0x210A             MOVS     R1,#+10
   \   00000044   0xF805 0x1008      STRB     R1,[R5, R8]
    342          		
    343          		codebufpoint += 1;		
   \   00000048   0x1C40             ADDS     R0,R0,#+1
   \   0000004A   0x6038             STR      R0,[R7, #+0]
    344          		if(USARTClass::check())
   \   0000004C   0x4620             MOV      R0,R4
   \   0000004E   0x.... 0x....      BL       _ZN10USARTClass5checkEv
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD00B             BEQ.N    ??MoremenuCmd_4
    345          		{
    346          			for(j=0;j<i+1;j++)
   \                     ??MoremenuCmd_5: (+1)
   \   00000056   0xB2F6             UXTB     R6,R6
   \   00000058   0x4630             MOV      R0,R6
   \   0000005A   0x1C69             ADDS     R1,R5,#+1
   \   0000005C   0x4288             CMP      R0,R1
   \   0000005E   0xDA0B             BGE.N    ??MoremenuCmd_0
    347          			{
    348                			_rx_buffer->store_char(codebuff[j]) ;
   \   00000060   0xF810 0x1008      LDRB     R1,[R0, R8]
   \   00000064   0x6920             LDR      R0,[R4, #+16]
   \   00000066   0x.... 0x....      BL       _ZN10RingBuffer10store_charEh
    349          			}
   \   0000006A   0x1C76             ADDS     R6,R6,#+1
   \   0000006C   0xE7F3             B.N      ??MoremenuCmd_5
    350          		}
    351          		else
    352          		{
    353          			codebufpoint = codebufpoint - i - 1;
   \                     ??MoremenuCmd_4: (+1)
   \   0000006E   0x4268             RSBS     R0,R5,#+0
   \   00000070   0x6839             LDR      R1,[R7, #+0]
   \   00000072   0x1840             ADDS     R0,R0,R1
   \   00000074   0x1E40             SUBS     R0,R0,#+1
   \   00000076   0x6038             STR      R0,[R7, #+0]
    354          		}
    355          		i = 0;
    356          	}
    357          	
    358          }
   \                     ??MoremenuCmd_0: (+1)
   \   00000078   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    359          

   \                                 In section .text, align 2, keep-with-next
    360          int USARTClass::check( void )
    361          {
    362            if ( _rx_buffer->_iHead == _rx_buffer->_iTail )       //?¨®¨¢D??
   \                     _ZN10USARTClass5checkEv: (+1)
   \   00000000   0x6900             LDR      R0,[R0, #+16]
   \   00000002   0x6E01             LDR      R1,[R0, #+96]
   \   00000004   0x6E40             LDR      R0,[R0, #+100]
   \   00000006   0x4281             CMP      R1,R0
   \   00000008   0xD101             BNE.N    ??check_0
    363              return 1 ;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x4770             BX       LR
    364            else
    365              return 0;
   \                     ??check_0: (+1)
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x4770             BX       LR               ;; return
    366          }
    367          #if 1
    368          extern uint8_t next_cnt;
    369          extern uint8_t leveling_start_flg;

   \                                 In section .text, align 2, keep-with-next
    370          void USARTClass::Leveling_move_action(void)
    371          {
    372          #if 0  
    373          	uint8_t i;
    374          	char move_point_temp[50]={0};
    375          	switch(next_cnt)
    376          	{
    377          	case 1:
    378          			
    379          			if(leveling_start_flg == 1)//??¨º??a¨º?2?D¨¨¨°a??¨¢?
    380          			{
    381          				leveling_start_flg = 0;
    382          				if(USARTClass::check())
    383          				{
    384          					memset(move_point_temp,0,sizeof(move_point_temp));
    385          					sprintf((char*)move_point_temp,"G28\nG91\nG1 Z%d\nG90\nG1 X%d Y%d\nG28 Z0\n",gCfgItems.pause_zpos,gCfgItems.leveling_point1_x,gCfgItems.leveling_point1_y);
    386          					for(i=0;i<strlen(move_point_temp);i++)
    387          					{
    388          		      			_rx_buffer->store_char(move_point_temp[i]) ;
    389          					}
    390          				}			
    391          			}
    392          			else
    393          			{
    394          				if(USARTClass::check())
    395          				{
    396          					memset(move_point_temp,0,sizeof(move_point_temp));
    397          					sprintf((char*)move_point_temp,"G91\nG1 Z%d\nG90\nG1 X%d Y%d\nG28 Z0\n",gCfgItems.pause_zpos,gCfgItems.leveling_point1_x,gCfgItems.leveling_point1_y);
    398          					for(i=0;i<strlen(move_point_temp);i++)
    399          					{
    400          		      			_rx_buffer->store_char(move_point_temp[i]) ;
    401          					}
    402          				}
    403          			}
    404          
    405          		break;
    406          	case 2:
    407          		if(USARTClass::check())
    408          		{
    409          			memset(move_point_temp,0,sizeof(move_point_temp));
    410          			sprintf((char*)move_point_temp,"G91\nG1 Z%d\nG90\nG1 X%d Y%d\nG28 Z0\n",gCfgItems.pause_zpos,gCfgItems.leveling_point2_x,gCfgItems.leveling_point2_y);
    411          			for(i=0;i<strlen(move_point_temp);i++)
    412          			{
    413                			_rx_buffer->store_char(move_point_temp[i]) ;
    414          			}
    415          		}		
    416          		break;
    417          	case 3:
    418          		if(USARTClass::check())
    419          		{
    420          			memset(move_point_temp,0,sizeof(move_point_temp));
    421          			sprintf((char*)move_point_temp,"G91\nG1 Z%d\nG90\nG1 X%d Y%d\nG28 Z0\n",gCfgItems.pause_zpos,gCfgItems.leveling_point3_x,gCfgItems.leveling_point3_y);
    422          			for(i=0;i<strlen(move_point_temp);i++)
    423          			{
    424                			_rx_buffer->store_char(move_point_temp[i]) ;
    425          			}
    426          		}		
    427          		break;
    428          	case 4:
    429          		if(USARTClass::check())
    430          		{
    431          			memset(move_point_temp,0,sizeof(move_point_temp));
    432          			sprintf((char*)move_point_temp,"G91\nG1 Z%d\nG90\nG1 X%d Y%d\nG28 Z0\n",gCfgItems.pause_zpos,gCfgItems.leveling_point4_x,gCfgItems.leveling_point4_y);
    433          			for(i=0;i<strlen(move_point_temp);i++)
    434          			{
    435                			_rx_buffer->store_char(move_point_temp[i]) ;
    436          			}
    437          		}		
    438          		break;
    439          	case 5:
    440          		if(USARTClass::check())
    441          		{
    442          			memset(move_point_temp,0,sizeof(move_point_temp));
    443          			sprintf((char*)move_point_temp,"G91\nG1 Z%d\nG90\nG1 X%d Y%d\nG28 Z0\n",gCfgItems.pause_zpos,gCfgItems.leveling_point5_x,gCfgItems.leveling_point5_y);
    444          			for(i=0;i<strlen(move_point_temp);i++)
    445          			{
    446                			_rx_buffer->store_char(move_point_temp[i]) ;
    447          			}
    448          		}		
    449          		break;
    450          	}
    451          #endif        
    452          }
   \                     _ZN10USARTClass20Leveling_move_actionEv: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    453          #endif
    454          
    455          extern uint8_t filamentchange_Process;

   \                                 In section .text, align 2, keep-with-next
    456          void USARTClass::filamentchange(void)
    457          {
   \                     _ZN10USARTClass14filamentchangeEv: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB08D             SUB      SP,SP,#+52
   \   00000004   0x4604             MOV      R4,R0
    458          	uint8_t i;
    459          	char filament_temp[50]={0};
   \   00000006   0xA800             ADD      R0,SP,#+0
   \   00000008   0x2134             MOVS     R1,#+52
   \   0000000A   0x.... 0x....      BL       __aeabi_memclr4
    460          	
    461          	switch(filamentchange_Process)
   \   0000000E   0x....             LDR.N    R0,??DataTable4_4
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD002             BEQ.N    ??filamentchange_0
   \   00000016   0x2802             CMP      R0,#+2
   \   00000018   0xD018             BEQ.N    ??filamentchange_1
   \   0000001A   0xE02F             B.N      ??filamentchange_2
    462          	{
    463          		case 1:
    464          			if(USARTClass::check())
   \                     ??filamentchange_0: (+1)
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       _ZN10USARTClass5checkEv
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD02A             BEQ.N    ??filamentchange_2
    465          			{
    466          				memset(filament_temp,0,sizeof(filament_temp));
   \   00000026   0x2232             MOVS     R2,#+50
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0xA800             ADD      R0,SP,#+0
   \   0000002C   0x.... 0x....      BL       memset
    467          				for(i=0;i<strlen(filament_temp);i++)
   \   00000030   0x2500             MOVS     R5,#+0
   \                     ??filamentchange_3: (+1)
   \   00000032   0xA800             ADD      R0,SP,#+0
   \   00000034   0x.... 0x....      BL       strlen
   \   00000038   0xB2ED             UXTB     R5,R5
   \   0000003A   0x4285             CMP      R5,R0
   \   0000003C   0xD21E             BCS.N    ??filamentchange_2
    468          				{
    469          	      			_rx_buffer->store_char(filament_temp[i]) ;
   \   0000003E   0xA800             ADD      R0,SP,#+0
   \   00000040   0x5C29             LDRB     R1,[R5, R0]
   \   00000042   0x6920             LDR      R0,[R4, #+16]
   \   00000044   0x.... 0x....      BL       _ZN10RingBuffer10store_charEh
    470          				}
   \   00000048   0x1C6D             ADDS     R5,R5,#+1
   \   0000004A   0xE7F2             B.N      ??filamentchange_3
    471          			}	
    472          			break;
    473          		case 2:
    474          		if(USARTClass::check())
   \                     ??filamentchange_1: (+1)
   \   0000004C   0x4620             MOV      R0,R4
   \   0000004E   0x.... 0x....      BL       _ZN10USARTClass5checkEv
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD012             BEQ.N    ??filamentchange_2
    475          		{
    476          			memset(filament_temp,0,sizeof(filament_temp));
   \   00000056   0x2232             MOVS     R2,#+50
   \   00000058   0x2100             MOVS     R1,#+0
   \   0000005A   0xA800             ADD      R0,SP,#+0
   \   0000005C   0x.... 0x....      BL       memset
    477          			for(i=0;i<strlen(filament_temp);i++)
   \   00000060   0x2500             MOVS     R5,#+0
   \   00000062   0xE005             B.N      ??filamentchange_4
    478          			{
    479                			_rx_buffer->store_char(filament_temp[i]) ;
   \                     ??filamentchange_5: (+1)
   \   00000064   0xA800             ADD      R0,SP,#+0
   \   00000066   0x5C29             LDRB     R1,[R5, R0]
   \   00000068   0x6920             LDR      R0,[R4, #+16]
   \   0000006A   0x.... 0x....      BL       _ZN10RingBuffer10store_charEh
    480          			}
   \   0000006E   0x1C6D             ADDS     R5,R5,#+1
   \                     ??filamentchange_4: (+1)
   \   00000070   0xA800             ADD      R0,SP,#+0
   \   00000072   0x.... 0x....      BL       strlen
   \   00000076   0xB2ED             UXTB     R5,R5
   \   00000078   0x4285             CMP      R5,R0
   \   0000007A   0xD3F3             BCC.N    ??filamentchange_5
    481          		}			
    482          			break;
    483          		case 3:
    484          			
    485          			break;
    486          		default:break;
    487          	}
    488          }
   \                     ??filamentchange_2: (+1)
   \   0000007C   0xB00D             ADD      SP,SP,#+52
   \   0000007E   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x........         DC32     _ZTV10USARTClass+0x8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     codebufpoint

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x........         DC32     codebuff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x........         DC32     filamentchange_Process

   \                                 In section .text, align 2
   \   __code __interwork __softfp Print::subobject Print()
   \                     _ZN5PrintC2Ev: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN5PrintC1Ev

   \                                 In section .text, align 2
   \   __code __interwork __softfp Stream::subobject Stream()
   \                     _ZN6StreamC2Ev: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN6StreamC1Ev

   \                                 In section .text, align 2
   \   __code __interwork __softfp HardwareSerial::subobject HardwareSerial()
   \                     _ZN14HardwareSerialC2Ev: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN14HardwareSerialC1Ev

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {'\\000'}>`:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000021   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
    489          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HardwareSerial::HardwareSerial()
         8   -> Stream::subobject Stream()
       0   HardwareSerial::subobject HardwareSerial()
         0   -> HardwareSerial::HardwareSerial()
       0   NVIC_EnableIRQ(IRQn_Type)
       0   Print::Print()
       0   Print::subobject Print()
         0   -> Print::Print()
       8   Stream::Stream()
         8   -> Print::subobject Print()
       0   Stream::subobject Stream()
         0   -> Stream::Stream()
      16   USARTClass::IrqHandler()
         0   -> RingBuffer::store_char(uint8_t)
        16   -> USART_ClearFlag
        16   -> USART_ClearITPendingBit
        16   -> USART_GetFlagStatus
        16   -> USART_GetITStatus
        16   -> USART_ReceiveData
       0   USARTClass::Leveling_move_action()
      24   USARTClass::MoremenuCmd()
        24   -> RingBuffer::store_char(uint8_t)
        24   -> USARTClass::check()
        24   -> memset
      24   USARTClass::USARTClass(USART_TypeDef *, IRQn_Type, uint32_t, RingBuffer *)
        24   -> HardwareSerial::subobject HardwareSerial()
       0   USARTClass::available()
       8   USARTClass::begin(uint32_t)
         8   -> NVIC_EnableIRQ(IRQn_Type)
         0   -> USART_Cmd
         8   -> USART_ITConfig
       0   USARTClass::check()
       0   USARTClass::end()
      64   USARTClass::filamentchange()
        64   -> RingBuffer::store_char(uint8_t)
        64   -> USARTClass::check()
        64   -> __aeabi_memclr4
        64   -> memset
        64   -> strlen
       0   USARTClass::flush()
       0   USARTClass::operator bool()
       0   USARTClass::peek()
       4   USARTClass::read()
      16   USARTClass::subobject USARTClass(USART_TypeDef *, IRQn_Type, uint32_t, RingBuffer *)
        16   -> USARTClass::USARTClass(USART_TypeDef *, IRQn_Type, uint32_t, RingBuffer *)
       8   USARTClass::write(uint8_t)
         8   -> USART_GetFlagStatus
         8   -> USART_SendData


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      52  ?<Constant {'\000'}>
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
      12  HardwareSerial::HardwareSerial()
       4  HardwareSerial::subobject HardwareSerial()
      18  NVIC_EnableIRQ(IRQn_Type)
       6  Print::Print()
       4  Print::subobject Print()
      18  Stream::Stream()
       4  Stream::subobject Stream()
     136  USARTClass::IrqHandler()
       2  USARTClass::Leveling_move_action()
     124  USARTClass::MoremenuCmd()
      34  USARTClass::USARTClass(USART_TypeDef *, IRQn_Type, uint32_t, RingBuffer *)
      26  USARTClass::available()
      36  USARTClass::begin(uint32_t)
      18  USARTClass::check()
       2  USARTClass::end()
     128  USARTClass::filamentchange()
       8  USARTClass::flush()
       4  USARTClass::operator bool()
      20  USARTClass::peek()
      42  USARTClass::read()
      14  USARTClass::subobject USARTClass(USART_TypeDef *, IRQn_Type, uint32_t, RingBuffer *)
      26  USARTClass::write(uint8_t)
      40  -- Other

 
  92 bytes in section .rodata
 706 bytes in section .text
 
 654 bytes of CODE  memory (+ 52 bytes shared)
  52 bytes of CONST memory (+ 40 bytes shared)

Errors: none
Warnings: 35
