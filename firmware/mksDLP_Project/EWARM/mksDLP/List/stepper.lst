###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  11:57:00
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\stepper.cpp
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\stepper.cpp
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --eec++ -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\stepper.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\stepper.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\stepper.cpp
      1          /**
      2           * Marlin 3D Printer Firmware
      3           * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
      4           *
      5           * Based on Sprinter and grbl.
      6           * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
      7           *
      8           * This program is free software: you can redistribute it and/or modify
      9           * it under the terms of the GNU General Public License as published by
     10           * the Free Software Foundation, either version 3 of the License, or
     11           * (at your option) any later version.
     12           *
     13           * This program is distributed in the hope that it will be useful,
     14           * but WITHOUT ANY WARRANTY; without even the implied warranty of
     15           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     16           * GNU General Public License for more details.
     17           *
     18           * You should have received a copy of the GNU General Public License
     19           * along with this program.  If not, see <http://www.gnu.org/licenses/>.
     20           *
     21           */
     22          
     23          /**
     24           * stepper.cpp - A singleton object to execute motion plans using stepper motors
     25           * Marlin Firmware
     26           *
     27           * Derived from Grbl
     28           * Copyright (c) 2009-2011 Simen Svale Skogsrud
     29           *
     30           * Grbl is free software: you can redistribute it and/or modify
     31           * it under the terms of the GNU General Public License as published by
     32           * the Free Software Foundation, either version 3 of the License, or
     33           * (at your option) any later version.
     34           *
     35           * Grbl is distributed in the hope that it will be useful,
     36           * but WITHOUT ANY WARRANTY; without even the implied warranty of
     37           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     38           * GNU General Public License for more details.
     39           *
     40           * You should have received a copy of the GNU General Public License
     41           * along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
     42           */
     43          
     44          /* The timer calculations of this module informed by the 'RepRap cartesian firmware' by Zack Smith
     45             and Philipp Tiefenbacher. */
     46          
     47          #include "Marlin.h"

    #define MIN_SOFTWARE_ENDSTOPS mksCfg.min_software_endstops	/*--mks cfg--*/
            ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\Configuration.h",824  Warning[Pe047]: 
          incompatible redefinition of macro "MIN_SOFTWARE_ENDSTOPS" (declared
          at line 819)

    #define MAX_SOFTWARE_ENDSTOPS mksCfg.max_software_endstops	/*--mks cfg--*/
            ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\Configuration.h",834  Warning[Pe047]: 
          incompatible redefinition of macro "MAX_SOFTWARE_ENDSTOPS" (declared
          at line 829)

  #define UNUSED(x) ((void)(x))
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_def.h",87  Warning[Pe047]: 
          incompatible redefinition of macro "UNUSED" (declared at line 101 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\macros.h")

  		volatile volatile float desireBedTempBak;
  		         ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Inc\mks_cfg.h",351  Warning[Pe083]: 
          type qualifier specified more than once

  #define strcpy_P(dest, src) strcpy((dest), (src))
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",23  Warning[Pe047]: 
          incompatible redefinition of macro "strcpy_P" (declared at line 93
          of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\Marlin_export.h")

  #define strstr_P(a, b) strstr((a), (b))
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",26  Warning[Pe047]: 
          incompatible redefinition of macro "strstr_P" (declared at line 94
          of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\Marlin_export.h")

  #define sprintf_P(s, f, ...) sprintf((s), (f), __VA_ARGS__)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",28  Warning[Pe047]: 
          incompatible redefinition of macro "sprintf_P" (declared at line 95
          of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\Marlin_export.h")

  #define pgm_read_word_near(addr) pgm_read_word(addr)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",38  Warning[Pe047]: 
          incompatible redefinition of macro "pgm_read_word_near" (declared at
          line 65 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\Marlin_export.h")

  #define IS_IWDG_PRESCALER(PRESCALER) (((PRESCALER) == IWDG_Prescaler_4)  || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_iwdg.h",80  Warning[Pe047]: 
          incompatible redefinition of macro "IS_IWDG_PRESCALER" (declared at
          line 209 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_iwdg.h")

  #define IS_IWDG_RELOAD(RELOAD) ((RELOAD) <= 0xFFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_iwdg.h",97  Warning[Pe047]: 
          incompatible redefinition of macro "IS_IWDG_RELOAD" (declared at
          line 222 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_iwdg.h")

  #define IS_FSMC_NORSRAM_BANK(BANK) (((BANK) == FSMC_Bank1_NORSRAM1) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",272  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_NORSRAM_BANK" (declared
          at line 834 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_NAND_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",277  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_NAND_BANK" (declared at
          line 855 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_MUX(MUX) (((MUX) == FSMC_DataAddressMux_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",298  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_MUX" (declared at line
          839 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_MEMORY(MEMORY) (((MEMORY) == FSMC_MemoryType_SRAM) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",311  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_MEMORY" (declared at
          line 842 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_BURSTMODE(STATE) (((STATE) == FSMC_BurstAccessMode_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",336  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_BURSTMODE" (declared at
          line 894 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ASYNWAIT(STATE) (((STATE) == FSMC_AsynchronousWait_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",347  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ASYNWAIT" (declared at
          line 915 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAIT_POLARITY(POLARITY) (((POLARITY) == FSMC_WaitSignalPolarity_Low) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",358  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAIT_POLARITY" (declared
          at line 897 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WRAP_MODE(MODE) (((MODE) == FSMC_WrapMode_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",369  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WRAP_MODE" (declared at
          line 900 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAIT_SIGNAL_ACTIVE(ACTIVE) (((ACTIVE) == FSMC_WaitSignalActive_BeforeWaitState) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",380  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAIT_SIGNAL_ACTIVE"
          (declared at line 903 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WRITE_OPERATION(OPERATION) (((OPERATION) == FSMC_WriteOperation_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",391  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WRITE_OPERATION"
          (declared at line 906 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAITE_SIGNAL(SIGNAL) (((SIGNAL) == FSMC_WaitSignal_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",402  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAITE_SIGNAL" (declared
          at line 909 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_EXTENDED_MODE(MODE) (((MODE) == FSMC_ExtendedMode_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",414  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_EXTENDED_MODE" (declared
          at line 912 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WRITE_BURST(BURST) (((BURST) == FSMC_WriteBurst_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",426  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WRITE_BURST" (declared
          at line 920 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ADDRESS_SETUP_TIME(TIME) ((TIME) <= 0xF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",435  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ADDRESS_SETUP_TIME"
          (declared at line 923 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ADDRESS_HOLD_TIME(TIME) ((TIME) <= 0xF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",443  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ADDRESS_HOLD_TIME"
          (declared at line 925 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_DATASETUP_TIME(TIME) (((TIME) > 0) && ((TIME) <= 0xFF))
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",451  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_DATASETUP_TIME"
          (declared at line 927 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_TURNAROUND_TIME(TIME) ((TIME) <= 0xF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",459  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_TURNAROUND_TIME"
          (declared at line 929 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_CLK_DIV(DIV) ((DIV) <= 0xF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",467  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_CLK_DIV" (declared at
          line 934 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_DATA_LATENCY(LATENCY) ((LATENCY) <= 0xF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",475  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_DATA_LATENCY" (declared
          at line 918 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ACCESS_MODE(MODE) (((MODE) == FSMC_AccessMode_A) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",487  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ACCESS_MODE" (declared
          at line 850 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAIT_FEATURE(FEATURE) (((FEATURE) == FSMC_Waitfeature_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",508  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAIT_FEATURE" (declared
          at line 858 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ECC_STATE(STATE) (((STATE) == FSMC_ECC_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",520  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ECC_STATE" (declared at
          line 864 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ECCPAGE_SIZE(SIZE) (((SIZE) == FSMC_ECCPageSize_256Bytes) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",535  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ECCPAGE_SIZE" (declared
          at line 867 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_TCLR_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",548  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_TCLR_TIME" (declared at
          line 874 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_TAR_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",556  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_TAR_TIME" (declared at
          line 876 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_SETUP_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",564  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_SETUP_TIME" (declared at
          line 878 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAIT_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",572  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAIT_TIME" (declared at
          line 880 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_HOLD_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",580  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_HOLD_TIME" (declared at
          line 882 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_HIZ_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",588  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_HIZ_TIME" (declared at
          line 884 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define FSMC_FLAG_FEMPT                          ((uint32_t)0x00000040)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",613  Warning[Pe047]: 
          incompatible redefinition of macro "FSMC_FLAG_FEMPT" (declared at
          line 530 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

    #define assert_param(expr) ((void)0)        
            ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\stm32f4xx_conf.h",149  Warning[Pe047]: 
          incompatible redefinition of macro "assert_param" (declared at line
          431 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\stm32f4x
          x_hal_conf.h")

   \                                 In section .text, align 4
   \   __interwork __softfp void serialprintPGM(char const *)
   \                     _Z14serialprintPGMPKc: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xE003             B.N      ??serialprintPGM_0
   \                     ??serialprintPGM_1: (+1)
   \   00000006   0xB2C9             UXTB     R1,R1
   \   00000008   0x4803             LDR.N    R0,??serialprintPGM_2
   \   0000000A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??serialprintPGM_0: (+1)
   \   0000000E   0xF914 0x1B01      LDRSB    R1,[R4], #+1
   \   00000012   0x0008             MOVS     R0,R1
   \   00000014   0xD1F7             BNE.N    ??serialprintPGM_1
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
   \                     ??serialprintPGM_2:
   \   00000018   0x........         DC32     Serial6
     48          #include "stepper.h"

   \                                 In section .text, align 4
   \   __interwork __softfp bool Planner::blocks_queued()
   \                     _ZN7Planner13blocks_queuedEv: (+1)
   \   00000000   0x4804             LDR.N    R0,??blocks_queued_0
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4904             LDR.N    R1,??blocks_queued_0+0x4
   \   00000006   0x7809             LDRB     R1,[R1, #+0]
   \   00000008   0x4288             CMP      R0,R1
   \   0000000A   0xD001             BEQ.N    ??blocks_queued_1
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x4770             BX       LR
   \                     ??blocks_queued_1: (+1)
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x4770             BX       LR               ;; return
   \                     ??blocks_queued_0:
   \   00000014   0x........         DC32     _ZN7Planner17block_buffer_headE
   \   00000018   0x........         DC32     _ZN7Planner17block_buffer_tailE

   \                                 In section .text, align 4
   \   __interwork __softfp void Planner::discard_current_block()
   \                     _ZN7Planner21discard_current_blockEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      BL       _ZN7Planner13blocks_queuedEv
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD005             BEQ.N    ??discard_current_block_0
   \   0000000A   0x4803             LDR.N    R0,??discard_current_block_1
   \   0000000C   0x7801             LDRB     R1,[R0, #+0]
   \   0000000E   0x1C49             ADDS     R1,R1,#+1
   \   00000010   0xF001 0x010F      AND      R1,R1,#0xF
   \   00000014   0x7001             STRB     R1,[R0, #+0]
   \                     ??discard_current_block_0: (+1)
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
   \                     ??discard_current_block_1:
   \   00000018   0x........         DC32     _ZN7Planner17block_buffer_tailE

   \                                 In section .text, align 4
   \   __interwork __softfp bool Planner::discard_continued_block()
   \                     _ZN7Planner23discard_continued_blockEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x.... 0x....      BL       _ZN7Planner13blocks_queuedEv
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD00A             BEQ.N    ??discard_continued_block_0
   \   0000000A   0x4809             LDR.N    R0,??discard_continued_block_1
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2154             MOVS     R1,#+84
   \   00000010   0x4A08             LDR.N    R2,??discard_continued_block_1+0x4
   \   00000012   0xFB11 0x2000      SMLABB   R0,R1,R0,R2
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x0900             LSRS     R0,R0,#+4
   \   0000001A   0xF000 0x0401      AND      R4,R0,#0x1
   \   0000001E   0xE000             B.N      ??discard_continued_block_2
   \                     ??discard_continued_block_0: (+1)
   \   00000020   0x2400             MOVS     R4,#+0
   \                     ??discard_continued_block_2: (+1)
   \   00000022   0x2C00             CMP      R4,#+0
   \   00000024   0xD001             BEQ.N    ??discard_continued_block_3
   \   00000026   0x.... 0x....      BL       _ZN7Planner21discard_current_blockEv
   \                     ??discard_continued_block_3: (+1)
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
   \   0000002E   0xBF00             Nop      
   \                     ??discard_continued_block_1:
   \   00000030   0x........         DC32     _ZN7Planner17block_buffer_tailE
   \   00000034   0x........         DC32     _ZN7Planner12block_bufferE

   \                                 In section .text, align 4
   \   __interwork __softfp block_t *Planner::get_current_block()
   \                     _ZN7Planner17get_current_blockEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      BL       _ZN7Planner13blocks_queuedEv
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD00A             BEQ.N    ??get_current_block_0
   \   0000000A   0x4806             LDR.N    R0,??get_current_block_1
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2154             MOVS     R1,#+84
   \   00000010   0x4A05             LDR.N    R2,??get_current_block_1+0x4
   \   00000012   0xFB11 0x2000      SMLABB   R0,R1,R0,R2
   \   00000016   0x7801             LDRB     R1,[R0, #+0]
   \   00000018   0xF041 0x0108      ORR      R1,R1,#0x8
   \   0000001C   0x7001             STRB     R1,[R0, #+0]
   \   0000001E   0xBD02             POP      {R1,PC}
   \                     ??get_current_block_0: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xBD02             POP      {R1,PC}          ;; return
   \                     ??get_current_block_1:
   \   00000024   0x........         DC32     _ZN7Planner17block_buffer_tailE
   \   00000028   0x........         DC32     _ZN7Planner12block_bufferE

      static constexpr int8_t next_block_index(const int8_t block_index) { return BLOCK_MOD(block_index + 1); }
             ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\planner.h",582  Warning[Pe815]: 
          type qualifier on return type is meaningless

      static constexpr int8_t prev_block_index(const int8_t block_index) { return BLOCK_MOD(block_index - 1); }
             ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\planner.h",583  Warning[Pe815]: 
          type qualifier on return type is meaningless

   \                                 In section .text, align 4
   \   __interwork __softfp bool Stepper::motor_direction(AxisEnum)
   \                     _ZN7Stepper15motor_directionE8AxisEnum: (+1)
   \   00000000   0x4905             LDR.N    R1,??motor_direction_0
   \   00000002   0x7909             LDRB     R1,[R1, #+4]
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0xFA02 0xF000      LSL      R0,R2,R0
   \   0000000A   0x4001             ANDS     R1,R0,R1
   \   0000000C   0x4608             MOV      R0,R1
   \   0000000E   0x1E40             SUBS     R0,R0,#+1
   \   00000010   0x4180             SBCS     R0,R0,R0
   \   00000012   0x43C0             MVNS     R0,R0
   \   00000014   0x0FC0             LSRS     R0,R0,#+31
   \   00000016   0x4770             BX       LR               ;; return
   \                     ??motor_direction_0:
   \   00000018   0x........         DC32     _ZN7Stepper15count_directionE

   \                                 In section .text, align 4
   \   __interwork __softfp void Stepper::kill_current_block()
   \                     _ZN7Stepper18kill_current_blockEv: (+1)
   \   00000000   0x4802             LDR.N    R0,??kill_current_block_0
   \   00000002   0x6A01             LDR      R1,[R0, #+32]
   \   00000004   0x6949             LDR      R1,[R1, #+20]
   \   00000006   0x6341             STR      R1,[R0, #+52]
   \   00000008   0x4770             BX       LR               ;; return
   \   0000000A   0xBF00             Nop      
   \                     ??kill_current_block_0:
   \   0000000C   0x........         DC32     _ZN7Stepper15count_directionE

   \                                 In section .text, align 4
   \   __interwork __softfp unsigned short Stepper::calc_timer_interval(unsigned short)
   \                     _ZN7Stepper19calc_timer_intervalEt: (+1)
   \   00000000   0xF649 0x4141      MOVW     R1,#+40001
   \   00000004   0x4288             CMP      R0,R1
   \   00000006   0xDB01             BLT.N    ??calc_timer_interval_0
   \   00000008   0xF649 0x4040      MOVW     R0,#+40000
   \                     ??calc_timer_interval_0: (+1)
   \   0000000C   0x4601             MOV      R1,R0
   \   0000000E   0x4A0E             LDR.N    R2,??calc_timer_interval_1
   \   00000010   0xF644 0x6321      MOVW     R3,#+20001
   \   00000014   0x4299             CMP      R1,R3
   \   00000016   0xDB03             BLT.N    ??calc_timer_interval_2
   \   00000018   0x0880             LSRS     R0,R0,#+2
   \   0000001A   0x2104             MOVS     R1,#+4
   \   0000001C   0x7151             STRB     R1,[R2, #+5]
   \   0000001E   0xE009             B.N      ??calc_timer_interval_3
   \                     ??calc_timer_interval_2: (+1)
   \   00000020   0xF242 0x7311      MOVW     R3,#+10001
   \   00000024   0x4299             CMP      R1,R3
   \   00000026   0xDB03             BLT.N    ??calc_timer_interval_4
   \   00000028   0x0840             LSRS     R0,R0,#+1
   \   0000002A   0x2102             MOVS     R1,#+2
   \   0000002C   0x7151             STRB     R1,[R2, #+5]
   \   0000002E   0xE001             B.N      ??calc_timer_interval_3
   \                     ??calc_timer_interval_4: (+1)
   \   00000030   0x2101             MOVS     R1,#+1
   \   00000032   0x7151             STRB     R1,[R2, #+5]
   \                     ??calc_timer_interval_3: (+1)
   \   00000034   0x4905             LDR.N    R1,??calc_timer_interval_1+0x4  ;; 0xa037a00
   \   00000036   0x2256             MOVS     R2,#+86
   \   00000038   0x4350             MULS     R0,R2,R0
   \   0000003A   0xFB91 0xF0F0      SDIV     R0,R1,R0
   \   0000003E   0xB280             UXTH     R0,R0
   \   00000040   0x2809             CMP      R0,#+9
   \   00000042   0xDA00             BGE.N    ??calc_timer_interval_5
   \   00000044   0x2009             MOVS     R0,#+9
   \                     ??calc_timer_interval_5: (+1)
   \   00000046   0x4770             BX       LR               ;; return
   \                     ??calc_timer_interval_1:
   \   00000048   0x........         DC32     _ZN7Stepper15count_directionE
   \   0000004C   0x0A037A00         DC32     0xa037a00

   \                                 In section .text, align 4
   \   __interwork __softfp void Stepper::trapezoid_generator_reset()
   \                     _ZN7Stepper25trapezoid_generator_resetEv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4C18             LDR.N    R4,??trapezoid_generator_reset_0
   \   00000004   0x6A20             LDR      R0,[R4, #+32]
   \   00000006   0xF890 0x1024      LDRB     R1,[R0, #+36]
   \   0000000A   0x4A17             LDR.N    R2,??trapezoid_generator_reset_0+0x4
   \   0000000C   0x7923             LDRB     R3,[R4, #+4]
   \   0000000E   0x4299             CMP      R1,R3
   \   00000010   0xD104             BNE.N    ??trapezoid_generator_reset_1
   \   00000012   0x7843             LDRB     R3,[R0, #+1]
   \   00000014   0xF992 0x5000      LDRSB    R5,[R2, #+0]
   \   00000018   0x42AB             CMP      R3,R5
   \   0000001A   0xD005             BEQ.N    ??trapezoid_generator_reset_2
   \                     ??trapezoid_generator_reset_1: (+1)
   \   0000001C   0x7121             STRB     R1,[R4, #+4]
   \   0000001E   0xF990 0x0001      LDRSB    R0,[R0, #+1]
   \   00000022   0x7010             STRB     R0,[R2, #+0]
   \   00000024   0x.... 0x....      BL       _ZN7Stepper14set_directionsEv
   \                     ??trapezoid_generator_reset_2: (+1)
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x63E0             STR      R0,[R4, #+60]
   \   0000002C   0x6A25             LDR      R5,[R4, #+32]
   \   0000002E   0x6BE8             LDR      R0,[R5, #+60]
   \   00000030   0xB280             UXTH     R0,R0
   \   00000032   0x.... 0x....      BL       _ZN7Stepper19calc_timer_intervalEt
   \   00000036   0x8160             STRH     R0,[R4, #+10]
   \   00000038   0x7960             LDRB     R0,[R4, #+5]
   \   0000003A   0x71A0             STRB     R0,[R4, #+6]
   \   0000003C   0x6C28             LDR      R0,[R5, #+64]
   \   0000003E   0x81A0             STRH     R0,[R4, #+12]
   \   00000040   0x89A0             LDRH     R0,[R4, #+12]
   \   00000042   0x.... 0x....      BL       _ZN7Stepper19calc_timer_intervalEt
   \   00000046   0x63A0             STR      R0,[R4, #+56]
   \   00000048   0x4808             LDR.N    R0,??trapezoid_generator_reset_0+0x8
   \   0000004A   0x6BA1             LDR      R1,[R4, #+56]
   \   0000004C   0x6802             LDR      R2,[R0, #+0]
   \   0000004E   0x62D1             STR      R1,[R2, #+44]
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0x6AC1             LDR      R1,[R0, #+44]
   \   00000054   0x6A42             LDR      R2,[R0, #+36]
   \   00000056   0x4291             CMP      R1,R2
   \   00000058   0xD202             BCS.N    ??trapezoid_generator_reset_3
   \   0000005A   0x6AC1             LDR      R1,[R0, #+44]
   \   0000005C   0x1E49             SUBS     R1,R1,#+1
   \   0000005E   0x6241             STR      R1,[R0, #+36]
   \                     ??trapezoid_generator_reset_3: (+1)
   \   00000060   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \   00000062   0xBF00             Nop      
   \                     ??trapezoid_generator_reset_0:
   \   00000064   0x........         DC32     _ZN7Stepper15count_directionE
   \   00000068   0x........         DC32     _ZZN7Stepper25trapezoid_generator_resetEvE13last_extruder
   \   0000006C   0x........         DC32     htim2

   \                                 In section .data, align 1
   \   __absolute int8_t Stepper::trapezoid_generator_reset()::last_extruder
   \                     _ZZN7Stepper25trapezoid_generator_resetEvE13last_extruder:
   \   00000000   0xFF               DC8 -1
     49          #include "endstops.h"

   \                                 In section .text, align 4
   \   __interwork __softfp void Endstops::enable(bool)
   \                     _ZN8Endstops6enableEb: (+1)
   \   00000000   0x4901             LDR.N    R1,??enable_0
   \   00000002   0x7008             STRB     R0,[R1, #+0]
   \   00000004   0x4770             BX       LR               ;; return
   \   00000006   0xBF00             Nop      
   \                     ??enable_0:
   \   00000008   0x........         DC32     _ZN8Endstops7enabledE
     50          #include "planner.h"
     51          #include "temperature.h"

        target_temperature[HOTEND_INDEX] = celsius;
                                         ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\temperature.h",397  Warning[Pa093]: 
          implicit conversion from floating point to integer
     52          #include "ultralcd.h"
     53          #include "language.h"
     54          #include "cardreader.h"

  #define SD_DETECT_INVERTED false
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\cardreader.h",27  Warning[Pe047]: 
          incompatible redefinition of macro "SD_DETECT_INVERTED" (declared at
          line 512 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\Configuration_adv.h")

  #define PSTR(s) s
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\cardreader.h",31  Warning[Pe047]: 
          incompatible redefinition of macro "PSTR" (declared at line 63 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\Marlin.h")

  #define pgm_read_byte(x) (*(char*)x)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\cardreader.h",32  Warning[Pe047]: 
          incompatible redefinition of macro "pgm_read_byte" (declared at line
          64 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\Marlin_export.h")

  #define LONG_FILENAME_LENGTH (13*MAX_VFAT_ENTRIES+1)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\cardreader.h",61  Warning[Pe047]: 
          incompatible redefinition of macro "LONG_FILENAME_LENGTH" (declared
          at line 119 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\SdFatConfig.h")

  #define ALLOW_DEPRECATED_FUNCTIONS 0
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\SdFat.h",635  Warning[Pe047]: 
          incompatible redefinition of macro "ALLOW_DEPRECATED_FUNCTIONS"
          (declared at line 67 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\SdFatConfig.h")

  #define SPI_SD_INIT_RATE 11
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\SdFat.h",647  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_SD_INIT_RATE" (declared at
          line 79 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\SdFatConfig.h")

      static bool blocks_queued() { return (block_buffer_head != block_buffer_tail); }
                                    ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\planner.h",504  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement

        _NEXT_ISR(acceleration_time);
        ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\stepper.h",389  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement
     55          #include "mks_cfg.h"
     56          //#include "speed_lookuptable.h"
     57          #include "tim.h"
     58          
     59          #if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(ULTIPANEL)
     60            #include "ubl.h"
     61          #endif
     62          
     63          #if HAS_DIGIPOTSS
     64            #include <SPI.h>
     65          #endif
     66          

   \                                 In section .bss, align 4
     67          Stepper stepper; // Singleton
   \                     stepper:
   \   00000000                      DS8 4
     68          
     69          // public:
     70          
     71          block_t* Stepper::current_block = NULL;  // A pointer to the block currently being traced
     72          
     73          #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
     74            bool Stepper::abort_on_endstop_hit = false;
     75          #endif
     76          
     77          #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
     78            bool Stepper::performing_homing = false;
     79          #endif
     80          
     81          #if HAS_MOTOR_CURRENT_PWM
     82            uint32_t Stepper::motor_current_setting[3]; // Initialized by settings.load()
     83          #endif
     84          
     85          // private:
     86          
     87          uint8_t Stepper::last_direction_bits = 0;        // The next stepping-bits to be output
     88          int16_t Stepper::cleaning_buffer_counter = 0;
     89          
     90          #if ENABLED(X_DUAL_ENDSTOPS)
     91            bool Stepper::locked_x_motor = false, Stepper::locked_x2_motor = false;
     92          #endif
     93          #if ENABLED(Y_DUAL_ENDSTOPS)
     94            bool Stepper::locked_y_motor = false, Stepper::locked_y2_motor = false;
     95          #endif
     96          #if ENABLED(Z_DUAL_ENDSTOPS)
     97            bool Stepper::locked_z_motor = false, Stepper::locked_z2_motor = false;
     98          #endif
     99          
    100          long Stepper::counter_X = 0,
    101               Stepper::counter_Y = 0,
    102               Stepper::counter_Z = 0,
    103               Stepper::counter_E = 0;
    104          
    105          volatile uint32_t Stepper::step_events_completed = 0; // The number of step events executed in the current block
    106          
    107          #if ENABLED(LIN_ADVANCE)
    108          
    109            constexpr uint16_t ADV_NEVER = 65535;
    110          
    111            uint16_t Stepper::nextMainISR = 0,
    112                     Stepper::nextAdvanceISR = ADV_NEVER,
    113                     Stepper::eISR_Rate = ADV_NEVER;
    114          
    115            volatile int Stepper::e_steps[E_STEPPERS];
    116            int Stepper::final_estep_rate,
    117                Stepper::current_estep_rate[E_STEPPERS],
    118                Stepper::current_adv_steps[E_STEPPERS];
    119          
    120            /**
    121             * See https://github.com/MarlinFirmware/Marlin/issues/5699#issuecomment-309264382
    122             *
    123             * This fix isn't perfect and may lose steps - but better than locking up completely
    124             * in future the planner should slow down if advance stepping rate would be too high
    125             */
    126            FORCE_INLINE uint16_t adv_rate(const int steps, const uint16_t timer, const uint8_t loops) {
    127              if (steps) {
    128                const uint16_t rate = (timer * loops) / abs(steps);
    129                //return constrain(rate, 1, ADV_NEVER - 1)
    130                return rate ? rate : 1;
    131              }
    132              return ADV_NEVER;
    133            }
    134          
    135          #endif // LIN_ADVANCE
    136          
    137          long Stepper::acceleration_time, Stepper::deceleration_time;
    138          
    139          volatile long Stepper::count_position[NUM_AXIS] = { 0 };
    140          volatile signed char Stepper::count_direction[NUM_AXIS] = { 1, 1, 1, 1 };
    141          
    142          #if ENABLED(MIXING_EXTRUDER)
    143            long Stepper::counter_m[MIXING_STEPPERS];
    144          #endif
    145          
    146          uint8_t Stepper::step_loops, Stepper::step_loops_nominal;
    147          
    148          uint16_t Stepper::OCR1A_nominal,
    149                   Stepper::acc_step_rate; // needed for deceleration start point
    150          
    151          volatile long Stepper::endstops_trigsteps[XYZ];
    152          
    153          #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
    154            #define LOCKED_X_MOTOR  locked_x_motor
    155            #define LOCKED_Y_MOTOR  locked_y_motor
    156            #define LOCKED_Z_MOTOR  locked_z_motor
    157            #define LOCKED_X2_MOTOR locked_x2_motor
    158            #define LOCKED_Y2_MOTOR locked_y2_motor
    159            #define LOCKED_Z2_MOTOR locked_z2_motor
    160            #define DUAL_ENDSTOP_APPLY_STEP(AXIS,v)                                                                                                             \
    161              if (performing_homing) {                                                                                                                          \
    162                if (AXIS##_HOME_DIR < 0) {                                                                                                                      \
    163                  if (!(TEST(endstops.old_endstop_bits, AXIS##_MIN) && (count_direction[AXIS##_AXIS] < 0)) && !LOCKED_##AXIS##_MOTOR) AXIS##_STEP_WRITE(v);     \
    164                  if (!(TEST(endstops.old_endstop_bits, AXIS##2_MIN) && (count_direction[AXIS##_AXIS] < 0)) && !LOCKED_##AXIS##2_MOTOR) AXIS##2_STEP_WRITE(v);  \
    165                }                                                                                                                                               \
    166                else {                                                                                                                                          \
    167                  if (!(TEST(endstops.old_endstop_bits, AXIS##_MAX) && (count_direction[AXIS##_AXIS] > 0)) && !LOCKED_##AXIS##_MOTOR) AXIS##_STEP_WRITE(v);     \
    168                  if (!(TEST(endstops.old_endstop_bits, AXIS##2_MAX) && (count_direction[AXIS##_AXIS] > 0)) && !LOCKED_##AXIS##2_MOTOR) AXIS##2_STEP_WRITE(v);  \
    169                }                                                                                                                                               \
    170              }                                                                                                                                                 \
    171              else {                                                                                                                                            \
    172                AXIS##_STEP_WRITE(v);                                                                                                                           \
    173                AXIS##2_STEP_WRITE(v);                                                                                                                          \
    174              }
    175          #endif
    176          
    177          #if ENABLED(X_DUAL_STEPPER_DRIVERS)
    178            #define X_APPLY_DIR(v,Q) do{ X_DIR_WRITE(v); X2_DIR_WRITE((v) != INVERT_X2_VS_X_DIR); }while(0)
    179            #if ENABLED(DUAL_X_CARRIAGE)
    180              #define X_APPLY_DIR(v,ALWAYS) \
    181                if (extruder_duplication_enabled || ALWAYS) { \
    182                  X_DIR_WRITE(v); \
    183                  X2_DIR_WRITE(v); \
    184                } \
    185                else { \
    186                  if (current_block->active_extruder) X2_DIR_WRITE(v); else X_DIR_WRITE(v); \
    187                }
    188              #define X_APPLY_STEP(v,ALWAYS) \
    189                if (extruder_duplication_enabled || ALWAYS) { \
    190                  X_STEP_WRITE(v); \
    191                  X2_STEP_WRITE(v); \
    192                } \
    193                else { \
    194                  if (current_block->active_extruder) X2_STEP_WRITE(v); else X_STEP_WRITE(v); \
    195                }
    196            #elif ENABLED(X_DUAL_ENDSTOPS)
    197              #define X_APPLY_STEP(v,Q) DUAL_ENDSTOP_APPLY_STEP(X,v)
    198            #else
    199              #define X_APPLY_STEP(v,Q) do{ X_STEP_WRITE(v); X2_STEP_WRITE(v); }while(0)
    200            #endif
    201          #else
    202            #define X_APPLY_DIR(v,Q) X_DIR_WRITE(v)
    203            #define X_APPLY_STEP(v,Q) X_STEP_WRITE(v)
    204          #endif
    205          
    206          #if ENABLED(Y_DUAL_STEPPER_DRIVERS)
    207            #define Y_APPLY_DIR(v,Q) do{ Y_DIR_WRITE(v); Y2_DIR_WRITE((v) != INVERT_Y2_VS_Y_DIR); }while(0)
    208            #if ENABLED(Y_DUAL_ENDSTOPS)
    209              #define Y_APPLY_STEP(v,Q) DUAL_ENDSTOP_APPLY_STEP(Y,v)
    210            #else
    211              #define Y_APPLY_STEP(v,Q) do{ Y_STEP_WRITE(v); Y2_STEP_WRITE(v); }while(0)
    212            #endif
    213          #else
    214            #define Y_APPLY_DIR(v,Q) Y_DIR_WRITE(v)
    215            #define Y_APPLY_STEP(v,Q) Y_STEP_WRITE(v)
    216          #endif
    217          
    218          #if ENABLED(Z_DUAL_STEPPER_DRIVERS)
    219            #define Z_APPLY_DIR(v,Q) do{ Z_DIR_WRITE(v); Z2_DIR_WRITE(v); }while(0)
    220            #if ENABLED(Z_DUAL_ENDSTOPS)
    221              #define Z_APPLY_STEP(v,Q) DUAL_ENDSTOP_APPLY_STEP(Z,v)
    222            #else
    223              #define Z_APPLY_STEP(v,Q) do{ Z_STEP_WRITE(v); Z2_STEP_WRITE(v); }while(0)
    224            #endif
    225          #else
    226            #define Z_APPLY_DIR(v,Q) Z_DIR_WRITE(v)
    227            #define Z_APPLY_STEP(v,Q) Z_STEP_WRITE(v)
    228          #endif
    229          
    230          #if DISABLED(MIXING_EXTRUDER)
    231            #define E_APPLY_STEP(v,Q) E_STEP_WRITE(v)
    232          #endif
    233          
    234          // intRes = longIn1 * longIn2 >> 24
    235          // uses:
    236          // r26 to store 0
    237          // r27 to store bits 16-23 of the 48bit result. The top bit is used to round the two byte result.
    238          // note that the lower two bytes and the upper byte of the 48bit result are not calculated.
    239          // this can cause the result to be out by one as the lower bytes may cause carries into the upper ones.
    240          // B0 A0 are bits 24-39 and are the returned value
    241          // C1 B1 A1 is longIn1
    242          // D2 C2 B2 A2 is longIn2
    243          //
    244          #define MultiU24X32toH16(intRes, longIn1, longIn2)  intRes = (uint16_t)((((uint64_t)longIn1 * (uint64_t)longIn2)>> 24)& 0XFFFF);
    245          /*
    246          #define MultiU24X32toH16(intRes, longIn1, longIn2) \
    247            asm volatile ( \
    248                           "clr r26 \n\t" \
    249                           "mul %A1, %B2 \n\t" \
    250                           "mov r27, r1 \n\t" \
    251                           "mul %B1, %C2 \n\t" \
    252                           "movw %A0, r0 \n\t" \
    253                           "mul %C1, %C2 \n\t" \
    254                           "add %B0, r0 \n\t" \
    255                           "mul %C1, %B2 \n\t" \
    256                           "add %A0, r0 \n\t" \
    257                           "adc %B0, r1 \n\t" \
    258                           "mul %A1, %C2 \n\t" \
    259                           "add r27, r0 \n\t" \
    260                           "adc %A0, r1 \n\t" \
    261                           "adc %B0, r26 \n\t" \
    262                           "mul %B1, %B2 \n\t" \
    263                           "add r27, r0 \n\t" \
    264                           "adc %A0, r1 \n\t" \
    265                           "adc %B0, r26 \n\t" \
    266                           "mul %C1, %A2 \n\t" \
    267                           "add r27, r0 \n\t" \
    268                           "adc %A0, r1 \n\t" \
    269                           "adc %B0, r26 \n\t" \
    270                           "mul %B1, %A2 \n\t" \
    271                           "add r27, r1 \n\t" \
    272                           "adc %A0, r26 \n\t" \
    273                           "adc %B0, r26 \n\t" \
    274                           "lsr r27 \n\t" \
    275                           "adc %A0, r26 \n\t" \
    276                           "adc %B0, r26 \n\t" \
    277                           "mul %D2, %A1 \n\t" \
    278                           "add %A0, r0 \n\t" \
    279                           "adc %B0, r1 \n\t" \
    280                           "mul %D2, %B1 \n\t" \
    281                           "add %B0, r0 \n\t" \
    282                           "clr r1 \n\t" \
    283                           : \
    284                           "=&r" (intRes) \
    285                           : \
    286                           "d" (longIn1), \
    287                           "d" (longIn2) \
    288                           : \
    289                           "r26" , "r27" \
    290                         )
    291          */
    292          // Some useful constants
    293          
    294          /**
    295           *         __________________________
    296           *        /|                        |\     _________________         ^
    297           *       / |                        | \   /|               |\        |
    298           *      /  |                        |  \ / |               | \       s
    299           *     /   |                        |   |  |               |  \      p
    300           *    /    |                        |   |  |               |   \     e
    301           *   +-----+------------------------+---+--+---------------+----+    e
    302           *   |               BLOCK 1            |      BLOCK 2          |    d
    303           *
    304           *                           time ----->
    305           *
    306           *  The trapezoid is the shape the speed curve over time. It starts at block->initial_rate, accelerates
    307           *  first block->accelerate_until step_events_completed, then keeps going at constant speed until
    308           *  step_events_completed reaches block->decelerate_after after which it decelerates until the trapezoid generator is reset.
    309           *  The slope of acceleration is calculated using v = u + at where t is the accumulated timer values of the steps so far.
    310           */

   \                                 In section .text, align 2, keep-with-next
    311          void Stepper::wake_up() {
    312            // TCNT1 = 0;
    313            ENABLE_STEPPER_DRIVER_INTERRUPT();
   \                     _ZN7Stepper7wake_upEv: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   00000004   0x.... 0x....      B.W      HAL_TIM_Base_Start_IT
    314          }
    315          
    316          /**
    317           * Set the stepper direction of each axis
    318           *
    319           *   COREXY: X_AXIS=A_AXIS and Y_AXIS=B_AXIS
    320           *   COREXZ: X_AXIS=A_AXIS and Z_AXIS=C_AXIS
    321           *   COREYZ: Y_AXIS=B_AXIS and Z_AXIS=C_AXIS
    322           */

   \                                 In section .text, align 2, keep-with-next
    323          void Stepper::set_directions() {
   \                     _ZN7Stepper14set_directionsEv: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    324          #if 1
    325          
    326              if (motor_direction(Z_AXIS)) { 
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   00000006   0x6804             LDR      R4,[R0, #+0]
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable14_3
   \   0000000C   0x8805             LDRH     R5,[R0, #+0]
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable14_4
   \   00000012   0x7806             LDRB     R6,[R0, #+0]
   \   00000014   0x.... 0x....      LDR.W    R7,??DataTable14_5
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD009             BEQ.N    ??set_directions_0
    327                Z_APPLY_DIR(INVERT_Z_DIR, false);
   \   00000022   0x4632             MOV      R2,R6
   \   00000024   0xB252             SXTB     R2,R2
   \   00000026   0x4629             MOV      R1,R5
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       HAL_GPIO_WritePin
    328                count_direction[Z_AXIS] = -1; 
   \   0000002E   0xF04F 0x30FF      MOV      R0,#-1
   \   00000032   0x70B8             STRB     R0,[R7, #+2]
   \   00000034   0xBDF1             POP      {R0,R4-R7,PC}
    329              } 
    330              else {
    331                Z_APPLY_DIR(!INVERT_Z_DIR, false); 
   \                     ??set_directions_0: (+1)
   \   00000036   0x1E72             SUBS     R2,R6,#+1
   \   00000038   0x4192             SBCS     R2,R2,R2
   \   0000003A   0x0FD2             LSRS     R2,R2,#+31
   \   0000003C   0xB252             SXTB     R2,R2
   \   0000003E   0x4629             MOV      R1,R5
   \   00000040   0x4620             MOV      R0,R4
   \   00000042   0x.... 0x....      BL       HAL_GPIO_WritePin
    332                count_direction[Z_AXIS] = 1;
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0x70B8             STRB     R0,[R7, #+2]
    333              }
    334            
    335          #else
    336          
    337            #define SET_STEP_DIR(AXIS) \
    338              if (motor_direction(AXIS ##_AXIS)) { \
    339                AXIS ##_APPLY_DIR(INVERT_## AXIS ##_DIR, false); \
    340                count_direction[AXIS ##_AXIS] = -1; \
    341              } \
    342              else { \
    343                AXIS ##_APPLY_DIR(!INVERT_## AXIS ##_DIR, false); \
    344                count_direction[AXIS ##_AXIS] = 1; \
    345              }
    346          
    347            #if HAS_X_DIR
    348              SET_STEP_DIR(X); // A
    349            #endif
    350            #if HAS_Y_DIR
    351              SET_STEP_DIR(Y); // B
    352            #endif
    353            #if HAS_Z_DIR
    354              SET_STEP_DIR(Z); // C
    355            #endif
    356          
    357            #if DISABLED(LIN_ADVANCE)
    358              if (motor_direction(E_AXIS)) {
    359                REV_E_DIR();
    360                count_direction[E_AXIS] = -1;
    361              }
    362              else {
    363                NORM_E_DIR();
    364                count_direction[E_AXIS] = 1;
    365              }
    366            #endif // !LIN_ADVANCE
    367          
    368          #endif
    369          }
   \   0000004A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    370          
    371          #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
    372            extern volatile uint8_t e_hit;
    373          #endif
    374          
    375          /**
    376           * Stepper Driver Interrupt
    377           *
    378           * Directly pulses the stepper motors at high frequency.
    379           * Timer 1 runs at a base frequency of 2MHz, with this ISR using OCR1A compare mode.
    380           *
    381           * OCR1A   Frequency
    382           *     1     2 MHz
    383           *    50    40 KHz
    384           *   100    20 KHz - capped max rate
    385           *   200    10 KHz - nominal max rate
    386           *  2000     1 KHz - sleep rate
    387           *  4000   500  Hz - init rate
    388           */
    389           /*
    390          ISR(TIMER1_COMPA_vect) {
    391            #if ENABLED(LIN_ADVANCE)
    392              Stepper::advance_isr_scheduler();
    393            #else
    394              Stepper::isr();
    395            #endif
    396          }
    397          */
    398          
    399          //#define _ENABLE_ISRs() do { cli(); if (thermalManager.in_temp_isr) CBI(TIMSK0, OCIE0B); else SBI(TIMSK0, OCIE0B); ENABLE_STEPPER_DRIVER_INTERRUPT(); } while(0)
    400          #define _ENABLE_ISRs() do { sei(); if (thermalManager.in_temp_isr) HAL_TIM_Base_Stop_IT(&htim4); else HAL_TIM_Base_Start_IT(&htim4); ENABLE_STEPPER_DRIVER_INTERRUPT(); } while(0)
    401          

   \                                 In section .text, align 4, keep-with-next
    402          void IsrStepperHandler() { 
   \                     IsrStepperHandler: (+1)
   \   00000000   0xBF00             Nop      
   \   00000002   0xBF00             Nop      
    403          #if ENABLED(ADVANCE) || ENABLED(LIN_ADVANCE)
    404          		Stepper::advance_isr_scheduler();
    405          #else
    406          		Stepper::StepperHandler(); 
   \   00000004                      REQUIRE _ZN7Stepper14StepperHandlerEv
   \   00000004                      ;; // Fall through to label Stepper::StepperHandler()
    407          #endif
    408            }
    409          

   \                                 In section .text, align 4, keep-with-next
    410          void Stepper::StepperHandler() {
   \                     _ZN7Stepper14StepperHandlerEv: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
    411          
    412          
    413            uint16_t ocr_val;
    414          
    415            #define ENDSTOP_NOMINAL_OCR_VAL 3000 // Check endstops every 1.5ms to guarantee two stepper ISRs within 5ms for BLTouch
    416            #define OCR_VAL_TOLERANCE       1000 // First max delay is 2.0ms, last min delay is 0.5ms, all others 1.5ms
    417          
    418            #if DISABLED(LIN_ADVANCE)
    419              // Disable Timer0 ISRs and enable global ISR again to capture UART events (incoming chars)
    420              //CBI(TIMSK0, OCIE0B); // Temperature ISR
    421              HAL_TIM_Base_Stop_IT(&htim4);		//1??2a???D???
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable14_6
   \   00000008   0x4628             MOV      R0,R5
   \   0000000A   0x.... 0x....      BL       HAL_TIM_Base_Stop_IT
    422              DISABLE_STEPPER_DRIVER_INTERRUPT();
   \   0000000E   0x.... 0x....      LDR.W    R4,??DataTable14_1
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       HAL_TIM_Base_Stop_IT
    423              sei();
   \   00000018   0xB662             cpsie i
    424            #endif
    425          
    426            #define _SPLIT(L) (ocr_val = (uint16_t)L)
    427            #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
    428          
    429              #define SPLIT(L) _SPLIT(L)
    430          
    431            #else // !ENDSTOP_INTERRUPTS_FEATURE : Sample endstops between stepping ISRs
    432          
    433              static uint32_t step_remaining = 0;
    434          
    435              #define SPLIT(L) do { \
    436                _SPLIT(L); \
    437                if (ENDSTOPS_ENABLED && L > ENDSTOP_NOMINAL_OCR_VAL) { \
    438                  const uint16_t remainder = (uint16_t)L % (ENDSTOP_NOMINAL_OCR_VAL); \
    439                  ocr_val = (remainder < OCR_VAL_TOLERANCE) ? ENDSTOP_NOMINAL_OCR_VAL + remainder : ENDSTOP_NOMINAL_OCR_VAL; \
    440                  step_remaining = (uint16_t)L - ocr_val; \
    441                } \
    442              }while(0)
    443          
    444              if (step_remaining && ENDSTOPS_ENABLED) {   // Just check endstops - not yet time for a step
   \   0000001A   0x.... 0x....      LDR.W    R6,??DataTable14_5
   \   0000001E   0x6CF0             LDR      R0,[R6, #+76]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD032             BEQ.N    ??StepperHandler_0
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable14_7
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD02D             BEQ.N    ??StepperHandler_0
    445                endstops.update();
   \   0000002E   0x.... 0x....      BL       _ZN8Endstops6updateEv
    446          
    447                // Next ISR either for endstops or stepping
    448                ocr_val = step_remaining <= ENDSTOP_NOMINAL_OCR_VAL ? step_remaining : ENDSTOP_NOMINAL_OCR_VAL;
   \   00000032   0x6CF0             LDR      R0,[R6, #+76]
   \   00000034   0xF640 0x31B9      MOVW     R1,#+3001
   \   00000038   0x4288             CMP      R0,R1
   \   0000003A   0xD201             BCS.N    ??StepperHandler_1
   \   0000003C   0x4601             MOV      R1,R0
   \   0000003E   0xE001             B.N      ??StepperHandler_2
   \                     ??StepperHandler_1: (+1)
   \   00000040   0xF640 0x31B8      MOVW     R1,#+3000
    449                step_remaining -= ocr_val;
   \                     ??StepperHandler_2: (+1)
   \   00000044   0xB289             UXTH     R1,R1
   \   00000046   0x1A40             SUBS     R0,R0,R1
   \   00000048   0x64F0             STR      R0,[R6, #+76]
    450                _NEXT_ISR(ocr_val);
                       ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x62C1             STR      R1,[R0, #+44]
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0x6AC1             LDR      R1,[R0, #+44]
   \   00000052   0x6A42             LDR      R2,[R0, #+36]
   \   00000054   0x4291             CMP      R1,R2
   \   00000056   0xD202             BCS.N    ??StepperHandler_3
   \   00000058   0x6AC1             LDR      R1,[R0, #+44]
   \   0000005A   0x1E49             SUBS     R1,R1,#+1
   \   0000005C   0x6241             STR      R1,[R0, #+36]
    451                NOLESS(OCR1A, TCNT1 + 16);
                       ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \                     ??StepperHandler_3: (+1)
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x6AC1             LDR      R1,[R0, #+44]
   \   00000062   0x6A42             LDR      R2,[R0, #+36]
   \   00000064   0x3210             ADDS     R2,R2,#+16
   \   00000066   0x4291             CMP      R1,R2
   \   00000068   0xD202             BCS.N    ??StepperHandler_4
   \   0000006A   0x6A41             LDR      R1,[R0, #+36]
   \   0000006C   0x3110             ADDS     R1,R1,#+16
   \   0000006E   0x62C1             STR      R1,[R0, #+44]
    452                _ENABLE_ISRs(); // re-enable ISRs
   \                     ??StepperHandler_4: (+1)
   \   00000070   0xB662             cpsie i
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable14_8
   \   00000076   0x7800             LDRB     R0,[R0, #+0]
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0x4628             MOV      R0,R5
   \   0000007C   0xD002             BEQ.N    ??StepperHandler_5
   \   0000007E   0x.... 0x....      BL       HAL_TIM_Base_Stop_IT
   \   00000082   0xE191             B.N      ??StepperHandler_6
   \                     ??StepperHandler_5: (+1)
   \   00000084   0x.... 0x....      BL       HAL_TIM_Base_Start_IT
   \   00000088   0xE18E             B.N      ??StepperHandler_6
    453                return;
    454              }
    455          
    456            #endif // !ENDSTOP_INTERRUPTS_FEATURE
    457          
    458            //
    459            // When cleaning, discard the current block and run fast
    460            //
    461            if (cleaning_buffer_counter) {
   \                     ??StepperHandler_0: (+1)
   \   0000008A   0xF9B6 0x7008      LDRSH    R7,[R6, #+8]
   \   0000008E   0x2F00             CMP      R7,#+0
   \   00000090   0xD031             BEQ.N    ??StepperHandler_7
    462              if (cleaning_buffer_counter < 0) {          // Count up for endstop hit
   \   00000092   0xD50B             BPL.N    ??StepperHandler_8
    463                if (current_block) planner.discard_current_block(); // Discard the active block that led to the trigger
   \   00000094   0x6A30             LDR      R0,[R6, #+32]
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD001             BEQ.N    ??StepperHandler_9
   \   0000009A   0x.... 0x....      BL       _ZN7Planner21discard_current_blockEv
    464                if (!planner.discard_continued_block())   // Discard next CONTINUED block
   \                     ??StepperHandler_9: (+1)
   \   0000009E   0x.... 0x....      BL       _ZN7Planner23discard_continued_blockEv
   \   000000A2   0x2800             CMP      R0,#+0
   \   000000A4   0xD10D             BNE.N    ??StepperHandler_10
    465                  cleaning_buffer_counter = 0;            // Keep discarding until non-CONTINUED
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0x8130             STRH     R0,[R6, #+8]
   \   000000AA   0xE00A             B.N      ??StepperHandler_10
    466              }
    467              else {
    468                planner.discard_current_block();
   \                     ??StepperHandler_8: (+1)
   \   000000AC   0x.... 0x....      BL       _ZN7Planner21discard_current_blockEv
    469                --cleaning_buffer_counter;                // Count down for abort print
   \   000000B0   0x1E78             SUBS     R0,R7,#+1
   \   000000B2   0x8130             STRH     R0,[R6, #+8]
    470                #if ENABLED(SD_FINISHED_STEPPERRELEASE) && defined(SD_FINISHED_RELEASECOMMAND)
    471                  if (!cleaning_buffer_counter) enqueue_and_echo_commands_P(PSTR(SD_FINISHED_RELEASECOMMAND));
   \   000000B4   0xB200             SXTH     R0,R0
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD103             BNE.N    ??StepperHandler_10
   \   000000BA   0x.... 0x....      ADR.W    R0,`?<Constant "M84 X Y Z E">`
   \   000000BE   0x.... 0x....      BL       _Z27enqueue_and_echo_commands_PPKc
    472                #endif
    473              }
    474              current_block = NULL;                       // Prep to get a new block after cleaning
   \                     ??StepperHandler_10: (+1)
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0x6230             STR      R0,[R6, #+32]
    475              _NEXT_ISR(200);                             // Run at max speed - 10 KHz
                     ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \   000000C6   0x20C8             MOVS     R0,#+200
   \   000000C8   0x6821             LDR      R1,[R4, #+0]
   \   000000CA   0x62C8             STR      R0,[R1, #+44]
   \   000000CC   0x6820             LDR      R0,[R4, #+0]
   \   000000CE   0x6AC1             LDR      R1,[R0, #+44]
   \   000000D0   0x6A42             LDR      R2,[R0, #+36]
   \   000000D2   0x4291             CMP      R1,R2
   \   000000D4   0xD202             BCS.N    ??StepperHandler_11
   \   000000D6   0x6AC1             LDR      R1,[R0, #+44]
   \   000000D8   0x1E49             SUBS     R1,R1,#+1
   \   000000DA   0x6241             STR      R1,[R0, #+36]
    476              _ENABLE_ISRs();
   \                     ??StepperHandler_11: (+1)
   \   000000DC   0xB662             cpsie i
   \   000000DE   0x.... 0x....      LDR.W    R0,??DataTable14_8
   \   000000E2   0x7800             LDRB     R0,[R0, #+0]
   \   000000E4   0x2800             CMP      R0,#+0
   \   000000E6   0x4628             MOV      R0,R5
   \   000000E8   0xD002             BEQ.N    ??StepperHandler_12
   \   000000EA   0x.... 0x....      BL       HAL_TIM_Base_Stop_IT
   \   000000EE   0xE15B             B.N      ??StepperHandler_6
   \                     ??StepperHandler_12: (+1)
   \   000000F0   0x.... 0x....      BL       HAL_TIM_Base_Start_IT
   \   000000F4   0xE158             B.N      ??StepperHandler_6
    477              return;
    478            }
    479          
    480            // If there is no current block, attempt to pop one from the buffer
    481            if (!current_block) {
   \                     ??StepperHandler_7: (+1)
   \   000000F6   0x6A30             LDR      R0,[R6, #+32]
   \   000000F8   0x2800             CMP      R0,#+0
   \   000000FA   0xD111             BNE.N    ??StepperHandler_13
    482              // Anything in the buffer?
    483              if ((current_block = planner.get_current_block())) {
   \   000000FC   0x.... 0x....      BL       _ZN7Planner17get_current_blockEv
   \   00000100   0x6230             STR      R0,[R6, #+32]
   \   00000102   0x2800             CMP      R0,#+0
   \   00000104   0xF000 0x80A4      BEQ.W    ??StepperHandler_14
    484                trapezoid_generator_reset();
   \   00000108   0x.... 0x....      BL       _ZN7Stepper25trapezoid_generator_resetEv
    485          
    486                // Initialize Bresenham counters to 1/2 the ceiling
    487                counter_X = counter_Y = counter_Z = counter_E = -(current_block->step_event_count >> 1);
   \   0000010C   0x6A30             LDR      R0,[R6, #+32]
   \   0000010E   0x6940             LDR      R0,[R0, #+20]
   \   00000110   0x0840             LSRS     R0,R0,#+1
   \   00000112   0x4240             RSBS     R0,R0,#+0
   \   00000114   0x6330             STR      R0,[R6, #+48]
   \   00000116   0x62F0             STR      R0,[R6, #+44]
   \   00000118   0x62B0             STR      R0,[R6, #+40]
   \   0000011A   0x6270             STR      R0,[R6, #+36]
    488          
    489                #if ENABLED(MIXING_EXTRUDER)
    490                  MIXING_STEPPERS_LOOP(i)
    491                    counter_m[i] = -(current_block->mix_event_count[i] >> 1);
    492                #endif
    493          
    494                step_events_completed = 0;
   \   0000011C   0x2000             MOVS     R0,#+0
   \   0000011E   0x6370             STR      R0,[R6, #+52]
    495          
    496                #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
    497                  e_hit = 2; // Needed for the case an endstop is already triggered before the new move begins.
    498                             // No 'change' can be detected.
    499                #endif
    500          
    501                #if ENABLED(Z_LATE_ENABLE)
    502                  if (current_block->steps[Z_AXIS] > 0) {
    503                    enable_Z();
    504                    _NEXT_ISR(2000); // Run at slow speed - 1 KHz
    505                    _ENABLE_ISRs(); // re-enable ISRs
    506                    return;
    507                  }
    508                #endif
    509              }
    510              else {
    511                _NEXT_ISR(2000); // Run at slow speed - 1 KHz
                       ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
    512                _ENABLE_ISRs(); // re-enable ISRs
    513                return;
    514              }
    515            }
    516          
    517            // Update endstops state, if enabled
    518            #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
    519              if (e_hit && ENDSTOPS_ENABLED) {
    520                endstops.update();
    521                e_hit--;
    522              }
    523            #else
    524              if (ENDSTOPS_ENABLED) 
   \                     ??StepperHandler_13: (+1)
   \   00000120   0x.... 0x....      LDR.W    R8,??DataTable14_7
   \   00000124   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   00000128   0x2800             CMP      R0,#+0
   \   0000012A   0xD001             BEQ.N    ??StepperHandler_15
    525          		endstops.update();
   \   0000012C   0x.... 0x....      BL       _ZN8Endstops6updateEv
    526            #endif
    527          
    528            // Take multiple steps per interrupt (For high speed moves)
    529            bool all_steps_done = false;
   \                     ??StepperHandler_15: (+1)
   \   00000130   0x2700             MOVS     R7,#+0
    530            for (uint8_t i = step_loops; i--;) {
   \   00000132   0xF896 0x9005      LDRB     R9,[R6, #+5]
   \                     ??StepperHandler_16: (+1)
   \   00000136   0x4648             MOV      R0,R9
   \   00000138   0xF1A0 0x0901      SUB      R9,R0,#+1
   \   0000013C   0xB2C0             UXTB     R0,R0
   \   0000013E   0x2800             CMP      R0,#+0
   \   00000140   0xD055             BEQ.N    ??StepperHandler_17
    531              #if ENABLED(LIN_ADVANCE)
    532          
    533                counter_E += current_block->steps[E_AXIS];
    534                if (counter_E > 0) {
    535                  counter_E -= current_block->step_event_count;
    536                  #if DISABLED(MIXING_EXTRUDER)
    537                    // Don't step E here for mixing extruder
    538                    count_position[E_AXIS] += count_direction[E_AXIS];
    539                    motor_direction(E_AXIS) ? --e_steps[TOOL_E_INDEX] : ++e_steps[TOOL_E_INDEX];
    540                  #endif
    541                }
    542          
    543                #if ENABLED(MIXING_EXTRUDER)
    544                  // Step mixing steppers proportionally
    545                  const bool dir = motor_direction(E_AXIS);
    546                  MIXING_STEPPERS_LOOP(j) {
    547                    counter_m[j] += current_block->steps[E_AXIS];
    548                    if (counter_m[j] > 0) {
    549                      counter_m[j] -= current_block->mix_event_count[j];
    550                      dir ? --e_steps[j] : ++e_steps[j];
    551                    }
    552                  }
    553                #endif
    554          
    555              #endif // LIN_ADVANCE
    556          
    557              #define _COUNTER(AXIS) counter_## AXIS
    558              #define _APPLY_STEP(AXIS) AXIS ##_APPLY_STEP
    559              #define _INVERT_STEP_PIN(AXIS) INVERT_## AXIS ##_STEP_PIN
    560          
    561              // Advance the Bresenham counter; start a pulse if the axis needs a step
    562              #define PULSE_START(AXIS) \
    563                _COUNTER(AXIS) += current_block->steps[_AXIS(AXIS)]; \
    564                if (_COUNTER(AXIS) > 0) { _APPLY_STEP(AXIS)(!_INVERT_STEP_PIN(AXIS),0); }
    565          
    566              // Stop an active pulse, reset the Bresenham counter, update the position
    567              #define PULSE_STOP(AXIS) \
    568                if (_COUNTER(AXIS) > 0) { \
    569                  _COUNTER(AXIS) -= current_block->step_event_count; \
    570                  count_position[_AXIS(AXIS)] += count_direction[_AXIS(AXIS)]; \
    571                  _APPLY_STEP(AXIS)(_INVERT_STEP_PIN(AXIS),0); \
    572                }
    573          
    574              /**
    575               * Estimate the number of cycles that the stepper logic already takes
    576               * up between the start and stop of the X stepper pulse.
    577               *
    578               * Currently this uses very modest estimates of around 5 cycles.
    579               * True values may be derived by careful testing.
    580               *
    581               * Once any delay is added, the cost of the delay code itself
    582               * may be subtracted from this value to get a more accurate delay.
    583               * Delays under 20 cycles (1.25s) will be very accurate, using NOPs.
    584               * Longer delays use a loop. The resolution is 8 cycles.
    585               */
    586              #if HAS_X_STEP
    587                #define _CYCLE_APPROX_1 5
    588              #else
    589                #define _CYCLE_APPROX_1 0
    590              #endif
    591              #if ENABLED(X_DUAL_STEPPER_DRIVERS)
    592                #define _CYCLE_APPROX_2 _CYCLE_APPROX_1 + 4
    593              #else
    594                #define _CYCLE_APPROX_2 _CYCLE_APPROX_1
    595              #endif
    596              #if HAS_Y_STEP
    597                #define _CYCLE_APPROX_3 _CYCLE_APPROX_2 + 5
    598              #else
    599                #define _CYCLE_APPROX_3 _CYCLE_APPROX_2
    600              #endif
    601              #if ENABLED(Y_DUAL_STEPPER_DRIVERS)
    602                #define _CYCLE_APPROX_4 _CYCLE_APPROX_3 + 4
    603              #else
    604                #define _CYCLE_APPROX_4 _CYCLE_APPROX_3
    605              #endif
    606              #if HAS_Z_STEP
    607                #define _CYCLE_APPROX_5 _CYCLE_APPROX_4 + 5
    608              #else
    609                #define _CYCLE_APPROX_5 _CYCLE_APPROX_4
    610              #endif
    611              #if ENABLED(Z_DUAL_STEPPER_DRIVERS)
    612                #define _CYCLE_APPROX_6 _CYCLE_APPROX_5 + 4
    613              #else
    614                #define _CYCLE_APPROX_6 _CYCLE_APPROX_5
    615              #endif
    616              #if DISABLED(LIN_ADVANCE)
    617                #if ENABLED(MIXING_EXTRUDER)
    618                  #define _CYCLE_APPROX_7 _CYCLE_APPROX_6 + (MIXING_STEPPERS) * 6
    619                #else
    620                  #define _CYCLE_APPROX_7 _CYCLE_APPROX_6 + 5
    621                #endif
    622              #else
    623                #define _CYCLE_APPROX_7 _CYCLE_APPROX_6
    624              #endif
    625          
    626              #define CYCLES_EATEN_XYZE _CYCLE_APPROX_7
    627              #define EXTRA_CYCLES_XYZE (STEP_PULSE_CYCLES - (CYCLES_EATEN_XYZE))
    628          
    629              /**
    630               * If a minimum pulse time was specified get the timer 0 value.
    631               *
    632               * TCNT0 has an 8x prescaler, so it increments every 8 cycles.
    633               * That's every 0.5s on 16MHz and every 0.4s on 20MHz.
    634               * 20 counts of TCNT0 -by itself- is a good pulse delay.
    635               * 10s = 160 or 200 cycles.
    636               */
    637              #if EXTRA_CYCLES_XYZE > 20
    638                uint32_t pulse_start = TCNT0;
    639              #endif
    640          
    641              #if HAS_X_STEP
    642                PULSE_START(X);
    643              #endif
    644              #if HAS_Y_STEP
    645                PULSE_START(Y);
    646              #endif
    647              #if HAS_Z_STEP
    648                PULSE_START(Z);
   \   00000142   0x6AF0             LDR      R0,[R6, #+44]
   \   00000144   0x6A31             LDR      R1,[R6, #+32]
   \   00000146   0x68C9             LDR      R1,[R1, #+12]
   \   00000148   0x1808             ADDS     R0,R1,R0
   \   0000014A   0x62F0             STR      R0,[R6, #+44]
   \   0000014C   0x2801             CMP      R0,#+1
   \   0000014E   0xDB08             BLT.N    ??StepperHandler_18
   \   00000150   0x2201             MOVS     R2,#+1
   \   00000152   0x.... 0x....      LDR.W    R0,??DataTable14_3
   \   00000156   0x8841             LDRH     R1,[R0, #+2]
   \   00000158   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   0000015C   0x6840             LDR      R0,[R0, #+4]
   \   0000015E   0x.... 0x....      BL       HAL_GPIO_WritePin
    649              #endif
    650          
    651              // For non-advance use linear interpolation for E also
    652              #if DISABLED(LIN_ADVANCE)
    653                #if ENABLED(MIXING_EXTRUDER)
    654                  // Keep updating the single E axis
    655                  counter_E += current_block->steps[E_AXIS];
    656                  // Tick the counters used for this mix
    657                  MIXING_STEPPERS_LOOP(j) {
    658                    // Step mixing steppers (proportionally)
    659                    counter_m[j] += current_block->steps[E_AXIS];
    660                    // Step when the counter goes over zero
    661                    if (counter_m[j] > 0) En_STEP_WRITE(j, !INVERT_E_STEP_PIN);
    662                  }
    663                #else // !MIXING_EXTRUDER
    664                  PULSE_START(E);
   \                     ??StepperHandler_18: (+1)
   \   00000162   0x6B30             LDR      R0,[R6, #+48]
   \   00000164   0x6A31             LDR      R1,[R6, #+32]
   \   00000166   0x6909             LDR      R1,[R1, #+16]
   \   00000168   0x1808             ADDS     R0,R1,R0
   \   0000016A   0x6330             STR      R0,[R6, #+48]
   \   0000016C   0x2801             CMP      R0,#+1
   \   0000016E   0xDB0A             BLT.N    ??StepperHandler_19
   \   00000170   0x2201             MOVS     R2,#+1
   \   00000172   0x.... 0x....      LDR.W    R0,??DataTable14_3
   \   00000176   0xF830 0x1C02      LDRH     R1,[R0, #-2]
   \   0000017A   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   0000017E   0xF850 0x0C04      LDR      R0,[R0, #-4]
   \   00000182   0x.... 0x....      BL       HAL_GPIO_WritePin
    665                #endif
    666              #endif // !LIN_ADVANCE
    667          
    668              // For minimum pulse time wait before stopping pulses
    669              #if EXTRA_CYCLES_XYZE > 20
    670                while (EXTRA_CYCLES_XYZE > (uint32_t)(TCNT0 - pulse_start) * (INT0_PRESCALER)) { /* nada */ }
    671                pulse_start = TCNT0;
    672              #elif EXTRA_CYCLES_XYZE > 0
    673                DELAY_NOPS(EXTRA_CYCLES_XYZE);
    674              #endif
    675          
    676              #if HAS_X_STEP
    677                PULSE_STOP(X);
    678              #endif
    679              #if HAS_Y_STEP
    680                PULSE_STOP(Y);
    681              #endif
    682              #if HAS_Z_STEP
    683                PULSE_STOP(Z);
                       ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \                     ??StepperHandler_19: (+1)
   \   00000186   0x6AF0             LDR      R0,[R6, #+44]
   \   00000188   0x2801             CMP      R0,#+1
   \   0000018A   0xDB12             BLT.N    ??StepperHandler_20
   \   0000018C   0x6A31             LDR      R1,[R6, #+32]
   \   0000018E   0x6949             LDR      R1,[R1, #+20]
   \   00000190   0x1A40             SUBS     R0,R0,R1
   \   00000192   0x62F0             STR      R0,[R6, #+44]
   \   00000194   0xF996 0x0002      LDRSB    R0,[R6, #+2]
   \   00000198   0x69B1             LDR      R1,[R6, #+24]
   \   0000019A   0xFA41 0xF080      SXTAB    R0,R1,R0
   \   0000019E   0x61B0             STR      R0,[R6, #+24]
   \   000001A0   0x463A             MOV      R2,R7
   \   000001A2   0x.... 0x....      LDR.W    R0,??DataTable14_3
   \   000001A6   0x8841             LDRH     R1,[R0, #+2]
   \   000001A8   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   000001AC   0x6840             LDR      R0,[R0, #+4]
   \   000001AE   0x.... 0x....      BL       HAL_GPIO_WritePin
    684              #endif
    685          
    686              #if DISABLED(LIN_ADVANCE)
    687                #if ENABLED(MIXING_EXTRUDER)
    688                  // Always step the single E axis
    689                  if (counter_E > 0) {
    690                    counter_E -= current_block->step_event_count;
    691                    count_position[E_AXIS] += count_direction[E_AXIS];
    692                  }
    693                  MIXING_STEPPERS_LOOP(j) {
    694                    if (counter_m[j] > 0) {
    695                      counter_m[j] -= current_block->mix_event_count[j];
    696                      En_STEP_WRITE(j, INVERT_E_STEP_PIN);
    697                    }
    698                  }
    699                #else // !MIXING_EXTRUDER
    700                  PULSE_STOP(E);
                         ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \                     ??StepperHandler_20: (+1)
   \   000001B2   0x6B30             LDR      R0,[R6, #+48]
   \   000001B4   0x2801             CMP      R0,#+1
   \   000001B6   0xDB12             BLT.N    ??StepperHandler_21
   \   000001B8   0x6A31             LDR      R1,[R6, #+32]
   \   000001BA   0x6949             LDR      R1,[R1, #+20]
   \   000001BC   0x1A40             SUBS     R0,R0,R1
   \   000001BE   0x6330             STR      R0,[R6, #+48]
   \   000001C0   0xF996 0x0003      LDRSB    R0,[R6, #+3]
   \   000001C4   0x69F1             LDR      R1,[R6, #+28]
   \   000001C6   0xFA41 0xF080      SXTAB    R0,R1,R0
   \   000001CA   0x61F0             STR      R0,[R6, #+28]
   \   000001CC   0x463A             MOV      R2,R7
   \   000001CE   0x....             LDR.N    R0,??DataTable14_3
   \   000001D0   0xF830 0x1C02      LDRH     R1,[R0, #-2]
   \   000001D4   0x....             LDR.N    R0,??DataTable14_2
   \   000001D6   0xF850 0x0C04      LDR      R0,[R0, #-4]
   \   000001DA   0x.... 0x....      BL       HAL_GPIO_WritePin
    701                #endif
    702              #endif // !LIN_ADVANCE
    703          
    704              if (++step_events_completed >= current_block->step_event_count) {
   \                     ??StepperHandler_21: (+1)
   \   000001DE   0x6B70             LDR      R0,[R6, #+52]
   \   000001E0   0x1C40             ADDS     R0,R0,#+1
   \   000001E2   0x6370             STR      R0,[R6, #+52]
   \   000001E4   0x6A31             LDR      R1,[R6, #+32]
   \   000001E6   0x6949             LDR      R1,[R1, #+20]
   \   000001E8   0x4288             CMP      R0,R1
   \   000001EA   0xD3A4             BCC.N    ??StepperHandler_16
    705                all_steps_done = true;
   \   000001EC   0x2701             MOVS     R7,#+1
    706                break;
    707              }
    708          
    709              // For minimum pulse time wait after stopping pulses also
    710              #if EXTRA_CYCLES_XYZE > 20
    711                if (i) while (EXTRA_CYCLES_XYZE > (uint32_t)(TCNT0 - pulse_start) * (INT0_PRESCALER)) { /* nada */ }
    712              #elif EXTRA_CYCLES_XYZE > 0
    713                if (i) DELAY_NOPS(EXTRA_CYCLES_XYZE);
    714              #endif
    715          
    716            } // steps_loop
    717          
    718            #if ENABLED(LIN_ADVANCE)
    719          
    720              if (current_block->use_advance_lead) {
    721                const int delta_adv_steps = current_estep_rate[TOOL_E_INDEX] - current_adv_steps[TOOL_E_INDEX];
    722                current_adv_steps[TOOL_E_INDEX] += delta_adv_steps;
    723                #if ENABLED(MIXING_EXTRUDER)
    724                  // Mixing extruders apply advance lead proportionally
    725                  MIXING_STEPPERS_LOOP(j)
    726                    e_steps[j] += delta_adv_steps * current_block->step_event_count / current_block->mix_event_count[j];
    727                #else
    728                  // For most extruders, advance the single E stepper
    729                  e_steps[TOOL_E_INDEX] += delta_adv_steps;
    730                #endif
    731              }
    732              // If we have esteps to execute, fire the next advance_isr "now"
    733              if (e_steps[TOOL_E_INDEX]) nextAdvanceISR = 0;
    734          
    735            #endif // LIN_ADVANCE
    736          
    737            // Calculate new timer value
    738            if (step_events_completed <= (uint32_t)current_block->accelerate_until) {
   \                     ??StepperHandler_17: (+1)
   \   000001EE   0x6A32             LDR      R2,[R6, #+32]
   \   000001F0   0x6990             LDR      R0,[R2, #+24]
   \   000001F2   0x6B71             LDR      R1,[R6, #+52]
   \   000001F4   0x4288             CMP      R0,R1
   \   000001F6   0xD354             BCC.N    ??StepperHandler_22
    739          
    740              MultiU24X32toH16(acc_step_rate, acceleration_time, current_block->acceleration_rate);
   \   000001F8   0x6BB0             LDR      R0,[R6, #+56]
   \   000001FA   0x6A11             LDR      R1,[R2, #+32]
   \   000001FC   0xFB81 0x0100      SMULL    R0,R1,R1,R0
   \   00000200   0x0E00             LSRS     R0,R0,#+24
   \   00000202   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   00000206   0x81B0             STRH     R0,[R6, #+12]
   \   00000208   0x89B0             LDRH     R0,[R6, #+12]
   \   0000020A   0x6C11             LDR      R1,[R2, #+64]
   \   0000020C   0x1808             ADDS     R0,R1,R0
   \   0000020E   0x81B0             STRH     R0,[R6, #+12]
    741              acc_step_rate += current_block->initial_rate;
    742          
    743              // upper limit
    744              NOMORE(acc_step_rate, current_block->nominal_rate);
   \   00000210   0x6BD1             LDR      R1,[R2, #+60]
   \   00000212   0xB280             UXTH     R0,R0
   \   00000214   0x4281             CMP      R1,R0
   \   00000216   0xD200             BCS.N    ??StepperHandler_23
   \   00000218   0x81B1             STRH     R1,[R6, #+12]
    745          
    746              // step_rate to timer interval
    747              const uint16_t interval = calc_timer_interval(acc_step_rate);
   \                     ??StepperHandler_23: (+1)
   \   0000021A   0x89B0             LDRH     R0,[R6, #+12]
   \   0000021C   0x.... 0x....      BL       _ZN7Stepper19calc_timer_intervalEt
    748          
    749              SPLIT(interval);  // split step into multiple ISRs if larger than ENDSTOP_NOMINAL_OCR_VAL
   \   00000220   0x4601             MOV      R1,R0
   \   00000222   0xF898 0x2000      LDRB     R2,[R8, #+0]
   \   00000226   0x2A00             CMP      R2,#+0
   \   00000228   0xD02D             BEQ.N    ??StepperHandler_24
   \   0000022A   0xF640 0x32B9      MOVW     R2,#+3001
   \   0000022E   0x4290             CMP      R0,R2
   \   00000230   0xDB29             BLT.N    ??StepperHandler_24
   \   00000232   0xF640 0x31B8      MOVW     R1,#+3000
   \   00000236   0x460A             MOV      R2,R1
   \   00000238   0xFB90 0xF2F2      SDIV     R2,R0,R2
   \   0000023C   0xFB01 0x0212      MLS      R2,R1,R2,R0
   \   00000240   0xB292             UXTH     R2,R2
   \   00000242   0x4613             MOV      R3,R2
   \   00000244   0xF5B3 0x7F7A      CMP      R3,#+1000
   \   00000248   0xDA1A             BGE.N    ??StepperHandler_25
   \   0000024A   0xF602 0x31B8      ADDW     R1,R2,#+3000
   \   0000024E   0xE017             B.N      ??StepperHandler_25
   \                     ??StepperHandler_14: (+1)
   \   00000250   0xF44F 0x60FA      MOV      R0,#+2000
   \   00000254   0x6821             LDR      R1,[R4, #+0]
   \   00000256   0x62C8             STR      R0,[R1, #+44]
   \   00000258   0x6820             LDR      R0,[R4, #+0]
   \   0000025A   0x6AC1             LDR      R1,[R0, #+44]
   \   0000025C   0x6A42             LDR      R2,[R0, #+36]
   \   0000025E   0x4291             CMP      R1,R2
   \   00000260   0xD202             BCS.N    ??StepperHandler_26
   \   00000262   0x6AC1             LDR      R1,[R0, #+44]
   \   00000264   0x1E49             SUBS     R1,R1,#+1
   \   00000266   0x6241             STR      R1,[R0, #+36]
   \                     ??StepperHandler_26: (+1)
   \   00000268   0xB662             cpsie i
   \   0000026A   0x....             LDR.N    R0,??DataTable14_8
   \   0000026C   0x7800             LDRB     R0,[R0, #+0]
   \   0000026E   0x2800             CMP      R0,#+0
   \   00000270   0x4628             MOV      R0,R5
   \   00000272   0xD002             BEQ.N    ??StepperHandler_27
   \   00000274   0x.... 0x....      BL       HAL_TIM_Base_Stop_IT
   \   00000278   0xE096             B.N      ??StepperHandler_6
   \                     ??StepperHandler_27: (+1)
   \   0000027A   0x.... 0x....      BL       HAL_TIM_Base_Start_IT
   \   0000027E   0xE093             B.N      ??StepperHandler_6
   \                     ??StepperHandler_25: (+1)
   \   00000280   0xB289             UXTH     R1,R1
   \   00000282   0x1A42             SUBS     R2,R0,R1
   \   00000284   0x64F2             STR      R2,[R6, #+76]
    750              _NEXT_ISR(ocr_val);
                     ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \                     ??StepperHandler_24: (+1)
   \   00000286   0x6822             LDR      R2,[R4, #+0]
   \   00000288   0x62D1             STR      R1,[R2, #+44]
   \   0000028A   0x6821             LDR      R1,[R4, #+0]
   \   0000028C   0x6ACA             LDR      R2,[R1, #+44]
   \   0000028E   0x6A4B             LDR      R3,[R1, #+36]
   \   00000290   0x429A             CMP      R2,R3
   \   00000292   0xD202             BCS.N    ??StepperHandler_28
   \   00000294   0x6ACA             LDR      R2,[R1, #+44]
   \   00000296   0x1E52             SUBS     R2,R2,#+1
   \   00000298   0x624A             STR      R2,[R1, #+36]
    751          
    752              acceleration_time += interval;
   \                     ??StepperHandler_28: (+1)
   \   0000029A   0x6BB1             LDR      R1,[R6, #+56]
   \   0000029C   0x1840             ADDS     R0,R0,R1
   \   0000029E   0x63B0             STR      R0,[R6, #+56]
   \   000002A0   0xE068             B.N      ??StepperHandler_29
    753          
    754              #if ENABLED(LIN_ADVANCE)
    755          
    756                if (current_block->use_advance_lead) {
    757                  #if ENABLED(MIXING_EXTRUDER)
    758                    MIXING_STEPPERS_LOOP(j)
    759                      current_estep_rate[j] = ((uint32_t)acc_step_rate * current_block->abs_adv_steps_multiplier8 * current_block->step_event_count / current_block->mix_event_count[j]) >> 17;
    760                  #else
    761                    current_estep_rate[TOOL_E_INDEX] = ((uint32_t)acc_step_rate * current_block->abs_adv_steps_multiplier8) >> 17;
    762                  #endif
    763                }
    764                eISR_Rate = adv_rate(e_steps[TOOL_E_INDEX], interval, step_loops);
    765          
    766              #endif // LIN_ADVANCE
    767            }
    768            else if (step_events_completed > (uint32_t)current_block->decelerate_after) {
   \                     ??StepperHandler_22: (+1)
   \   000002A2   0x69D0             LDR      R0,[R2, #+28]
   \   000002A4   0x6B71             LDR      R1,[R6, #+52]
   \   000002A6   0x4288             CMP      R0,R1
   \   000002A8   0xD23D             BCS.N    ??StepperHandler_30
    769              uint16_t step_rate;
    770              MultiU24X32toH16(step_rate, deceleration_time, current_block->acceleration_rate);
   \   000002AA   0x6BF0             LDR      R0,[R6, #+60]
   \   000002AC   0x6A11             LDR      R1,[R2, #+32]
   \   000002AE   0xFB81 0x0100      SMULL    R0,R1,R1,R0
   \   000002B2   0x0E00             LSRS     R0,R0,#+24
   \   000002B4   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
    771          
    772              if (step_rate < acc_step_rate) { // Still decelerating?
   \   000002B8   0x6C51             LDR      R1,[R2, #+68]
   \   000002BA   0x89B2             LDRH     R2,[R6, #+12]
   \   000002BC   0xB280             UXTH     R0,R0
   \   000002BE   0x4290             CMP      R0,R2
   \   000002C0   0xD205             BCS.N    ??StepperHandler_31
    773                step_rate = acc_step_rate - step_rate;
   \   000002C2   0x1A10             SUBS     R0,R2,R0
    774                NOLESS(step_rate, current_block->final_rate);
   \   000002C4   0xB280             UXTH     R0,R0
   \   000002C6   0x4288             CMP      R0,R1
   \   000002C8   0xD202             BCS.N    ??StepperHandler_32
   \   000002CA   0x4608             MOV      R0,R1
   \   000002CC   0xE000             B.N      ??StepperHandler_32
    775              }
    776              else
    777                step_rate = current_block->final_rate;
   \                     ??StepperHandler_31: (+1)
   \   000002CE   0x4608             MOV      R0,R1
    778          
    779              // step_rate to timer interval
    780              const uint16_t interval = calc_timer_interval(step_rate);
   \                     ??StepperHandler_32: (+1)
   \   000002D0   0xB280             UXTH     R0,R0
   \   000002D2   0x.... 0x....      BL       _ZN7Stepper19calc_timer_intervalEt
    781          
    782              SPLIT(interval);  // split step into multiple ISRs if larger than ENDSTOP_NOMINAL_OCR_VAL
   \   000002D6   0x4601             MOV      R1,R0
   \   000002D8   0xF898 0x2000      LDRB     R2,[R8, #+0]
   \   000002DC   0x2A00             CMP      R2,#+0
   \   000002DE   0xD014             BEQ.N    ??StepperHandler_33
   \   000002E0   0xF640 0x32B9      MOVW     R2,#+3001
   \   000002E4   0x4290             CMP      R0,R2
   \   000002E6   0xDB10             BLT.N    ??StepperHandler_33
   \   000002E8   0xF640 0x31B8      MOVW     R1,#+3000
   \   000002EC   0x460A             MOV      R2,R1
   \   000002EE   0xFB90 0xF2F2      SDIV     R2,R0,R2
   \   000002F2   0xFB01 0x0212      MLS      R2,R1,R2,R0
   \   000002F6   0xB292             UXTH     R2,R2
   \   000002F8   0x4613             MOV      R3,R2
   \   000002FA   0xF5B3 0x7F7A      CMP      R3,#+1000
   \   000002FE   0xDA01             BGE.N    ??StepperHandler_34
   \   00000300   0xF602 0x31B8      ADDW     R1,R2,#+3000
   \                     ??StepperHandler_34: (+1)
   \   00000304   0xB289             UXTH     R1,R1
   \   00000306   0x1A42             SUBS     R2,R0,R1
   \   00000308   0x64F2             STR      R2,[R6, #+76]
    783              _NEXT_ISR(ocr_val);
                     ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \                     ??StepperHandler_33: (+1)
   \   0000030A   0x6822             LDR      R2,[R4, #+0]
   \   0000030C   0x62D1             STR      R1,[R2, #+44]
   \   0000030E   0x6821             LDR      R1,[R4, #+0]
   \   00000310   0x6ACA             LDR      R2,[R1, #+44]
   \   00000312   0x6A4B             LDR      R3,[R1, #+36]
   \   00000314   0x429A             CMP      R2,R3
   \   00000316   0xD202             BCS.N    ??StepperHandler_35
   \   00000318   0x6ACA             LDR      R2,[R1, #+44]
   \   0000031A   0x1E52             SUBS     R2,R2,#+1
   \   0000031C   0x624A             STR      R2,[R1, #+36]
    784          
    785              deceleration_time += interval;
   \                     ??StepperHandler_35: (+1)
   \   0000031E   0x6BF1             LDR      R1,[R6, #+60]
   \   00000320   0x1840             ADDS     R0,R0,R1
   \   00000322   0x63F0             STR      R0,[R6, #+60]
   \   00000324   0xE026             B.N      ??StepperHandler_29
    786          
    787              #if ENABLED(LIN_ADVANCE)
    788          
    789                if (current_block->use_advance_lead) {
    790                  #if ENABLED(MIXING_EXTRUDER)
    791                    MIXING_STEPPERS_LOOP(j)
    792                      current_estep_rate[j] = ((uint32_t)step_rate * current_block->abs_adv_steps_multiplier8 * current_block->step_event_count / current_block->mix_event_count[j]) >> 17;
    793                  #else
    794                    current_estep_rate[TOOL_E_INDEX] = ((uint32_t)step_rate * current_block->abs_adv_steps_multiplier8) >> 17;
    795                  #endif
    796                }
    797                eISR_Rate = adv_rate(e_steps[TOOL_E_INDEX], interval, step_loops);
    798          
    799              #endif // LIN_ADVANCE
    800            }
    801            else {
    802          
    803              #if ENABLED(LIN_ADVANCE)
    804          
    805                if (current_block->use_advance_lead)
    806                  current_estep_rate[TOOL_E_INDEX] = final_estep_rate;
    807          
    808                eISR_Rate = adv_rate(e_steps[TOOL_E_INDEX], OCR1A_nominal, step_loops_nominal);
    809          
    810              #endif
    811          
    812              SPLIT(OCR1A_nominal);  // split step into multiple ISRs if larger than ENDSTOP_NOMINAL_OCR_VAL
   \                     ??StepperHandler_30: (+1)
   \   00000326   0x8970             LDRH     R0,[R6, #+10]
   \   00000328   0x4601             MOV      R1,R0
   \   0000032A   0xF898 0x2000      LDRB     R2,[R8, #+0]
   \   0000032E   0x2A00             CMP      R2,#+0
   \   00000330   0xD014             BEQ.N    ??StepperHandler_36
   \   00000332   0xF640 0x32B9      MOVW     R2,#+3001
   \   00000336   0x4290             CMP      R0,R2
   \   00000338   0xDB10             BLT.N    ??StepperHandler_36
   \   0000033A   0xF640 0x31B8      MOVW     R1,#+3000
   \   0000033E   0x460A             MOV      R2,R1
   \   00000340   0xFB90 0xF2F2      SDIV     R2,R0,R2
   \   00000344   0xFB01 0x0212      MLS      R2,R1,R2,R0
   \   00000348   0xB292             UXTH     R2,R2
   \   0000034A   0x4613             MOV      R3,R2
   \   0000034C   0xF5B3 0x7F7A      CMP      R3,#+1000
   \   00000350   0xDA01             BGE.N    ??StepperHandler_37
   \   00000352   0xF602 0x31B8      ADDW     R1,R2,#+3000
   \                     ??StepperHandler_37: (+1)
   \   00000356   0xB289             UXTH     R1,R1
   \   00000358   0x1A40             SUBS     R0,R0,R1
   \   0000035A   0x64F0             STR      R0,[R6, #+76]
    813              _NEXT_ISR(ocr_val);
                     ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \                     ??StepperHandler_36: (+1)
   \   0000035C   0x6820             LDR      R0,[R4, #+0]
   \   0000035E   0x62C1             STR      R1,[R0, #+44]
   \   00000360   0x6820             LDR      R0,[R4, #+0]
   \   00000362   0x6AC1             LDR      R1,[R0, #+44]
   \   00000364   0x6A42             LDR      R2,[R0, #+36]
   \   00000366   0x4291             CMP      R1,R2
   \   00000368   0xD202             BCS.N    ??StepperHandler_38
   \   0000036A   0x6AC1             LDR      R1,[R0, #+44]
   \   0000036C   0x1E49             SUBS     R1,R1,#+1
   \   0000036E   0x6241             STR      R1,[R0, #+36]
    814          
    815              // ensure we're running at the correct step rate, even if we just came off an acceleration
    816              step_loops = step_loops_nominal;
   \                     ??StepperHandler_38: (+1)
   \   00000370   0x79B0             LDRB     R0,[R6, #+6]
   \   00000372   0x7170             STRB     R0,[R6, #+5]
    817            }
    818          
    819            #if DISABLED(LIN_ADVANCE)
    820              NOLESS(OCR1A, TCNT1 + 16);
                     ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \                     ??StepperHandler_29: (+1)
   \   00000374   0x6820             LDR      R0,[R4, #+0]
   \   00000376   0x6AC1             LDR      R1,[R0, #+44]
   \   00000378   0x6A42             LDR      R2,[R0, #+36]
   \   0000037A   0x3210             ADDS     R2,R2,#+16
   \   0000037C   0x4291             CMP      R1,R2
   \   0000037E   0xD202             BCS.N    ??StepperHandler_39
   \   00000380   0x6A41             LDR      R1,[R0, #+36]
   \   00000382   0x3110             ADDS     R1,R1,#+16
   \   00000384   0x62C1             STR      R1,[R0, #+44]
    821            #endif
    822          
    823            // If current block is finished, reset pointer
    824            if (all_steps_done) {
   \                     ??StepperHandler_39: (+1)
   \   00000386   0x2F00             CMP      R7,#+0
   \   00000388   0xD003             BEQ.N    ??StepperHandler_40
    825              current_block = NULL;
   \   0000038A   0x2000             MOVS     R0,#+0
   \   0000038C   0x6230             STR      R0,[R6, #+32]
    826              planner.discard_current_block();
   \   0000038E   0x.... 0x....      BL       _ZN7Planner21discard_current_blockEv
    827            }
    828            #if DISABLED(LIN_ADVANCE)
    829              _ENABLE_ISRs(); // re-enable ISRs
   \                     ??StepperHandler_40: (+1)
   \   00000392   0xB662             cpsie i
   \   00000394   0x....             LDR.N    R0,??DataTable14_8
   \   00000396   0x7800             LDRB     R0,[R0, #+0]
   \   00000398   0x2800             CMP      R0,#+0
   \   0000039A   0x4628             MOV      R0,R5
   \   0000039C   0xD002             BEQ.N    ??StepperHandler_41
   \   0000039E   0x.... 0x....      BL       HAL_TIM_Base_Stop_IT
   \   000003A2   0xE001             B.N      ??StepperHandler_6
   \                     ??StepperHandler_41: (+1)
   \   000003A4   0x.... 0x....      BL       HAL_TIM_Base_Start_IT
   \                     ??StepperHandler_6: (+1)
   \   000003A8   0x4620             MOV      R0,R4
   \   000003AA   0xE8BD 0x43F2      POP      {R1,R4-R9,LR}
   \   000003AE   0x.... 0x....      B.W      HAL_TIM_Base_Start_IT
    830            #endif
    831          }

   \                                 In section .data, align 4
   \                     _ZN7Stepper15count_directionE:
   \   00000000   0x01 0x01          DC8 1, 1, 1, 1
   \              0x01 0x01    
   \                     _ZN7Stepper19last_direction_bitsE:
   \   00000004   0x00               DC8 0
   \                     _ZN7Stepper10step_loopsE:
   \   00000005   0x00               DC8 0
   \                     _ZN7Stepper18step_loops_nominalE:
   \   00000006   0x00               DC8 0
   \   00000007   0x00               DC8 0
   \                     _ZN7Stepper23cleaning_buffer_counterE:
   \   00000008   0x0000             DC16 0
   \                     _ZN7Stepper13OCR1A_nominalE:
   \   0000000A   0x00 0x00          DC8 0, 0
   \                     _ZN7Stepper13acc_step_rateE:
   \   0000000C   0x00 0x00          DC8 0, 0
   \   0000000E   0x00 0x00          DC8 0, 0
   \                     _ZN7Stepper14count_positionE:
   \   00000010   0x00000000         DC32 0, 0, 0, 0
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \                     _ZN7Stepper13current_blockE:
   \   00000020   0x00000000         DC32 0H
   \                     _ZN7Stepper9counter_XE:
   \   00000024   0x00000000         DC32 0
   \                     _ZN7Stepper9counter_YE:
   \   00000028   0x00000000         DC32 0
   \                     _ZN7Stepper9counter_ZE:
   \   0000002C   0x00000000         DC32 0
   \                     _ZN7Stepper9counter_EE:
   \   00000030   0x00000000         DC32 0
   \                     _ZN7Stepper21step_events_completedE:
   \   00000034   0x00000000         DC32 0
   \                     _ZN7Stepper17acceleration_timeE:
   \   00000038   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN7Stepper17deceleration_timeE:
   \   0000003C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN7Stepper18endstops_trigstepsE:
   \   00000040   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   0000004C   0x00000000         DC32 0
    832          
    833          #if ENABLED(LIN_ADVANCE)
    834          
    835            #define CYCLES_EATEN_E (E_STEPPERS * 5)
    836            #define EXTRA_CYCLES_E (STEP_PULSE_CYCLES - (CYCLES_EATEN_E))
    837          
    838            // Timer interrupt for E. e_steps is set in the main routine;
    839          
    840            void Stepper::advance_isr() {
    841          
    842              nextAdvanceISR = eISR_Rate;
    843          
    844              #if ENABLED(MK2_MULTIPLEXER)
    845                // Even-numbered steppers are reversed
    846                #define SET_E_STEP_DIR(INDEX) \
    847                  if (e_steps[INDEX]) E## INDEX ##_DIR_WRITE(e_steps[INDEX] < 0 ? !INVERT_E## INDEX ##_DIR ^ TEST(INDEX, 0) : INVERT_E## INDEX ##_DIR ^ TEST(INDEX, 0))
    848              #else
    849                #define SET_E_STEP_DIR(INDEX) \
    850                  if (e_steps[INDEX]) E## INDEX ##_DIR_WRITE(e_steps[INDEX] < 0 ? INVERT_E## INDEX ##_DIR : !INVERT_E## INDEX ##_DIR)
    851              #endif
    852          
    853              #define START_E_PULSE(INDEX) \
    854                if (e_steps[INDEX]) E## INDEX ##_STEP_WRITE(!INVERT_E_STEP_PIN)
    855          
    856              #define STOP_E_PULSE(INDEX) \
    857                if (e_steps[INDEX]) { \
    858                  e_steps[INDEX] < 0 ? ++e_steps[INDEX] : --e_steps[INDEX]; \
    859                  E## INDEX ##_STEP_WRITE(INVERT_E_STEP_PIN); \
    860                }
    861          
    862              SET_E_STEP_DIR(0);
    863              #if E_STEPPERS > 1
    864                SET_E_STEP_DIR(1);
    865                #if E_STEPPERS > 2
    866                  SET_E_STEP_DIR(2);
    867                  #if E_STEPPERS > 3
    868                    SET_E_STEP_DIR(3);
    869                    #if E_STEPPERS > 4
    870                      SET_E_STEP_DIR(4);
    871                    #endif
    872                  #endif
    873                #endif
    874              #endif
    875          
    876              // Step all E steppers that have steps
    877              for (uint8_t i = step_loops; i--;) {
    878          
    879                #if EXTRA_CYCLES_E > 20
    880                  uint32_t pulse_start = TCNT0;
    881                #endif
    882          
    883                START_E_PULSE(0);
    884                #if E_STEPPERS > 1
    885                  START_E_PULSE(1);
    886                  #if E_STEPPERS > 2
    887                    START_E_PULSE(2);
    888                    #if E_STEPPERS > 3
    889                      START_E_PULSE(3);
    890                      #if E_STEPPERS > 4
    891                        START_E_PULSE(4);
    892                      #endif
    893                    #endif
    894                  #endif
    895                #endif
    896          
    897                // For minimum pulse time wait before stopping pulses
    898                #if EXTRA_CYCLES_E > 20
    899                  while (EXTRA_CYCLES_E > (uint32_t)(TCNT0 - pulse_start) * (INT0_PRESCALER)) { /* nada */ }
    900                  pulse_start = TCNT0;
    901                #elif EXTRA_CYCLES_E > 0
    902                  DELAY_NOPS(EXTRA_CYCLES_E);
    903                #endif
    904          
    905                STOP_E_PULSE(0);
    906                #if E_STEPPERS > 1
    907                  STOP_E_PULSE(1);
    908                  #if E_STEPPERS > 2
    909                    STOP_E_PULSE(2);
    910                    #if E_STEPPERS > 3
    911                      STOP_E_PULSE(3);
    912                      #if E_STEPPERS > 4
    913                        STOP_E_PULSE(4);
    914                      #endif
    915                    #endif
    916                  #endif
    917                #endif
    918          
    919                // For minimum pulse time wait before looping
    920                #if EXTRA_CYCLES_E > 20
    921                  if (i) while (EXTRA_CYCLES_E > (uint32_t)(TCNT0 - pulse_start) * (INT0_PRESCALER)) { /* nada */ }
    922                #elif EXTRA_CYCLES_E > 0
    923                  if (i) DELAY_NOPS(EXTRA_CYCLES_E);
    924                #endif
    925          
    926              } // steps_loop
    927            }
    928          
    929            void Stepper::advance_isr_scheduler() {
    930              // Disable Timer0 ISRs and enable global ISR again to capture UART events (incoming chars)
    931              CBI(TIMSK0, OCIE0B); // Temperature ISR
    932              DISABLE_STEPPER_DRIVER_INTERRUPT();
    933              sei();
    934          
    935              // Run main stepping ISR if flagged
    936              if (!nextMainISR) isr();
    937          
    938              // Run Advance stepping ISR if flagged
    939              if (!nextAdvanceISR) advance_isr();
    940          
    941              // Is the next advance ISR scheduled before the next main ISR?
    942              if (nextAdvanceISR <= nextMainISR) {
    943                // Set up the next interrupt
    944                OCR1A = nextAdvanceISR;
    945                // New interval for the next main ISR
    946                if (nextMainISR) nextMainISR -= nextAdvanceISR;
    947                // Will call Stepper::advance_isr on the next interrupt
    948                nextAdvanceISR = 0;
    949              }
    950              else {
    951                // The next main ISR comes first
    952                OCR1A = nextMainISR;
    953                // New interval for the next advance ISR, if any
    954                if (nextAdvanceISR && nextAdvanceISR != ADV_NEVER)
    955                  nextAdvanceISR -= nextMainISR;
    956                // Will call Stepper::isr on the next interrupt
    957                nextMainISR = 0;
    958              }
    959          
    960              // Don't run the ISR faster than possible
    961              NOLESS(OCR1A, TCNT1 + 16);
    962          
    963              // Restore original ISR settings
    964              _ENABLE_ISRs();
    965            }
    966          
    967          #endif // LIN_ADVANCE
    968          

   \                                 In section .text, align 4, keep-with-next
    969          void Stepper::init() {
   \                     _ZN7Stepper4initEv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    970          
    971            // Init Digipot Motor Current
    972            #if HAS_DIGIPOTSS || HAS_MOTOR_CURRENT_PWM
    973              digipot_init();
    974            #endif
    975          
    976            // Init Microstepping Pins
    977            #if HAS_MICROSTEPS
    978              microstep_init();
    979            #endif
    980          
    981            // Init TMC Steppers
    982            #if ENABLED(HAVE_TMCDRIVER)
    983              tmc_init();
    984            #endif
    985          
    986            // Init TMC2130 Steppers
    987            #if ENABLED(HAVE_TMC2130)
    988              tmc2130_init();
    989            #endif
    990          
    991            // Init TMC2208 Steppers
    992            #if ENABLED(HAVE_TMC2208)
    993              tmc2208_init();
    994            #endif
    995          
    996            // TRAMS, TMC2130 and TMC2208 advanced settings
    997            #if HAS_TRINAMIC
    998              TMC_ADV()
    999            #endif
   1000          
   1001            // Init L6470 Steppers
   1002            #if ENABLED(HAVE_L6470DRIVER)
   1003              L6470_init();
   1004            #endif
   1005          
   1006            // Init Dir Pins
   1007            #if HAS_X_DIR
   1008              X_DIR_INIT;
   1009            #endif
   1010            #if HAS_X2_DIR
   1011              X2_DIR_INIT;
   1012            #endif
   1013            #if HAS_Y_DIR
   1014              Y_DIR_INIT;
   1015              #if ENABLED(Y_DUAL_STEPPER_DRIVERS) && HAS_Y2_DIR
   1016                Y2_DIR_INIT;
   1017              #endif
   1018            #endif
   1019            #if HAS_Z_DIR
   1020              Z_DIR_INIT;
   1021              #if ENABLED(Z_DUAL_STEPPER_DRIVERS) && HAS_Z2_DIR
   1022                Z2_DIR_INIT;
   1023              #endif
   1024            #endif
   1025            #if HAS_E0_DIR
   1026              E0_DIR_INIT;
   1027            #endif
   1028            #if HAS_E1_DIR
   1029              E1_DIR_INIT;
   1030            #endif
   1031            #if HAS_E2_DIR
   1032              E2_DIR_INIT;
   1033            #endif
   1034            #if HAS_E3_DIR
   1035              E3_DIR_INIT;
   1036            #endif
   1037            #if HAS_E4_DIR
   1038              E4_DIR_INIT;
   1039            #endif
   1040          
   1041            // Init Enable Pins - steppers default to disabled.
   1042            #if HAS_X_ENABLE
   1043              X_ENABLE_INIT;
   1044              if (!X_ENABLE_ON) X_ENABLE_WRITE(HIGH);
   1045              #if ENABLED(DUAL_X_CARRIAGE) && HAS_X2_ENABLE
   1046                X2_ENABLE_INIT;
   1047                if (!X_ENABLE_ON) X2_ENABLE_WRITE(HIGH);
   1048              #endif
   1049            #endif
   1050            #if HAS_Y_ENABLE
   1051              Y_ENABLE_INIT;
   1052              if (!Y_ENABLE_ON) Y_ENABLE_WRITE(HIGH);
   1053              #if ENABLED(Y_DUAL_STEPPER_DRIVERS) && HAS_Y2_ENABLE
   1054                Y2_ENABLE_INIT;
   1055                if (!Y_ENABLE_ON) Y2_ENABLE_WRITE(HIGH);
   1056              #endif
   1057            #endif
   1058            #if HAS_Z_ENABLE
   1059              Z_ENABLE_INIT;
   1060              if (!Z_ENABLE_ON) Z_ENABLE_WRITE(HIGH);
   \   00000002   0x....             LDR.N    R4,??DataTable14_2
   \   00000004   0x....             LDR.N    R5,??DataTable14_3
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0x88A9             LDRH     R1,[R5, #+4]
   \   0000000A   0x68A0             LDR      R0,[R4, #+8]
   \   0000000C   0x.... 0x....      BL       HAL_GPIO_WritePin
   1061              #if ENABLED(Z_DUAL_STEPPER_DRIVERS) && HAS_Z2_ENABLE
   1062                Z2_ENABLE_INIT;
   1063                if (!Z_ENABLE_ON) Z2_ENABLE_WRITE(HIGH);
   1064              #endif
   1065            #endif
   1066            #if HAS_E0_ENABLE
   1067              E0_ENABLE_INIT;
   1068              if (!E_ENABLE_ON) E0_ENABLE_WRITE(HIGH);
   1069            #endif
   1070            #if HAS_E1_ENABLE
   1071              E1_ENABLE_INIT;
   1072              if (!E_ENABLE_ON) E1_ENABLE_WRITE(HIGH);
   1073            #endif
   1074            #if HAS_E2_ENABLE
   1075              E2_ENABLE_INIT;
   1076              if (!E_ENABLE_ON) E2_ENABLE_WRITE(HIGH);
   1077            #endif
   1078            #if HAS_E3_ENABLE
   1079              E3_ENABLE_INIT;
   1080              if (!E_ENABLE_ON) E3_ENABLE_WRITE(HIGH);
   1081            #endif
   1082            #if HAS_E4_ENABLE
   1083              E4_ENABLE_INIT;
   1084              if (!E_ENABLE_ON) E4_ENABLE_WRITE(HIGH);
   1085            #endif
   1086          
   1087            // Init endstops and pullups
   1088            endstops.init();
   \   00000010   0x....             LDR.N    R0,??DataTable14_9
   \   00000012   0x.... 0x....      BL       _ZN8Endstops4initEv
   1089          
   1090            #define _STEP_INIT(AXIS) AXIS ##_STEP_INIT
   1091            #define _WRITE_STEP(AXIS, HIGHLOW) AXIS ##_STEP_WRITE(HIGHLOW)
   1092            #define _DISABLE(AXIS) disable_## AXIS()
   1093          
   1094            #define AXIS_INIT(AXIS, PIN) \
   1095              _STEP_INIT(AXIS); \
   1096              _WRITE_STEP(AXIS, _INVERT_STEP_PIN(PIN)); \
   1097              _DISABLE(AXIS)
   1098          
   1099            #define E_AXIS_INIT(NUM) AXIS_INIT(E## NUM, E)
   1100          
   1101            // Init Step Pins
   1102            #if HAS_X_STEP
   1103              #if ENABLED(X_DUAL_STEPPER_DRIVERS) || ENABLED(DUAL_X_CARRIAGE)
   1104                X2_STEP_INIT;
   1105                X2_STEP_WRITE(INVERT_X_STEP_PIN);
   1106              #endif
   1107              AXIS_INIT(X, X);
   1108            #endif
   1109          
   1110            #if HAS_Y_STEP
   1111              #if ENABLED(Y_DUAL_STEPPER_DRIVERS)
   1112                Y2_STEP_INIT;
   1113                Y2_STEP_WRITE(INVERT_Y_STEP_PIN);
   1114              #endif
   1115              AXIS_INIT(Y, Y);
   1116            #endif
   1117          
   1118            #if HAS_Z_STEP
   1119              #if ENABLED(Z_DUAL_STEPPER_DRIVERS)
   1120                Z2_STEP_INIT;
   1121                Z2_STEP_WRITE(INVERT_Z_STEP_PIN);
   1122              #endif
   1123              AXIS_INIT(Z, Z);
   \   00000016   0x2200             MOVS     R2,#+0
   \   00000018   0x8869             LDRH     R1,[R5, #+2]
   \   0000001A   0x6860             LDR      R0,[R4, #+4]
   \   0000001C   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   00000020   0x2201             MOVS     R2,#+1
   \   00000022   0x88A9             LDRH     R1,[R5, #+4]
   \   00000024   0x68A0             LDR      R0,[R4, #+8]
   \   00000026   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x....             LDR.N    R1,??DataTable14_10
   \   0000002E   0x7088             STRB     R0,[R1, #+2]
   1124            #endif
   1125          
   1126            #if HAS_E0_STEP
   1127              E_AXIS_INIT(0);
   1128            #endif
   1129            #if HAS_E1_STEP
   1130              E_AXIS_INIT(1);
   1131            #endif
   1132            #if HAS_E2_STEP
   1133              E_AXIS_INIT(2);
   1134            #endif
   1135            #if HAS_E3_STEP
   1136              E_AXIS_INIT(3);
   1137            #endif
   1138            #if HAS_E4_STEP
   1139              E_AXIS_INIT(4);
   1140            #endif
   1141          #if 0
   1142            // waveform generation = 0100 = CTC
   1143            SET_WGM(1, CTC_OCRnA);
   1144          
   1145            // output mode = 00 (disconnected)
   1146            SET_COMA(1, NORMAL);
   1147          
   1148            // Set the timer pre-scaler
   1149            // Generally we use a divider of 8, resulting in a 2MHz timer
   1150            // frequency on a 16MHz MCU. If you are going to change this, be
   1151            // sure to regenerate speed_lookuptable.h with
   1152            // create_speed_lookuptable.py
   1153            SET_CS(1, PRESCALER_8);  //  CS 2 = 1/8 prescaler
   1154          
   1155            // Init Stepper ISR to 122 Hz for quick starting
   1156            OCR1A = 0x4000;
   1157            TCNT1 = 0;
   1158          #endif
   1159            ENABLE_STEPPER_DRIVER_INTERRUPT();
   \   00000030   0x....             LDR.N    R0,??DataTable14_1
   \   00000032   0x.... 0x....      BL       HAL_TIM_Base_Start_IT
   1160          
   1161            #if ENABLED(LIN_ADVANCE)
   1162              for (uint8_t i = 0; i < COUNT(e_steps); i++) e_steps[i] = 0;
   1163              ZERO(current_adv_steps);
   1164            #endif
   1165          
   1166            endstops.enable(true); // Start with endstops active. After homing they can be disabled
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x.... 0x....      BL       _ZN8Endstops6enableEb
   1167            sei();
   \   0000003C   0xB662             cpsie i
   1168          
   1169            set_directions(); // Init directions to last_direction_bits = 0
   \   0000003E   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000042   0x....             B.N      _ZN7Stepper14set_directionsEv
   1170          }
   1171          
   1172          
   1173          /**
   1174           * Block until all buffered steps are executed / cleaned
   1175           */

   \                                 In section .text, align 2, keep-with-next
   1176          void Stepper::synchronize() { while (planner.blocks_queued() || cleaning_buffer_counter) idle(); }
   \                     _ZN7Stepper11synchronizeEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0xE001             B.N      ??synchronize_0
   \                     ??synchronize_1: (+1)
   \   00000004   0x.... 0x....      BL       _Z4idlev
   \                     ??synchronize_0: (+1)
   \   00000008   0x.... 0x....      BL       _ZN7Planner13blocks_queuedEv
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD1F9             BNE.N    ??synchronize_1
   \   00000010   0x....             LDR.N    R0,??DataTable14_5
   \   00000012   0xF9B0 0x0008      LDRSH    R0,[R0, #+8]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD1F4             BNE.N    ??synchronize_1
   \   0000001A   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   1177          void Stepper::waitUntilEndOfAllBuffers() { while (planner.blocks_queued()) ;}
   \                     _ZN7Stepper24waitUntilEndOfAllBuffersEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \                     ??waitUntilEndOfAllBuffers_0: (+1)
   \   00000002   0x.... 0x....      BL       _ZN7Planner13blocks_queuedEv
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD1FB             BNE.N    ??waitUntilEndOfAllBuffers_0
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   1178          void Stepper:: waitUntilEndOfAllMoves()	{ }
   \                     _ZN7Stepper22waitUntilEndOfAllMovesEv: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1179          
   1180          /**
   1181           * Set the stepper positions directly in steps
   1182           *
   1183           * The input is based on the typical per-axis XYZ steps.
   1184           * For CORE machines XYZ needs to be translated to ABC.
   1185           *
   1186           * This allows get_axis_position_mm to correctly
   1187           * derive the current XYZ position later on.
   1188           */

   \                                 In section .text, align 4, keep-with-next
   1189          void Stepper::set_position(const long &a, const long &b, const long &c, const long &e) {
   \                     _ZN7Stepper12set_positionERKlS1_S1_S1_: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0x461F             MOV      R7,R3
   1190          
   1191            synchronize(); // Bad to set stepper counts in the middle of a move
   \   0000000A   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   1192          
   1193            CRITICAL_SECTION_START;
   \   0000000E   0xB672             cpsid i
   1194          
   1195            #if CORE_IS_XY
   1196              // corexy positioning
   1197              // these equations follow the form of the dA and dB equations on http://www.corexy.com/theory.html
   1198              count_position[A_AXIS] = a + b;
   1199              count_position[B_AXIS] = CORESIGN(a - b);
   1200              count_position[Z_AXIS] = c;
   1201            #elif CORE_IS_XZ
   1202              // corexz planning
   1203              count_position[A_AXIS] = a + c;
   1204              count_position[Y_AXIS] = b;
   1205              count_position[C_AXIS] = CORESIGN(a - c);
   1206            #elif CORE_IS_YZ
   1207              // coreyz planning
   1208              count_position[X_AXIS] = a;
   1209              count_position[B_AXIS] = b + c;
   1210              count_position[C_AXIS] = CORESIGN(b - c);
   1211            #else
   1212              // default non-h-bot planning
   1213              count_position[X_AXIS] = a;
   \   00000010   0x....             LDR.N    R0,??DataTable14_5
   \   00000012   0x6821             LDR      R1,[R4, #+0]
   \   00000014   0x6101             STR      R1,[R0, #+16]
   1214              count_position[Y_AXIS] = b;
   \   00000016   0x6829             LDR      R1,[R5, #+0]
   \   00000018   0x6141             STR      R1,[R0, #+20]
   1215              count_position[Z_AXIS] = c;
   \   0000001A   0x6831             LDR      R1,[R6, #+0]
   \   0000001C   0x6181             STR      R1,[R0, #+24]
   1216            #endif
   1217          
   1218            count_position[E_AXIS] = e;
   \   0000001E   0x6839             LDR      R1,[R7, #+0]
   \   00000020   0x61C1             STR      R1,[R0, #+28]
   1219            CRITICAL_SECTION_END;
   \   00000022   0xB662             cpsie i
   1220          }
   \   00000024   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1221          

   \                                 In section .text, align 4, keep-with-next
   1222          void Stepper::set_position(const AxisEnum &axis, const long &v) {
   1223            CRITICAL_SECTION_START;
   \                     _ZN7Stepper12set_positionERK8AxisEnumRKl: (+1)
   \   00000000   0xB672             cpsid i
   1224            count_position[axis] = v;
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000008   0x....             LDR.N    R2,??DataTable14_5
   \   0000000A   0xEB02 0x0080      ADD      R0,R2,R0, LSL #+2
   \   0000000E   0x6101             STR      R1,[R0, #+16]
   1225            CRITICAL_SECTION_END;
   \   00000010   0xB662             cpsie i
   1226          }
   \   00000012   0x4770             BX       LR               ;; return
   1227          

   \                                 In section .text, align 4, keep-with-next
   1228          void Stepper::set_e_position(const long &e) {
   1229            CRITICAL_SECTION_START;
   \                     _ZN7Stepper14set_e_positionERKl: (+1)
   \   00000000   0xB672             cpsid i
   1230            count_position[E_AXIS] = e;
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x....             LDR.N    R1,??DataTable14_5
   \   00000006   0x61C8             STR      R0,[R1, #+28]
   1231            CRITICAL_SECTION_END;
   \   00000008   0xB662             cpsie i
   1232          }
   \   0000000A   0x4770             BX       LR               ;; return
   1233          
   1234          /**
   1235           * Get a stepper's position in steps.
   1236           */

   \                                 In section .text, align 4, keep-with-next
   1237          long Stepper::position(const AxisEnum axis) {
   1238            CRITICAL_SECTION_START;
   \                     _ZN7Stepper8positionE8AxisEnum: (+1)
   \   00000000   0xB672             cpsid i
   1239            const long count_pos = count_position[axis];
   \   00000002   0x....             LDR.N    R1,??DataTable14_5
   \   00000004   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   00000008   0x6900             LDR      R0,[R0, #+16]
   1240            CRITICAL_SECTION_END;
   \   0000000A   0xB662             cpsie i
   1241            return count_pos;
   \   0000000C   0x4770             BX       LR               ;; return
   1242          }
   1243          
   1244          /**
   1245           * Get an axis position according to stepper position(s)
   1246           * For CORE machines apply translation from ABC to XYZ.
   1247           */

   \                                 In section .text, align 2, keep-with-next
   1248          float Stepper::get_axis_position_mm(const AxisEnum axis) {
   \                     _ZN7Stepper20get_axis_position_mmE8AxisEnum: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1249            float axis_steps;
   1250            #if IS_CORE
   1251              // Requesting one of the "core" axes?
   1252              if (axis == CORE_AXIS_1 || axis == CORE_AXIS_2) {
   1253                CRITICAL_SECTION_START;
   1254                // ((a1+a2)+(a1-a2))/2 -> (a1+a2+a1-a2)/2 -> (a1+a1)/2 -> a1
   1255                // ((a1+a2)-(a1-a2))/2 -> (a1+a2-a1+a2)/2 -> (a2+a2)/2 -> a2
   1256                axis_steps = 0.5f * (
   1257                  axis == CORE_AXIS_2 ? CORESIGN(count_position[CORE_AXIS_1] - count_position[CORE_AXIS_2])
   1258                                      : count_position[CORE_AXIS_1] + count_position[CORE_AXIS_2]
   1259                );
   1260                CRITICAL_SECTION_END;
   1261              }
   1262              else
   1263                axis_steps = position(axis);
   1264            #else
   1265              axis_steps = position(axis);
   \   00000004   0x.... 0x....      BL       _ZN7Stepper8positionE8AxisEnum
   \   00000008   0xEE00 0x0A10      VMOV     S0,R0
   \   0000000C   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   1266            #endif
   1267            return axis_steps * planner.steps_to_mm[axis];
   \   00000010   0x....             LDR.N    R0,??DataTable14_11
   \   00000012   0xEB00 0x0084      ADD      R0,R0,R4, LSL #+2
   \   00000016   0xEDD0 0x0A00      VLDR     S1,[R0, #0]
   \   0000001A   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
   1268          }
   1269          

   \                                 In section .text, align 2, keep-with-next
   1270          void Stepper::finish_and_disable() {
   \                     _ZN7Stepper18finish_and_disableEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1271            synchronize();
   \   00000002   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   1272            disable_all_steppers();
   \   00000006   0xE8BD 0x4001      POP      {R0,LR}
   \   0000000A   0x.... 0x....      B.W      _Z20disable_all_steppersv
   1273          }
   1274          

   \                                 In section .text, align 2, keep-with-next
   1275          void Stepper::quick_stop() {
   \                     _ZN7Stepper10quick_stopEv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1276            cleaning_buffer_counter = 5000;
   \   00000002   0x....             LDR.N    R4,??DataTable14_5
   \   00000004   0xF241 0x3088      MOVW     R0,#+5000
   \   00000008   0x8120             STRH     R0,[R4, #+8]
   1277            DISABLE_STEPPER_DRIVER_INTERRUPT();
   \   0000000A   0x....             LDR.N    R5,??DataTable14_1
   \   0000000C   0x4628             MOV      R0,R5
   \   0000000E   0x.... 0x....      BL       HAL_TIM_Base_Stop_IT
   \   00000012   0xE001             B.N      ??quick_stop_0
   1278            while (planner.blocks_queued()) planner.discard_current_block();
   \                     ??quick_stop_1: (+1)
   \   00000014   0x.... 0x....      BL       _ZN7Planner21discard_current_blockEv
   \                     ??quick_stop_0: (+1)
   \   00000018   0x.... 0x....      BL       _ZN7Planner13blocks_queuedEv
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD1F9             BNE.N    ??quick_stop_1
   1279            current_block = NULL;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x6220             STR      R0,[R4, #+32]
   1280            ENABLE_STEPPER_DRIVER_INTERRUPT();
   \   00000024   0x4628             MOV      R0,R5
   \   00000026   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000002A   0x.... 0x....      B.W      HAL_TIM_Base_Start_IT
   1281            #if ENABLED(ULTRA_LCD)
   1282              planner.clear_block_buffer_runtime();
   1283            #endif
   1284          }
   1285          

   \                                 In section .text, align 2, keep-with-next
   1286          void Stepper::endstop_triggered(AxisEnum axis) {
   \                     _ZN7Stepper17endstop_triggeredE8AxisEnum: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x....             LDR.N    R4,??DataTable14_5
   \   00000004   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   00000008   0x6901             LDR      R1,[R0, #+16]
   \   0000000A   0x6401             STR      R1,[R0, #+64]
   1287          
   1288            #if IS_CORE
   1289          
   1290              endstops_trigsteps[axis] = 0.5f * (
   1291                axis == CORE_AXIS_2 ? CORESIGN(count_position[CORE_AXIS_1] - count_position[CORE_AXIS_2])
   1292                                    : count_position[CORE_AXIS_1] + count_position[CORE_AXIS_2]
   1293              );
   1294          
   1295            #else // !COREXY && !COREXZ && !COREYZ
   1296          
   1297              endstops_trigsteps[axis] = count_position[axis];
   1298          
   1299            #endif // !COREXY && !COREXZ && !COREYZ
   1300          
   1301            kill_current_block();
   \   0000000C   0x.... 0x....      BL       _ZN7Stepper18kill_current_blockEv
   1302            cleaning_buffer_counter = -1; // Discard the rest of the move
   \   00000010   0xF04F 0x30FF      MOV      R0,#-1
   \   00000014   0x8120             STRH     R0,[R4, #+8]
   1303          }
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
   1304          

   \                                 In section .text, align 4, keep-with-next
   1305          void Stepper::report_positions() {
   \                     _ZN7Stepper16report_positionsEv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1306            CRITICAL_SECTION_START;
   \   00000002   0xB672             cpsid i
   1307            const long xpos = count_position[X_AXIS],
   \   00000004   0x....             LDR.N    R0,??DataTable14_5
   \   00000006   0x6901             LDR      R1,[R0, #+16]
   1308                       ypos = count_position[Y_AXIS],
   \   00000008   0x6941             LDR      R1,[R0, #+20]
   1309                       zpos = count_position[Z_AXIS];
   \   0000000A   0x6984             LDR      R4,[R0, #+24]
   1310            CRITICAL_SECTION_END;
   \   0000000C   0xB662             cpsie i
   1311          #if 0
   1312            #if CORE_IS_XY || CORE_IS_XZ || IS_SCARA
   1313              SERIAL_PROTOCOLPGM(MSG_COUNT_A);
   1314            #else
   1315              SERIAL_PROTOCOLPGM(MSG_COUNT_X);
   1316            #endif
   1317            SERIAL_PROTOCOL(xpos);
   1318          
   1319            #if CORE_IS_XY || CORE_IS_YZ || IS_SCARA
   1320              SERIAL_PROTOCOLPGM(" B:");
   1321            #else
   1322              SERIAL_PROTOCOLPGM(" Y:");
   1323            #endif
   1324            SERIAL_PROTOCOL(ypos);
   1325          #endif
   1326            #if CORE_IS_XZ || CORE_IS_YZ
   1327              SERIAL_PROTOCOLPGM(" C:");
   1328            #else
   1329              SERIAL_PROTOCOLPGM(" Z:");
   \   0000000E   0x....             ADR.N    R0,??DataTable14  ;; " Z:"
   \   00000010   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1330            #endif
   1331            SERIAL_PROTOCOL(zpos);
   \   00000014   0x....             LDR.N    R5,??DataTable14_12
   \   00000016   0x220A             MOVS     R2,#+10
   \   00000018   0x4621             MOV      R1,R4
   \   0000001A   0x4628             MOV      R0,R5
   \   0000001C   0x.... 0x....      BL       _ZN5Print5printEli
   1332          
   1333            SERIAL_EOL();
   \   00000020   0x210A             MOVS     R1,#+10
   \   00000022   0x4628             MOV      R0,R5
   \   00000024   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000028   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   1334          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x20 0x5A          DC8      " Z:"
   \              0x3A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x........         DC32     htim2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x........         DC32     gArrayGpioPort

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \   00000000   0x........         DC32     gArrayGpioPin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \   00000000   0x........         DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \   00000000   0x........         DC32     _ZN7Stepper15count_directionE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \   00000000   0x........         DC32     htim4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_7:
   \   00000000   0x........         DC32     _ZN8Endstops7enabledE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_8:
   \   00000000   0x........         DC32     _ZN11Temperature11in_temp_isrE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_9:
   \   00000000   0x........         DC32     endstops

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_10:
   \   00000000   0x........         DC32     axis_known_position

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_11:
   \   00000000   0x........         DC32     _ZN7Planner11steps_to_mmE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_12:
   \   00000000   0x........         DC32     Serial6

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "M84 X Y Z E">`:
   \   00000000   0x4D 0x38          DC8 "M84 X Y Z E"
   \              0x34 0x20    
   \              0x58 0x20    
   \              0x59 0x20    
   \              0x5A 0x20    
   \              0x45 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant " Z:">`:
   \   00000000   0x20 0x5A          DC8 " Z:"
   \              0x3A 0x00    
   1335          
   1336          #if ENABLED(BABYSTEPPING)
   1337          
   1338            #if ENABLED(DELTA)
   1339              #define CYCLES_EATEN_BABYSTEP (2 * 15)
   1340            #else
   1341              #define CYCLES_EATEN_BABYSTEP 0
   1342            #endif
   1343            #define EXTRA_CYCLES_BABYSTEP (STEP_PULSE_CYCLES - (CYCLES_EATEN_BABYSTEP))
   1344          
   1345            #define _ENABLE(AXIS) enable_## AXIS()
   1346            #define _READ_DIR(AXIS) AXIS ##_DIR_READ
   1347            #define _INVERT_DIR(AXIS) INVERT_## AXIS ##_DIR
   1348            #define _APPLY_DIR(AXIS, INVERT) AXIS ##_APPLY_DIR(INVERT, true)
   1349          
   1350            #if EXTRA_CYCLES_BABYSTEP > 20
   1351              #define _SAVE_START const uint32_t pulse_start = TCNT0
   1352              #define _PULSE_WAIT while (EXTRA_CYCLES_BABYSTEP > (uint32_t)(TCNT0 - pulse_start) * (INT0_PRESCALER)) { /* nada */ }
   1353            #else
   1354              #define _SAVE_START NOOP
   1355              #if EXTRA_CYCLES_BABYSTEP > 0
   1356                #define _PULSE_WAIT DELAY_NOPS(EXTRA_CYCLES_BABYSTEP)
   1357              #elif STEP_PULSE_CYCLES > 0
   1358                #define _PULSE_WAIT NOOP
   1359              #elif ENABLED(DELTA)
   1360                #define _PULSE_WAIT delayMicroseconds(2);
   1361              #else
   1362                #define _PULSE_WAIT delayMicroseconds(4);
   1363              #endif
   1364            #endif
   1365          
   1366            #define BABYSTEP_AXIS(AXIS, INVERT) {                     \
   1367                const uint8_t old_dir = _READ_DIR(AXIS);              \
   1368                _ENABLE(AXIS);                                        \
   1369                _SAVE_START;                                          \
   1370                _APPLY_DIR(AXIS, _INVERT_DIR(AXIS)^direction^INVERT); \
   1371                _APPLY_STEP(AXIS)(!_INVERT_STEP_PIN(AXIS), true);     \
   1372                _PULSE_WAIT;                                          \
   1373                _APPLY_STEP(AXIS)(_INVERT_STEP_PIN(AXIS), true);      \
   1374                _APPLY_DIR(AXIS, old_dir);                            \
   1375              }
   1376          
   1377            // MUST ONLY BE CALLED BY AN ISR,
   1378            // No other ISR should ever interrupt this!
   1379            void Stepper::babystep(const AxisEnum axis, const bool direction) {
   1380              cli();
   1381          
   1382              switch (axis) {
   1383          
   1384                #if ENABLED(BABYSTEP_XY)
   1385          
   1386                  case X_AXIS:
   1387                    BABYSTEP_AXIS(X, false);
   1388                    break;
   1389          
   1390                  case Y_AXIS:
   1391                    BABYSTEP_AXIS(Y, false);
   1392                    break;
   1393          
   1394                #endif
   1395          
   1396                case Z_AXIS: {
   1397          
   1398                  #if DISABLED(DELTA)
   1399          
   1400                    BABYSTEP_AXIS(Z, BABYSTEP_INVERT_Z);
   1401          
   1402                  #else // DELTA
   1403          
   1404                    const bool z_direction = direction ^ BABYSTEP_INVERT_Z;
   1405          
   1406                    enable_X();
   1407                    enable_Y();
   1408                    enable_Z();
   1409          
   1410                    const uint8_t old_x_dir_pin = X_DIR_READ,
   1411                                  old_y_dir_pin = Y_DIR_READ,
   1412                                  old_z_dir_pin = Z_DIR_READ;
   1413          
   1414                    X_DIR_WRITE(INVERT_X_DIR ^ z_direction);
   1415                    Y_DIR_WRITE(INVERT_Y_DIR ^ z_direction);
   1416                    Z_DIR_WRITE(INVERT_Z_DIR ^ z_direction);
   1417          
   1418                    _SAVE_START;
   1419          
   1420                    X_STEP_WRITE(!INVERT_X_STEP_PIN);
   1421                    Y_STEP_WRITE(!INVERT_Y_STEP_PIN);
   1422                    Z_STEP_WRITE(!INVERT_Z_STEP_PIN);
   1423          
   1424                    _PULSE_WAIT;
   1425          
   1426                    X_STEP_WRITE(INVERT_X_STEP_PIN);
   1427                    Y_STEP_WRITE(INVERT_Y_STEP_PIN);
   1428                    Z_STEP_WRITE(INVERT_Z_STEP_PIN);
   1429          
   1430                    // Restore direction bits
   1431                    X_DIR_WRITE(old_x_dir_pin);
   1432                    Y_DIR_WRITE(old_y_dir_pin);
   1433                    Z_DIR_WRITE(old_z_dir_pin);
   1434          
   1435                  #endif
   1436          
   1437                } break;
   1438          
   1439                default: break;
   1440              }
   1441              sei();
   1442            }
   1443          
   1444          #endif // BABYSTEPPING
   1445          
   1446          /**
   1447           * Software-controlled Stepper Motor Current
   1448           */
   1449          
   1450          #if HAS_DIGIPOTSS
   1451          
   1452            // From Arduino DigitalPotControl example
   1453            void Stepper::digitalPotWrite(const int16_t address, const int16_t value) {
   1454              WRITE(DIGIPOTSS_PIN, LOW);  // Take the SS pin low to select the chip
   1455              SPI.transfer(address);      // Send the address and value via SPI
   1456              SPI.transfer(value);
   1457              WRITE(DIGIPOTSS_PIN, HIGH); // Take the SS pin high to de-select the chip
   1458              //delay(10);
   1459            }
   1460          
   1461          #endif // HAS_DIGIPOTSS
   1462          
   1463          #if HAS_MOTOR_CURRENT_PWM
   1464          
   1465            void Stepper::refresh_motor_power() {
   1466              for (uint8_t i = 0; i < COUNT(motor_current_setting); ++i) {
   1467                switch (i) {
   1468                  #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
   1469                    case 0:
   1470                  #endif
   1471                  #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
   1472                    case 1:
   1473                  #endif
   1474                  #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
   1475                    case 2:
   1476                  #endif
   1477                      digipot_current(i, motor_current_setting[i]);
   1478                  default: break;
   1479                }
   1480              }
   1481            }
   1482          
   1483          #endif // HAS_MOTOR_CURRENT_PWM
   1484          
   1485          #if HAS_DIGIPOTSS || HAS_MOTOR_CURRENT_PWM
   1486          
   1487            void Stepper::digipot_current(const uint8_t driver, const int current) {
   1488          
   1489              #if HAS_DIGIPOTSS
   1490          
   1491                const uint8_t digipot_ch[] = DIGIPOT_CHANNELS;
   1492                digitalPotWrite(digipot_ch[driver], current);
   1493          
   1494              #elif HAS_MOTOR_CURRENT_PWM
   1495          
   1496                if (WITHIN(driver, 0, 2))
   1497                  motor_current_setting[driver] = current; // update motor_current_setting
   1498          
   1499                #define _WRITE_CURRENT_PWM(P) analogWrite(MOTOR_CURRENT_PWM_## P ##_PIN, 255L * current / (MOTOR_CURRENT_PWM_RANGE))
   1500                switch (driver) {
   1501                  #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
   1502                    case 0: _WRITE_CURRENT_PWM(XY); break;
   1503                  #endif
   1504                  #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
   1505                    case 1: _WRITE_CURRENT_PWM(Z); break;
   1506                  #endif
   1507                  #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
   1508                    case 2: _WRITE_CURRENT_PWM(E); break;
   1509                  #endif
   1510                }
   1511              #endif
   1512            }
   1513          
   1514            void Stepper::digipot_init() {
   1515          
   1516              #if HAS_DIGIPOTSS
   1517          
   1518                static const uint8_t digipot_motor_current[] = DIGIPOT_MOTOR_CURRENT;
   1519          
   1520                SPI.begin();
   1521                SET_OUTPUT(DIGIPOTSS_PIN);
   1522          
   1523                for (uint8_t i = 0; i < COUNT(digipot_motor_current); i++) {
   1524                  //digitalPotWrite(digipot_ch[i], digipot_motor_current[i]);
   1525                  digipot_current(i, digipot_motor_current[i]);
   1526                }
   1527          
   1528              #elif HAS_MOTOR_CURRENT_PWM
   1529          
   1530                #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
   1531                  SET_OUTPUT(MOTOR_CURRENT_PWM_XY_PIN);
   1532                #endif
   1533                #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
   1534                  SET_OUTPUT(MOTOR_CURRENT_PWM_Z_PIN);
   1535                #endif
   1536                #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
   1537                  SET_OUTPUT(MOTOR_CURRENT_PWM_E_PIN);
   1538                #endif
   1539          
   1540                refresh_motor_power();
   1541          
   1542                // Set Timer5 to 31khz so the PWM of the motor power is as constant as possible. (removes a buzzing noise)
   1543                SET_CS5(PRESCALER_1);
   1544          
   1545              #endif
   1546            }
   1547          
   1548          #endif
   1549          
   1550          #if HAS_MICROSTEPS
   1551          
   1552            /**
   1553             * Software-controlled Microstepping
   1554             */
   1555          
   1556            void Stepper::microstep_init() {
   1557              SET_OUTPUT(X_MS1_PIN);
   1558              SET_OUTPUT(X_MS2_PIN);
   1559              #if HAS_Y_MICROSTEPS
   1560                SET_OUTPUT(Y_MS1_PIN);
   1561                SET_OUTPUT(Y_MS2_PIN);
   1562              #endif
   1563              #if HAS_Z_MICROSTEPS
   1564                SET_OUTPUT(Z_MS1_PIN);
   1565                SET_OUTPUT(Z_MS2_PIN);
   1566              #endif
   1567              #if HAS_E0_MICROSTEPS
   1568                SET_OUTPUT(E0_MS1_PIN);
   1569                SET_OUTPUT(E0_MS2_PIN);
   1570              #endif
   1571              #if HAS_E1_MICROSTEPS
   1572                SET_OUTPUT(E1_MS1_PIN);
   1573                SET_OUTPUT(E1_MS2_PIN);
   1574              #endif
   1575              #if HAS_E2_MICROSTEPS
   1576                SET_OUTPUT(E2_MS1_PIN);
   1577                SET_OUTPUT(E2_MS2_PIN);
   1578              #endif
   1579              #if HAS_E3_MICROSTEPS
   1580                SET_OUTPUT(E3_MS1_PIN);
   1581                SET_OUTPUT(E3_MS2_PIN);
   1582              #endif
   1583              #if HAS_E4_MICROSTEPS
   1584                SET_OUTPUT(E4_MS1_PIN);
   1585                SET_OUTPUT(E4_MS2_PIN);
   1586              #endif
   1587              static const uint8_t microstep_modes[] = MICROSTEP_MODES;
   1588              for (uint16_t i = 0; i < COUNT(microstep_modes); i++)
   1589                microstep_mode(i, microstep_modes[i]);
   1590            }
   1591          
   1592            void Stepper::microstep_ms(const uint8_t driver, const int8_t ms1, const int8_t ms2) {
   1593              if (ms1 >= 0) switch (driver) {
   1594                case 0: WRITE(X_MS1_PIN, ms1); break;
   1595                #if HAS_Y_MICROSTEPS
   1596                  case 1: WRITE(Y_MS1_PIN, ms1); break;
   1597                #endif
   1598                #if HAS_Z_MICROSTEPS
   1599                  case 2: WRITE(Z_MS1_PIN, ms1); break;
   1600                #endif
   1601                #if HAS_E0_MICROSTEPS
   1602                  case 3: WRITE(E0_MS1_PIN, ms1); break;
   1603                #endif
   1604                #if HAS_E1_MICROSTEPS
   1605                  case 4: WRITE(E1_MS1_PIN, ms1); break;
   1606                #endif
   1607                #if HAS_E2_MICROSTEPS
   1608                  case 5: WRITE(E2_MS1_PIN, ms1); break;
   1609                #endif
   1610                #if HAS_E3_MICROSTEPS
   1611                  case 6: WRITE(E3_MS1_PIN, ms1); break;
   1612                #endif
   1613                #if HAS_E4_MICROSTEPS
   1614                  case 7: WRITE(E4_MS1_PIN, ms1); break;
   1615                #endif
   1616              }
   1617              if (ms2 >= 0) switch (driver) {
   1618                case 0: WRITE(X_MS2_PIN, ms2); break;
   1619                #if HAS_Y_MICROSTEPS
   1620                  case 1: WRITE(Y_MS2_PIN, ms2); break;
   1621                #endif
   1622                #if HAS_Z_MICROSTEPS
   1623                  case 2: WRITE(Z_MS2_PIN, ms2); break;
   1624                #endif
   1625                #if HAS_E0_MICROSTEPS
   1626                  case 3: WRITE(E0_MS2_PIN, ms2); break;
   1627                #endif
   1628                #if HAS_E1_MICROSTEPS
   1629                  case 4: WRITE(E1_MS2_PIN, ms2); break;
   1630                #endif
   1631                #if HAS_E2_MICROSTEPS
   1632                  case 5: WRITE(E2_MS2_PIN, ms2); break;
   1633                #endif
   1634                #if HAS_E3_MICROSTEPS
   1635                  case 6: WRITE(E3_MS2_PIN, ms2); break;
   1636                #endif
   1637                #if HAS_E4_MICROSTEPS
   1638                  case 7: WRITE(E4_MS2_PIN, ms2); break;
   1639                #endif
   1640              }
   1641            }
   1642          
   1643            void Stepper::microstep_mode(const uint8_t driver, const uint8_t stepping_mode) {
   1644              switch (stepping_mode) {
   1645                case 1: microstep_ms(driver, MICROSTEP1); break;
   1646                case 2: microstep_ms(driver, MICROSTEP2); break;
   1647                case 4: microstep_ms(driver, MICROSTEP4); break;
   1648                case 8: microstep_ms(driver, MICROSTEP8); break;
   1649                case 16: microstep_ms(driver, MICROSTEP16); break;
   1650              }
   1651            }
   1652          
   1653            void Stepper::microstep_readings() {
   1654              SERIAL_PROTOCOLLNPGM("MS1,MS2 Pins");
   1655              SERIAL_PROTOCOLPGM("X: ");
   1656              SERIAL_PROTOCOL(READ(X_MS1_PIN));
   1657              SERIAL_PROTOCOLLN(READ(X_MS2_PIN));
   1658              #if HAS_Y_MICROSTEPS
   1659                SERIAL_PROTOCOLPGM("Y: ");
   1660                SERIAL_PROTOCOL(READ(Y_MS1_PIN));
   1661                SERIAL_PROTOCOLLN(READ(Y_MS2_PIN));
   1662              #endif
   1663              #if HAS_Z_MICROSTEPS
   1664                SERIAL_PROTOCOLPGM("Z: ");
   1665                SERIAL_PROTOCOL(READ(Z_MS1_PIN));
   1666                SERIAL_PROTOCOLLN(READ(Z_MS2_PIN));
   1667              #endif
   1668              #if HAS_E0_MICROSTEPS
   1669                SERIAL_PROTOCOLPGM("E0: ");
   1670                SERIAL_PROTOCOL(READ(E0_MS1_PIN));
   1671                SERIAL_PROTOCOLLN(READ(E0_MS2_PIN));
   1672              #endif
   1673              #if HAS_E1_MICROSTEPS
   1674                SERIAL_PROTOCOLPGM("E1: ");
   1675                SERIAL_PROTOCOL(READ(E1_MS1_PIN));
   1676                SERIAL_PROTOCOLLN(READ(E1_MS2_PIN));
   1677              #endif
   1678              #if HAS_E2_MICROSTEPS
   1679                SERIAL_PROTOCOLPGM("E2: ");
   1680                SERIAL_PROTOCOL(READ(E2_MS1_PIN));
   1681                SERIAL_PROTOCOLLN(READ(E2_MS2_PIN));
   1682              #endif
   1683              #if HAS_E3_MICROSTEPS
   1684                SERIAL_PROTOCOLPGM("E3: ");
   1685                SERIAL_PROTOCOL(READ(E3_MS1_PIN));
   1686                SERIAL_PROTOCOLLN(READ(E3_MS2_PIN));
   1687              #endif
   1688              #if HAS_E4_MICROSTEPS
   1689                SERIAL_PROTOCOLPGM("E4: ");
   1690                SERIAL_PROTOCOL(READ(E4_MS1_PIN));
   1691                SERIAL_PROTOCOLLN(READ(E4_MS2_PIN));
   1692              #endif
   1693            }
   1694          
   1695          #endif // HAS_MICROSTEPS

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   Endstops::enable(bool)
       0   IsrStepperHandler
         0   -> Stepper::StepperHandler()
       0   Planner::blocks_queued()
       8   Planner::discard_continued_block()
         8   -> Planner::blocks_queued()
         8   -> Planner::discard_current_block()
       8   Planner::discard_current_block()
         8   -> Planner::blocks_queued()
       8   Planner::get_current_block()
         8   -> Planner::blocks_queued()
      32   Stepper::StepperHandler()
        32   -> Endstops::update()
        32   -> HAL_GPIO_WritePin
         0   -> HAL_TIM_Base_Start_IT
        32   -> HAL_TIM_Base_Start_IT
        32   -> HAL_TIM_Base_Stop_IT
        32   -> Planner::discard_continued_block()
        32   -> Planner::discard_current_block()
        32   -> Planner::get_current_block()
        32   -> Stepper::calc_timer_interval(unsigned short)
        32   -> Stepper::trapezoid_generator_reset()
        32   -> enqueue_and_echo_commands_P(char const *)
       0   Stepper::calc_timer_interval(unsigned short)
       8   Stepper::endstop_triggered(AxisEnum)
         8   -> Stepper::kill_current_block()
       8   Stepper::finish_and_disable()
         8   -> Stepper::synchronize()
         0   -> disable_all_steppers()
       8   Stepper::get_axis_position_mm(AxisEnum)
         8   -> Stepper::position(AxisEnum)
      16   Stepper::init()
        16   -> Endstops::enable(bool)
        16   -> Endstops::init()
        16   -> HAL_GPIO_WritePin
        16   -> HAL_TIM_Base_Start_IT
         0   -> Stepper::set_directions()
       0   Stepper::kill_current_block()
       0   Stepper::motor_direction(AxisEnum)
       0   Stepper::position(AxisEnum)
      16   Stepper::quick_stop()
         0   -> HAL_TIM_Base_Start_IT
        16   -> HAL_TIM_Base_Stop_IT
        16   -> Planner::blocks_queued()
        16   -> Planner::discard_current_block()
      16   Stepper::report_positions()
        16   -> Print::print(long, int)
         0   -> USARTClass::write(uint8_t)
        16   -> serialprintPGM(char const *)
      24   Stepper::set_directions()
        24   -> HAL_GPIO_WritePin
        24   -> Stepper::motor_direction(AxisEnum)
       0   Stepper::set_e_position(long const &)
       0   Stepper::set_position(AxisEnum const &, long const &)
      24   Stepper::set_position(long const &, long const &, long const &, long const &)
        24   -> Stepper::synchronize()
       8   Stepper::synchronize()
         8   -> Planner::blocks_queued()
         8   -> idle()
      16   Stepper::trapezoid_generator_reset()
        16   -> Stepper::calc_timer_interval(unsigned short)
        16   -> Stepper::set_directions()
       8   Stepper::waitUntilEndOfAllBuffers()
         8   -> Planner::blocks_queued()
       0   Stepper::waitUntilEndOfAllMoves()
       0   Stepper::wake_up()
         0   -> HAL_TIM_Base_Start_IT
       8   serialprintPGM(char const *)
         8   -> USARTClass::write(uint8_t)


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ?<Constant " Z:">
      12  ?<Constant "M84 X Y Z E">
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_10
       4  ??DataTable14_11
       4  ??DataTable14_12
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable14_8
       4  ??DataTable14_9
      12  Endstops::enable(bool)
       4  IsrStepperHandler
      28  Planner::blocks_queued()
      56  Planner::discard_continued_block()
      28  Planner::discard_current_block()
      44  Planner::get_current_block()
     946  Stepper::StepperHandler()
      80  Stepper::calc_timer_interval(unsigned short)
      80  Stepper::count_direction
          Stepper::last_direction_bits
          Stepper::step_loops
          Stepper::step_loops_nominal
          Stepper::cleaning_buffer_counter
          Stepper::OCR1A_nominal
          Stepper::acc_step_rate
          Stepper::count_position
          Stepper::current_block
          Stepper::counter_X
          Stepper::counter_Y
          Stepper::counter_Z
          Stepper::counter_E
          Stepper::step_events_completed
          Stepper::acceleration_time
          Stepper::deceleration_time
          Stepper::endstops_trigsteps
          step_remaining
      24  Stepper::endstop_triggered(AxisEnum)
      14  Stepper::finish_and_disable()
      32  Stepper::get_axis_position_mm(AxisEnum)
      68  Stepper::init()
      16  Stepper::kill_current_block()
      28  Stepper::motor_direction(AxisEnum)
      14  Stepper::position(AxisEnum)
      46  Stepper::quick_stop()
      44  Stepper::report_positions()
      76  Stepper::set_directions()
      12  Stepper::set_e_position(long const &)
      20  Stepper::set_position(AxisEnum const &, long const &)
      38  Stepper::set_position(long const &, long const &, long const &, long const &)
      28  Stepper::synchronize()
     112  Stepper::trapezoid_generator_reset()
      12  Stepper::waitUntilEndOfAllBuffers()
       2  Stepper::waitUntilEndOfAllMoves()
       8  Stepper::wake_up()
       1  last_extruder
      28  serialprintPGM(char const *)
       4  stepper
       1  -- Other

 
     4 bytes in section .bss
    81 bytes in section .data
     5 bytes in section .rodata
 1 884 bytes in section .text
 
 1 452 bytes of CODE  memory (+ 432 bytes shared)
     4 bytes of CONST memory (+   1 byte  shared)
    84 bytes of DATA  memory (+   1 byte  shared)

Errors: none
Warnings: 62
