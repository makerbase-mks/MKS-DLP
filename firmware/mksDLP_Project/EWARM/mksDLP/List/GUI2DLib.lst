###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  10:58:00
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Core\GUI2DLib.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Core\GUI2DLib.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\GUI2DLib.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\GUI2DLib.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Core\GUI2DLib.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              µC/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : GUI2DLib.C
     16          Purpose     : Main part of the 2D graphics library
     17          ---------------------------END-OF-HEADER------------------------------
     18          */
     19          
     20          #include <stddef.h>           /* needed for definition of NULL */
     21          #include "GUI_Protected.h"
     22          #include "GUIDebug.h"
     23          
     24          /*********************************************************************
     25          *
     26          *       defines
     27          *
     28          **********************************************************************
     29          */
     30          
     31          #define ABS(v) ((v>0) ? v : -v)
     32          
     33          /*********************************************************************
     34          *
     35          *       static code, helper functions
     36          *
     37          **********************************************************************
     38          */
     39          /*********************************************************************
     40          *
     41          *       _SwapInt
     42          */

   \                                 In section .text, align 2, keep-with-next
     43          static void _SwapInt(int* pa, int* pb) {
     44            int t;
     45            t = *pa;
   \                     _SwapInt: (+1)
   \   00000000   0x6802             LDR      R2,[R0, #+0]
     46            *pa = *pb;
   \   00000002   0x680B             LDR      R3,[R1, #+0]
   \   00000004   0x6003             STR      R3,[R0, #+0]
     47            *pb = t;
   \   00000006   0x600A             STR      R2,[R1, #+0]
     48          }
   \   00000008   0x4770             BX       LR               ;; return
     49          
     50          /*********************************************************************
     51          *
     52          *       Abs
     53          */

   \                                 In section .text, align 2, keep-with-next
     54          static int Abs(int v) {
     55            return ABS(v);
   \                     Abs: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD500             BPL.N    ??Abs_0
   \   00000004   0x4240             RSBS     R0,R0,#+0
   \                     ??Abs_0: (+1)
   \   00000006   0x4770             BX       LR               ;; return
     56          }
     57          
     58          /*********************************************************************
     59          *
     60          *       trigonometric functions
     61          *
     62          *  NOTE:
     63          *   All trigonometric functions are for internal usage only and
     64          *   use the following conventions:
     65          *
     66          *      Angles: 4096 <==> 360°
     67          *
     68          **********************************************************************
     69          */
     70          
     71          #if GUI_45DEG != 512
     72            #error Wrong define for this library !
     73          #endif
     74          
     75          /*********************************************************************
     76          *
     77          *       sin / cos (internal)
     78          *
     79          *  Angle : 90/1024°
     80          *  Data  : 1/1024
     81          */

   \                                 In section .text, align 4, keep-with-next
     82          static const U16 aSin[] = {
   \                     aSin:
   \   00000000   0x0000 0x0064      DC16 0, 100, 200, 297, 392, 483, 569, 650, 724, 792, 851, 903, 946, 980
   \              0x00C8 0x0129
   \              0x0188 0x01E3
   \              0x0239 0x028A
   \              0x02D4 0x0318
   \              0x0353 0x0387
   \              0x03B2 0x03D4
   \   0000001C   0x03EC 0x03FB      DC16 1004, 1019, 1024
   \              0x0400       
   \   00000022   0x00 0x00          DC8 0, 0
     83            0,       /*  1/16 *90° */
     84            100,     /*  1/16 *90° */
     85            200,     /*  2/16 *90° */
     86            297,     /*  3/16 *90° */
     87            392,     /*  4/16 *90° */
     88            483,     /*  5/16 *90° */
     89            569,     /*  6/16 *90° */
     90            650,     /*  7/16 *90° */
     91            724,     /*  8/16 *90° */
     92            792,     /*  9/16 *90° */
     93            851,     /* 10/16 *90° */
     94            903,     /* 11/16 *90° */
     95            946,     /* 12/16 *90° */
     96            980,     /* 13/16 *90° */
     97            1004,    /* 14/16 *90° */
     98            1019,    /* 15/16 *90° */
     99            1024     /* 16/16 *90° */
    100          };
    101          
    102          /*********************************************************************
    103          *
    104          *       GUI_sin
    105          */

   \                                 In section .text, align 2, keep-with-next
    106          int GUI_sin(int angle) {
   \                     GUI_sin: (+1)
   \   00000000   0xB410             PUSH     {R4}
    107            char IsNeg =0;
   \   00000002   0x2100             MOVS     R1,#+0
    108            int i;
    109          	U16 Faktor;
    110            U32 t;
    111            angle &= ((1<<12)-1);  /* reduce to 0-360 degrees */
   \   00000004   0x0500             LSLS     R0,R0,#+20
   \   00000006   0x0D00             LSRS     R0,R0,#+20
    112            if (angle> 2* GUI_90DEG) {
   \   00000008   0xF5B0 0x6F00      CMP      R0,#+2048
   \   0000000C   0xDD02             BLE.N    ??GUI_sin_0
    113              angle -= 2* GUI_90DEG;
   \   0000000E   0xF5A0 0x6000      SUB      R0,R0,#+2048
    114              IsNeg =1;
   \   00000012   0x2101             MOVS     R1,#+1
    115            }
    116            if (angle> GUI_90DEG) {  /* between 90-180 */
   \                     ??GUI_sin_0: (+1)
   \   00000014   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000018   0xDD01             BLE.N    ??GUI_sin_1
    117              angle = 2*GUI_90DEG-angle;   /* use sine symetry */
   \   0000001A   0xF5C0 0x6000      RSB      R0,R0,#+2048
    118            }
    119            /* Now angle is reduced to 0° <= <= 90° */
    120          #if 0
    121            angle >>=2;    /* make sure we do not exceed 16 bits in calculations */
    122            i = angle>>4;
    123            Faktor = (1<<4)-(angle&((1<<4)-1));
    124            r = aSin[i]*Faktor;
    125            if (Faktor !=(1<<4)) {
    126              r += aSin[i+1]*((1<<4)-Faktor);
    127            }
    128            r = (r+(1<<3)) >>4;   /* divide,incl. rounding */
    129          #else
    130            i = angle>>6;
   \                     ??GUI_sin_1: (+1)
   \   0000001E   0x1182             ASRS     R2,R0,#+6
    131            {
    132              Faktor = (U16)((1<<6)-(angle&((1<<6)-1)));
   \   00000020   0xF000 0x003F      AND      R0,R0,#0x3F
   \   00000024   0xF1C0 0x0040      RSB      R0,R0,#+64
   \   00000028   0xB280             UXTH     R0,R0
    133              t = aSin[i]*(U32)Faktor;
   \   0000002A   0x.... 0x....      ADR.W    R3,aSin
   \   0000002E   0xF833 0x4012      LDRH     R4,[R3, R2, LSL #+1]
   \   00000032   0x4344             MULS     R4,R0,R4
    134              if (Faktor !=(1<<6)) {
   \   00000034   0x2840             CMP      R0,#+64
   \   00000036   0xD006             BEQ.N    ??GUI_sin_2
    135                t += aSin[i+1]*((1<<6)-Faktor);
   \   00000038   0xEB03 0x0242      ADD      R2,R3,R2, LSL #+1
   \   0000003C   0x8852             LDRH     R2,[R2, #+2]
   \   0000003E   0xF1C0 0x0040      RSB      R0,R0,#+64
   \   00000042   0xFB00 0x4402      MLA      R4,R0,R2,R4
    136              }
    137          	}
    138            t = (t+(1<<5)) >>6;   /* divide,incl. rounding */
   \                     ??GUI_sin_2: (+1)
   \   00000046   0xF104 0x0020      ADD      R0,R4,#+32
   \   0000004A   0x0980             LSRS     R0,R0,#+6
    139          #endif
    140            return (IsNeg) ? 0-t : t;
   \   0000004C   0x2900             CMP      R1,#+0
   \   0000004E   0xD000             BEQ.N    ??GUI_sin_3
   \   00000050   0x4240             RSBS     R0,R0,#+0
   \                     ??GUI_sin_3: (+1)
   \   00000052   0xBC10             POP      {R4}
   \   00000054   0x4770             BX       LR               ;; return
    141          }
    142          
    143          /*********************************************************************
    144          *
    145          *       GUI_cos
    146          */

   \                                 In section .text, align 2, keep-with-next
    147          int GUI_cos(int angle) {
    148            return GUI_sin(angle+GUI_90DEG);
   \                     GUI_cos: (+1)
   \   00000000   0xF500 0x6080      ADD      R0,R0,#+1024
   \   00000004   0x....             B.N      GUI_sin
    149          }
    150          
    151          /*********************************************************************
    152          *
    153          *       atan() (internal)
    154          *
    155          *  Angle : 360/4096°
    156          */

   \                                 In section .text, align 4, keep-with-next
    157          const I16 aTan[] = {
   \                     aTan:
   \   00000000   0x0000 0x0029      DC16 0, 41, 81, 121, 160, 197, 234, 269, 302, 334, 364, 393, 419, 445
   \              0x0051 0x0079
   \              0x00A0 0x00C5
   \              0x00EA 0x010D
   \              0x012E 0x014E
   \              0x016C 0x0189
   \              0x01A3 0x01BD
   \   0000001C   0x01D5 0x01EB      DC16 469, 491, 512
   \              0x0200       
   \   00000022   0x00 0x00          DC8 0, 0
    158            0,       /* atan(0/16) */
    159            41,      /* atan(1/16) */
    160            81,      /* atan(2/16) */
    161            121,     /* atan(3/16) */
    162            160,     /* atan(4/16) */
    163            197,     /* atan(5/16) */
    164            234,     /* atan(6/16) */
    165            269,     /* atan(7/16) */
    166            302,     /* atan(8/16) */
    167            334,     /* atan(9/16) */
    168            364,     /* atan(10/16) */
    169            393,     /* atan(11/16) */
    170            419,     /* atan(12/16) */
    171            445,     /* atan(13/16) */
    172            469,     /* atan(14/16) */
    173            491,     /* atan(15/16) */
    174            512      /* atan(1) = 45° = 512/1024 */
    175          };
    176          
    177          /*********************************************************************
    178          *
    179          *       _atan0_45
    180          *
    181          * Calculate arctan of q, where q is any where between 0 and 1024
    182          */

   \                                 In section .text, align 2, keep-with-next
    183          static int _atan0_45(int q) {
    184            int r;
    185            int i, Faktor;
    186            /* Now angle is reduced to 0° <= <= 90° ==>  0 <= <= 256*/
    187            q >>=2;    /* make sure we do not exceed 16 bits in calculations */
   \                     _atan0_45: (+1)
   \   00000000   0x1080             ASRS     R0,R0,#+2
    188            i = q>>4;
   \   00000002   0x1101             ASRS     R1,R0,#+4
    189            Faktor = (1<<4)-(q&((1<<4)-1));
   \   00000004   0xF000 0x000F      AND      R0,R0,#0xF
   \   00000008   0xF1C0 0x0010      RSB      R0,R0,#+16
    190            r = aTan[i]*Faktor;
   \   0000000C   0x.... 0x....      ADR.W    R2,aTan
   \   00000010   0xF932 0x3011      LDRSH    R3,[R2, R1, LSL #+1]
   \   00000014   0xFB10 0xF303      SMULBB   R3,R0,R3
    191            if (Faktor !=(1<<4)) {
   \   00000018   0x2810             CMP      R0,#+16
   \   0000001A   0xD007             BEQ.N    ??_atan0_45_0
    192              r += aTan[i+1]*((1<<4)-Faktor);
   \   0000001C   0xEB02 0x0141      ADD      R1,R2,R1, LSL #+1
   \   00000020   0xF9B1 0x1002      LDRSH    R1,[R1, #+2]
   \   00000024   0xF1C0 0x0010      RSB      R0,R0,#+16
   \   00000028   0xFB10 0x3301      SMLABB   R3,R0,R1,R3
    193            }
    194            r = (r+(1<<3))/(1<<4);   /* divide  incl. rounding */
    195            return r;
   \                     ??_atan0_45_0: (+1)
   \   0000002C   0xF103 0x0008      ADD      R0,R3,#+8
   \   00000030   0x10C1             ASRS     R1,R0,#+3
   \   00000032   0xEB00 0x7011      ADD      R0,R0,R1, LSR #+28
   \   00000036   0x1100             ASRS     R0,R0,#+4
   \   00000038   0x4770             BX       LR               ;; return
    196          }
    197          
    198          /*********************************************************************
    199          *
    200          *       _atan2
    201          */

   \                                 In section .text, align 2, keep-with-next
    202          static int _atan2(I32 x, I32 y) {
   \                     _atan2: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4602             MOV      R2,R0
    203            U8 q =0;
   \   00000004   0x2400             MOVS     R4,#+0
    204            int angle;
    205          /* first make sure we are in angle between 0 and 45° */
    206            if (x<0) {
   \   00000006   0x2A00             CMP      R2,#+0
   \   00000008   0xD501             BPL.N    ??_atan2_0
    207              q=1;
   \   0000000A   0x2401             MOVS     R4,#+1
    208              x=-x;
   \   0000000C   0x4252             RSBS     R2,R2,#+0
    209            }
    210            if (y<0) {
   \                     ??_atan2_0: (+1)
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD502             BPL.N    ??_atan2_1
    211              q |= (1<<1);
   \   00000012   0xF044 0x0402      ORR      R4,R4,#0x2
    212              y=-y;
   \   00000016   0x4249             RSBS     R1,R1,#+0
    213            }
    214            if (y>x) {
   \                     ??_atan2_1: (+1)
   \   00000018   0x428A             CMP      R2,R1
   \   0000001A   0xDA04             BGE.N    ??_atan2_2
    215              int t = y;
   \   0000001C   0x4608             MOV      R0,R1
    216              y=x;
   \   0000001E   0x4611             MOV      R1,R2
    217              x=t;
   \   00000020   0x4602             MOV      R2,R0
    218              q |= (1<<2);  
   \   00000022   0xF044 0x0404      ORR      R4,R4,#0x4
    219            }
    220            y <<=10;
    221            y += (x/2);
    222            y /= x;
    223            angle = _atan0_45(y);
   \                     ??_atan2_2: (+1)
   \   00000026   0xEB02 0x70D2      ADD      R0,R2,R2, LSR #+31
   \   0000002A   0x1040             ASRS     R0,R0,#+1
   \   0000002C   0xEB00 0x2081      ADD      R0,R0,R1, LSL #+10
   \   00000030   0xFB90 0xF0F2      SDIV     R0,R0,R2
   \   00000034   0x.... 0x....      BL       _atan0_45
    224            if (q&(1<<2)) { /* y/x reverse ? */
   \   00000038   0x4621             MOV      R1,R4
   \   0000003A   0x0749             LSLS     R1,R1,#+29
   \   0000003C   0xD501             BPL.N    ??_atan2_3
    225              angle = GUI_90DEG-angle;
   \   0000003E   0xF5C0 0x6080      RSB      R0,R0,#+1024
    226            }
    227            if (q&1) {  /* xreverse ? */
   \                     ??_atan2_3: (+1)
   \   00000042   0x4621             MOV      R1,R4
   \   00000044   0x07C9             LSLS     R1,R1,#+31
   \   00000046   0xD501             BPL.N    ??_atan2_4
    228              angle = GUI_180DEG-angle;
   \   00000048   0xF5C0 0x6000      RSB      R0,R0,#+2048
    229            }
    230            if (q&(1<<1)) { /* y-reverse ? */
   \                     ??_atan2_4: (+1)
   \   0000004C   0x07A1             LSLS     R1,R4,#+30
   \   0000004E   0xD501             BPL.N    ??_atan2_5
    231              angle = GUI_360DEG-angle;
   \   00000050   0xF5C0 0x5080      RSB      R0,R0,#+4096
    232            }
    233            return angle;
   \                     ??_atan2_5: (+1)
   \   00000054   0xBD10             POP      {R4,PC}          ;; return
    234          }
    235          
    236          /*********************************************************************
    237          *
    238          *       _SetLineColor
    239          */

   \                                 In section .text, align 2, keep-with-next
    240          static int _SetLineColor(int i) {
    241            switch (GUI_Context.LineStyle) {
   \                     _SetLineColor: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable17
   \   00000004   0x7D89             LDRB     R1,[R1, #+22]
   \   00000006   0x2901             CMP      R1,#+1
   \   00000008   0xD006             BEQ.N    ??_SetLineColor_0
   \   0000000A   0xD348             BCC.N    ??_SetLineColor_1
   \   0000000C   0x2903             CMP      R1,#+3
   \   0000000E   0xD01C             BEQ.N    ??_SetLineColor_2
   \   00000010   0xD30F             BCC.N    ??_SetLineColor_3
   \   00000012   0x2904             CMP      R1,#+4
   \   00000014   0xD02B             BEQ.N    ??_SetLineColor_4
   \   00000016   0xE042             B.N      ??_SetLineColor_1
    242            case GUI_LS_DASH:
    243              i = (i+6)%16;
    244              return (i<12);
   \                     ??_SetLineColor_0: (+1)
   \   00000018   0x1D80             ADDS     R0,R0,#+6
   \   0000001A   0x10C1             ASRS     R1,R0,#+3
   \   0000001C   0xEB00 0x7111      ADD      R1,R0,R1, LSR #+28
   \   00000020   0x1109             ASRS     R1,R1,#+4
   \   00000022   0xEBA0 0x1001      SUB      R0,R0,R1, LSL #+4
   \   00000026   0x280C             CMP      R0,#+12
   \   00000028   0xDA01             BGE.N    ??_SetLineColor_5
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x4770             BX       LR
   \                     ??_SetLineColor_5: (+1)
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x4770             BX       LR
    245            case GUI_LS_DOT:
    246              i %= 4;
    247              return (i<2);
   \                     ??_SetLineColor_3: (+1)
   \   00000032   0x1041             ASRS     R1,R0,#+1
   \   00000034   0xEB00 0x7191      ADD      R1,R0,R1, LSR #+30
   \   00000038   0x1089             ASRS     R1,R1,#+2
   \   0000003A   0xEBA0 0x0081      SUB      R0,R0,R1, LSL #+2
   \   0000003E   0x2802             CMP      R0,#+2
   \   00000040   0xDA01             BGE.N    ??_SetLineColor_6
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0x4770             BX       LR
   \                     ??_SetLineColor_6: (+1)
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x4770             BX       LR
    248            case GUI_LS_DASHDOT:
    249              i %= 20;
   \                     ??_SetLineColor_2: (+1)
   \   0000004A   0x2114             MOVS     R1,#+20
   \   0000004C   0xFB90 0xF1F1      SDIV     R1,R0,R1
   \   00000050   0xEB01 0x0281      ADD      R2,R1,R1, LSL #+2
   \   00000054   0xEBA0 0x0082      SUB      R0,R0,R2, LSL #+2
    250              if (i<12)
   \   00000058   0x280C             CMP      R0,#+12
   \   0000005A   0xDA01             BGE.N    ??_SetLineColor_7
    251                return 1;
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0x4770             BX       LR
    252              else if ((i>=16) && (i<18))
   \                     ??_SetLineColor_7: (+1)
   \   00000060   0x3810             SUBS     R0,R0,#+16
   \   00000062   0x2802             CMP      R0,#+2
   \   00000064   0xD201             BCS.N    ??_SetLineColor_8
    253                return 1;
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0x4770             BX       LR
    254              return 0;
   \                     ??_SetLineColor_8: (+1)
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x4770             BX       LR
    255            case GUI_LS_DASHDOTDOT:
    256              i %= 24;
   \                     ??_SetLineColor_4: (+1)
   \   0000006E   0x2118             MOVS     R1,#+24
   \   00000070   0xFB90 0xF1F1      SDIV     R1,R0,R1
   \   00000074   0xEB01 0x0241      ADD      R2,R1,R1, LSL #+1
   \   00000078   0xEBA0 0x00C2      SUB      R0,R0,R2, LSL #+3
    257              if (i<12)
   \   0000007C   0x280C             CMP      R0,#+12
   \   0000007E   0xDA01             BGE.N    ??_SetLineColor_9
    258                return 1;
   \   00000080   0x2001             MOVS     R0,#+1
   \   00000082   0x4770             BX       LR
    259              else if ((i>=16) && (i<18))
   \                     ??_SetLineColor_9: (+1)
   \   00000084   0xF1A0 0x0110      SUB      R1,R0,#+16
   \   00000088   0x2902             CMP      R1,#+2
   \   0000008A   0xD201             BCS.N    ??_SetLineColor_10
    260                return 1;
   \   0000008C   0x2001             MOVS     R0,#+1
   \   0000008E   0x4770             BX       LR
    261              else if ((i>=20) && (i<22))
   \                     ??_SetLineColor_10: (+1)
   \   00000090   0x3814             SUBS     R0,R0,#+20
   \   00000092   0x2802             CMP      R0,#+2
   \   00000094   0xD201             BCS.N    ??_SetLineColor_11
    262                return 1;
   \   00000096   0x2001             MOVS     R0,#+1
   \   00000098   0x4770             BX       LR
    263              else 
    264                return 0;
   \                     ??_SetLineColor_11: (+1)
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0x4770             BX       LR
    265            }
    266            return 0;
   \                     ??_SetLineColor_1: (+1)
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x4770             BX       LR               ;; return
    267          }
    268          
    269          /*********************************************************************
    270          *
    271          *       _atan2
    272          */
    273          #if 0
    274          int _atan2(int xDiff, int yDiff) {
    275            double atanf = atan2(xDiff, yDiff);
    276            return (int)(atanf*(16384.0/6.2831852));
    277          }
    278          #endif
    279          
    280          /*********************************************************************
    281          *
    282          *       _CalcOrto
    283          */

   \                                 In section .text, align 2, keep-with-next
    284          static void _CalcOrto(int xDiff, int yDiff, I32 r, int*px, int*py) {
   \                     _CalcOrto: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4615             MOV      R5,R2
   \   00000004   0x461C             MOV      R4,R3
    285            I32 x,y;
    286          /*
    287            int Angle = _atan2(xDiff, yDiff);
    288          */
    289          #if 0
    290            double Angle = atan2(xDiff, yDiff);
    291            x = (int)(-r*cos(Angle));
    292            y = (int)(r*sin(Angle));
    293          #else
    294            int Angle = _atan2(xDiff, yDiff);
   \   00000006   0x.... 0x....      BL       _atan2
    295            Angle+= GUI_90DEG;
   \   0000000A   0xF500 0x6680      ADD      R6,R0,#+1024
    296            x = ( r*(I32)GUI_cos(Angle));
   \   0000000E   0x4630             MOV      R0,R6
   \   00000010   0x.... 0x....      BL       GUI_cos
   \   00000014   0xFB00 0xF705      MUL      R7,R0,R5
    297            y = ( r*(I32)GUI_sin(Angle));
   \   00000018   0x4630             MOV      R0,R6
   \   0000001A   0x.... 0x....      BL       GUI_sin
   \   0000001E   0x4368             MULS     R0,R0,R5
    298          #endif
    299            x = (x<0) ? -((-x+512)>>10) : ((x+512)>>10);
   \   00000020   0x2F00             CMP      R7,#+0
   \   00000022   0xD504             BPL.N    ??_CalcOrto_0
   \   00000024   0xF5C7 0x7100      RSB      R1,R7,#+512
   \   00000028   0x1289             ASRS     R1,R1,#+10
   \   0000002A   0x4249             RSBS     R1,R1,#+0
   \   0000002C   0xE002             B.N      ??_CalcOrto_1
   \                     ??_CalcOrto_0: (+1)
   \   0000002E   0xF507 0x7100      ADD      R1,R7,#+512
   \   00000032   0x1289             ASRS     R1,R1,#+10
    300            y = (y<0) ? -((-y+512)>>10) : ((y+512)>>10);
   \                     ??_CalcOrto_1: (+1)
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD504             BPL.N    ??_CalcOrto_2
   \   00000038   0xF5C0 0x7000      RSB      R0,R0,#+512
   \   0000003C   0x1280             ASRS     R0,R0,#+10
   \   0000003E   0x4240             RSBS     R0,R0,#+0
   \   00000040   0xE002             B.N      ??_CalcOrto_3
   \                     ??_CalcOrto_2: (+1)
   \   00000042   0xF500 0x7000      ADD      R0,R0,#+512
   \   00000046   0x1280             ASRS     R0,R0,#+10
    301            *px = x;
   \                     ??_CalcOrto_3: (+1)
   \   00000048   0x6021             STR      R1,[R4, #+0]
    302            *py = y;
   \   0000004A   0x9906             LDR      R1,[SP, #+24]
   \   0000004C   0x6008             STR      R0,[R1, #+0]
    303          }
   \   0000004E   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    304          
    305          /*********************************************************************
    306          *
    307          *       DrawLine, public
    308          *
    309          * Draw end points of the line.
    310          * In most cases, this is a circle.
    311          *
    312          **********************************************************************
    313          */
    314          /*********************************************************************
    315          *
    316          *       _DrawLineEnd
    317          */

   \                                 In section .text, align 2, keep-with-next
    318          static void _DrawLineEnd(int x0, int y0) {
    319            switch (GUI_Context.PenShape) {
   \                     _DrawLineEnd: (+1)
   \   00000000   0x.... 0x....      LDR.W    R2,??DataTable17
   \   00000004   0x7D52             LDRB     R2,[R2, #+21]
   \   00000006   0x2A00             CMP      R2,#+0
   \   00000008   0xD100             BNE.N    ??_DrawLineEnd_0
    320            case GUI_PS_ROUND:
    321              GL_DrawPoint(x0,y0);
   \   0000000A   0x....             B.N      GL_DrawPoint
    322              break;
    323            case GUI_PS_FLAT:
    324              break;
    325            }
    326          }
   \                     ??_DrawLineEnd_0: (+1)
   \   0000000C   0x4770             BX       LR               ;; return
    327          
    328          /*********************************************************************
    329          *
    330          *       DrawLine, public
    331          *
    332          **********************************************************************
    333          */
    334          /*********************************************************************
    335          *
    336          *       GL_DrawLine
    337          */

   \                                 In section .text, align 2, keep-with-next
    338          void GL_DrawLine(int x0, int y0, int x1, int y1) {
   \                     GL_DrawLine: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x461F             MOV      R7,R3
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000010   0x7D02             LDRB     R2,[R0, #+20]
   \   00000012   0x2A01             CMP      R2,#+1
   \   00000014   0xD104             BNE.N    ??GL_DrawLine_0
    339            if (GUI_Context.PenSize ==1) {
    340              GL_DrawLine1(x0,y0,x1,y1);
   \   00000016   0x4632             MOV      R2,R6
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       GL_DrawLine1
   \   0000001E   0xE059             B.N      ??GL_DrawLine_1
    341            } else {
    342              int xdiff, ydiff;
    343              xdiff = x0-x1;
    344              ydiff = y0-y1;
    345              if (xdiff | ydiff) {    
   \                     ??GL_DrawLine_0: (+1)
   \   00000020   0x1BE9             SUBS     R1,R5,R7
   \   00000022   0x1BA0             SUBS     R0,R4,R6
   \   00000024   0xEA51 0x0300      ORRS     R3,R1,R0
   \   00000028   0xD054             BEQ.N    ??GL_DrawLine_1
    346                GUI_POINT Poly[4];
    347                int xOff, yOff;
    348                int xOffP, yOffP, xOffM, yOffM;
    349                _CalcOrto(x0-x1,y0-y1, (I32)(GUI_Context.PenSize-1), &xOff, &yOff);
   \   0000002A   0xAB01             ADD      R3,SP,#+4
   \   0000002C   0x9300             STR      R3,[SP, #+0]
   \   0000002E   0xAB02             ADD      R3,SP,#+8
   \   00000030   0x1E52             SUBS     R2,R2,#+1
   \   00000032   0x.... 0x....      BL       _CalcOrto
    350            /* Do rounding for offsets */
    351                if (xOff >0) {
   \   00000036   0x9802             LDR      R0,[SP, #+8]
   \   00000038   0x4601             MOV      R1,R0
   \   0000003A   0xEB01 0x70D0      ADD      R0,R1,R0, LSR #+31
   \   0000003E   0x1042             ASRS     R2,R0,#+1
   \   00000040   0x4608             MOV      R0,R1
   \   00000042   0x2801             CMP      R0,#+1
   \   00000044   0xDB04             BLT.N    ??GL_DrawLine_2
    352                  xOffP = (xOff+1)/2;
   \   00000046   0x1C40             ADDS     R0,R0,#+1
   \   00000048   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   0000004C   0x1041             ASRS     R1,R0,#+1
    353                  xOffM =  xOff   /2;
   \   0000004E   0xE004             B.N      ??GL_DrawLine_3
    354                } else {
    355                  xOffP =   xOff/2;
   \                     ??GL_DrawLine_2: (+1)
   \   00000050   0x4611             MOV      R1,R2
    356                  xOffM =  (xOff-1)   /2;
   \   00000052   0x1E40             SUBS     R0,R0,#+1
   \   00000054   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   00000058   0x1042             ASRS     R2,R0,#+1
    357                }
    358                if (yOff >0) {
   \                     ??GL_DrawLine_3: (+1)
   \   0000005A   0x9801             LDR      R0,[SP, #+4]
   \   0000005C   0x4603             MOV      R3,R0
   \   0000005E   0xEB03 0x70D0      ADD      R0,R3,R0, LSR #+31
   \   00000062   0x1043             ASRS     R3,R0,#+1
   \   00000064   0x9801             LDR      R0,[SP, #+4]
   \   00000066   0x2801             CMP      R0,#+1
   \   00000068   0xDB04             BLT.N    ??GL_DrawLine_4
    359                  yOffP = (yOff+1)/2;
   \   0000006A   0x1C40             ADDS     R0,R0,#+1
   \   0000006C   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   00000070   0x1040             ASRS     R0,R0,#+1
    360                  yOffM =  yOff   /2;
   \   00000072   0xE005             B.N      ??GL_DrawLine_5
    361                } else {
    362                  yOffP =   yOff/2;
   \                     ??GL_DrawLine_4: (+1)
   \   00000074   0x4618             MOV      R0,R3
    363                  yOffM =  (yOff-1)   /2;
   \   00000076   0x9B01             LDR      R3,[SP, #+4]
   \   00000078   0x1E5B             SUBS     R3,R3,#+1
   \   0000007A   0xEB03 0x73D3      ADD      R3,R3,R3, LSR #+31
   \   0000007E   0x105B             ASRS     R3,R3,#+1
    364                }
    365                Poly[0].x = x0+xOffP;
   \                     ??GL_DrawLine_5: (+1)
   \   00000080   0xEB01 0x0E04      ADD      LR,R1,R4
   \   00000084   0xF8AD 0xE00C      STRH     LR,[SP, #+12]
    366                Poly[0].y = y0+yOffP;
   \   00000088   0xEB00 0x0E05      ADD      LR,R0,R5
   \   0000008C   0xF8AD 0xE00E      STRH     LR,[SP, #+14]
    367                Poly[1].x = x0-xOffM; 
   \   00000090   0xEBA4 0x0E02      SUB      LR,R4,R2
   \   00000094   0xF8AD 0xE010      STRH     LR,[SP, #+16]
    368                Poly[1].y = y0-yOffM; 
   \   00000098   0xEBA5 0x0E03      SUB      LR,R5,R3
   \   0000009C   0xF8AD 0xE012      STRH     LR,[SP, #+18]
    369                Poly[2].x = x1-xOffM;
   \   000000A0   0x1AB2             SUBS     R2,R6,R2
   \   000000A2   0xF8AD 0x2014      STRH     R2,[SP, #+20]
    370                Poly[2].y = y1-yOffM;
   \   000000A6   0x1AFA             SUBS     R2,R7,R3
   \   000000A8   0xF8AD 0x2016      STRH     R2,[SP, #+22]
    371                Poly[3].x = x1+xOffP; 
   \   000000AC   0x1989             ADDS     R1,R1,R6
   \   000000AE   0xF8AD 0x1018      STRH     R1,[SP, #+24]
    372                Poly[3].y = y1+yOffP;
   \   000000B2   0x19C0             ADDS     R0,R0,R7
   \   000000B4   0xF8AD 0x001A      STRH     R0,[SP, #+26]
    373                GL_FillPolygon(&Poly[0], 4, 0,0);
   \   000000B8   0x2300             MOVS     R3,#+0
   \   000000BA   0x461A             MOV      R2,R3
   \   000000BC   0x2104             MOVS     R1,#+4
   \   000000BE   0xA803             ADD      R0,SP,#+12
   \   000000C0   0x.... 0x....      BL       GL_FillPolygon
    374                _DrawLineEnd(x0,y0);
   \   000000C4   0x4629             MOV      R1,R5
   \   000000C6   0x4620             MOV      R0,R4
   \   000000C8   0x.... 0x....      BL       _DrawLineEnd
    375                _DrawLineEnd(x1,y1);
   \   000000CC   0x4639             MOV      R1,R7
   \   000000CE   0x4630             MOV      R0,R6
   \   000000D0   0x.... 0x....      BL       _DrawLineEnd
    376              }
    377            }
    378          }
   \                     ??GL_DrawLine_1: (+1)
   \   000000D4   0xB007             ADD      SP,SP,#+28
   \   000000D6   0xBDF0             POP      {R4-R7,PC}       ;; return
    379          
    380          /*********************************************************************
    381          *
    382          *       GUI_DrawLine
    383          */

   \                                 In section .text, align 2, keep-with-next
    384          void GUI_DrawLine(int x0, int y0, int x1, int y1) {
   \                     GUI_DrawLine: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    385            GUI_LOCK();
    386            #if (GUI_WINSUPPORT)
    387              WM_ADDORG(x0,y0);
   \   00000002   0x....             LDR.N    R4,??DataTable17
   \   00000004   0x6C25             LDR      R5,[R4, #+64]
   \   00000006   0x182E             ADDS     R6,R5,R0
   \   00000008   0x6C60             LDR      R0,[R4, #+68]
   \   0000000A   0x1844             ADDS     R4,R0,R1
    388              WM_ADDORG(x1,y1);
   \   0000000C   0x18AD             ADDS     R5,R5,R2
   \   0000000E   0x18C7             ADDS     R7,R0,R3
    389              WM_ITERATE_START(NULL); {
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x.... 0x....      BL       WM__InitIVRSearch
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD009             BEQ.N    ??GUI_DrawLine_0
    390            #endif
    391            GL_DrawLine (x0, y0, x1, y1);
   \                     ??GUI_DrawLine_1: (+1)
   \   0000001A   0x463B             MOV      R3,R7
   \   0000001C   0x462A             MOV      R2,R5
   \   0000001E   0x4621             MOV      R1,R4
   \   00000020   0x4630             MOV      R0,R6
   \   00000022   0x.... 0x....      BL       GL_DrawLine
    392            #if (GUI_WINSUPPORT)
    393              } WM_ITERATE_END();
   \   00000026   0x.... 0x....      BL       WM__GetNextIVR
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD1F5             BNE.N    ??GUI_DrawLine_1
    394            #endif
    395            GUI_UNLOCK();
    396          }
   \                     ??GUI_DrawLine_0: (+1)
   \   0000002E   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    397          
    398          /*********************************************************************
    399          *
    400          *       GL_DrawPolygon
    401          */

   \                                 In section .text, align 2, keep-with-next
    402          void GL_DrawPolygon(const GUI_POINT*pPoints, int NumPoints, int x0, int y0) {
   \                     GL_DrawPolygon: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4607             MOV      R7,R0
   \   00000006   0x4688             MOV      R8,R1
   \   00000008   0x4614             MOV      R4,R2
   \   0000000A   0x461D             MOV      R5,R3
    403            const GUI_POINT* pPoint = pPoints;
   \   0000000C   0x463E             MOV      R6,R7
    404            GL_MoveTo(pPoint->x+x0, pPoint->y+y0);
   \   0000000E   0xF9B6 0x0002      LDRSH    R0,[R6, #+2]
   \   00000012   0x1829             ADDS     R1,R5,R0
   \   00000014   0xF9B6 0x0000      LDRSH    R0,[R6, #+0]
   \   00000018   0xFA04 0xF080      SXTAH    R0,R4,R0
   \   0000001C   0x.... 0x....      BL       GL_MoveTo
   \   00000020   0xE009             B.N      ??GL_DrawPolygon_0
    405            while (--NumPoints >0) {
    406              pPoint++;
   \                     ??GL_DrawPolygon_1: (+1)
   \   00000022   0x1D36             ADDS     R6,R6,#+4
    407              GL_DrawLineTo(pPoint->x+x0, pPoint->y+y0);
   \   00000024   0xF9B6 0x0002      LDRSH    R0,[R6, #+2]
   \   00000028   0x1829             ADDS     R1,R5,R0
   \   0000002A   0xF9B6 0x0000      LDRSH    R0,[R6, #+0]
   \   0000002E   0xFA04 0xF080      SXTAH    R0,R4,R0
   \   00000032   0x.... 0x....      BL       GL_DrawLineTo
    408            }
   \                     ??GL_DrawPolygon_0: (+1)
   \   00000036   0xF1A8 0x0801      SUB      R8,R8,#+1
   \   0000003A   0xF1B8 0x0F01      CMP      R8,#+1
   \   0000003E   0xDAF0             BGE.N    ??GL_DrawPolygon_1
    409            /* Now draw closing line unless it has already been closed */
    410            if ( (pPoint->x != pPoints->x)
    411               ||(pPoint->y != pPoints->y))
   \   00000040   0xF9B7 0x0002      LDRSH    R0,[R7, #+2]
   \   00000044   0xF9B7 0x2000      LDRSH    R2,[R7, #+0]
   \   00000048   0xF9B6 0x1000      LDRSH    R1,[R6, #+0]
   \   0000004C   0x4291             CMP      R1,R2
   \   0000004E   0xD103             BNE.N    ??GL_DrawPolygon_2
   \   00000050   0xF9B6 0x1002      LDRSH    R1,[R6, #+2]
   \   00000054   0x4281             CMP      R1,R0
   \   00000056   0xD006             BEQ.N    ??GL_DrawPolygon_3
    412            {
    413              GL_DrawLineTo(pPoints->x+x0, pPoints->y+y0);
   \                     ??GL_DrawPolygon_2: (+1)
   \   00000058   0xFA05 0xF180      SXTAH    R1,R5,R0
   \   0000005C   0xFA04 0xF082      SXTAH    R0,R4,R2
   \   00000060   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   00000064   0x....             B.N      GL_DrawLineTo
    414            }
    415          }
   \                     ??GL_DrawPolygon_3: (+1)
   \   00000066   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    416          
    417          /*********************************************************************
    418          *
    419          *       GUI_DrawPolygon
    420          */

   \                                 In section .text, align 2, keep-with-next
    421          void GUI_DrawPolygon(const GUI_POINT* pPoints, int NumPoints, int x0, int y0) {
   \                     GUI_DrawPolygon: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    422            GUI_LOCK();
    423            #if (GUI_WINSUPPORT)
    424              WM_ADDORG(x0,y0);
   \   00000006   0x....             LDR.N    R0,??DataTable17
   \   00000008   0x6C01             LDR      R1,[R0, #+64]
   \   0000000A   0x188E             ADDS     R6,R1,R2
   \   0000000C   0x6C40             LDR      R0,[R0, #+68]
   \   0000000E   0x18C7             ADDS     R7,R0,R3
    425              WM_ITERATE_START(NULL); {
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x.... 0x....      BL       WM__InitIVRSearch
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD009             BEQ.N    ??GUI_DrawPolygon_0
    426            #endif
    427            GL_DrawPolygon (pPoints, NumPoints, x0, y0);
   \                     ??GUI_DrawPolygon_1: (+1)
   \   0000001A   0x463B             MOV      R3,R7
   \   0000001C   0x4632             MOV      R2,R6
   \   0000001E   0x4629             MOV      R1,R5
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       GL_DrawPolygon
    428            #if (GUI_WINSUPPORT)
    429              } WM_ITERATE_END();
   \   00000026   0x.... 0x....      BL       WM__GetNextIVR
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD1F5             BNE.N    ??GUI_DrawPolygon_1
    430            #endif
    431            GUI_UNLOCK();
    432          }
   \                     ??GUI_DrawPolygon_0: (+1)
   \   0000002E   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    433          
    434          /*********************************************************************
    435          *
    436          *       Draw Line to group
    437          *
    438          **********************************************************************
    439          */
    440          /*********************************************************************
    441          *
    442          *       GL_DrawLineRelNM
    443          */

   \                                 In section .text, align 2, keep-with-next
    444          static void GL_DrawLineRelNM(int dx, int dy) {
   \                     GL_DrawLineRelNM: (+1)
   \   00000000   0xB418             PUSH     {R3,R4}
   \   00000002   0x4602             MOV      R2,R0
    445            GL_DrawLine (GUI_Context.DrawPosX,    GUI_Context.DrawPosY, 
    446                         GUI_Context.DrawPosX+dx, GUI_Context.DrawPosY+dy); 
   \   00000004   0x....             LDR.N    R3,??DataTable17
   \   00000006   0xF9B3 0x0026      LDRSH    R0,[R3, #+38]
   \   0000000A   0xF9B3 0x4028      LDRSH    R4,[R3, #+40]
   \   0000000E   0x190B             ADDS     R3,R1,R4
   \   00000010   0x1812             ADDS     R2,R2,R0
   \   00000012   0x4621             MOV      R1,R4
   \   00000014   0xB001             ADD      SP,SP,#+4
   \   00000016   0xBC10             POP      {R4}
   \   00000018   0x....             B.N      GL_DrawLine
    447          }
    448          
    449          /*********************************************************************
    450          *
    451          *       GUI_DrawLineRel
    452          */

   \                                 In section .text, align 2, keep-with-next
    453          void GUI_DrawLineRel(int dx, int dy) {
   \                     GUI_DrawLineRel: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    454            GUI_LOCK();
    455            #if (GUI_WINSUPPORT)
    456              WM_ITERATE_START(NULL); {
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x.... 0x....      BL       WM__InitIVRSearch
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD007             BEQ.N    ??GUI_DrawLineRel_0
    457            #endif
    458            GL_DrawLineRelNM(dx,dy);
   \                     ??GUI_DrawLineRel_1: (+1)
   \   00000010   0x4629             MOV      R1,R5
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       GL_DrawLineRelNM
    459            #if (GUI_WINSUPPORT)
    460              } WM_ITERATE_END();
   \   00000018   0x.... 0x....      BL       WM__GetNextIVR
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD1F7             BNE.N    ??GUI_DrawLineRel_1
    461            #endif
    462            GUI_MoveRel(dx,dy);
   \                     ??GUI_DrawLineRel_0: (+1)
   \   00000020   0x4629             MOV      R1,R5
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000028   0x....             B.N      GUI_MoveRel
    463            GUI_UNLOCK();
    464          }
    465          
    466          /*********************************************************************
    467          *
    468          *       GL_DrawLineTo
    469          */

   \                                 In section .text, align 2, keep-with-next
    470          void GL_DrawLineTo(int x, int y) {
   \                     GL_DrawLineTo: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    471            GL_DrawLine (GUI_Context.DrawPosX, GUI_Context.DrawPosY, x, y); 
   \   00000006   0x....             LDR.N    R6,??DataTable17
   \   00000008   0x462B             MOV      R3,R5
   \   0000000A   0x4622             MOV      R2,R4
   \   0000000C   0xF9B6 0x1028      LDRSH    R1,[R6, #+40]
   \   00000010   0xF9B6 0x0026      LDRSH    R0,[R6, #+38]
   \   00000014   0x.... 0x....      BL       GL_DrawLine
    472            GUI_Context.DrawPosX = x;
   \   00000018   0x84F4             STRH     R4,[R6, #+38]
    473            GUI_Context.DrawPosY = y;
   \   0000001A   0x8535             STRH     R5,[R6, #+40]
    474          }
   \   0000001C   0xBD70             POP      {R4-R6,PC}       ;; return
    475          
    476          /*********************************************************************
    477          *
    478          *       GL_DrawLineToNM
    479          */

   \                                 In section .text, align 2, keep-with-next
    480          static void GL_DrawLineToNM(int x, int y) {
   \                     GL_DrawLineToNM: (+1)
   \   00000000   0xB418             PUSH     {R3,R4}
    481            GL_DrawLine (GUI_Context.DrawPosX, GUI_Context.DrawPosY, x, y); 
   \   00000002   0x....             LDR.N    R4,??DataTable17
   \   00000004   0x460B             MOV      R3,R1
   \   00000006   0x4602             MOV      R2,R0
   \   00000008   0xF9B4 0x1028      LDRSH    R1,[R4, #+40]
   \   0000000C   0xF9B4 0x0026      LDRSH    R0,[R4, #+38]
   \   00000010   0xB001             ADD      SP,SP,#+4
   \   00000012   0xBC10             POP      {R4}
   \   00000014   0x....             B.N      GL_DrawLine
    482          }
    483          
    484          /*********************************************************************
    485          *
    486          *       GUI_DrawLineTo
    487          */

   \                                 In section .text, align 2, keep-with-next
    488          void GUI_DrawLineTo(int x, int y) {
   \                     GUI_DrawLineTo: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    489            GUI_LOCK();
    490            #if (GUI_WINSUPPORT)
    491              WM_ADDORG(x,y);
   \   00000002   0x....             LDR.N    R2,??DataTable17
   \   00000004   0x6C13             LDR      R3,[R2, #+64]
   \   00000006   0x181C             ADDS     R4,R3,R0
   \   00000008   0x6C50             LDR      R0,[R2, #+68]
   \   0000000A   0x1845             ADDS     R5,R0,R1
    492              WM_ITERATE_START(NULL); {
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x.... 0x....      BL       WM__InitIVRSearch
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD007             BEQ.N    ??GUI_DrawLineTo_0
    493            #endif
    494            GL_DrawLineToNM(x,y);
   \                     ??GUI_DrawLineTo_1: (+1)
   \   00000016   0x4629             MOV      R1,R5
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       GL_DrawLineToNM
    495            #if (GUI_WINSUPPORT)
    496              } WM_ITERATE_END();
   \   0000001E   0x.... 0x....      BL       WM__GetNextIVR
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD1F7             BNE.N    ??GUI_DrawLineTo_1
    497            #endif
    498            GL_MoveTo(x,y);
   \                     ??GUI_DrawLineTo_0: (+1)
   \   00000026   0x4629             MOV      R1,R5
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   0000002E   0x....             B.N      GL_MoveTo
    499            GUI_UNLOCK();
    500          }
    501          
    502          /*********************************************************************
    503          *
    504          *       GUI_MoveRel
    505          */

   \                                 In section .text, align 2, keep-with-next
    506          void GUI_MoveRel(int dx, int dy) { /*tbd: GL_LinePos. */
    507            GUI_LOCK();
    508            GUI_Context.DrawPosX += dx;
   \                     GUI_MoveRel: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable17
   \   00000002   0x8CD3             LDRH     R3,[R2, #+38]
   \   00000004   0x18C0             ADDS     R0,R0,R3
   \   00000006   0x84D0             STRH     R0,[R2, #+38]
    509            GUI_Context.DrawPosY += dy;
   \   00000008   0x8D10             LDRH     R0,[R2, #+40]
   \   0000000A   0x1808             ADDS     R0,R1,R0
   \   0000000C   0x8510             STRH     R0,[R2, #+40]
    510            GUI_UNLOCK();
    511          }
   \   0000000E   0x4770             BX       LR               ;; return
    512          
    513          /*********************************************************************
    514          *
    515          *       GL_MoveTo
    516          */

   \                                 In section .text, align 2, keep-with-next
    517          void GL_MoveTo(int x, int y) {
    518            GUI_Context.DrawPosX = x;
   \                     GL_MoveTo: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable17
   \   00000002   0x84D0             STRH     R0,[R2, #+38]
    519            GUI_Context.DrawPosY = y;
   \   00000004   0x8511             STRH     R1,[R2, #+40]
    520          }
   \   00000006   0x4770             BX       LR               ;; return
    521          
    522          /*********************************************************************
    523          *
    524          *       GUI_MoveTo
    525          */

   \                                 In section .text, align 2, keep-with-next
    526          void GUI_MoveTo(int x, int y) {
    527            GUI_LOCK();
    528            #if (GUI_WINSUPPORT)
    529              WM_ADDORG(x,y);
    530            #endif
    531            GL_MoveTo(x,y);
   \                     GUI_MoveTo: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable17
   \   00000002   0x6C53             LDR      R3,[R2, #+68]
   \   00000004   0x1859             ADDS     R1,R3,R1
   \   00000006   0x6C12             LDR      R2,[R2, #+64]
   \   00000008   0x1810             ADDS     R0,R2,R0
   \   0000000A   0x....             B.N      GL_MoveTo
    532            GUI_UNLOCK();
    533          }
    534          
    535          /*********************************************************************
    536          *
    537          *       Rectangle filling / inverting
    538          *
    539          **********************************************************************
    540          */
    541          /*********************************************************************
    542          *
    543          *       _DrawRect
    544          */

   \                                 In section .text, align 2, keep-with-next
    545          static void _DrawRect(int x0, int y0, int x1, int y1) {
   \                     _DrawRect: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0x461F             MOV      R7,R3
    546            LCD_DrawHLine(x0, y0, x1);
   \   0000000A   0x.... 0x....      BL       LCD_DrawHLine
    547            LCD_DrawHLine(x0, y1, x1);
   \   0000000E   0x4632             MOV      R2,R6
   \   00000010   0x4639             MOV      R1,R7
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       LCD_DrawHLine
    548            LCD_DrawVLine(x0, y0 + 1, y1 - 1);
   \   00000018   0x1C6D             ADDS     R5,R5,#+1
   \   0000001A   0x1E7F             SUBS     R7,R7,#+1
   \   0000001C   0x463A             MOV      R2,R7
   \   0000001E   0x4629             MOV      R1,R5
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       LCD_DrawVLine
    549            LCD_DrawVLine(x1, y0 + 1, y1 - 1);
   \   00000026   0x463A             MOV      R2,R7
   \   00000028   0x4629             MOV      R1,R5
   \   0000002A   0x4630             MOV      R0,R6
   \   0000002C   0xE8BD 0x40F8      POP      {R3-R7,LR}
   \   00000030   0x.... 0x....      B.W      LCD_DrawVLine
    550          }
    551          
    552          /*********************************************************************
    553          *
    554          *       GUI_DrawRect
    555          */

   \                                 In section .text, align 2, keep-with-next
    556          void GUI_DrawRect(int x0, int y0, int x1, int y1) {
   \                     GUI_DrawRect: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    557            #if (GUI_WINSUPPORT)
    558              int Off;
    559              GUI_RECT r;
    560            #endif
    561            GUI_LOCK();
    562            #if (GUI_WINSUPPORT)
    563              Off = GUI_Context.PenSize -1;
   \   00000004   0x....             LDR.N    R5,??DataTable17
   \   00000006   0x7D2C             LDRB     R4,[R5, #+20]
   \   00000008   0xF1A4 0x0E01      SUB      LR,R4,#+1
    564              WM_ADDORG(x0,y0);
   \   0000000C   0x6C2E             LDR      R6,[R5, #+64]
   \   0000000E   0x1834             ADDS     R4,R6,R0
   \   00000010   0x6C68             LDR      R0,[R5, #+68]
   \   00000012   0x1845             ADDS     R5,R0,R1
    565              WM_ADDORG(x1,y1);
   \   00000014   0x18B6             ADDS     R6,R6,R2
   \   00000016   0x18C7             ADDS     R7,R0,R3
    566              r.x0 = x0 - Off;
   \   00000018   0xEBA4 0x000E      SUB      R0,R4,LR
   \   0000001C   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    567              r.x1 = x1 + Off;
   \   00000020   0xEB0E 0x0006      ADD      R0,LR,R6
   \   00000024   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    568              r.y0 = y0 - Off;
   \   00000028   0xEBA5 0x000E      SUB      R0,R5,LR
   \   0000002C   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    569              r.y1 = y1 + Off;
   \   00000030   0xEB0E 0x0007      ADD      R0,LR,R7
   \   00000034   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    570              WM_ITERATE_START(&r); {
   \   00000038   0xA800             ADD      R0,SP,#+0
   \   0000003A   0x.... 0x....      BL       WM__InitIVRSearch
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD009             BEQ.N    ??GUI_DrawRect_0
    571            #endif
    572          //  if((((x1 - x0) > 6) && ((y1 - y0) > 6)))         //Ïû³ýÀâ½Ç
    573          //  {
    574          //    GL_DrawArc(x0+3,y0+3,3,3,0,90);
    575          //  }
    576          //  else
    577          //  {
    578              _DrawRect(x0, y0, x1, y1);
   \                     ??GUI_DrawRect_1: (+1)
   \   00000042   0x463B             MOV      R3,R7
   \   00000044   0x4632             MOV      R2,R6
   \   00000046   0x4629             MOV      R1,R5
   \   00000048   0x4620             MOV      R0,R4
   \   0000004A   0x.... 0x....      BL       _DrawRect
    579          //  }
    580            #if (GUI_WINSUPPORT)
    581              } WM_ITERATE_END();
   \   0000004E   0x.... 0x....      BL       WM__GetNextIVR
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD1F5             BNE.N    ??GUI_DrawRect_1
    582            #endif
    583            GUI_UNLOCK();
    584          }
   \                     ??GUI_DrawRect_0: (+1)
   \   00000056   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
    585          
    586          /*********************************************************************
    587          *
    588          *       DrawLine, internal, 1 pixel
    589          *
    590          **********************************************************************
    591          */
    592          /*********************************************************************
    593          *
    594          *       GL_DrawLine1
    595          */

   \                                 In section .text, align 2, keep-with-next
    596          void GL_DrawLine1(int x0, int y0, int x1, int y1) {
   \                     GL_DrawLine1: (+1)
   \   00000000   0xB5FF             PUSH     {R0-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    597            int xdiff = x1-x0;
   \   00000004   0x4610             MOV      R0,R2
   \   00000006   0x9903             LDR      R1,[SP, #+12]
   \   00000008   0x1A40             SUBS     R0,R0,R1
   \   0000000A   0x9000             STR      R0,[SP, #+0]
    598            int ydiff = y1-y0;
   \   0000000C   0x9806             LDR      R0,[SP, #+24]
   \   0000000E   0x9904             LDR      R1,[SP, #+16]
   \   00000010   0x1A40             SUBS     R0,R0,R1
   \   00000012   0x9001             STR      R0,[SP, #+4]
    599            int xdiffby2;
    600            int i;
    601            char Swapped =0;
   \   00000014   0x2400             MOVS     R4,#+0
    602          /* check if no line */
    603            if (!(xdiff|ydiff)) {
   \   00000016   0x9800             LDR      R0,[SP, #+0]
   \   00000018   0x9901             LDR      R1,[SP, #+4]
   \   0000001A   0x4308             ORRS     R0,R1,R0
   \   0000001C   0xD104             BNE.N    ??GL_DrawLine1_0
    604              GL_DrawPoint(x0,y0);
   \   0000001E   0x9904             LDR      R1,[SP, #+16]
   \   00000020   0x9803             LDR      R0,[SP, #+12]
   \   00000022   0x.... 0x....      BL       GL_DrawPoint
    605              return;
   \   00000026   0xE06F             B.N      ??GL_DrawLine1_1
    606            }
    607          #if 0
    608          /* check if horizontal line */
    609            if (!xdiff) {
    610              GL_DrawVLine(x0,y0,y1);
    611              return;
    612            }
    613          /* check if vertical line */
    614            if (!ydiff) {
    615              GL_DrawHLine(y0,x0,x1);
    616              return;
    617            }
    618          #endif
    619          /* check if we swap x and y for calculation */
    620            if (Abs(xdiff) < Abs(ydiff)) {
   \                     ??GL_DrawLine1_0: (+1)
   \   00000028   0x9800             LDR      R0,[SP, #+0]
   \   0000002A   0x.... 0x....      BL       Abs
   \   0000002E   0x4605             MOV      R5,R0
   \   00000030   0x9801             LDR      R0,[SP, #+4]
   \   00000032   0x.... 0x....      BL       Abs
   \   00000036   0x4285             CMP      R5,R0
   \   00000038   0xDA0C             BGE.N    ??GL_DrawLine1_2
    621              _SwapInt(&xdiff,&ydiff);
   \   0000003A   0xA901             ADD      R1,SP,#+4
   \   0000003C   0xA800             ADD      R0,SP,#+0
   \   0000003E   0x.... 0x....      BL       _SwapInt
    622              _SwapInt(&x0,&y0);
   \   00000042   0xA904             ADD      R1,SP,#+16
   \   00000044   0xA803             ADD      R0,SP,#+12
   \   00000046   0x.... 0x....      BL       _SwapInt
    623              _SwapInt(&x1,&y1);
   \   0000004A   0xA906             ADD      R1,SP,#+24
   \   0000004C   0xA805             ADD      R0,SP,#+20
   \   0000004E   0x.... 0x....      BL       _SwapInt
    624              Swapped =1;
   \   00000052   0x2401             MOVS     R4,#+1
    625            }
    626          /* make sure line direction is positive */
    627            if (xdiff!=Abs(xdiff)) {
   \                     ??GL_DrawLine1_2: (+1)
   \   00000054   0x9D00             LDR      R5,[SP, #+0]
   \   00000056   0x4628             MOV      R0,R5
   \   00000058   0x.... 0x....      BL       Abs
   \   0000005C   0x4285             CMP      R5,R0
   \   0000005E   0xD00D             BEQ.N    ??GL_DrawLine1_3
    628              xdiff = -xdiff;
   \   00000060   0x9800             LDR      R0,[SP, #+0]
   \   00000062   0x4240             RSBS     R0,R0,#+0
   \   00000064   0x9000             STR      R0,[SP, #+0]
    629              ydiff = -ydiff;
   \   00000066   0x9801             LDR      R0,[SP, #+4]
   \   00000068   0x4240             RSBS     R0,R0,#+0
   \   0000006A   0x9001             STR      R0,[SP, #+4]
    630              _SwapInt(&x0,&x1);
   \   0000006C   0xA905             ADD      R1,SP,#+20
   \   0000006E   0xA803             ADD      R0,SP,#+12
   \   00000070   0x.... 0x....      BL       _SwapInt
    631              _SwapInt(&y0,&y1);
   \   00000074   0xA906             ADD      R1,SP,#+24
   \   00000076   0xA804             ADD      R0,SP,#+16
   \   00000078   0x.... 0x....      BL       _SwapInt
    632            }
    633            xdiffby2 = xdiff/2;
   \                     ??GL_DrawLine1_3: (+1)
   \   0000007C   0x9800             LDR      R0,[SP, #+0]
   \   0000007E   0x4601             MOV      R1,R0
   \   00000080   0xEB01 0x70D0      ADD      R0,R1,R0, LSR #+31
   \   00000084   0x1045             ASRS     R5,R0,#+1
    634            if (ydiff<0)
   \   00000086   0x9801             LDR      R0,[SP, #+4]
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD500             BPL.N    ??GL_DrawLine1_4
    635              xdiffby2 = -xdiffby2;
   \   0000008C   0x426D             RSBS     R5,R5,#+0
    636          /* Draw pixel by pixel solid*/
    637            if (GUI_Context.LineStyle == GUI_LS_SOLID) {
   \                     ??GL_DrawLine1_4: (+1)
   \   0000008E   0x....             LDR.N    R0,??DataTable17
   \   00000090   0x7D80             LDRB     R0,[R0, #+22]
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xD119             BNE.N    ??GL_DrawLine1_5
    638              for (i=0; i<=xdiff; i++) {
   \   00000096   0x2600             MOVS     R6,#+0
   \   00000098   0xE003             B.N      ??GL_DrawLine1_6
    639                I32 l = ((I32)ydiff)*i+xdiffby2;
    640                int y = (ABS(l)<32767) ? (y0 + ((int)l)/xdiff) : (y0 + l/xdiff);
    641                if (!Swapped)
    642                  LCD_HL_DrawPixel(x0+i, y);
    643                else
    644                  LCD_HL_DrawPixel(y, x0+i);
   \                     ??GL_DrawLine1_7: (+1)
   \   0000009A   0x4611             MOV      R1,R2
   \   0000009C   0x.... 0x....      BL       LCD_DrawPixel
   \                     ??GL_DrawLine1_8: (+1)
   \   000000A0   0x1C76             ADDS     R6,R6,#+1
   \                     ??GL_DrawLine1_6: (+1)
   \   000000A2   0x9800             LDR      R0,[SP, #+0]
   \   000000A4   0x42B0             CMP      R0,R6
   \   000000A6   0xDB2F             BLT.N    ??GL_DrawLine1_1
   \   000000A8   0x9801             LDR      R0,[SP, #+4]
   \   000000AA   0xFB06 0x5000      MLA      R0,R6,R0,R5
   \   000000AE   0x9A04             LDR      R2,[SP, #+16]
   \   000000B0   0x9B00             LDR      R3,[SP, #+0]
   \   000000B2   0xFB90 0xF0F3      SDIV     R0,R0,R3
   \   000000B6   0x1880             ADDS     R0,R0,R2
   \   000000B8   0x9903             LDR      R1,[SP, #+12]
   \   000000BA   0x1872             ADDS     R2,R6,R1
   \   000000BC   0x2C00             CMP      R4,#+0
   \   000000BE   0xD1EC             BNE.N    ??GL_DrawLine1_7
   \   000000C0   0x4601             MOV      R1,R0
   \   000000C2   0x4610             MOV      R0,R2
   \   000000C4   0x.... 0x....      BL       LCD_DrawPixel
   \   000000C8   0xE7EA             B.N      ??GL_DrawLine1_8
    645              }
    646          /* Draw pixel by pixel with fill style */
    647            } else {
    648              for (i=0; i<=xdiff; i++) {
   \                     ??GL_DrawLine1_5: (+1)
   \   000000CA   0x2600             MOVS     R6,#+0
   \   000000CC   0xE004             B.N      ??GL_DrawLine1_9
    649                long l = ((long)ydiff)*i+xdiffby2;
    650                int y = (ABS(l)<32767) ? (y0 + ((int)l)/xdiff) : (y0 + l/xdiff);
    651                if (!_SetLineColor(i)) {
    652                  if (!Swapped)
    653                    LCD_HL_DrawPixel(x0+i, y);
    654                  else
    655                    LCD_HL_DrawPixel(y, x0+i);
   \                     ??GL_DrawLine1_10: (+1)
   \   000000CE   0x4601             MOV      R1,R0
   \   000000D0   0x4638             MOV      R0,R7
   \   000000D2   0x.... 0x....      BL       LCD_DrawPixel
   \                     ??GL_DrawLine1_11: (+1)
   \   000000D6   0x1C76             ADDS     R6,R6,#+1
   \                     ??GL_DrawLine1_9: (+1)
   \   000000D8   0x9800             LDR      R0,[SP, #+0]
   \   000000DA   0x42B0             CMP      R0,R6
   \   000000DC   0xDB14             BLT.N    ??GL_DrawLine1_1
   \   000000DE   0x9801             LDR      R0,[SP, #+4]
   \   000000E0   0xFB06 0x5000      MLA      R0,R6,R0,R5
   \   000000E4   0x9A04             LDR      R2,[SP, #+16]
   \   000000E6   0x9B00             LDR      R3,[SP, #+0]
   \   000000E8   0xFB90 0xF0F3      SDIV     R0,R0,R3
   \   000000EC   0x1887             ADDS     R7,R0,R2
   \   000000EE   0x4630             MOV      R0,R6
   \   000000F0   0x.... 0x....      BL       _SetLineColor
   \   000000F4   0x2800             CMP      R0,#+0
   \   000000F6   0xD1EE             BNE.N    ??GL_DrawLine1_11
   \   000000F8   0x9803             LDR      R0,[SP, #+12]
   \   000000FA   0x1830             ADDS     R0,R6,R0
   \   000000FC   0x2C00             CMP      R4,#+0
   \   000000FE   0xD1E6             BNE.N    ??GL_DrawLine1_10
   \   00000100   0x4639             MOV      R1,R7
   \   00000102   0x.... 0x....      BL       LCD_DrawPixel
   \   00000106   0xE7E6             B.N      ??GL_DrawLine1_11
    656                }
    657              }
    658            }
    659          }
   \                     ??GL_DrawLine1_1: (+1)
   \   00000108   0xB007             ADD      SP,SP,#+28
   \   0000010A   0xBDF0             POP      {R4-R7,PC}       ;; return
    660          
    661          /*********************************************************************
    662          *
    663          *       Draw point
    664          *
    665          **********************************************************************
    666          */
    667          /*********************************************************************
    668          *
    669          *       GL_DrawPoint
    670          */

   \                                 In section .text, align 2, keep-with-next
    671          void GL_DrawPoint(int x, int y) {
   \                     GL_DrawPoint: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable17
   \   00000002   0x7D12             LDRB     R2,[R2, #+20]
   \   00000004   0x2A01             CMP      R2,#+1
   \   00000006   0xD101             BNE.N    ??GL_DrawPoint_0
    672            if (GUI_Context.PenSize == 1) {
    673              LCD_HL_DrawPixel(x, y);
   \   00000008   0x.... 0x....      B.W      LCD_DrawPixel
    674            } else {
    675              GL_FillCircle(x, y, (GUI_Context.PenSize - 1) / 2);
   \                     ??GL_DrawPoint_0: (+1)
   \   0000000C   0x1E52             SUBS     R2,R2,#+1
   \   0000000E   0xEB02 0x72D2      ADD      R2,R2,R2, LSR #+31
   \   00000012   0x1052             ASRS     R2,R2,#+1
   \   00000014   0x.... 0x....      B.W      GL_FillCircle
    676            }
    677          }
    678          
    679          /*********************************************************************
    680          *
    681          *       GUI_DrawPoint
    682          */

   \                                 In section .text, align 2, keep-with-next
    683          void GUI_DrawPoint(int x, int y) {
   \                     GUI_DrawPoint: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    684            GUI_LOCK();
    685            #if (GUI_WINSUPPORT)
    686              WM_ADDORG(x, y);
   \   00000002   0x....             LDR.N    R2,??DataTable17
   \   00000004   0x6C13             LDR      R3,[R2, #+64]
   \   00000006   0x181C             ADDS     R4,R3,R0
   \   00000008   0x6C50             LDR      R0,[R2, #+68]
   \   0000000A   0x1845             ADDS     R5,R0,R1
    687              WM_ITERATE_START(NULL); {
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x.... 0x....      BL       WM__InitIVRSearch
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD007             BEQ.N    ??GUI_DrawPoint_0
    688            #endif
    689            GL_DrawPoint(x, y);
   \                     ??GUI_DrawPoint_1: (+1)
   \   00000016   0x4629             MOV      R1,R5
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       GL_DrawPoint
    690            #if (GUI_WINSUPPORT)
    691              } WM_ITERATE_END();
   \   0000001E   0x.... 0x....      BL       WM__GetNextIVR
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD1F7             BNE.N    ??GUI_DrawPoint_1
    692            #endif
    693            GUI_UNLOCK();
    694          }
   \                     ??GUI_DrawPoint_0: (+1)
   \   00000026   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x........         DC32     GUI_Context
    695          
    696          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   Abs
      48   GL_DrawLine
        48   -> GL_DrawLine1
        48   -> GL_FillPolygon
        48   -> _CalcOrto
        48   -> _DrawLineEnd
      48   GL_DrawLine1
        48   -> Abs
        48   -> GL_DrawPoint
        48   -> LCD_DrawPixel
        48   -> _SetLineColor
        48   -> _SwapInt
       8   GL_DrawLineRelNM
         0   -> GL_DrawLine
      16   GL_DrawLineTo
        16   -> GL_DrawLine
       8   GL_DrawLineToNM
         0   -> GL_DrawLine
       0   GL_DrawPoint
         0   -> GL_FillCircle
         0   -> LCD_DrawPixel
      24   GL_DrawPolygon
         0   -> GL_DrawLineTo
        24   -> GL_DrawLineTo
        24   -> GL_MoveTo
       0   GL_MoveTo
      24   GUI_DrawLine
        24   -> GL_DrawLine
        24   -> WM__GetNextIVR
        24   -> WM__InitIVRSearch
      16   GUI_DrawLineRel
        16   -> GL_DrawLineRelNM
         0   -> GUI_MoveRel
        16   -> WM__GetNextIVR
        16   -> WM__InitIVRSearch
      16   GUI_DrawLineTo
        16   -> GL_DrawLineToNM
         0   -> GL_MoveTo
        16   -> WM__GetNextIVR
        16   -> WM__InitIVRSearch
      16   GUI_DrawPoint
        16   -> GL_DrawPoint
        16   -> WM__GetNextIVR
        16   -> WM__InitIVRSearch
      24   GUI_DrawPolygon
        24   -> GL_DrawPolygon
        24   -> WM__GetNextIVR
        24   -> WM__InitIVRSearch
      32   GUI_DrawRect
        32   -> WM__GetNextIVR
        32   -> WM__InitIVRSearch
        32   -> _DrawRect
       0   GUI_MoveRel
       0   GUI_MoveTo
         0   -> GL_MoveTo
       0   GUI_cos
         0   -> GUI_sin
       4   GUI_sin
      24   _CalcOrto
        24   -> GUI_cos
        24   -> GUI_sin
        24   -> _atan2
       0   _DrawLineEnd
         0   -> GL_DrawPoint
      24   _DrawRect
        24   -> LCD_DrawHLine
         0   -> LCD_DrawVLine
        24   -> LCD_DrawVLine
       0   _SetLineColor
       0   _SwapInt
       0   _atan0_45
       8   _atan2
         8   -> _atan0_45


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable17
       8  Abs
     216  GL_DrawLine
     268  GL_DrawLine1
      26  GL_DrawLineRelNM
      30  GL_DrawLineTo
      22  GL_DrawLineToNM
      24  GL_DrawPoint
     106  GL_DrawPolygon
       8  GL_MoveTo
      48  GUI_DrawLine
      42  GUI_DrawLineRel
      48  GUI_DrawLineTo
      40  GUI_DrawPoint
      48  GUI_DrawPolygon
      88  GUI_DrawRect
      16  GUI_MoveRel
      12  GUI_MoveTo
       6  GUI_cos
      86  GUI_sin
      80  _CalcOrto
      14  _DrawLineEnd
      52  _DrawRect
     162  _SetLineColor
      10  _SwapInt
      58  _atan0_45
      86  _atan2
      36  aSin
      36  aTan

 
 1 680 bytes in section .text
 
 1 680 bytes of CODE memory

Errors: none
Warnings: none
