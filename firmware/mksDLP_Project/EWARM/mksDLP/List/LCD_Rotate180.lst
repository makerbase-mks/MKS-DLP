###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  10:59:01
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Core\LCD_Rotate180.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Core\LCD_Rotate180.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\LCD_Rotate180.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\LCD_Rotate180.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Core\LCD_Rotate180.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              µC/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : LCD_Rotate180.c
     16          Purpose     : Implementation of GUI_SetRotation
     17          ---------------------------END-OF-HEADER------------------------------
     18          */
     19          
     20          #include "GUI_Private.h"
     21          #include "LCD.h"
     22          #if GUI_WINSUPPORT
     23            #include "WM.h"
     24          #endif
     25          
     26          #if GUI_SUPPORT_ROTATION
     27          
     28          /*********************************************************************
     29          *
     30          *       Static code
     31          *
     32          **********************************************************************
     33          */
     34          /*********************************************************************
     35          *
     36          *       _DrawBitLine1BPP
     37          */

   \                                 In section .text, align 2, keep-with-next
     38          static void  _DrawBitLine1BPP(int x, int y, U8 const GUI_UNI_PTR *p, int Diff, int xsize, const LCD_PIXELINDEX*pTrans) {
   \                     _DrawBitLine1BPP: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x460C             MOV      R4,R1
   \   00000006   0x4615             MOV      R5,R2
   \   00000008   0x461E             MOV      R6,R3
   \   0000000A   0x9909             LDR      R1,[SP, #+36]
     39            LCD_PIXELINDEX Index0 = *(pTrans+0);
   \   0000000C   0xF8B1 0x9000      LDRH     R9,[R1, #+0]
     40            LCD_PIXELINDEX Index1 = *(pTrans+1);
   \   00000010   0xF8B1 0xA002      LDRH     R10,[R1, #+2]
     41            x -= Diff;
   \   00000014   0x1B87             SUBS     R7,R0,R6
   \   00000016   0xF8DD 0x8020      LDR      R8,[SP, #+32]
     42            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   0000001A   0x....             LDR.N    R0,??DataTable3
   \   0000001C   0x7B00             LDRB     R0,[R0, #+12]
   \   0000001E   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   00000022   0xD003             BEQ.N    ??_DrawBitLine1BPP_0
   \   00000024   0x2802             CMP      R0,#+2
   \   00000026   0xD017             BEQ.N    ??_DrawBitLine1BPP_1
   \   00000028   0xD32A             BCC.N    ??_DrawBitLine1BPP_2
   \   0000002A   0xE042             B.N      ??_DrawBitLine1BPP_3
     43            case 0:
     44              do {
     45                LCDDEV_L0_SetPixelIndex(x--, y, (*p & (0x80 >> Diff)) ? Index1 : Index0);
   \                     ??_DrawBitLine1BPP_0: (+1)
   \   0000002C   0x7828             LDRB     R0,[R5, #+0]
   \   0000002E   0x2180             MOVS     R1,#+128
   \   00000030   0x4131             ASRS     R1,R1,R6
   \   00000032   0x4208             TST      R0,R1
   \   00000034   0xD001             BEQ.N    ??_DrawBitLine1BPP_4
   \   00000036   0x4652             MOV      R2,R10
   \   00000038   0xE000             B.N      ??_DrawBitLine1BPP_5
   \                     ??_DrawBitLine1BPP_4: (+1)
   \   0000003A   0x464A             MOV      R2,R9
   \                     ??_DrawBitLine1BPP_5: (+1)
   \   0000003C   0x4621             MOV      R1,R4
   \   0000003E   0x4638             MOV      R0,R7
   \   00000040   0x.... 0x....      BL       LCD_L0_SetPixelIndex
   \   00000044   0x1E7F             SUBS     R7,R7,#+1
     46          			if (++Diff == 8) {
   \   00000046   0x1C76             ADDS     R6,R6,#+1
   \   00000048   0x2E08             CMP      R6,#+8
   \   0000004A   0xD101             BNE.N    ??_DrawBitLine1BPP_6
     47                  Diff = 0;
   \   0000004C   0x2600             MOVS     R6,#+0
     48          				p++;
   \   0000004E   0x1C6D             ADDS     R5,R5,#+1
     49          			}
     50          		} while (--xsize);
   \                     ??_DrawBitLine1BPP_6: (+1)
   \   00000050   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \   00000054   0xD1EA             BNE.N    ??_DrawBitLine1BPP_0
   \   00000056   0xE02C             B.N      ??_DrawBitLine1BPP_3
     51              break;
     52            case LCD_DRAWMODE_TRANS:
     53              do {
     54            		if (*p & (0x80 >> Diff))
   \                     ??_DrawBitLine1BPP_1: (+1)
   \   00000058   0x7828             LDRB     R0,[R5, #+0]
   \   0000005A   0x2180             MOVS     R1,#+128
   \   0000005C   0x4131             ASRS     R1,R1,R6
   \   0000005E   0x4208             TST      R0,R1
   \   00000060   0xD004             BEQ.N    ??_DrawBitLine1BPP_7
     55                  LCDDEV_L0_SetPixelIndex(x, y, Index1);
   \   00000062   0x4652             MOV      R2,R10
   \   00000064   0x4621             MOV      R1,R4
   \   00000066   0x4638             MOV      R0,R7
   \   00000068   0x.... 0x....      BL       LCD_L0_SetPixelIndex
     56                x--;
   \                     ??_DrawBitLine1BPP_7: (+1)
   \   0000006C   0x1E7F             SUBS     R7,R7,#+1
     57          			if (++Diff == 8) {
   \   0000006E   0x1C76             ADDS     R6,R6,#+1
   \   00000070   0x2E08             CMP      R6,#+8
   \   00000072   0xD101             BNE.N    ??_DrawBitLine1BPP_8
     58                  Diff = 0;
   \   00000074   0x2600             MOVS     R6,#+0
     59          				p++;
   \   00000076   0x1C6D             ADDS     R5,R5,#+1
     60          			}
     61          		} while (--xsize);
   \                     ??_DrawBitLine1BPP_8: (+1)
   \   00000078   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \   0000007C   0xD1EC             BNE.N    ??_DrawBitLine1BPP_1
   \   0000007E   0xE018             B.N      ??_DrawBitLine1BPP_3
     62              break;
     63            case LCD_DRAWMODE_XOR:;
     64              do {
     65            		if (*p & (0x80 >> Diff)) {
   \                     ??_DrawBitLine1BPP_2: (+1)
   \   00000080   0x7828             LDRB     R0,[R5, #+0]
   \   00000082   0x2180             MOVS     R1,#+128
   \   00000084   0x4131             ASRS     R1,R1,R6
   \   00000086   0x4208             TST      R0,R1
   \   00000088   0xD00A             BEQ.N    ??_DrawBitLine1BPP_9
     66                  int Pixel = LCD_L0_GetPixelIndex(x, y);
   \   0000008A   0x4621             MOV      R1,R4
   \   0000008C   0x4638             MOV      R0,R7
   \   0000008E   0x.... 0x....      BL       LCD_L0_GetPixelIndex
     67                  LCDDEV_L0_SetPixelIndex(x, y, LCD_NUM_COLORS - 1 - Pixel);
   \   00000092   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000096   0x1A0A             SUBS     R2,R1,R0
   \   00000098   0x4621             MOV      R1,R4
   \   0000009A   0x4638             MOV      R0,R7
   \   0000009C   0x.... 0x....      BL       LCD_L0_SetPixelIndex
     68                }
     69                x--;
   \                     ??_DrawBitLine1BPP_9: (+1)
   \   000000A0   0x1E7F             SUBS     R7,R7,#+1
     70          			if (++Diff == 8) {
   \   000000A2   0x1C76             ADDS     R6,R6,#+1
   \   000000A4   0x2E08             CMP      R6,#+8
   \   000000A6   0xD101             BNE.N    ??_DrawBitLine1BPP_10
     71                  Diff = 0;
   \   000000A8   0x2600             MOVS     R6,#+0
     72          				p++;
   \   000000AA   0x1C6D             ADDS     R5,R5,#+1
     73          			}
     74          		} while (--xsize);
   \                     ??_DrawBitLine1BPP_10: (+1)
   \   000000AC   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \   000000B0   0xD1E6             BNE.N    ??_DrawBitLine1BPP_2
     75              break;
     76          	}
     77          }
   \                     ??_DrawBitLine1BPP_3: (+1)
   \   000000B2   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
     78          
     79          /*********************************************************************
     80          *
     81          *       _DrawBitmap
     82          *
     83          * Purpose:
     84          *   Draws a bitmap (1bpp) rotated by 180 degrees.
     85          */

   \                                 In section .text, align 2, keep-with-next
     86          static void _DrawBitmap(int x0, int y0,
     87                                 int xsize, int ysize,
     88                                 int BitsPerPixel, 
     89                                 int BytesPerLine,
     90                                 const U8 GUI_UNI_PTR * pData, int Diff,
     91                                 const LCD_PIXELINDEX* pTrans)
     92          {
   \                     _DrawBitmap: (+1)
   \   00000000   0xE92D 0x4FF3      PUSH     {R0,R1,R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x4614             MOV      R4,R2
   \   00000008   0x461D             MOV      R5,R3
     93            int i;
     94            /* Use _DrawBitLineXBPP */
     95            for (i = 0; i < ysize; i++) {
   \   0000000A   0x2600             MOVS     R6,#+0
   \   0000000C   0x9F0E             LDR      R7,[SP, #+56]
   \   0000000E   0xF8DD 0x803C      LDR      R8,[SP, #+60]
   \   00000012   0xF8DD 0x9040      LDR      R9,[SP, #+64]
   \   00000016   0xF8DD 0xA044      LDR      R10,[SP, #+68]
   \   0000001A   0xF8DD 0xB048      LDR      R11,[SP, #+72]
   \   0000001E   0xE00D             B.N      ??_DrawBitmap_0
     96              switch (BitsPerPixel) {
   \                     ??_DrawBitmap_1: (+1)
   \   00000020   0x2F01             CMP      R7,#+1
   \   00000022   0xD109             BNE.N    ??_DrawBitmap_2
     97              case 1:
     98                _DrawBitLine1BPP(x0, y0 - i, pData, Diff, xsize, pTrans);
   \   00000024   0xF8CD 0xB004      STR      R11,[SP, #+4]
   \   00000028   0x9400             STR      R4,[SP, #+0]
   \   0000002A   0x4653             MOV      R3,R10
   \   0000002C   0x464A             MOV      R2,R9
   \   0000002E   0x9804             LDR      R0,[SP, #+16]
   \   00000030   0x1B81             SUBS     R1,R0,R6
   \   00000032   0x9803             LDR      R0,[SP, #+12]
   \   00000034   0x.... 0x....      BL       _DrawBitLine1BPP
     99                break;
    100              }
    101              pData += BytesPerLine;
   \                     ??_DrawBitmap_2: (+1)
   \   00000038   0x44C1             ADD      R9,R8,R9
    102            }
   \   0000003A   0x1C76             ADDS     R6,R6,#+1
   \                     ??_DrawBitmap_0: (+1)
   \   0000003C   0x42AE             CMP      R6,R5
   \   0000003E   0xDBEF             BLT.N    ??_DrawBitmap_1
    103          }
   \   00000040   0xB005             ADD      SP,SP,#+20
   \   00000042   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    104          
    105          /*********************************************************************
    106          *
    107          *       _Rect2TextRect
    108          *
    109          * Purpose:
    110          *   This function transforms a given rectangle (window coordinates)
    111          *   to the rectangle used to clip the text.
    112          */

   \                                 In section .text, align 2, keep-with-next
    113          static void _Rect2TextRect(GUI_RECT * pRect) {
    114            GUI_USE_PARA(pRect);
    115            /* nothing to do in case of rotating text by 180 degrees */
    116          }
   \                     _Rect2TextRect: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    117          
    118          /*********************************************************************
    119          *
    120          *       _TransformPoint180
    121          *
    122          * Purpose:
    123          *   This function transforms an unrotated point (window
    124          *   coordinates) into a rotated point in desktop coordinates
    125          *   and handles the rotation of the current text rectangle.
    126          */

   \                                 In section .text, align 2, keep-with-next
    127          static void _TransformPoint180(int * pXPos, int * pYPos) {
   \                     _TransformPoint180: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    128            GUI_RECT ClientRect = {0};
   \   00000006   0x.... 0x....      ADR.W    R0,`?<Constant {0}>`
   \   0000000A   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \   0000000E   0xE9CD 0x2300      STRD     R2,R3,[SP, #+0]
    129            int xPos, yPos, xNumPixel, yNumPixel;
    130            /* Get the client rectangle */
    131            #if GUI_WINSUPPORT
    132              WM_GetWindowRect(&ClientRect);
   \   00000012   0xA800             ADD      R0,SP,#+0
   \   00000014   0x.... 0x....      BL       WM_GetWindowRect
    133            #else
    134              GUI_GetClientRect(&ClientRect);
    135            #endif
    136            xNumPixel = LCD_GetXSize() - 1;
   \   00000018   0x.... 0x....      BL       LCD_GetXSize
   \   0000001C   0x1E46             SUBS     R6,R0,#+1
    137            yNumPixel = LCD_GetYSize() - 1;
   \   0000001E   0x.... 0x....      BL       LCD_GetYSize
   \   00000022   0x1E40             SUBS     R0,R0,#+1
    138            if (ClientRect.x1 > xNumPixel) {
   \   00000024   0xF9BD 0x1004      LDRSH    R1,[SP, #+4]
   \   00000028   0x428E             CMP      R6,R1
   \   0000002A   0xDA01             BGE.N    ??_TransformPoint180_0
    139              ClientRect.x1 = xNumPixel;
   \   0000002C   0xF8AD 0x6004      STRH     R6,[SP, #+4]
    140            }
    141            if (ClientRect.y1 > yNumPixel) {
   \                     ??_TransformPoint180_0: (+1)
   \   00000030   0xF9BD 0x1006      LDRSH    R1,[SP, #+6]
   \   00000034   0x4288             CMP      R0,R1
   \   00000036   0xDA01             BGE.N    ??_TransformPoint180_1
    142              ClientRect.y1 = yNumPixel;
   \   00000038   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    143            }
    144            /* Save old positions */
    145            xPos = *pXPos;
    146            yPos = *pYPos;
   \                     ??_TransformPoint180_1: (+1)
   \   0000003C   0x6829             LDR      R1,[R5, #+0]
    147            /* Handle rotation of text rectangle */
    148            *pXPos = ClientRect.x0 + GUI_RectDispString.x1 - (xPos - GUI_RectDispString.x0);
   \   0000003E   0x....             LDR.N    R0,??DataTable3_1
   \   00000040   0xF9BD 0x2000      LDRSH    R2,[SP, #+0]
   \   00000044   0xF9B0 0x3004      LDRSH    R3,[R0, #+4]
   \   00000048   0xFA03 0xF282      SXTAH    R2,R3,R2
   \   0000004C   0x6823             LDR      R3,[R4, #+0]
   \   0000004E   0x1AD2             SUBS     R2,R2,R3
   \   00000050   0xF9B0 0x3000      LDRSH    R3,[R0, #+0]
   \   00000054   0xFA02 0xF283      SXTAH    R2,R2,R3
   \   00000058   0x6022             STR      R2,[R4, #+0]
    149            *pYPos = ClientRect.y0 + GUI_RectDispString.y1 - (yPos - GUI_RectDispString.y0);
   \   0000005A   0xF9BD 0x2002      LDRSH    R2,[SP, #+2]
   \   0000005E   0xF9B0 0x3006      LDRSH    R3,[R0, #+6]
   \   00000062   0xFA03 0xF282      SXTAH    R2,R3,R2
   \   00000066   0x1A51             SUBS     R1,R2,R1
   \   00000068   0xF9B0 0x0002      LDRSH    R0,[R0, #+2]
   \   0000006C   0x1808             ADDS     R0,R1,R0
   \   0000006E   0x6028             STR      R0,[R5, #+0]
    150          }
   \   00000070   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    151          
    152          /*********************************************************************
    153          *
    154          *       _DrawBitmap180
    155          */

   \                                 In section .text, align 2, keep-with-next
    156          static void _DrawBitmap180(int x0, int y0, int xsize, int ysize, int xMul, int yMul,
    157                                     int BitsPerPixel, int BytesPerLine,
    158                                     const U8 GUI_UNI_PTR * pPixel, const LCD_PIXELINDEX* pTrans)
    159          {
   \                     _DrawBitmap180: (+1)
   \   00000000   0xE92D 0x4FFB      PUSH     {R0,R1,R3-R11,LR}
   \   00000004   0xB088             SUB      SP,SP,#+32
   \   00000006   0x4614             MOV      R4,R2
    160            U8  Data = 0;
   \   00000008   0x2500             MOVS     R5,#+0
    161            int x1, y1;
    162            /* Handle the optional Y-magnification */
    163            y1 = y0 + ysize - 1;
   \   0000000A   0x4608             MOV      R0,R1
   \   0000000C   0x4619             MOV      R1,R3
   \   0000000E   0x1808             ADDS     R0,R1,R0
   \   00000010   0x1E40             SUBS     R0,R0,#+1
   \   00000012   0x9006             STR      R0,[SP, #+24]
    164            x1 = x0 + xsize - 1;
   \   00000014   0x9808             LDR      R0,[SP, #+32]
   \   00000016   0x1820             ADDS     R0,R4,R0
   \   00000018   0x1E40             SUBS     R0,R0,#+1
   \   0000001A   0x9005             STR      R0,[SP, #+20]
    165            /* Rotate positions */
    166            _TransformPoint180(&x0, &y0);
   \   0000001C   0xA909             ADD      R1,SP,#+36
   \   0000001E   0xA808             ADD      R0,SP,#+32
   \   00000020   0x.... 0x....      BL       _TransformPoint180
    167            _TransformPoint180(&x1, &y1);
   \   00000024   0xA906             ADD      R1,SP,#+24
   \   00000026   0xA805             ADD      R0,SP,#+20
   \   00000028   0x.... 0x....      BL       _TransformPoint180
    168            /*  Handle BITMAP without magnification */
    169            if ((xMul == 1) && (yMul == 1)) {
   \   0000002C   0x9814             LDR      R0,[SP, #+80]
   \   0000002E   0x2801             CMP      R0,#+1
   \   00000030   0xD151             BNE.N    ??_DrawBitmap180_0
   \   00000032   0x9815             LDR      R0,[SP, #+84]
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xD14E             BNE.N    ??_DrawBitmap180_0
    170              int Diff;
    171              /* Clip top */
    172              if (y0 > GUI_Context.ClipRect.y1) {
   \   00000038   0x....             LDR.N    R7,??DataTable3
   \   0000003A   0xF9B7 0x000A      LDRSH    R0,[R7, #+10]
   \   0000003E   0x9909             LDR      R1,[SP, #+36]
   \   00000040   0x4288             CMP      R0,R1
   \   00000042   0xDA09             BGE.N    ??_DrawBitmap180_1
    173                int Diff = y0 - GUI_Context.ClipRect.y1;
   \   00000044   0x1A09             SUBS     R1,R1,R0
    174                y0       = GUI_Context.ClipRect.y1;
   \   00000046   0x9009             STR      R0,[SP, #+36]
    175                pPixel  += Diff * BytesPerLine;
   \   00000048   0x9817             LDR      R0,[SP, #+92]
   \   0000004A   0x9A18             LDR      R2,[SP, #+96]
   \   0000004C   0xFB00 0x2001      MLA      R0,R0,R1,R2
   \   00000050   0x9018             STR      R0,[SP, #+96]
    176                ysize   -= Diff;
   \   00000052   0x980A             LDR      R0,[SP, #+40]
   \   00000054   0x1A40             SUBS     R0,R0,R1
   \   00000056   0x900A             STR      R0,[SP, #+40]
   \                     ??_DrawBitmap180_1: (+1)
   \   00000058   0xF9B7 0x0006      LDRSH    R0,[R7, #+6]
   \   0000005C   0x9906             LDR      R1,[SP, #+24]
   \   0000005E   0x4281             CMP      R1,R0
   \   00000060   0xDA04             BGE.N    ??_DrawBitmap180_2
    177              }
    178              /* Clip bottom */
    179              if (y1 < GUI_Context.ClipRect.y0) {
    180                int Diff = GUI_Context.ClipRect.y0 - y1;
    181                ysize -= Diff;
   \   00000062   0x990A             LDR      R1,[SP, #+40]
   \   00000064   0x1A08             SUBS     R0,R1,R0
   \   00000066   0x9906             LDR      R1,[SP, #+24]
   \   00000068   0x1808             ADDS     R0,R1,R0
   \   0000006A   0x900A             STR      R0,[SP, #+40]
    182              }
    183              if (ysize <= 0) {
   \                     ??_DrawBitmap180_2: (+1)
   \   0000006C   0x980A             LDR      R0,[SP, #+40]
   \   0000006E   0x2801             CMP      R0,#+1
   \   00000070   0xDB2E             BLT.N    ??_DrawBitmap180_3
    184          		  return;
   \   00000072   0xF9B7 0x0004      LDRSH    R0,[R7, #+4]
   \   00000076   0x9905             LDR      R1,[SP, #+20]
   \   00000078   0x4281             CMP      R1,R0
   \   0000007A   0xDA01             BGE.N    ??_DrawBitmap180_4
    185              }
    186              /* Clip right side */
    187              if (x1 < GUI_Context.ClipRect.x0) {
    188                int Diff = GUI_Context.ClipRect.x0 - x1;
    189                xsize   -= Diff;
   \   0000007C   0x1A20             SUBS     R0,R4,R0
   \   0000007E   0x180C             ADDS     R4,R1,R0
    190              }
    191              /* Clip left side */
    192              Diff = 0;
   \                     ??_DrawBitmap180_4: (+1)
   \   00000080   0x4628             MOV      R0,R5
   \   00000082   0xF9B7 0x1008      LDRSH    R1,[R7, #+8]
   \   00000086   0x9A08             LDR      R2,[SP, #+32]
   \   00000088   0x4291             CMP      R1,R2
   \   0000008A   0xDA10             BGE.N    ??_DrawBitmap180_5
    193              if (x0 > GUI_Context.ClipRect.x1) {
    194                Diff   = x0 - GUI_Context.ClipRect.x1;
   \   0000008C   0x4610             MOV      R0,R2
   \   0000008E   0x1A40             SUBS     R0,R0,R1
    195          			xsize -= Diff;
   \   00000090   0x1A24             SUBS     R4,R4,R0
    196          			switch (BitsPerPixel) {
   \   00000092   0x9916             LDR      R1,[SP, #+88]
   \   00000094   0x2901             CMP      R1,#+1
   \   00000096   0xD10A             BNE.N    ??_DrawBitmap180_5
    197          			case 1:
    198            			pPixel += (Diff >> 3); x0 += (Diff >> 3) << 3; Diff &= 7;
   \   00000098   0x9918             LDR      R1,[SP, #+96]
   \   0000009A   0xEB01 0x01E0      ADD      R1,R1,R0, ASR #+3
   \   0000009E   0x9118             STR      R1,[SP, #+96]
   \   000000A0   0x9908             LDR      R1,[SP, #+32]
   \   000000A2   0xF020 0x0207      BIC      R2,R0,#0x7
   \   000000A6   0x1851             ADDS     R1,R2,R1
   \   000000A8   0x9108             STR      R1,[SP, #+32]
   \   000000AA   0xF000 0x0007      AND      R0,R0,#0x7
    199          				break;
    200          			}
    201              }
    202              if (xsize <= 0) {
   \                     ??_DrawBitmap180_5: (+1)
   \   000000AE   0x2C01             CMP      R4,#+1
   \   000000B0   0xDB0E             BLT.N    ??_DrawBitmap180_3
    203          		  return;
    204              }
    205              _DrawBitmap(x0, y0, xsize, ysize, BitsPerPixel, BytesPerLine, pPixel, Diff, pTrans);
   \   000000B2   0x9919             LDR      R1,[SP, #+100]
   \   000000B4   0x9104             STR      R1,[SP, #+16]
   \   000000B6   0x9003             STR      R0,[SP, #+12]
   \   000000B8   0x9818             LDR      R0,[SP, #+96]
   \   000000BA   0x9002             STR      R0,[SP, #+8]
   \   000000BC   0x9817             LDR      R0,[SP, #+92]
   \   000000BE   0x9001             STR      R0,[SP, #+4]
   \   000000C0   0x9816             LDR      R0,[SP, #+88]
   \   000000C2   0x9000             STR      R0,[SP, #+0]
   \   000000C4   0x9B0A             LDR      R3,[SP, #+40]
   \   000000C6   0x4622             MOV      R2,R4
   \   000000C8   0x9909             LDR      R1,[SP, #+36]
   \   000000CA   0x9808             LDR      R0,[SP, #+32]
   \   000000CC   0x.... 0x....      BL       _DrawBitmap
    206            } else {
    207              /* Handle BITMAP with magnification */
    208              int x, y;
    209              int yi;
    210              int Shift = 8 - BitsPerPixel;
    211              for (y = y0, yi = 0; yi < ysize; yi++, y -= yMul, pPixel += BytesPerLine) {
    212                int yMax = y + yMul - 1;
    213                /* Draw if within clip area (Optimization ... "if" is not required !) */
    214                if ((yMax >= GUI_Context.ClipRect.y0) && (y <= GUI_Context.ClipRect.y1)) {
    215                  int BitsLeft = 0;
    216                  int xi;
    217                  const U8 GUI_UNI_PTR * pDataLine = pPixel;
    218                  for (x = x0, xi = 0; xi < xsize; xi++, x -= xMul) {
    219                    U8  Index;
    220                    if (!BitsLeft) {
    221                      Data = *pDataLine++;
    222                      BitsLeft =8;
    223                    }
    224                    Index = Data >> Shift;
    225                    Data    <<= BitsPerPixel;
    226                    BitsLeft -= BitsPerPixel;
    227                    if (Index || ((GUI_Context.DrawMode & LCD_DRAWMODE_TRANS) == 0)) {
    228                      LCD_PIXELINDEX OldColor = LCD_COLORINDEX;
    229                      if (pTrans) {
    230                        LCD_COLORINDEX = *(pTrans + Index);
    231                      } else {
    232                        LCD_COLORINDEX = Index;
    233                      }
    234                      LCD_FillRect(x - xMul + 1, y, x, yMax);
    235                      LCD_COLORINDEX = OldColor;
    236                    }
    237                  }
    238                }
    239              }
    240            }
    241          }
   \                     ??_DrawBitmap180_3: (+1)
   \   000000D0   0xB00B             ADD      SP,SP,#+44
   \   000000D2   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   \                     ??_DrawBitmap180_0: (+1)
   \   000000D6   0x9816             LDR      R0,[SP, #+88]
   \   000000D8   0xF1C0 0x0008      RSB      R0,R0,#+8
   \   000000DC   0x9003             STR      R0,[SP, #+12]
   \   000000DE   0x9E09             LDR      R6,[SP, #+36]
   \   000000E0   0x4628             MOV      R0,R5
   \   000000E2   0x9000             STR      R0,[SP, #+0]
   \   000000E4   0x....             LDR.N    R7,??DataTable3
   \   000000E6   0xE008             B.N      ??_DrawBitmap180_6
   \                     ??_DrawBitmap180_7: (+1)
   \   000000E8   0x9800             LDR      R0,[SP, #+0]
   \   000000EA   0x1C40             ADDS     R0,R0,#+1
   \   000000EC   0x9000             STR      R0,[SP, #+0]
   \   000000EE   0x9815             LDR      R0,[SP, #+84]
   \   000000F0   0x1A36             SUBS     R6,R6,R0
   \   000000F2   0x9817             LDR      R0,[SP, #+92]
   \   000000F4   0x9918             LDR      R1,[SP, #+96]
   \   000000F6   0x1840             ADDS     R0,R0,R1
   \   000000F8   0x9018             STR      R0,[SP, #+96]
   \                     ??_DrawBitmap180_6: (+1)
   \   000000FA   0x9800             LDR      R0,[SP, #+0]
   \   000000FC   0x990A             LDR      R1,[SP, #+40]
   \   000000FE   0x4288             CMP      R0,R1
   \   00000100   0xDAE6             BGE.N    ??_DrawBitmap180_3
   \   00000102   0x9815             LDR      R0,[SP, #+84]
   \   00000104   0x1980             ADDS     R0,R0,R6
   \   00000106   0x1E40             SUBS     R0,R0,#+1
   \   00000108   0x9001             STR      R0,[SP, #+4]
   \   0000010A   0xF9B7 0x1006      LDRSH    R1,[R7, #+6]
   \   0000010E   0x4288             CMP      R0,R1
   \   00000110   0xDBEA             BLT.N    ??_DrawBitmap180_7
   \   00000112   0xF9B7 0x000A      LDRSH    R0,[R7, #+10]
   \   00000116   0x42B0             CMP      R0,R6
   \   00000118   0xDBE6             BLT.N    ??_DrawBitmap180_7
   \   0000011A   0xF04F 0x0800      MOV      R8,#+0
   \   0000011E   0x9818             LDR      R0,[SP, #+96]
   \   00000120   0x9002             STR      R0,[SP, #+8]
   \   00000122   0xF8DD 0x9020      LDR      R9,[SP, #+32]
   \   00000126   0x46C2             MOV      R10,R8
   \   00000128   0xE010             B.N      ??_DrawBitmap180_8
   \                     ??_DrawBitmap180_9: (+1)
   \   0000012A   0x8078             STRH     R0,[R7, #+2]
   \                     ??_DrawBitmap180_10: (+1)
   \   0000012C   0x9B01             LDR      R3,[SP, #+4]
   \   0000012E   0x464A             MOV      R2,R9
   \   00000130   0x4631             MOV      R1,R6
   \   00000132   0x9814             LDR      R0,[SP, #+80]
   \   00000134   0xEBA9 0x0000      SUB      R0,R9,R0
   \   00000138   0x1C40             ADDS     R0,R0,#+1
   \   0000013A   0x.... 0x....      BL       LCD_FillRect
   \   0000013E   0xF8A7 0xB002      STRH     R11,[R7, #+2]
   \                     ??_DrawBitmap180_11: (+1)
   \   00000142   0xF10A 0x0A01      ADD      R10,R10,#+1
   \   00000146   0x9814             LDR      R0,[SP, #+80]
   \   00000148   0xEBA9 0x0900      SUB      R9,R9,R0
   \                     ??_DrawBitmap180_8: (+1)
   \   0000014C   0x45A2             CMP      R10,R4
   \   0000014E   0xDACB             BGE.N    ??_DrawBitmap180_7
   \   00000150   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000154   0xD106             BNE.N    ??_DrawBitmap180_12
   \   00000156   0x9802             LDR      R0,[SP, #+8]
   \   00000158   0x1C40             ADDS     R0,R0,#+1
   \   0000015A   0x9002             STR      R0,[SP, #+8]
   \   0000015C   0x1E40             SUBS     R0,R0,#+1
   \   0000015E   0x7805             LDRB     R5,[R0, #+0]
   \   00000160   0xF04F 0x0808      MOV      R8,#+8
   \                     ??_DrawBitmap180_12: (+1)
   \   00000164   0xB2ED             UXTB     R5,R5
   \   00000166   0x9803             LDR      R0,[SP, #+12]
   \   00000168   0xFA45 0xF000      ASR      R0,R5,R0
   \   0000016C   0xB2C0             UXTB     R0,R0
   \   0000016E   0x9916             LDR      R1,[SP, #+88]
   \   00000170   0x408D             LSLS     R5,R5,R1
   \   00000172   0xEBA8 0x0801      SUB      R8,R8,R1
   \   00000176   0x2800             CMP      R0,#+0
   \   00000178   0xD102             BNE.N    ??_DrawBitmap180_13
   \   0000017A   0x7B39             LDRB     R1,[R7, #+12]
   \   0000017C   0x0789             LSLS     R1,R1,#+30
   \   0000017E   0xD4E0             BMI.N    ??_DrawBitmap180_11
   \                     ??_DrawBitmap180_13: (+1)
   \   00000180   0xF8B7 0xB002      LDRH     R11,[R7, #+2]
   \   00000184   0x9919             LDR      R1,[SP, #+100]
   \   00000186   0x2900             CMP      R1,#+0
   \   00000188   0xD0CF             BEQ.N    ??_DrawBitmap180_9
   \   0000018A   0xF831 0x0010      LDRH     R0,[R1, R0, LSL #+1]
   \   0000018E   0x8078             STRH     R0,[R7, #+2]
   \   00000190   0xE7CC             B.N      ??_DrawBitmap180_10
    242          
    243          /*********************************************************************
    244          *
    245          *       Global data
    246          *
    247          **********************************************************************
    248          */
    249          /*********************************************************************
    250          *
    251          *       LCD_APIList180
    252          *
    253          * Purpose:
    254          *   Function pointer table for rotating text 180
    255          */

   \                                 In section .data, align 4
    256          tLCD_APIList LCD_APIList180 = {
   \                     LCD_APIList180:
   \   00000000   0x........         DC32 _DrawBitmap180, _Rect2TextRect
   \              0x........   

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     GUI_Context

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     GUI_RectDispString

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>`:
   \   00000000   0x0000             DC16 0
   \   00000002   0x00 0x00          DC8 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
    257            (tLCD_DrawBitmap*)&_DrawBitmap180,
    258            &_Rect2TextRect
    259          };
    260          
    261          #else
    262          void LCD_Rotate180_C(void);
    263          void LCD_Rotate180_C(void){}
    264          #endif
    265          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   _DrawBitLine1BPP
        32   -> LCD_L0_GetPixelIndex
        32   -> LCD_L0_SetPixelIndex
      56   _DrawBitmap
        56   -> _DrawBitLine1BPP
      80   _DrawBitmap180
        80   -> LCD_FillRect
        80   -> _DrawBitmap
        80   -> _TransformPoint180
       0   _Rect2TextRect
      24   _TransformPoint180
        24   -> LCD_GetXSize
        24   -> LCD_GetYSize
        24   -> WM_GetWindowRect


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       8  ?<Constant {0}>
       4  ??DataTable3
       4  ??DataTable3_1
       8  LCD_APIList180
     182  _DrawBitLine1BPP
      70  _DrawBitmap
     402  _DrawBitmap180
       2  _Rect2TextRect
     114  _TransformPoint180

 
   8 bytes in section .data
 786 bytes in section .text
 
 786 bytes of CODE memory
   8 bytes of DATA memory

Errors: none
Warnings: none
