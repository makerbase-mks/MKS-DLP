###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  10:58:15
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Core\GUI_MOUSE_DriverPS2.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Core\GUI_MOUSE_DriverPS2.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\GUI_MOUSE_DriverPS2.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\GUI_MOUSE_DriverPS2.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Core\GUI_MOUSE_DriverPS2.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              µC/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : GUITOUCH.C
     16          Purpose     : Touch screen manager
     17          ----------------------------------------------------------------------
     18          This module handles the touch screen. It is configured in the file
     19          GUITouch.conf.h (Should be located in the Config\ directory).
     20          ----------------------------------------------------------------------
     21          */
     22          
     23          #include "LCD_Private.h"      /* private modul definitions & config */
     24          #include "GUI_Protected.h"
     25          
     26          /*********************************************************************
     27          *
     28          *       Static data
     29          *
     30          **********************************************************************
     31          */
     32          

   \                                 In section .bss, align 4
     33          static int  _ScreenX              = 0;    /* x-pos              */
     34          static int  _ScreenY              = 0;    /* y-pos              */
     35          static int  _NumBytesInBuffer     = 0;    /* bytes in rx buffer */
     36          static U8   _Buttons              = 0;    /* button status      */
     37          static U8   _abInBuffer[3];               /* mouse rx buffer    */
   \                     _abInBuffer:
   \   00000000                      DS8 4
   \   00000004                      DS8 1
   \   00000005                      DS8 3
   \   00000008                      DS8 4
   \   0000000C                      DS8 4
   \   00000010                      DS8 4
     38          
     39          /*********************************************************************
     40          *
     41          *       Static code
     42          *
     43          **********************************************************************
     44          */
     45          /*********************************************************************
     46          *
     47          *       _EvaPacket
     48          *
     49          * Purpose:
     50          *   Process data packet from mouse:
     51          *
     52          *             | D7    D6    D5    D4    D3    D2    D1    D0
     53          *   ----------+----------------------------------------------
     54          *   1st byte  | --    --    Y-    X-     1    --    LB    RB
     55          *   2nd byte  | X7    X6    X5    X4    X3    X2    X1    X0
     56          *   3rd byte  | Y7    Y6    Y5    Y4    Y3    Y2    Y1    Y0
     57          */

   \                                 In section .text, align 2, keep-with-next
     58          static void _EvaPacket(void) {
   \                     _EvaPacket: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
     59            char a;
     60            GUI_PID_STATE State;
     61            _Buttons = _abInBuffer[0] & 0x03;
   \   00000002   0x....             LDR.N    R1,??DataTable2
   \   00000004   0x780A             LDRB     R2,[R1, #+0]
   \   00000006   0xF002 0x0003      AND      R0,R2,#0x3
   \   0000000A   0x7108             STRB     R0,[R1, #+4]
     62            a = _abInBuffer[1];
   \   0000000C   0xF991 0x3001      LDRSB    R3,[R1, #+1]
     63            /* test x move sign. */
     64            if(_abInBuffer[0] & 0x10) {
   \   00000010   0x688C             LDR      R4,[R1, #+8]
   \   00000012   0x06D5             LSLS     R5,R2,#+27
   \   00000014   0xD504             BPL.N    ??_EvaPacket_0
     65              a=-a;
     66              _ScreenX  -= a;
   \   00000016   0x425B             RSBS     R3,R3,#+0
   \   00000018   0xB25B             SXTB     R3,R3
   \   0000001A   0x1AE3             SUBS     R3,R4,R3
   \   0000001C   0x608B             STR      R3,[R1, #+8]
   \   0000001E   0xE001             B.N      ??_EvaPacket_1
     67            }        /* direction is negative, move left */
     68            else {
     69              _ScreenX  += a;
   \                     ??_EvaPacket_0: (+1)
   \   00000020   0x191B             ADDS     R3,R3,R4
   \   00000022   0x608B             STR      R3,[R1, #+8]
     70            }
     71            a = _abInBuffer[2];
   \                     ??_EvaPacket_1: (+1)
   \   00000024   0xF991 0x3002      LDRSB    R3,[R1, #+2]
     72            /* test y move sign. */
     73            if(_abInBuffer[0] & 0x20) {
   \   00000028   0x68CC             LDR      R4,[R1, #+12]
   \   0000002A   0x0692             LSLS     R2,R2,#+26
   \   0000002C   0xD504             BPL.N    ??_EvaPacket_2
     74              a=-a;
     75              _ScreenY  += a;
   \   0000002E   0x425A             RSBS     R2,R3,#+0
   \   00000030   0xFA44 0xF282      SXTAB    R2,R4,R2
   \   00000034   0x60CA             STR      R2,[R1, #+12]
   \   00000036   0xE001             B.N      ??_EvaPacket_3
     76            }  /* direction is negative, move down */ else {
     77              _ScreenY  -= a;
   \                     ??_EvaPacket_2: (+1)
   \   00000038   0x1AE2             SUBS     R2,R4,R3
   \   0000003A   0x60CA             STR      R2,[R1, #+12]
     78            }
     79            /* check min/max positions */    
     80            if (_ScreenX < 0) {
   \                     ??_EvaPacket_3: (+1)
   \   0000003C   0x688A             LDR      R2,[R1, #+8]
   \   0000003E   0x2A00             CMP      R2,#+0
   \   00000040   0xD502             BPL.N    ??_EvaPacket_4
     81              _ScreenX = 0;
   \   00000042   0x2200             MOVS     R2,#+0
   \   00000044   0x608A             STR      R2,[R1, #+8]
   \   00000046   0xE005             B.N      ??_EvaPacket_5
     82            } else if (_ScreenX > LCD_XSIZE-1) {
   \                     ??_EvaPacket_4: (+1)
   \   00000048   0xF5B2 0x7FF0      CMP      R2,#+480
   \   0000004C   0xDB02             BLT.N    ??_EvaPacket_5
     83              _ScreenX = LCD_XSIZE-1;
   \   0000004E   0xF240 0x12DF      MOVW     R2,#+479
   \   00000052   0x608A             STR      R2,[R1, #+8]
     84            } if (_ScreenY < 0) {
   \                     ??_EvaPacket_5: (+1)
   \   00000054   0x68CA             LDR      R2,[R1, #+12]
   \   00000056   0x2A00             CMP      R2,#+0
   \   00000058   0xD502             BPL.N    ??_EvaPacket_6
     85              _ScreenY = 0;
   \   0000005A   0x2200             MOVS     R2,#+0
   \   0000005C   0x60CA             STR      R2,[R1, #+12]
   \   0000005E   0xE005             B.N      ??_EvaPacket_7
     86            } else if (_ScreenY > LCD_YSIZE-1) {
   \                     ??_EvaPacket_6: (+1)
   \   00000060   0xF5B2 0x7FA0      CMP      R2,#+320
   \   00000064   0xDB02             BLT.N    ??_EvaPacket_7
     87              _ScreenY = LCD_YSIZE-1;
   \   00000066   0xF240 0x123F      MOVW     R2,#+319
   \   0000006A   0x60CA             STR      R2,[R1, #+12]
     88            }
     89            /* signal new mouse data */
     90            State.x       = _ScreenX;
   \                     ??_EvaPacket_7: (+1)
   \   0000006C   0x688A             LDR      R2,[R1, #+8]
   \   0000006E   0x9200             STR      R2,[SP, #+0]
     91            State.y       = _ScreenY;
   \   00000070   0x68C9             LDR      R1,[R1, #+12]
   \   00000072   0x9101             STR      R1,[SP, #+4]
     92            State.Pressed = _Buttons;
   \   00000074   0xF88D 0x0008      STRB     R0,[SP, #+8]
     93            GUI_MOUSE_StoreState(&State);
   \   00000078   0xA800             ADD      R0,SP,#+0
   \   0000007A   0x.... 0x....      BL       GUI_MOUSE_StoreState
     94          }
   \   0000007E   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
     95          
     96          /*********************************************************************
     97          *
     98          *       Public code
     99          *
    100          **********************************************************************
    101          */
    102          /*********************************************************************
    103          *
    104          *       GUI_MOUSE_DRIVER_PS2_OnRx
    105          *
    106          * Purpose:
    107          *   Mouse receive interrupt handler. The PS2 mouse interrupt gets
    108          *   in three bytes from the mouse, then wakes up the mouse LSR.
    109          */

   \                                 In section .text, align 2, keep-with-next
    110          void GUI_MOUSE_DRIVER_PS2_OnRx(unsigned char Data) {
   \                     GUI_MOUSE_DRIVER_PS2_OnRx: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    111            if (!_NumBytesInBuffer) {
   \   00000002   0x....             LDR.N    R4,??DataTable2
   \   00000004   0x6921             LDR      R1,[R4, #+16]
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD107             BNE.N    ??GUI_MOUSE_DRIVER_PS2_OnRx_0
    112              /* check for start frame */
    113              if ((Data & 0x0c) == 0x08) {
   \   0000000A   0xF000 0x010C      AND      R1,R0,#0xC
   \   0000000E   0x2908             CMP      R1,#+8
   \   00000010   0xD10C             BNE.N    ??GUI_MOUSE_DRIVER_PS2_OnRx_1
    114                _abInBuffer[0] = Data;
   \   00000012   0x7020             STRB     R0,[R4, #+0]
    115                _NumBytesInBuffer++;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x6120             STR      R0,[R4, #+16]
   \   00000018   0xBD10             POP      {R4,PC}
    116              }
    117            } else {
    118              _abInBuffer[_NumBytesInBuffer] = Data;
   \                     ??GUI_MOUSE_DRIVER_PS2_OnRx_0: (+1)
   \   0000001A   0x5508             STRB     R0,[R1, R4]
    119              _NumBytesInBuffer++;
   \   0000001C   0x1C48             ADDS     R0,R1,#+1
   \   0000001E   0x6120             STR      R0,[R4, #+16]
    120              if (_NumBytesInBuffer >= 3) {
   \   00000020   0x2803             CMP      R0,#+3
   \   00000022   0xDB03             BLT.N    ??GUI_MOUSE_DRIVER_PS2_OnRx_1
    121                _EvaPacket();
   \   00000024   0x.... 0x....      BL       _EvaPacket
    122                _NumBytesInBuffer = 0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x6120             STR      R0,[R4, #+16]
    123              }
    124            }
    125          }
   \                     ??GUI_MOUSE_DRIVER_PS2_OnRx_1: (+1)
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
    126          
    127          /*********************************************************************
    128          *
    129          *       GUI_MOUSE_DRIVER_PS2_Init
    130          */

   \                                 In section .text, align 2, keep-with-next
    131          void GUI_MOUSE_DRIVER_PS2_Init(void) {
    132            _NumBytesInBuffer = 0; 
   \                     GUI_MOUSE_DRIVER_PS2_Init: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             LDR.N    R1,??DataTable2
   \   00000004   0x6108             STR      R0,[R1, #+16]
    133          }
   \   00000006   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     _abInBuffer
    134          
    135          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   GUI_MOUSE_DRIVER_PS2_Init
       8   GUI_MOUSE_DRIVER_PS2_OnRx
         8   -> _EvaPacket
      24   _EvaPacket
        24   -> GUI_MOUSE_StoreState


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       8  GUI_MOUSE_DRIVER_PS2_Init
      46  GUI_MOUSE_DRIVER_PS2_OnRx
     128  _EvaPacket
      20  _abInBuffer
          _Buttons
          _ScreenX
          _ScreenY
          _NumBytesInBuffer

 
  20 bytes in section .bss
 186 bytes in section .text
 
 186 bytes of CODE memory
  20 bytes of DATA memory

Errors: none
Warnings: none
