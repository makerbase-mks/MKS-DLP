###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  10:58:22
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Core\GUICharP.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Core\GUICharP.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\GUICharP.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\GUICharP.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Core\GUICharP.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              C/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : GUICharP.C
     16          Purpose     : Implementation of Proportional fonts
     17          ---------------------------END-OF-HEADER------------------------------
     18          */
     19          
     20          #include <stddef.h>           /* needed for definition of NULL */
     21          #include "GUI_Private.h"
     22          #include "spi_flash.h"  

  #define IS_SPI_MODE(MODE) (((MODE) == SPI_Mode_Master) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_spi.h",173  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_MODE" (declared at line
          511 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_spi.h")

  #define IS_SPI_DATASIZE(DATASIZE) (((DATASIZE) == SPI_DataSize_16b) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_spi.h",185  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_DATASIZE" (declared at
          line 523 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_spi.h")

  #define IS_SPI_CPOL(CPOL) (((CPOL) == SPI_CPOL_Low) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_spi.h",197  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_CPOL" (declared at line
          526 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_spi.h")

  #define IS_SPI_CPHA(CPHA) (((CPHA) == SPI_CPHA_1Edge) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_spi.h",209  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_CPHA" (declared at line
          529 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_spi.h")

  #define IS_SPI_NSS(NSS) (((NSS) == SPI_NSS_Soft) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_spi.h",221  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_NSS" (declared at line
          532 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_spi.h")

  #define IS_SPI_BAUDRATE_PRESCALER(PRESCALER) (((PRESCALER) == SPI_BaudRatePrescaler_2) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_spi.h",239  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_BAUDRATE_PRESCALER"
          (declared at line 536 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_spi.h")

  #define IS_SPI_FIRST_BIT(BIT) (((BIT) == SPI_FirstBit_MSB) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_spi.h",257  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_FIRST_BIT" (declared at
          line 545 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_spi.h")

  #define IS_SPI_DIRECTION(DIRECTION) (((DIRECTION) == SPI_Direction_Rx) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_spi.h",400  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_DIRECTION" (declared at
          line 514 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_spi.h")

  #define SPI_FLAG_CRCERR                 ((uint16_t)0x0010)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_spi.h",442  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_FLAG_CRCERR" (declared at
          line 293 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_spi.h")

  #define SPI_FLAG_MODF                   ((uint16_t)0x0020)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_spi.h",443  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_FLAG_MODF" (declared at line
          294 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_spi.h")

  #define IS_SPI_CRC_POLYNOMIAL(POLYNOMIAL) ((POLYNOMIAL) >= 0x1)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_spi.h",462  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_CRC_POLYNOMIAL" (declared
          at line 554 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_spi.h")

  #define SPI_IT_TXE                   SPI_I2S_IT_TXE
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_spi.h",473  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_IT_TXE" (declared at line
          280 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_spi.h")

  #define SPI_IT_RXNE                  SPI_I2S_IT_RXNE
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_spi.h",474  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_IT_RXNE" (declared at line
          281 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_spi.h")

  #define SPI_IT_ERR                   SPI_I2S_IT_ERR
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_spi.h",475  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_IT_ERR" (declared at line
          282 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_spi.h")

  #define SPI_FLAG_RXNE                SPI_I2S_FLAG_RXNE
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_spi.h",477  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_FLAG_RXNE" (declared at line
          290 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_spi.h")

  #define SPI_FLAG_TXE                 SPI_I2S_FLAG_TXE
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_spi.h",478  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_FLAG_TXE" (declared at line
          291 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_spi.h")

  #define SPI_FLAG_OVR                 SPI_I2S_FLAG_OVR
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_spi.h",479  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_FLAG_OVR" (declared at line
          295 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_spi.h")

  #define SPI_FLAG_BSY                 SPI_I2S_FLAG_BSY
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_spi.h",480  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_FLAG_BSY" (declared at line
          292 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_spi.h")
     23          #include "pic_manager.h"
     24          #include "GUI.h" 
     25          extern const unsigned char asc2_1608[95][16];
     26          extern GUI_CONST_STORAGE U8 acFont8x16[][16];
     27          //extern GUI_CONST_STORAGE GUI_CHARINFO GUI_Fontmks_fontHz14_CharInfo[192];
     28          extern GUI_CONST_STORAGE GUI_CHARINFO GUI_Fontmks_fontHz14_CharInfo[96];
     29          
     30          /*********************************************************************
     31          *
     32          *       Static code
     33          *
     34          **********************************************************************
     35          */
     36          //字模数据的暂存数组,以单个字模的最大字节数为设定值 
     37          #define BYTES_PER_FONT 32   //最大支持16*16的汉字

   \                                 In section .bss, align 4
     38          static U8 GUI_FontDataBuf[BYTES_PER_FONT];
   \                     GUI_FontDataBuf:
   \   00000000                      DS8 32
     39          extern const GUI_FONT GUI_FontHZ16;
     40          /*********************************************************************
     41          *
     42          *       GUIPROP_FindChar
     43          */

   \                                 In section .text, align 2, keep-with-next
     44          static const GUI_FONT_PROP GUI_UNI_PTR * GUIPROP_FindChar(const GUI_FONT_PROP GUI_UNI_PTR* pProp, U16P c) {
   \                     GUIPROP_FindChar: (+1)
   \   00000000   0xE000             B.N      ??GUIPROP_FindChar_0
     45            for (; pProp; pProp = pProp->pNext) {
   \                     ??GUIPROP_FindChar_1: (+1)
   \   00000002   0x6880             LDR      R0,[R0, #+8]
   \                     ??GUIPROP_FindChar_0: (+1)
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD005             BEQ.N    ??GUIPROP_FindChar_2
     46              if ((c>=pProp->First) && (c<=pProp->Last))
   \   00000008   0x8802             LDRH     R2,[R0, #+0]
   \   0000000A   0x4291             CMP      R1,R2
   \   0000000C   0xD3F9             BCC.N    ??GUIPROP_FindChar_1
   \   0000000E   0x8842             LDRH     R2,[R0, #+2]
   \   00000010   0x428A             CMP      R2,R1
   \   00000012   0xD3F6             BCC.N    ??GUIPROP_FindChar_1
     47                break;
     48            }
     49            return pProp;
   \                     ??GUIPROP_FindChar_2: (+1)
   \   00000014   0x4770             BX       LR               ;; return
     50          }
     51          
     52          /*********************************************************************
     53          *
     54          *       Public code
     55          *
     56          **********************************************************************
     57          */
     58          /*********************************************************************
     59          *
     60          *       GUIPROP_DispChar
     61          *
     62          * Purpose:
     63          *   This is the routine that displays a character. It is used by all
     64          *   other routines which display characters as a subroutine.
     65          */
     66          //tan0910
     67          #if 0
     68          void GUIPROP_DispChar(U16P c) {
     69            int BytesPerLine;
     70            GUI_DRAWMODE DrawMode = GUI_Context.TextMode;
     71            const GUI_FONT_PROP GUI_UNI_PTR * pProp = GUIPROP_FindChar(GUI_Context.pAFont->p.pProp, c);
     72            if (pProp) {
     73              GUI_DRAWMODE OldDrawMode;
     74              const GUI_CHARINFO GUI_UNI_PTR * pCharInfo = pProp->paCharInfo+(c-pProp->First);
     75              BytesPerLine = pCharInfo->BytesPerLine;
     76              OldDrawMode  = LCD_SetDrawMode(DrawMode);
     77              LCD_DrawBitmap( GUI_Context.DispPosX, GUI_Context.DispPosY,
     78                                 pCharInfo->XSize,
     79          											 GUI_Context.pAFont->YSize,
     80                                 GUI_Context.pAFont->XMag,
     81          											 GUI_Context.pAFont->YMag,
     82                                 1,     /* Bits per Pixel */
     83                                 BytesPerLine,
     84                                 pCharInfo->pData,
     85                                 &LCD_BKCOLORINDEX
     86                                 );
     87              /* Fill empty pixel lines */
     88              if (GUI_Context.pAFont->YDist > GUI_Context.pAFont->YSize) {
     89                int YMag = GUI_Context.pAFont->YMag;
     90                int YDist = GUI_Context.pAFont->YDist * YMag;
     91                int YSize = GUI_Context.pAFont->YSize * YMag;
     92                if (DrawMode != LCD_DRAWMODE_TRANS) {
     93                  LCD_COLOR OldColor = GUI_GetColor();
     94                  GUI_SetColor(GUI_GetBkColor());
     95                  LCD_FillRect(GUI_Context.DispPosX, 
     96                               GUI_Context.DispPosY + YSize, 
     97                               GUI_Context.DispPosX + pCharInfo->XSize, 
     98                               GUI_Context.DispPosY + YDist);
     99                  GUI_SetColor(OldColor);
    100                }
    101              }
    102              LCD_SetDrawMode(OldDrawMode); /* Restore draw mode */
    103              GUI_Context.DispPosX += pCharInfo->XDist * GUI_Context.pAFont->XMag;
    104            }
    105          }
    106          #endif

   \                                 In section .text, align 2, keep-with-next
    107          void GUIPROP_DispChar(U16P c) {
   \                     GUIPROP_DispChar: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
   \   00000006   0x4604             MOV      R4,R0
    108            
    109            static const unsigned char *buf_point1,*buf_point2;//tan
    110              
    111            unsigned char qh,ql;
    112            unsigned char i;					  
    113            unsigned long foffset; 
    114            unsigned char *mat;
    115            unsigned char size=16;//字体大小
    116            unsigned char t;
    117          
    118            U8 BytesPerFont;  //一个字的字节数
    119            
    120            int BytesPerLine;
    121            GUI_DRAWMODE DrawMode = GUI_Context.TextMode;
   \   00000008   0x....             LDR.N    R6,??DataTable1
   \   0000000A   0xF9B6 0x702A      LDRSH    R7,[R6, #+42]
    122            const GUI_FONT_PROP GUI_UNI_PTR * pProp = GUIPROP_FindChar(GUI_Context.pAFont->p.pProp, c);
   \   0000000E   0xF8D6 0xA018      LDR      R10,[R6, #+24]
   \   00000012   0x4621             MOV      R1,R4
   \   00000014   0xF8DA 0x0018      LDR      R0,[R10, #+24]
   \   00000018   0x.... 0x....      BL       GUIPROP_FindChar
    123            
    124            if (pProp) {
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xF000 0x80CC      BEQ.W    ??GUIPROP_DispChar_0
    125              GUI_DRAWMODE OldDrawMode;
    126              //const GUI_CHARINFO GUI_UNI_PTR * pCharInfo = pProp->paCharInfo+(c-pProp->First);
    127              const GUI_CHARINFO GUI_UNI_PTR * pCharInfo;
    128              
    129              if((GUI_Context.pAFont == &GUI_FontHZ16))
   \   00000022   0x6845             LDR      R5,[R0, #+4]
   \   00000024   0x46A0             MOV      R8,R4
   \   00000026   0x....             LDR.N    R1,??DataTable1_1
   \   00000028   0x458A             CMP      R10,R1
   \   0000002A   0xD175             BNE.N    ??GUIPROP_DispChar_1
    130              {
    131                pCharInfo = pProp->paCharInfo;
    132                //base = (U32)pProp->paCharInfo->pData; //找出字库对应的首地址
    133                BytesPerFont = GUI_Context.pAFont->YSize * pProp->paCharInfo->BytesPerLine; //每个字模的数据字节数
    134                if(BytesPerFont > BYTES_PER_FONT)
    135                {
    136                  BytesPerFont = BYTES_PER_FONT;
    137                }
    138                if (c < 0x80) //英文字符地址偏移算法 
   \   0000002C   0xF1B8 0x0F80      CMP      R8,#+128
   \   00000030   0xDA20             BGE.N    ??GUIPROP_DispChar_2
    139                {
    140                  /*
    141                  memset(GUI_FontDataBuf,0,sizeof(GUI_FontDataBuf));
    142                  
    143                  for(t=0;t<16;t++)
    144                  {
    145                    GUI_FontDataBuf[t] = acFont8x16[c-0x20][t]; //直接取出字模 
    146                  }
    147                  */
    148                  BytesPerLine = pCharInfo->BytesPerLine;//获取一行有多少个字节
   \   00000032   0xF895 0x9002      LDRB     R9,[R5, #+2]
    149                  OldDrawMode  = LCD_SetDrawMode(DrawMode);//设置画图模式		
   \   00000036   0x4638             MOV      R0,R7
   \   00000038   0x.... 0x....      BL       LCD_SetDrawMode
   \   0000003C   0x4604             MOV      R4,R0
    150          
    151                  LCD_DrawBitmap( GUI_Context.DispPosX, 
    152                                  GUI_Context.DispPosY,
    153                                  pCharInfo->XSize,
    154                                  GUI_Context.pAFont->YSize,
    155                                  GUI_Context.pAFont->XMag,
    156                                  GUI_Context.pAFont->YMag,
    157                                  1,     
    158                                  BytesPerLine,
    159                                  GUI_Fontmks_fontHz14_CharInfo[c-0x20].pData,//GUI_Fontmks_fontHz14_CharInfo[c-0x20].pData,   //加载的字符数据
    160                                  &LCD_BKCOLORINDEX
    161                                  ); 
   \   0000003E   0x69B0             LDR      R0,[R6, #+24]
   \   00000040   0x9605             STR      R6,[SP, #+20]
   \   00000042   0x....             LDR.N    R1,??DataTable1_2
   \   00000044   0xEB01 0x01C8      ADD      R1,R1,R8, LSL #+3
   \   00000048   0xF851 0x1CFC      LDR      R1,[R1, #-252]
   \   0000004C   0x9104             STR      R1,[SP, #+16]
   \   0000004E   0xF8CD 0x900C      STR      R9,[SP, #+12]
   \   00000052   0x2101             MOVS     R1,#+1
   \   00000054   0x9102             STR      R1,[SP, #+8]
   \   00000056   0xF990 0x1017      LDRSB    R1,[R0, #+23]
   \   0000005A   0x9101             STR      R1,[SP, #+4]
   \   0000005C   0xF990 0x1016      LDRSB    R1,[R0, #+22]
   \   00000060   0x9100             STR      R1,[SP, #+0]
   \   00000062   0x7D03             LDRB     R3,[R0, #+20]
   \   00000064   0x782A             LDRB     R2,[R5, #+0]
   \   00000066   0xF9B6 0x1024      LDRSH    R1,[R6, #+36]
   \   0000006A   0xF9B6 0x0022      LDRSH    R0,[R6, #+34]
   \   0000006E   0x.... 0x....      BL       LCD_DrawBitmap
   \   00000072   0xE072             B.N      ??GUIPROP_DispChar_3
    162                    
    163                }
    164                else
    165                {
    166                  qh=c/256;
   \                     ??GUIPROP_DispChar_2: (+1)
   \   00000074   0xEA4F 0x2A14      LSR      R10,R4,#+8
    167          	    ql=c%256;
   \   00000078   0xB2E4             UXTB     R4,R4
    168                  if(qh<0x81||ql<0x40||ql==0xff||qh==0xff)//非 常用汉字
   \   0000007A   0xF1BA 0x0F81      CMP      R10,#+129
   \   0000007E   0xDB06             BLT.N    ??GUIPROP_DispChar_4
   \   00000080   0x2C40             CMP      R4,#+64
   \   00000082   0xDB04             BLT.N    ??GUIPROP_DispChar_4
   \   00000084   0x2CFF             CMP      R4,#+255
   \   00000086   0xD002             BEQ.N    ??GUIPROP_DispChar_4
   \   00000088   0xF1BA 0x0FFF      CMP      R10,#+255
   \   0000008C   0xD108             BNE.N    ??GUIPROP_DispChar_5
    169                  {   		    
    170                      for(i=0;i<(size*2);i++)*mat++=0x00;//填充满格
   \                     ??GUIPROP_DispChar_4: (+1)
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x4601             MOV      R1,R0
   \   00000092   0xE002             B.N      ??GUIPROP_DispChar_6
   \                     ??GUIPROP_DispChar_7: (+1)
   \   00000094   0xF809 0x1B01      STRB     R1,[R9], #+1
   \   00000098   0x1C40             ADDS     R0,R0,#+1
   \                     ??GUIPROP_DispChar_6: (+1)
   \   0000009A   0x2820             CMP      R0,#+32
   \   0000009C   0xDBFA             BLT.N    ??GUIPROP_DispChar_7
    171                      return; //结束访问
   \   0000009E   0xE08C             B.N      ??GUIPROP_DispChar_0
    172                  }          
    173                  if(ql<0x7f)ql-=0x40;//注意!
   \                     ??GUIPROP_DispChar_5: (+1)
   \   000000A0   0x2C7F             CMP      R4,#+127
   \   000000A2   0xDA02             BGE.N    ??GUIPROP_DispChar_8
   \   000000A4   0x3C40             SUBS     R4,R4,#+64
   \   000000A6   0xB2E4             UXTB     R4,R4
   \   000000A8   0xE001             B.N      ??GUIPROP_DispChar_9
    174                  else ql-=0x41;
   \                     ??GUIPROP_DispChar_8: (+1)
   \   000000AA   0x3C41             SUBS     R4,R4,#+65
   \   000000AC   0xB2E4             UXTB     R4,R4
    175                  qh-=0x81;   
    176                  foffset=((unsigned long)190*qh+ql)*(size*2);//得到字库中的字节偏移量					
    177                  if(size==16)
    178                  {
    179                     memset(GUI_FontDataBuf,0,sizeof(GUI_FontDataBuf));
                            ^
Warning[Pe223]: function "memset" declared implicitly

    static const unsigned char *buf_point1,*buf_point2;//tan
                                ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Core\GUICharP.c",109  Warning[Pe177]: 
          variable "buf_point1" was declared but never referenced

    static const unsigned char *buf_point1,*buf_point2;//tan
                                            ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Core\GUICharP.c",109  Warning[Pe177]: 
          variable "buf_point2" was declared but never referenced

    unsigned char t;
                  ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Core\GUICharP.c",116  Warning[Pe177]: 
          variable "t" was declared but never referenced
   \                     ??GUIPROP_DispChar_9: (+1)
   \   000000AE   0x.... 0x....      LDR.W    R8,??DataTable1_3
   \   000000B2   0x2220             MOVS     R2,#+32
   \   000000B4   0x2100             MOVS     R1,#+0
   \   000000B6   0x4640             MOV      R0,R8
   \   000000B8   0x.... 0x....      BL       memset
    180                     SPI_FLASH_BufferRead(GUI_FontDataBuf,foffset+GBK_FLASH_ADDR,32);
   \   000000BC   0x2220             MOVS     R2,#+32
   \   000000BE   0xF10A 0x007F      ADD      R0,R10,#+127
   \   000000C2   0xB2C0             UXTB     R0,R0
   \   000000C4   0x21BE             MOVS     R1,#+190
   \   000000C6   0xFB11 0xF000      SMULBB   R0,R1,R0
   \   000000CA   0xFA50 0xF084      UXTAB    R0,R0,R4
   \   000000CE   0x0140             LSLS     R0,R0,#+5
   \   000000D0   0xF500 0x01C0      ADD      R1,R0,#+6291456
   \   000000D4   0xF501 0x3134      ADD      R1,R1,#+184320
   \   000000D8   0x4640             MOV      R0,R8
   \   000000DA   0x.... 0x....      BL       SPI_FLASH_BufferRead
    181                  }
    182                  else 
    183                  {
    184                     SPI_FLASH_BufferRead(GUI_FontDataBuf,foffset+GBK_FLASH_ADDR,24);
    185                  }
    186                //}
    187                
    188                BytesPerLine = pCharInfo->BytesPerLine;//获取一行有多少个字节
   \   000000DE   0xF895 0x9002      LDRB     R9,[R5, #+2]
    189                OldDrawMode  = LCD_SetDrawMode(DrawMode);//设置画图模式		
   \   000000E2   0x4638             MOV      R0,R7
   \   000000E4   0x.... 0x....      BL       LCD_SetDrawMode
   \   000000E8   0x4604             MOV      R4,R0
    190          
    191                LCD_DrawBitmap( GUI_Context.DispPosX, 
    192                                GUI_Context.DispPosY,
    193                                pCharInfo->XSize,
    194                                GUI_Context.pAFont->YSize,
    195                                GUI_Context.pAFont->XMag,
    196                                GUI_Context.pAFont->YMag,
    197                                1,     
    198                                BytesPerLine,
    199                                GUI_FontDataBuf,   //加载的字符数据
    200                                &LCD_BKCOLORINDEX
    201                                ); 
   \   000000EA   0x69B0             LDR      R0,[R6, #+24]
   \   000000EC   0x9605             STR      R6,[SP, #+20]
   \   000000EE   0xF8CD 0x8010      STR      R8,[SP, #+16]
   \   000000F2   0xF8CD 0x900C      STR      R9,[SP, #+12]
   \   000000F6   0x2101             MOVS     R1,#+1
   \   000000F8   0x9102             STR      R1,[SP, #+8]
   \   000000FA   0xF990 0x1017      LDRSB    R1,[R0, #+23]
   \   000000FE   0x9101             STR      R1,[SP, #+4]
   \   00000100   0xF990 0x1016      LDRSB    R1,[R0, #+22]
   \   00000104   0x9100             STR      R1,[SP, #+0]
   \   00000106   0x7D03             LDRB     R3,[R0, #+20]
   \   00000108   0x782A             LDRB     R2,[R5, #+0]
   \   0000010A   0xF9B6 0x1024      LDRSH    R1,[R6, #+36]
   \   0000010E   0xF9B6 0x0022      LDRSH    R0,[R6, #+34]
   \   00000112   0x.... 0x....      BL       LCD_DrawBitmap
   \   00000116   0xE020             B.N      ??GUIPROP_DispChar_3
    202                }
    203              }
    204              else
    205              {
    206                pCharInfo	= pProp->paCharInfo+(c-pProp->First);
   \                     ??GUIPROP_DispChar_1: (+1)
   \   00000118   0x8800             LDRH     R0,[R0, #+0]
   \   0000011A   0xEBA8 0x0000      SUB      R0,R8,R0
   \   0000011E   0xEB05 0x05C0      ADD      R5,R5,R0, LSL #+3
    207                BytesPerLine = pCharInfo->BytesPerLine;
   \   00000122   0xF895 0x9002      LDRB     R9,[R5, #+2]
    208                OldDrawMode  = LCD_SetDrawMode(DrawMode);
   \   00000126   0x4638             MOV      R0,R7
   \   00000128   0x.... 0x....      BL       LCD_SetDrawMode
   \   0000012C   0x4604             MOV      R4,R0
    209                LCD_DrawBitmap( GUI_Context.DispPosX, GUI_Context.DispPosY,
    210                                   pCharInfo->XSize,
    211                                                         GUI_Context.pAFont->YSize,
    212                                   GUI_Context.pAFont->XMag,
    213                                                         GUI_Context.pAFont->YMag,
    214                                   1,     /* Bits per Pixel */
    215                                   BytesPerLine,
    216                                   pCharInfo->pData,
    217                                   &LCD_BKCOLORINDEX
    218                                   );
   \   0000012E   0x69B0             LDR      R0,[R6, #+24]
   \   00000130   0x9605             STR      R6,[SP, #+20]
   \   00000132   0x6869             LDR      R1,[R5, #+4]
   \   00000134   0x9104             STR      R1,[SP, #+16]
   \   00000136   0xF8CD 0x900C      STR      R9,[SP, #+12]
   \   0000013A   0x2101             MOVS     R1,#+1
   \   0000013C   0x9102             STR      R1,[SP, #+8]
   \   0000013E   0xF990 0x1017      LDRSB    R1,[R0, #+23]
   \   00000142   0x9101             STR      R1,[SP, #+4]
   \   00000144   0xF990 0x1016      LDRSB    R1,[R0, #+22]
   \   00000148   0x9100             STR      R1,[SP, #+0]
   \   0000014A   0x7D03             LDRB     R3,[R0, #+20]
   \   0000014C   0x782A             LDRB     R2,[R5, #+0]
   \   0000014E   0xF9B6 0x1024      LDRSH    R1,[R6, #+36]
   \   00000152   0xF9B6 0x0022      LDRSH    R0,[R6, #+34]
   \   00000156   0x.... 0x....      BL       LCD_DrawBitmap
    219              }
    220              /* Fill empty pixel lines */
    221              if (GUI_Context.pAFont->YDist > GUI_Context.pAFont->YSize) {
   \                     ??GUIPROP_DispChar_3: (+1)
   \   0000015A   0x69B0             LDR      R0,[R6, #+24]
   \   0000015C   0x7D41             LDRB     R1,[R0, #+21]
   \   0000015E   0x7D02             LDRB     R2,[R0, #+20]
   \   00000160   0x428A             CMP      R2,R1
   \   00000162   0xD21D             BCS.N    ??GUIPROP_DispChar_10
    222                int YMag = GUI_Context.pAFont->YMag;
   \   00000164   0xF990 0x0017      LDRSB    R0,[R0, #+23]
    223                int YDist = GUI_Context.pAFont->YDist * YMag;
   \   00000168   0xFB10 0xF801      SMULBB   R8,R0,R1
    224                int YSize = GUI_Context.pAFont->YSize * YMag;
   \   0000016C   0xFB10 0xF902      SMULBB   R9,R0,R2
    225                if (DrawMode != LCD_DRAWMODE_TRANS) {
   \   00000170   0x2F02             CMP      R7,#+2
   \   00000172   0xD015             BEQ.N    ??GUIPROP_DispChar_10
    226                  LCD_COLOR OldColor = GUI_GetColor();
   \   00000174   0x.... 0x....      BL       GUI_GetColor
   \   00000178   0x4607             MOV      R7,R0
    227                  GUI_SetColor(GUI_GetBkColor());
   \   0000017A   0x.... 0x....      BL       GUI_GetBkColor
   \   0000017E   0x.... 0x....      BL       GUI_SetColor
   \   00000182   0xF9B6 0x0022      LDRSH    R0,[R6, #+34]
   \   00000186   0xF9B6 0x1024      LDRSH    R1,[R6, #+36]
   \   0000018A   0xEB08 0x0301      ADD      R3,R8,R1
   \   0000018E   0x782A             LDRB     R2,[R5, #+0]
   \   00000190   0xFA50 0xF282      UXTAB    R2,R0,R2
   \   00000194   0x4449             ADD      R1,R9,R1
    228                  LCD_FillRect(GUI_Context.DispPosX, 
    229                               GUI_Context.DispPosY + YSize, 
    230                               GUI_Context.DispPosX + pCharInfo->XSize, 
    231                               GUI_Context.DispPosY + YDist);
   \   00000196   0x.... 0x....      BL       LCD_FillRect
    232                  GUI_SetColor(OldColor);
   \   0000019A   0x4638             MOV      R0,R7
   \   0000019C   0x.... 0x....      BL       GUI_SetColor
    233                }
    234              }
    235              LCD_SetDrawMode(OldDrawMode); /* Restore draw mode */
   \                     ??GUIPROP_DispChar_10: (+1)
   \   000001A0   0x4620             MOV      R0,R4
   \   000001A2   0x.... 0x....      BL       LCD_SetDrawMode
    236              GUI_Context.DispPosX += pCharInfo->XDist * GUI_Context.pAFont->XMag;
   \   000001A6   0xF9B6 0x0022      LDRSH    R0,[R6, #+34]
   \   000001AA   0x7869             LDRB     R1,[R5, #+1]
   \   000001AC   0x69B2             LDR      R2,[R6, #+24]
   \   000001AE   0xF992 0x2016      LDRSB    R2,[R2, #+22]
   \   000001B2   0xFB12 0xF101      SMULBB   R1,R2,R1
   \   000001B6   0x1808             ADDS     R0,R1,R0
   \   000001B8   0x8470             STRH     R0,[R6, #+34]
    237            }
    238          }
   \                     ??GUIPROP_DispChar_0: (+1)
   \   000001BA   0xB006             ADD      SP,SP,#+24
   \   000001BC   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    239          
    240          /*********************************************************************
    241          *
    242          *       GUIPROP_GetCharDistX
    243          */
    244          #if 0
    245          int GUIPROP_GetCharDistX(U16P c) {
    246            const GUI_FONT_PROP GUI_UNI_PTR * pProp = GUIPROP_FindChar(GUI_Context.pAFont->p.pProp, c);
    247            return (pProp) ? (pProp->paCharInfo+(c-pProp->First))->XSize * GUI_Context.pAFont->XMag : 0;
    248          }
    249          #endif
    250          extern const GUI_FONT_PROP GUI_FontHZ16_Prop0020;

   \                                 In section .text, align 2, keep-with-next
    251          int GUIPROP_GetCharDistX(U16P c)
    252          {
   \                     GUIPROP_GetCharDistX: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x....             LDR.N    R0,??DataTable1
   \   00000006   0x6985             LDR      R5,[R0, #+24]
   \   00000008   0x4621             MOV      R1,R4
   \   0000000A   0x69A8             LDR      R0,[R5, #+24]
    253          
    254            const GUI_FONT_PROP GUI_UNI_PTR * pProp = GUIPROP_FindChar(GUI_Context.pAFont->p.pProp, c);
   \   0000000C   0x.... 0x....      BL       GUIPROP_FindChar
    255            if(pProp)
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD008             BEQ.N    ??GUIPROP_GetCharDistX_0
    256            {
    257            	if(GUI_Context.pAFont == &GUI_FontHZ16)
   \   00000014   0x....             LDR.N    R1,??DataTable1_1
   \   00000016   0x428D             CMP      R5,R1
   \   00000018   0xD105             BNE.N    ??GUIPROP_GetCharDistX_0
    258          	{
    259          		if(c>0x80)return 16;
   \   0000001A   0x2C81             CMP      R4,#+129
   \   0000001C   0xDB01             BLT.N    ??GUIPROP_GetCharDistX_1
   \   0000001E   0x2010             MOVS     R0,#+16
   \   00000020   0xBD32             POP      {R1,R4,R5,PC}
    260          		else return 8;
   \                     ??GUIPROP_GetCharDistX_1: (+1)
   \   00000022   0x2008             MOVS     R0,#+8
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}
    261          	}	
    262            }
    263            return (pProp) ? (pProp->paCharInfo+(c-pProp->First))->XSize * GUI_Context.pAFont->XMag : 0;
   \                     ??GUIPROP_GetCharDistX_0: (+1)
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD009             BEQ.N    ??GUIPROP_GetCharDistX_2
   \   0000002A   0x8801             LDRH     R1,[R0, #+0]
   \   0000002C   0x1A61             SUBS     R1,R4,R1
   \   0000002E   0x6840             LDR      R0,[R0, #+4]
   \   00000030   0xF810 0x0031      LDRB     R0,[R0, R1, LSL #+3]
   \   00000034   0xF995 0x1016      LDRSB    R1,[R5, #+22]
   \   00000038   0xFB11 0xF000      SMULBB   R0,R1,R0
   \   0000003C   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??GUIPROP_GetCharDistX_2: (+1)
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    264          }
    265          
    266          /*********************************************************************
    267          *
    268          *       GUIPROP_GetFontInfo
    269          */

   \                                 In section .text, align 2, keep-with-next
    270          void GUIPROP_GetFontInfo(const GUI_FONT GUI_UNI_PTR * pFont, GUI_FONTINFO* pfi) {
    271            GUI_USE_PARA(pFont);
    272            pfi->Flags = GUI_FONTINFO_FLAG_PROP;
   \                     GUIPROP_GetFontInfo: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x8008             STRH     R0,[R1, #+0]
    273          }
   \   00000004   0x4770             BX       LR               ;; return
    274          
    275          /*********************************************************************
    276          *
    277          *       GUIPROP_IsInFont
    278          */

   \                                 In section .text, align 2, keep-with-next
    279          char GUIPROP_IsInFont(const GUI_FONT GUI_UNI_PTR * pFont, U16 c) {
   \                     GUIPROP_IsInFont: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    280            const GUI_FONT_PROP GUI_UNI_PTR * pProp = GUIPROP_FindChar(pFont->p.pProp, c);
    281            return (pProp==NULL) ? 0 : 1;
   \   00000002   0x6980             LDR      R0,[R0, #+24]
   \   00000004   0x.... 0x....      BL       GUIPROP_FindChar
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD101             BNE.N    ??GUIPROP_IsInFont_0
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xBD02             POP      {R1,PC}
   \                     ??GUIPROP_IsInFont_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xBD02             POP      {R1,PC}          ;; return
    282          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     GUI_Context

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x........         DC32     GUI_FontHZ16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x........         DC32     GUI_Fontmks_fontHz14_CharInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \   00000000   0x........         DC32     GUI_FontDataBuf
    283          
    284          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      56   GUIPROP_DispChar
        56   -> GUIPROP_FindChar
        56   -> GUI_GetBkColor
        56   -> GUI_GetColor
        56   -> GUI_SetColor
        56   -> LCD_DrawBitmap
        56   -> LCD_FillRect
        56   -> LCD_SetDrawMode
        56   -> SPI_FLASH_BufferRead
        56   -> memset
       0   GUIPROP_FindChar
      16   GUIPROP_GetCharDistX
        16   -> GUIPROP_FindChar
       0   GUIPROP_GetFontInfo
       8   GUIPROP_IsInFont
         8   -> GUIPROP_FindChar


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
     448  GUIPROP_DispChar
      22  GUIPROP_FindChar
      66  GUIPROP_GetCharDistX
       6  GUIPROP_GetFontInfo
      20  GUIPROP_IsInFont
      32  GUI_FontDataBuf

 
  32 bytes in section .bss
 578 bytes in section .text
 
 578 bytes of CODE memory
  32 bytes of DATA memory

Errors: none
Warnings: 22
