###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        16/Jul/2019  17:00:13
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\User\ui\QRENCODE\qrinput.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\User\ui\QRENCODE\qrinput.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\qrinput.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\qrinput.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\User\ui\QRENCODE\qrinput.c
      1          /*
      2           * qrencode - QR Code encoder
      3           *
      4           * Input data chunk class
      5           * Copyright (C) 2006-2011 Kentaro Fukuchi <kentaro@fukuchi.org>
      6           *
      7           * This library is free software; you can redistribute it and/or
      8           * modify it under the terms of the GNU Lesser General Public
      9           * License as published by the Free Software Foundation; either
     10           * version 2.1 of the License, or any later version.
     11           *
     12           * This library is distributed in the hope that it will be useful,
     13           * but WITHOUT ANY WARRANTY; without even the implied warranty of
     14           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
     15           * Lesser General Public License for more details.
     16           *
     17           * You should have received a copy of the GNU Lesser General Public
     18           * License along with this library; if not, write to the Free Software
     19           * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
     20           */
     21          
     22          #if HAVE_CONFIG_H
     23          # include "config.h"
     24          #endif
     25          #include <stdio.h>
     26          #include <stdlib.h>
     27          #include <string.h>
     28          #include <errno.h>
     29          
     30          #include "qrencode.h"
     31          #include "qrspec.h"
     32          #include "mqrspec.h"
     33          #include "bitstream.h"
     34          #include "qrinput.h"
     35          
     36          /******************************************************************************
     37           * Utilities
     38           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     39          int QRinput_isSplittableMode(QRencodeMode mode)
     40          {
     41          	return (mode >= QR_MODE_NUM && mode <= QR_MODE_KANJI);
   \                     QRinput_isSplittableMode: (+1)
   \   00000000   0x2804             CMP      R0,#+4
   \   00000002   0x4180             SBCS     R0,R0,R0
   \   00000004   0x0FC0             LSRS     R0,R0,#+31
   \   00000006   0x4770             BX       LR               ;; return
     42          }
     43          
     44          /******************************************************************************
     45           * Entry of input data
     46           *****************************************************************************/
     47          

   \                                 In section .text, align 2, keep-with-next
     48          static QRinput_List *QRinput_List_newEntry(QRencodeMode mode, int size, const unsigned char *data)
     49          {
   \                     QRinput_List_newEntry: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
     50          	QRinput_List *entry;
     51          
     52          	if(QRinput_check(mode, size, data)) {
   \   00000008   0x.... 0x....      BL       QRinput_check
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD006             BEQ.N    ??QRinput_List_newEntry_0
     53          		errno = EINVAL;
   \   00000010   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000014   0xF04F 0x31FF      MOV      R1,#-1
   \   00000018   0x6001             STR      R1,[R0, #+0]
     54          		return NULL;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xBDF2             POP      {R1,R4-R7,PC}
     55          	}
     56          
     57          	entry = (QRinput_List *)malloc(sizeof(QRinput_List));
   \                     ??QRinput_List_newEntry_0: (+1)
   \   0000001E   0x2014             MOVS     R0,#+20
   \   00000020   0x.... 0x....      BL       malloc
   \   00000024   0x0007             MOVS     R7,R0
     58          	if(entry == NULL) return NULL;
   \   00000026   0xD101             BNE.N    ??QRinput_List_newEntry_1
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xBDF2             POP      {R1,R4-R7,PC}
     59          
     60          	entry->mode = mode;
   \                     ??QRinput_List_newEntry_1: (+1)
   \   0000002C   0x703C             STRB     R4,[R7, #+0]
     61          	entry->size = size;
   \   0000002E   0x607D             STR      R5,[R7, #+4]
     62          	if(size > 0) {
   \   00000030   0x2D01             CMP      R5,#+1
   \   00000032   0xDB0E             BLT.N    ??QRinput_List_newEntry_2
     63          		entry->data = (unsigned char *)malloc(size);
   \   00000034   0x4628             MOV      R0,R5
   \   00000036   0x.... 0x....      BL       malloc
   \   0000003A   0x60B8             STR      R0,[R7, #+8]
     64          		if(entry->data == NULL) {
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD104             BNE.N    ??QRinput_List_newEntry_3
     65          			free(entry);
   \   00000040   0x4638             MOV      R0,R7
   \   00000042   0x.... 0x....      BL       free
     66          			return NULL;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xBDF2             POP      {R1,R4-R7,PC}
     67          		}
     68          		memcpy(entry->data, data, size);
   \                     ??QRinput_List_newEntry_3: (+1)
   \   0000004A   0x462A             MOV      R2,R5
   \   0000004C   0x4631             MOV      R1,R6
   \   0000004E   0x.... 0x....      BL       memcpy
     69          	}
     70          	entry->bstream = NULL;
   \                     ??QRinput_List_newEntry_2: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x60F8             STR      R0,[R7, #+12]
     71          	entry->next = NULL;
   \   00000056   0x6138             STR      R0,[R7, #+16]
     72          
     73          	return entry;
   \   00000058   0x4638             MOV      R0,R7
   \   0000005A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
     74          }
     75          

   \                                 In section .text, align 2, keep-with-next
     76          static void QRinput_List_freeEntry(QRinput_List *entry)
     77          {
   \                     QRinput_List_freeEntry: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     78          	if(entry != NULL) {
   \   00000004   0xD00A             BEQ.N    ??QRinput_List_freeEntry_0
     79          		free(entry->data);
   \   00000006   0x68A0             LDR      R0,[R4, #+8]
   \   00000008   0x.... 0x....      BL       free
     80          		BitStream_free(entry->bstream);
   \   0000000C   0x68E0             LDR      R0,[R4, #+12]
   \   0000000E   0x.... 0x....      BL       BitStream_free
     81          		free(entry);
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0xE8BD 0x4010      POP      {R4,LR}
   \   00000018   0x.... 0x....      B.W      free
     82          	}
     83          }
   \                     ??QRinput_List_freeEntry_0: (+1)
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
     84          

   \                                 In section .text, align 2, keep-with-next
     85          static QRinput_List *QRinput_List_dup(QRinput_List *entry)
     86          {
   \                     QRinput_List_dup: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
     87          	QRinput_List *n;
     88          
     89          	n = (QRinput_List *)malloc(sizeof(QRinput_List));
   \   00000004   0x2014             MOVS     R0,#+20
   \   00000006   0x.... 0x....      BL       malloc
   \   0000000A   0x0005             MOVS     R5,R0
     90          	if(n == NULL) return NULL;
   \   0000000C   0xD101             BNE.N    ??QRinput_List_dup_0
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xBD32             POP      {R1,R4,R5,PC}
     91          
     92          	n->mode = entry->mode;
   \                     ??QRinput_List_dup_0: (+1)
   \   00000012   0x7820             LDRB     R0,[R4, #+0]
   \   00000014   0x7028             STRB     R0,[R5, #+0]
     93          	n->size = entry->size;
   \   00000016   0x6860             LDR      R0,[R4, #+4]
   \   00000018   0x6068             STR      R0,[R5, #+4]
     94          	n->data = (unsigned char *)malloc(n->size);
   \   0000001A   0x.... 0x....      BL       malloc
   \   0000001E   0x60A8             STR      R0,[R5, #+8]
     95          	if(n->data == NULL) {
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD104             BNE.N    ??QRinput_List_dup_1
     96          		free(n);
   \   00000024   0x4628             MOV      R0,R5
   \   00000026   0x.... 0x....      BL       free
     97          		return NULL;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xBD32             POP      {R1,R4,R5,PC}
     98          	}
     99          	memcpy(n->data, entry->data, entry->size);
   \                     ??QRinput_List_dup_1: (+1)
   \   0000002E   0x6862             LDR      R2,[R4, #+4]
   \   00000030   0x68A1             LDR      R1,[R4, #+8]
   \   00000032   0x.... 0x....      BL       memcpy
    100          	n->bstream = NULL;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x60E8             STR      R0,[R5, #+12]
    101          	n->next = NULL;
   \   0000003A   0x6128             STR      R0,[R5, #+16]
    102          
    103          	return n;
   \   0000003C   0x4628             MOV      R0,R5
   \   0000003E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    104          }
    105          
    106          /******************************************************************************
    107           * Input Data
    108           *****************************************************************************/
    109          

   \                                 In section .text, align 2, keep-with-next
    110          QRinput *QRinput_new(void)
    111          {
    112          	return QRinput_new2(0, QR_ECLEVEL_L);
   \                     QRinput_new: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x4608             MOV      R0,R1
   \   00000004                      REQUIRE QRinput_new2
   \   00000004                      ;; // Fall through to label QRinput_new2
    113          }
    114          

   \                                 In section .text, align 2, keep-with-next
    115          QRinput *QRinput_new2(int version, QRecLevel level)
    116          {
   \                     QRinput_new2: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    117          	QRinput *input;
    118          
    119          	if(version < 0 || version > QRSPEC_VERSION_MAX || level > QR_ECLEVEL_H) {
   \   00000006   0x2C29             CMP      R4,#+41
   \   00000008   0xD201             BCS.N    ??QRinput_new2_0
   \   0000000A   0x2D04             CMP      R5,#+4
   \   0000000C   0xDB06             BLT.N    ??QRinput_new2_1
    120          		errno = EINVAL;
   \                     ??QRinput_new2_0: (+1)
   \   0000000E   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000012   0xF04F 0x31FF      MOV      R1,#-1
   \   00000016   0x6001             STR      R1,[R0, #+0]
    121          		return NULL;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xBD32             POP      {R1,R4,R5,PC}
    122          	}
    123          	//分配内存空间
    124          	input = (QRinput *)malloc(sizeof(QRinput));
   \                     ??QRinput_new2_1: (+1)
   \   0000001C   0x201C             MOVS     R0,#+28
   \   0000001E   0x.... 0x....      BL       malloc
    125          	if(input == NULL) return NULL;
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD101             BNE.N    ??QRinput_new2_2
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xBD32             POP      {R1,R4,R5,PC}
    126          
    127          	input->head = NULL;
   \                     ??QRinput_new2_2: (+1)
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0x6081             STR      R1,[R0, #+8]
    128          	input->tail = NULL;
   \   0000002E   0x60C1             STR      R1,[R0, #+12]
    129          	input->version = version;
   \   00000030   0x6004             STR      R4,[R0, #+0]
    130          	input->level = level;
   \   00000032   0x7105             STRB     R5,[R0, #+4]
    131          	input->mqr = 0;
   \   00000034   0x6101             STR      R1,[R0, #+16]
    132          	input->fnc1 = 0;
   \   00000036   0x6141             STR      R1,[R0, #+20]
    133          
    134          	return input;
   \   00000038   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    135          }
    136          //version：版本
    137          //level：纠错级别

   \                                 In section .text, align 2, keep-with-next
    138          QRinput *QRinput_newMQR(int version, QRecLevel level)
    139          {
   \                     QRinput_newMQR: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    140          	QRinput *input;
    141          
    142          	if(version <= 0 || version > MQRSPEC_VERSION_MAX) goto INVALID;
   \   00000006   0x1E60             SUBS     R0,R4,#+1
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD20F             BCS.N    ??QRinput_newMQR_0
    143          	if((MQRspec_getECCLength(version, level) == 0)) goto INVALID;
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       MQRspec_getECCLength
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD00A             BEQ.N    ??QRinput_newMQR_0
    144          
    145          	input = QRinput_new2(version, level);
   \   00000016   0x4629             MOV      R1,R5
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       QRinput_new2
    146          	if(input == NULL) return NULL;
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD101             BNE.N    ??QRinput_newMQR_1
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}
    147          
    148          	input->mqr = 1;
   \                     ??QRinput_newMQR_1: (+1)
   \   00000026   0x2101             MOVS     R1,#+1
   \   00000028   0x6101             STR      R1,[R0, #+16]
    149          
    150          	return input;
   \   0000002A   0xBD32             POP      {R1,R4,R5,PC}
    151          
    152          INVALID:
    153          	errno = EINVAL;
   \                     ??QRinput_newMQR_0: (+1)
   \   0000002C   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000030   0xF04F 0x31FF      MOV      R1,#-1
   \   00000034   0x6001             STR      R1,[R0, #+0]
    154          	return NULL;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    155          }
    156          

   \                                 In section .text, align 2, keep-with-next
    157          int QRinput_getVersion(QRinput *input)
    158          {
    159          	return input->version;
   \                     QRinput_getVersion: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x4770             BX       LR               ;; return
    160          }
    161          

   \                                 In section .text, align 2, keep-with-next
    162          int QRinput_setVersion(QRinput *input, int version)
    163          {
   \                     QRinput_setVersion: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    164          	if(input->mqr || version < 0 || version > QRSPEC_VERSION_MAX) {
   \   00000002   0x6902             LDR      R2,[R0, #+16]
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD101             BNE.N    ??QRinput_setVersion_0
   \   00000008   0x2929             CMP      R1,#+41
   \   0000000A   0xD306             BCC.N    ??QRinput_setVersion_1
    165          		errno = EINVAL;
   \                     ??QRinput_setVersion_0: (+1)
   \   0000000C   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000010   0xF04F 0x31FF      MOV      R1,#-1
   \   00000014   0x6001             STR      R1,[R0, #+0]
    166          		return -1;
   \   00000016   0x4608             MOV      R0,R1
   \   00000018   0xBD02             POP      {R1,PC}
    167          	}
    168          
    169          	input->version = version;
   \                     ??QRinput_setVersion_1: (+1)
   \   0000001A   0x6001             STR      R1,[R0, #+0]
    170          
    171          	return 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xBD02             POP      {R1,PC}          ;; return
    172          }
    173          

   \                                 In section .text, align 2, keep-with-next
    174          QRecLevel QRinput_getErrorCorrectionLevel(QRinput *input)
    175          {
    176          	return input->level;
   \                     QRinput_getErrorCorrectionLevel: (+1)
   \   00000000   0xF990 0x0004      LDRSB    R0,[R0, #+4]
   \   00000004   0x4770             BX       LR               ;; return
    177          }
    178          

   \                                 In section .text, align 2, keep-with-next
    179          int QRinput_setErrorCorrectionLevel(QRinput *input, QRecLevel level)
    180          {
   \                     QRinput_setErrorCorrectionLevel: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    181          	if(input->mqr || level > QR_ECLEVEL_H) {
   \   00000002   0x6902             LDR      R2,[R0, #+16]
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD101             BNE.N    ??QRinput_setErrorCorrectionLevel_0
   \   00000008   0x2904             CMP      R1,#+4
   \   0000000A   0xDB06             BLT.N    ??QRinput_setErrorCorrectionLevel_1
    182          		errno = EINVAL;
   \                     ??QRinput_setErrorCorrectionLevel_0: (+1)
   \   0000000C   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000010   0xF04F 0x31FF      MOV      R1,#-1
   \   00000014   0x6001             STR      R1,[R0, #+0]
    183          		return -1;
   \   00000016   0x4608             MOV      R0,R1
   \   00000018   0xBD02             POP      {R1,PC}
    184          	}
    185          
    186          	input->level = level;
   \                     ??QRinput_setErrorCorrectionLevel_1: (+1)
   \   0000001A   0x7101             STRB     R1,[R0, #+4]
    187          
    188          	return 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xBD02             POP      {R1,PC}          ;; return
    189          }
    190          

   \                                 In section .text, align 2, keep-with-next
    191          int QRinput_setVersionAndErrorCorrectionLevel(QRinput *input, int version, QRecLevel level)
    192          {
   \                     QRinput_setVersionAndErrorCorrectionLevel: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    193          	if(input->mqr) {
   \   00000008   0x6920             LDR      R0,[R4, #+16]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD00F             BEQ.N    ??QRinput_setVersionAndErrorCorrectionLevel_0
    194          		if(version <= 0 || version > MQRSPEC_VERSION_MAX) goto INVALID;
   \   0000000E   0x1E68             SUBS     R0,R5,#+1
   \   00000010   0x2804             CMP      R0,#+4
   \   00000012   0xD205             BCS.N    ??QRinput_setVersionAndErrorCorrectionLevel_1
    195          		if((MQRspec_getECCLength(version, level) == 0)) goto INVALID;
   \   00000014   0x4631             MOV      R1,R6
   \   00000016   0x4628             MOV      R0,R5
   \   00000018   0x.... 0x....      BL       MQRspec_getECCLength
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD10A             BNE.N    ??QRinput_setVersionAndErrorCorrectionLevel_2
    196          	} else {
    197          		if(version < 0 || version > QRSPEC_VERSION_MAX) goto INVALID;
    198          		if(level > QR_ECLEVEL_H) goto INVALID;
    199          	}
    200          
    201          	input->version = version;
    202          	input->level = level;
    203          
    204          	return 0;
    205          
    206          INVALID:
    207          	errno = EINVAL;
   \                     ??QRinput_setVersionAndErrorCorrectionLevel_1: (+1)
   \   00000020   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000024   0xF04F 0x31FF      MOV      R1,#-1
   \   00000028   0x6001             STR      R1,[R0, #+0]
    208          	return -1;
   \   0000002A   0x4608             MOV      R0,R1
   \   0000002C   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??QRinput_setVersionAndErrorCorrectionLevel_0: (+1)
   \   0000002E   0x2D29             CMP      R5,#+41
   \   00000030   0xD2F6             BCS.N    ??QRinput_setVersionAndErrorCorrectionLevel_1
   \   00000032   0x2E04             CMP      R6,#+4
   \   00000034   0xDAF4             BGE.N    ??QRinput_setVersionAndErrorCorrectionLevel_1
   \                     ??QRinput_setVersionAndErrorCorrectionLevel_2: (+1)
   \   00000036   0x6025             STR      R5,[R4, #+0]
   \   00000038   0x7126             STRB     R6,[R4, #+4]
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xBD70             POP      {R4-R6,PC}
    209          }
    210          

   \                                 In section .text, align 2, keep-with-next
    211          static void QRinput_appendEntry(QRinput *input, QRinput_List *entry)
    212          {
    213          	if(input->tail == NULL) {
   \                     QRinput_appendEntry: (+1)
   \   00000000   0x68C2             LDR      R2,[R0, #+12]
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD102             BNE.N    ??QRinput_appendEntry_0
    214          		input->head = entry;
   \   00000006   0x6081             STR      R1,[R0, #+8]
    215          		input->tail = entry;
   \   00000008   0x60C1             STR      R1,[R0, #+12]
   \   0000000A   0xE001             B.N      ??QRinput_appendEntry_1
    216          	} else {
    217          		input->tail->next = entry;
   \                     ??QRinput_appendEntry_0: (+1)
   \   0000000C   0x6111             STR      R1,[R2, #+16]
    218          		input->tail = entry;
   \   0000000E   0x60C1             STR      R1,[R0, #+12]
    219          	}
    220          	entry->next = NULL;
   \                     ??QRinput_appendEntry_1: (+1)
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x6108             STR      R0,[R1, #+16]
    221          }
   \   00000014   0x4770             BX       LR               ;; return
    222          

   \                                 In section .text, align 2, keep-with-next
    223          int QRinput_append(QRinput *input, QRencodeMode mode, int size, const unsigned char *data)
    224          {
   \                     QRinput_append: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4608             MOV      R0,R1
   \   00000006   0x4611             MOV      R1,R2
   \   00000008   0x461A             MOV      R2,R3
    225          	QRinput_List *entry;
    226          
    227          	entry = QRinput_List_newEntry(mode, size, data);
   \   0000000A   0x.... 0x....      BL       QRinput_List_newEntry
   \   0000000E   0x0001             MOVS     R1,R0
    228          	if(entry == NULL) {
   \   00000010   0xD102             BNE.N    ??QRinput_append_0
    229          		return -1;
   \   00000012   0xF04F 0x30FF      MOV      R0,#-1
   \   00000016   0xBD10             POP      {R4,PC}
    230          	}
    231          
    232          	QRinput_appendEntry(input, entry);
   \                     ??QRinput_append_0: (+1)
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       QRinput_appendEntry
    233          
    234          	return 0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
    235          }
    236          
    237          /**
    238           * Insert a structured-append header to the head of the input data.
    239           * @param input input data.
    240           * @param size number of structured symbols.
    241           * @param number index number of the symbol. (1 <= number <= size)
    242           * @param parity parity among input data. (NOTE: each symbol of a set of structured symbols has the same parity data)
    243           * @retval 0 success.
    244           * @retval -1 error occurred and errno is set to indeicate the error. See Execptions for the details.
    245           * @throw EINVAL invalid parameter.
    246           * @throw ENOMEM unable to allocate memory.
    247           */

   \                                 In section .text, align 2, keep-with-next
    248          static int QRinput_insertStructuredAppendHeader(QRinput *input, int size, int number, unsigned char parity)
    249          {
   \                     QRinput_insertStructuredAppendHeader: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
    250          	QRinput_List *entry;
    251          	unsigned char buf[3];
    252          
    253          	if(size > MAX_STRUCTURED_SYMBOLS) {
   \   00000006   0x2911             CMP      R1,#+17
   \   00000008   0xDB06             BLT.N    ??QRinput_insertStructuredAppendHeader_0
    254          		errno = EINVAL;
   \   0000000A   0x.... 0x....      BL       __aeabi_errno_addr
   \   0000000E   0xF04F 0x31FF      MOV      R1,#-1
   \   00000012   0x6001             STR      R1,[R0, #+0]
    255          		return -1;
   \   00000014   0x4608             MOV      R0,R1
   \   00000016   0xBD16             POP      {R1,R2,R4,PC}
    256          	}
    257          	if(number <= 0 || number > size) {
   \                     ??QRinput_insertStructuredAppendHeader_0: (+1)
   \   00000018   0x2A01             CMP      R2,#+1
   \   0000001A   0xDB01             BLT.N    ??QRinput_insertStructuredAppendHeader_1
   \   0000001C   0x4291             CMP      R1,R2
   \   0000001E   0xDA06             BGE.N    ??QRinput_insertStructuredAppendHeader_2
    258          		errno = EINVAL;
   \                     ??QRinput_insertStructuredAppendHeader_1: (+1)
   \   00000020   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000024   0xF04F 0x31FF      MOV      R1,#-1
   \   00000028   0x6001             STR      R1,[R0, #+0]
    259          		return -1;
   \   0000002A   0x4608             MOV      R0,R1
   \   0000002C   0xBD16             POP      {R1,R2,R4,PC}
    260          	}
    261          
    262          	buf[0] = (unsigned char)size;
   \                     ??QRinput_insertStructuredAppendHeader_2: (+1)
   \   0000002E   0xF88D 0x1000      STRB     R1,[SP, #+0]
    263          	buf[1] = (unsigned char)number;
   \   00000032   0xF88D 0x2001      STRB     R2,[SP, #+1]
    264          	buf[2] = parity;
   \   00000036   0xF88D 0x3002      STRB     R3,[SP, #+2]
    265          	entry = QRinput_List_newEntry(QR_MODE_STRUCTURE, 3, buf);
   \   0000003A   0xAA00             ADD      R2,SP,#+0
   \   0000003C   0x2103             MOVS     R1,#+3
   \   0000003E   0x2004             MOVS     R0,#+4
   \   00000040   0x.... 0x....      BL       QRinput_List_newEntry
    266          	if(entry == NULL) {
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD102             BNE.N    ??QRinput_insertStructuredAppendHeader_3
    267          		return -1;
   \   00000048   0xF04F 0x30FF      MOV      R0,#-1
   \   0000004C   0xBD16             POP      {R1,R2,R4,PC}
    268          	}
    269          
    270          	entry->next = input->head;
   \                     ??QRinput_insertStructuredAppendHeader_3: (+1)
   \   0000004E   0x68A1             LDR      R1,[R4, #+8]
   \   00000050   0x6101             STR      R1,[R0, #+16]
    271          	input->head = entry;
   \   00000052   0x60A0             STR      R0,[R4, #+8]
    272          
    273          	return 0;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    274          }
    275          

   \                                 In section .text, align 2, keep-with-next
    276          int QRinput_appendECIheader(QRinput *input, unsigned int ecinum)
    277          {
   \                     QRinput_appendECIheader: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    278          	unsigned char data[4];
    279          
    280          	if(ecinum > 999999) {
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable3  ;; 0xf4240
   \   00000006   0x4291             CMP      R1,R2
   \   00000008   0xD306             BCC.N    ??QRinput_appendECIheader_0
    281          		errno = EINVAL;
   \   0000000A   0x.... 0x....      BL       __aeabi_errno_addr
   \   0000000E   0xF04F 0x31FF      MOV      R1,#-1
   \   00000012   0x6001             STR      R1,[R0, #+0]
    282          		return -1;
   \   00000014   0x4608             MOV      R0,R1
   \   00000016   0xBD02             POP      {R1,PC}
    283          	}
    284          
    285          	/* We manually create byte array of ecinum because
    286          	 (unsigned char *)&ecinum may cause bus error on some architectures, */
    287          	data[0] = ecinum & 0xff;
   \                     ??QRinput_appendECIheader_0: (+1)
   \   00000018   0x460A             MOV      R2,R1
   \   0000001A   0xF88D 0x2000      STRB     R2,[SP, #+0]
    288          	data[1] = (ecinum >>  8) & 0xff;
   \   0000001E   0x0A0A             LSRS     R2,R1,#+8
   \   00000020   0xF88D 0x2001      STRB     R2,[SP, #+1]
    289          	data[2] = (ecinum >> 16) & 0xff;
   \   00000024   0x0C0A             LSRS     R2,R1,#+16
   \   00000026   0xF88D 0x2002      STRB     R2,[SP, #+2]
    290          	data[3] = (ecinum >> 24) & 0xff;
   \   0000002A   0x0E09             LSRS     R1,R1,#+24
   \   0000002C   0xF88D 0x1003      STRB     R1,[SP, #+3]
    291          	return QRinput_append(input, QR_MODE_ECI, 4, data);
   \   00000030   0xAB00             ADD      R3,SP,#+0
   \   00000032   0x2204             MOVS     R2,#+4
   \   00000034   0x2105             MOVS     R1,#+5
   \   00000036   0x.... 0x....      BL       QRinput_append
   \   0000003A   0xBD02             POP      {R1,PC}          ;; return
    292          }
    293          

   \                                 In section .text, align 2, keep-with-next
    294          void QRinput_free(QRinput *input)
    295          {
   \                     QRinput_free: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    296          	QRinput_List *list, *next;
    297          
    298          	if(input != NULL) {
   \   00000004   0xD00C             BEQ.N    ??QRinput_free_0
    299          		list = input->head;
   \   00000006   0x68A0             LDR      R0,[R4, #+8]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xE003             B.N      ??QRinput_free_1
    300          		while(list != NULL) {
    301          			next = list->next;
   \                     ??QRinput_free_2: (+1)
   \   0000000C   0x6905             LDR      R5,[R0, #+16]
    302          			QRinput_List_freeEntry(list);
   \   0000000E   0x.... 0x....      BL       QRinput_List_freeEntry
    303          			list = next;
   \   00000012   0x0028             MOVS     R0,R5
    304          		}
   \                     ??QRinput_free_1: (+1)
   \   00000014   0xD1FA             BNE.N    ??QRinput_free_2
    305          		free(input);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000001C   0x.... 0x....      B.W      free
    306          	}
    307          }
   \                     ??QRinput_free_0: (+1)
   \   00000020   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    308          

   \                                 In section .text, align 2, keep-with-next
    309          static unsigned char QRinput_calcParity(QRinput *input)
    310          {
    311          	unsigned char parity = 0;
   \                     QRinput_calcParity: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    312          	QRinput_List *list;
    313          	int i;
    314          
    315          	list = input->head;
   \   00000002   0x6880             LDR      R0,[R0, #+8]
   \   00000004   0xE006             B.N      ??QRinput_calcParity_0
    316          	while(list != NULL) {
    317          		if(list->mode != QR_MODE_STRUCTURE) {
    318          			for(i=list->size-1; i>=0; i--) {
    319          				parity ^= list->data[i];
   \                     ??QRinput_calcParity_1: (+1)
   \   00000006   0x6883             LDR      R3,[R0, #+8]
   \   00000008   0x5CD3             LDRB     R3,[R2, R3]
   \   0000000A   0x4059             EORS     R1,R3,R1
    320          			}
   \   0000000C   0x1E52             SUBS     R2,R2,#+1
   \                     ??QRinput_calcParity_2: (+1)
   \   0000000E   0x2A00             CMP      R2,#+0
   \   00000010   0xD5F9             BPL.N    ??QRinput_calcParity_1
    321          		}
    322          		list = list->next;
   \                     ??QRinput_calcParity_3: (+1)
   \   00000012   0x6900             LDR      R0,[R0, #+16]
   \                     ??QRinput_calcParity_0: (+1)
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD006             BEQ.N    ??QRinput_calcParity_4
   \   00000018   0xF990 0x2000      LDRSB    R2,[R0, #+0]
   \   0000001C   0x2A04             CMP      R2,#+4
   \   0000001E   0xD0F8             BEQ.N    ??QRinput_calcParity_3
   \   00000020   0x6842             LDR      R2,[R0, #+4]
   \   00000022   0x1E52             SUBS     R2,R2,#+1
   \   00000024   0xE7F3             B.N      ??QRinput_calcParity_2
    323          	}
    324          
    325          	return parity;
   \                     ??QRinput_calcParity_4: (+1)
   \   00000026   0x4608             MOV      R0,R1
   \   00000028   0xB2C0             UXTB     R0,R0
   \   0000002A   0x4770             BX       LR               ;; return
    326          }
    327          

   \                                 In section .text, align 2, keep-with-next
    328          QRinput *QRinput_dup(QRinput *input)
    329          {
   \                     QRinput_dup: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    330          	QRinput *n;
    331          	QRinput_List *list, *e;
    332          
    333          	if(input->mqr) {
   \   00000004   0xF994 0x1004      LDRSB    R1,[R4, #+4]
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x6922             LDR      R2,[R4, #+16]
   \   0000000C   0x2A00             CMP      R2,#+0
   \   0000000E   0xD003             BEQ.N    ??QRinput_dup_0
    334          		n = QRinput_newMQR(input->version, input->level);
   \   00000010   0x.... 0x....      BL       QRinput_newMQR
   \   00000014   0x4605             MOV      R5,R0
   \   00000016   0xE002             B.N      ??QRinput_dup_1
    335          	} else {
    336          		n = QRinput_new2(input->version, input->level);
   \                     ??QRinput_dup_0: (+1)
   \   00000018   0x.... 0x....      BL       QRinput_new2
   \   0000001C   0x4605             MOV      R5,R0
    337          	}
    338          	if(n == NULL) return NULL;
   \                     ??QRinput_dup_1: (+1)
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD101             BNE.N    ??QRinput_dup_2
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}
    339          
    340          	list = input->head;
   \                     ??QRinput_dup_2: (+1)
   \   00000026   0x68A4             LDR      R4,[R4, #+8]
   \   00000028   0xE004             B.N      ??QRinput_dup_3
    341          	while(list != NULL) {
    342          		e = QRinput_List_dup(list);
    343          		if(e == NULL) {
    344          			QRinput_free(n);
    345          			return NULL;
    346          		}
    347          		QRinput_appendEntry(n, e);
   \                     ??QRinput_dup_4: (+1)
   \   0000002A   0x4601             MOV      R1,R0
   \   0000002C   0x4628             MOV      R0,R5
   \   0000002E   0x.... 0x....      BL       QRinput_appendEntry
    348          		list = list->next;
   \   00000032   0x6924             LDR      R4,[R4, #+16]
   \                     ??QRinput_dup_3: (+1)
   \   00000034   0x2C00             CMP      R4,#+0
   \   00000036   0xD009             BEQ.N    ??QRinput_dup_5
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0x.... 0x....      BL       QRinput_List_dup
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD1F3             BNE.N    ??QRinput_dup_4
   \   00000042   0x4628             MOV      R0,R5
   \   00000044   0x.... 0x....      BL       QRinput_free
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xBD32             POP      {R1,R4,R5,PC}
    349          	}
    350          
    351          	return n;
   \                     ??QRinput_dup_5: (+1)
   \   0000004C   0x4628             MOV      R0,R5
   \   0000004E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    352          }
    353          
    354          /******************************************************************************
    355           * Numeric data
    356           *****************************************************************************/
    357          
    358          /**
    359           * Check the input data.
    360           * @param size
    361           * @param data
    362           * @return result
    363           */

   \                                 In section .text, align 2, keep-with-next
    364          static int QRinput_checkModeNum(int size, const char *data)
    365          {
    366          	int i;
    367          
    368          	for(i=0; i<size; i++) {
   \                     QRinput_checkModeNum: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0xE000             B.N      ??QRinput_checkModeNum_0
   \                     ??QRinput_checkModeNum_1: (+1)
   \   00000004   0x1C52             ADDS     R2,R2,#+1
   \                     ??QRinput_checkModeNum_0: (+1)
   \   00000006   0x4282             CMP      R2,R0
   \   00000008   0xDA06             BGE.N    ??QRinput_checkModeNum_2
    369          		if(data[i] < '0' || data[i] > '9')
   \   0000000A   0x5653             LDRSB    R3,[R2, R1]
   \   0000000C   0x3B30             SUBS     R3,R3,#+48
   \   0000000E   0x2B0A             CMP      R3,#+10
   \   00000010   0xD3F8             BCC.N    ??QRinput_checkModeNum_1
    370          			return -1;
   \   00000012   0xF04F 0x30FF      MOV      R0,#-1
   \   00000016   0x4770             BX       LR
    371          	}
    372          
    373          	return 0;
   \                     ??QRinput_checkModeNum_2: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x4770             BX       LR               ;; return
    374          }
    375          
    376          /**
    377           * Estimates the length of the encoded bit stream of numeric data.
    378           * @param size
    379           * @return number of bits
    380           */

   \                                 In section .text, align 2, keep-with-next
    381          int QRinput_estimateBitsModeNum(int size)
    382          {
    383          	int w;
    384          	int bits;
    385          
    386          	w = size / 3;
   \                     QRinput_estimateBitsModeNum: (+1)
   \   00000000   0x2103             MOVS     R1,#+3
   \   00000002   0xFB90 0xF2F1      SDIV     R2,R0,R1
    387          	bits = w * 10;
   \   00000006   0xEB02 0x0182      ADD      R1,R2,R2, LSL #+2
   \   0000000A   0x0049             LSLS     R1,R1,#+1
    388          	switch(size - w * 3) {
   \   0000000C   0xEB02 0x0242      ADD      R2,R2,R2, LSL #+1
   \   00000010   0x1A80             SUBS     R0,R0,R2
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD002             BEQ.N    ??QRinput_estimateBitsModeNum_0
   \   00000016   0x2802             CMP      R0,#+2
   \   00000018   0xD002             BEQ.N    ??QRinput_estimateBitsModeNum_1
   \   0000001A   0xE002             B.N      ??QRinput_estimateBitsModeNum_2
    389          		case 1:
    390          			bits += 4;
   \                     ??QRinput_estimateBitsModeNum_0: (+1)
   \   0000001C   0x1D09             ADDS     R1,R1,#+4
    391          			break;
   \   0000001E   0xE000             B.N      ??QRinput_estimateBitsModeNum_2
    392          		case 2:
    393          			bits += 7;
   \                     ??QRinput_estimateBitsModeNum_1: (+1)
   \   00000020   0x1DC9             ADDS     R1,R1,#+7
    394          			break;
    395          		default:
    396          			break;
    397          	}
    398          
    399          	return bits;
   \                     ??QRinput_estimateBitsModeNum_2: (+1)
   \   00000022   0x4608             MOV      R0,R1
   \   00000024   0x4770             BX       LR               ;; return
    400          }
    401          
    402          /**
    403           * Convert the number data to a bit stream.
    404           * @param entry
    405           * @param mqr
    406           * @retval 0 success
    407           * @retval -1 an error occurred and errno is set to indeicate the error.
    408           *            See Execptions for the details.
    409           * @throw ENOMEM unable to allocate memory.
    410           */

   \                                 In section .text, align 2, keep-with-next
    411          static int QRinput_encodeModeNum(QRinput_List *entry, int version, int mqr)
    412          {
   \                     QRinput_encodeModeNum: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    413          	int words, i, ret;
    414          	unsigned int val;
    415          
    416          	entry->bstream = BitStream_new();
   \   00000008   0x.... 0x....      BL       BitStream_new
   \   0000000C   0x60E0             STR      R0,[R4, #+12]
    417          	if(entry->bstream == NULL) return -1;
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD102             BNE.N    ??QRinput_encodeModeNum_0
   \   00000012   0xF04F 0x30FF      MOV      R0,#-1
   \   00000016   0xBDF2             POP      {R1,R4-R7,PC}
    418          
    419          	if(mqr) {
   \                     ??QRinput_encodeModeNum_0: (+1)
   \   00000018   0x2E00             CMP      R6,#+0
   \   0000001A   0xD01A             BEQ.N    ??QRinput_encodeModeNum_1
    420          		if(version > 1) {
   \   0000001C   0x2D02             CMP      R5,#+2
   \   0000001E   0xDB05             BLT.N    ??QRinput_encodeModeNum_2
    421          			ret = BitStream_appendNum(entry->bstream, version - 1, MQRSPEC_MODEID_NUM);
    422          			if(ret < 0) goto ABORT;
   \   00000020   0x2200             MOVS     R2,#+0
   \   00000022   0x1E69             SUBS     R1,R5,#+1
   \   00000024   0x.... 0x....      BL       BitStream_appendNum
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD40A             BMI.N    ??QRinput_encodeModeNum_3
    423          		}
    424          		ret = BitStream_appendNum(entry->bstream, MQRspec_lengthIndicator(QR_MODE_NUM, version), entry->size);
   \                     ??QRinput_encodeModeNum_2: (+1)
   \   0000002C   0x4629             MOV      R1,R5
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x.... 0x....      BL       MQRspec_lengthIndicator
   \   00000034   0x4601             MOV      R1,R0
   \   00000036   0x6862             LDR      R2,[R4, #+4]
   \   00000038   0x68E0             LDR      R0,[R4, #+12]
   \   0000003A   0x.... 0x....      BL       BitStream_appendNum
   \   0000003E   0x0005             MOVS     R5,R0
    425          		if(ret < 0) goto ABORT;
   \   00000040   0xD518             BPL.N    ??QRinput_encodeModeNum_4
    426          	} else {
    427          		ret = BitStream_appendNum(entry->bstream, 4, QRSPEC_MODEID_NUM);
    428          		if(ret < 0) goto ABORT;
    429          	
    430          		ret = BitStream_appendNum(entry->bstream, QRspec_lengthIndicator(QR_MODE_NUM, version), entry->size);
    431          		if(ret < 0) goto ABORT;
    432          	}
    433          
    434          	words = entry->size / 3;
    435          	for(i=0; i<words; i++) {
    436          		val  = (entry->data[i*3  ] - '0') * 100;
    437          		val += (entry->data[i*3+1] - '0') * 10;
    438          		val += (entry->data[i*3+2] - '0');
    439          
    440          		ret = BitStream_appendNum(entry->bstream, 10, val);
    441          		if(ret < 0) goto ABORT;
    442          	}
    443          
    444          	if(entry->size - words * 3 == 1) {
    445          		val = entry->data[words*3] - '0';
    446          		ret = BitStream_appendNum(entry->bstream, 4, val);
    447          		if(ret < 0) goto ABORT;
    448          	} else if(entry->size - words * 3 == 2) {
    449          		val  = (entry->data[words*3  ] - '0') * 10;
    450          		val += (entry->data[words*3+1] - '0');
    451          		BitStream_appendNum(entry->bstream, 7, val);
    452          		if(ret < 0) goto ABORT;
    453          	}
    454          
    455          	return 0;
    456          ABORT:
    457          	BitStream_free(entry->bstream);
   \                     ??QRinput_encodeModeNum_3: (+1)
   \   00000042   0x68E0             LDR      R0,[R4, #+12]
   \   00000044   0x.... 0x....      BL       BitStream_free
    458          	entry->bstream = NULL;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x60E0             STR      R0,[R4, #+12]
    459          	return -1;
   \   0000004C   0xF04F 0x30FF      MOV      R0,#-1
   \   00000050   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   \                     ??QRinput_encodeModeNum_1: (+1)
   \   00000052   0x2201             MOVS     R2,#+1
   \   00000054   0x2104             MOVS     R1,#+4
   \   00000056   0x.... 0x....      BL       BitStream_appendNum
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD4F1             BMI.N    ??QRinput_encodeModeNum_3
   \   0000005E   0x4629             MOV      R1,R5
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x.... 0x....      BL       QRspec_lengthIndicator
   \   00000066   0x6862             LDR      R2,[R4, #+4]
   \   00000068   0x4601             MOV      R1,R0
   \   0000006A   0x68E0             LDR      R0,[R4, #+12]
   \   0000006C   0x.... 0x....      BL       BitStream_appendNum
   \   00000070   0x0005             MOVS     R5,R0
   \   00000072   0xD4E6             BMI.N    ??QRinput_encodeModeNum_3
   \                     ??QRinput_encodeModeNum_4: (+1)
   \   00000074   0x6860             LDR      R0,[R4, #+4]
   \   00000076   0x2103             MOVS     R1,#+3
   \   00000078   0xFB90 0xF6F1      SDIV     R6,R0,R1
   \   0000007C   0x2700             MOVS     R7,#+0
   \   0000007E   0xE017             B.N      ??QRinput_encodeModeNum_5
   \                     ??QRinput_encodeModeNum_6: (+1)
   \   00000080   0x68A0             LDR      R0,[R4, #+8]
   \   00000082   0xEB07 0x0147      ADD      R1,R7,R7, LSL #+1
   \   00000086   0x180A             ADDS     R2,R1,R0
   \   00000088   0x5C08             LDRB     R0,[R1, R0]
   \   0000008A   0x3830             SUBS     R0,R0,#+48
   \   0000008C   0x2164             MOVS     R1,#+100
   \   0000008E   0x7853             LDRB     R3,[R2, #+1]
   \   00000090   0x3B30             SUBS     R3,R3,#+48
   \   00000092   0xEB03 0x0583      ADD      R5,R3,R3, LSL #+2
   \   00000096   0x006B             LSLS     R3,R5,#+1
   \   00000098   0xFB01 0x3000      MLA      R0,R1,R0,R3
   \   0000009C   0x7891             LDRB     R1,[R2, #+2]
   \   0000009E   0x3930             SUBS     R1,R1,#+48
   \   000000A0   0x180A             ADDS     R2,R1,R0
   \   000000A2   0x210A             MOVS     R1,#+10
   \   000000A4   0x68E0             LDR      R0,[R4, #+12]
   \   000000A6   0x.... 0x....      BL       BitStream_appendNum
   \   000000AA   0x0005             MOVS     R5,R0
   \   000000AC   0xD4C9             BMI.N    ??QRinput_encodeModeNum_3
   \   000000AE   0x1C7F             ADDS     R7,R7,#+1
   \                     ??QRinput_encodeModeNum_5: (+1)
   \   000000B0   0x42B7             CMP      R7,R6
   \   000000B2   0xDBE5             BLT.N    ??QRinput_encodeModeNum_6
   \   000000B4   0xEB06 0x0146      ADD      R1,R6,R6, LSL #+1
   \   000000B8   0x6860             LDR      R0,[R4, #+4]
   \   000000BA   0x1A40             SUBS     R0,R0,R1
   \   000000BC   0x2801             CMP      R0,#+1
   \   000000BE   0xD10A             BNE.N    ??QRinput_encodeModeNum_7
   \   000000C0   0x68A0             LDR      R0,[R4, #+8]
   \   000000C2   0x5C08             LDRB     R0,[R1, R0]
   \   000000C4   0xF1A0 0x0230      SUB      R2,R0,#+48
   \   000000C8   0x2104             MOVS     R1,#+4
   \   000000CA   0x68E0             LDR      R0,[R4, #+12]
   \   000000CC   0x.... 0x....      BL       BitStream_appendNum
   \   000000D0   0x2800             CMP      R0,#+0
   \   000000D2   0xD512             BPL.N    ??QRinput_encodeModeNum_8
   \   000000D4   0xE7B5             B.N      ??QRinput_encodeModeNum_3
   \                     ??QRinput_encodeModeNum_7: (+1)
   \   000000D6   0x2802             CMP      R0,#+2
   \   000000D8   0xD10F             BNE.N    ??QRinput_encodeModeNum_8
   \   000000DA   0x68A0             LDR      R0,[R4, #+8]
   \   000000DC   0x5C0A             LDRB     R2,[R1, R0]
   \   000000DE   0x3A30             SUBS     R2,R2,#+48
   \   000000E0   0xEB02 0x0382      ADD      R3,R2,R2, LSL #+2
   \   000000E4   0x1808             ADDS     R0,R1,R0
   \   000000E6   0x7840             LDRB     R0,[R0, #+1]
   \   000000E8   0x3830             SUBS     R0,R0,#+48
   \   000000EA   0xEB00 0x0243      ADD      R2,R0,R3, LSL #+1
   \   000000EE   0x2107             MOVS     R1,#+7
   \   000000F0   0x68E0             LDR      R0,[R4, #+12]
   \   000000F2   0x.... 0x....      BL       BitStream_appendNum
   \   000000F6   0x2D00             CMP      R5,#+0
   \   000000F8   0xD4A3             BMI.N    ??QRinput_encodeModeNum_3
   \                     ??QRinput_encodeModeNum_8: (+1)
   \   000000FA   0x2000             MOVS     R0,#+0
   \   000000FC   0xBDF2             POP      {R1,R4-R7,PC}
    460          }
    461          
    462          /******************************************************************************
    463           * Alphabet-numeric data
    464           *****************************************************************************/
    465          

   \                                 In section .text, align 4, keep-with-next
    466          const signed char QRinput_anTable[128] = {
   \                     QRinput_anTable:
   \   00000000   0xFF 0xFF          DC8 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF         
   \   00000011   0xFF 0xFF          DC8 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 36, -1
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0x24    
   \              0xFF         
   \   00000022   0xFF 0xFF          DC8 -1, -1, 37, 38, -1, -1, -1, -1, 39, 40, -1, 41, 42, 43, 0, 1, 2, 3
   \              0x25 0x26    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0x27 0x28    
   \              0xFF 0x29    
   \              0x2A 0x2B    
   \              0x00 0x01    
   \              0x02 0x03    
   \   00000034   0x04 0x05          DC8 4, 5, 6, 7, 8, 9, 44, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14
   \              0x06 0x07    
   \              0x08 0x09    
   \              0x2C 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0x0A    
   \              0x0B 0x0C    
   \              0x0D 0x0E    
   \   00000046   0x0F 0x10          DC8 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31
   \              0x11 0x12    
   \              0x13 0x14    
   \              0x15 0x16    
   \              0x17 0x18    
   \              0x19 0x1A    
   \              0x1B 0x1C    
   \              0x1D 0x1E    
   \              0x1F         
   \   00000057   0x20 0x21          DC8 32, 33, 34, 35, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
   \              0x22 0x23    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF         
   \   00000068   0xFF 0xFF          DC8 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF         
   \   00000079   0xFF 0xFF          DC8 -1, -1, -1, -1, -1, -1, -1
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF         
    467          	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    468          	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    469          	36, -1, -1, -1, 37, 38, -1, -1, -1, -1, 39, 40, -1, 41, 42, 43,
    470          	 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 44, -1, -1, -1, -1, -1,
    471          	-1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
    472          	25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1,
    473          	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    474          	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    475          };
    476          
    477          /**
    478           * Check the input data.
    479           * @param size
    480           * @param data
    481           * @return result
    482           */

   \                                 In section .text, align 2, keep-with-next
    483          static int QRinput_checkModeAn(int size, const char *data)
    484          {
   \                     QRinput_checkModeAn: (+1)
   \   00000000   0xB410             PUSH     {R4}
    485          	int i;
    486          
    487          	for(i=0; i<size; i++) {
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0xE000             B.N      ??QRinput_checkModeAn_0
   \                     ??QRinput_checkModeAn_1: (+1)
   \   00000006   0x1C52             ADDS     R2,R2,#+1
   \                     ??QRinput_checkModeAn_0: (+1)
   \   00000008   0x4282             CMP      R2,R0
   \   0000000A   0xDA0D             BGE.N    ??QRinput_checkModeAn_2
    488          		if(QRinput_lookAnTable(data[i]) < 0)
   \   0000000C   0x5653             LDRSB    R3,[R2, R1]
   \   0000000E   0x061C             LSLS     R4,R3,#+24
   \   00000010   0xD502             BPL.N    ??QRinput_checkModeAn_3
   \   00000012   0xF04F 0x33FF      MOV      R3,#-1
   \   00000016   0xE002             B.N      ??QRinput_checkModeAn_4
   \                     ??QRinput_checkModeAn_3: (+1)
   \   00000018   0x.... 0x....      ADR.W    R4,QRinput_anTable
   \   0000001C   0x571B             LDRSB    R3,[R3, R4]
   \                     ??QRinput_checkModeAn_4: (+1)
   \   0000001E   0x2B00             CMP      R3,#+0
   \   00000020   0xD5F1             BPL.N    ??QRinput_checkModeAn_1
    489          			return -1;
   \   00000022   0xF04F 0x30FF      MOV      R0,#-1
   \   00000026   0xE000             B.N      ??QRinput_checkModeAn_5
    490          	}
    491          
    492          	return 0;
   \                     ??QRinput_checkModeAn_2: (+1)
   \   00000028   0x2000             MOVS     R0,#+0
   \                     ??QRinput_checkModeAn_5: (+1)
   \   0000002A   0xBC10             POP      {R4}
   \   0000002C   0x4770             BX       LR               ;; return
    493          }
    494          
    495          /**
    496           * Estimates the length of the encoded bit stream of alphabet-numeric data.
    497           * @param size
    498           * @return number of bits
    499           */

   \                                 In section .text, align 2, keep-with-next
    500          int QRinput_estimateBitsModeAn(int size)
    501          {
    502          	int w;
    503          	int bits;
    504          
    505          	w = size / 2;
    506          	bits = w * 11;
   \                     QRinput_estimateBitsModeAn: (+1)
   \   00000000   0xEB00 0x71D0      ADD      R1,R0,R0, LSR #+31
   \   00000004   0x1049             ASRS     R1,R1,#+1
   \   00000006   0x220B             MOVS     R2,#+11
   \   00000008   0x4351             MULS     R1,R2,R1
    507          	if(size & 1) {
   \   0000000A   0x07C0             LSLS     R0,R0,#+31
   \   0000000C   0xD500             BPL.N    ??QRinput_estimateBitsModeAn_0
    508          		bits += 6;
   \   0000000E   0x1D89             ADDS     R1,R1,#+6
    509          	}
    510          
    511          	return bits;
   \                     ??QRinput_estimateBitsModeAn_0: (+1)
   \   00000010   0x4608             MOV      R0,R1
   \   00000012   0x4770             BX       LR               ;; return
    512          }
    513          
    514          /**
    515           * Convert the alphabet-numeric data to a bit stream.
    516           * @param entry
    517           * @param mqr
    518           * @retval 0 success
    519           * @retval -1 an error occurred and errno is set to indeicate the error.
    520           *            See Execptions for the details.
    521           * @throw ENOMEM unable to allocate memory.
    522           * @throw EINVAL invalid version.
    523           */

   \                                 In section .text, align 2, keep-with-next
    524          static int QRinput_encodeModeAn(QRinput_List *entry, int version, int mqr)
    525          {
   \                     QRinput_encodeModeAn: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    526          	int words, i, ret;
    527          	unsigned int val;
    528          
    529          	entry->bstream = BitStream_new();
   \   00000008   0x.... 0x....      BL       BitStream_new
   \   0000000C   0x60E0             STR      R0,[R4, #+12]
    530          	if(entry->bstream == NULL) return -1;
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD102             BNE.N    ??QRinput_encodeModeAn_0
   \   00000012   0xF04F 0x30FF      MOV      R0,#-1
   \   00000016   0xBD70             POP      {R4-R6,PC}
    531          
    532          	if(mqr) {
   \                     ??QRinput_encodeModeAn_0: (+1)
   \   00000018   0x2E00             CMP      R6,#+0
   \   0000001A   0xD020             BEQ.N    ??QRinput_encodeModeAn_1
    533          		if(version < 2) {
   \   0000001C   0x2D02             CMP      R5,#+2
   \   0000001E   0xDA0C             BGE.N    ??QRinput_encodeModeAn_2
    534          			errno = EINVAL;
   \   00000020   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000024   0xF04F 0x31FF      MOV      R1,#-1
   \   00000028   0x6001             STR      R1,[R0, #+0]
    535          			goto ABORT;
    536          		}
    537          		ret = BitStream_appendNum(entry->bstream, version - 1, MQRSPEC_MODEID_AN);
    538          		if(ret < 0) goto ABORT;
    539          		ret = BitStream_appendNum(entry->bstream, MQRspec_lengthIndicator(QR_MODE_AN, version), entry->size);
    540          		if(ret < 0) goto ABORT;
    541          	} else {
    542          		ret = BitStream_appendNum(entry->bstream, 4, QRSPEC_MODEID_AN);
    543          		if(ret < 0) goto ABORT;
    544          		ret = BitStream_appendNum(entry->bstream, QRspec_lengthIndicator(QR_MODE_AN, version), entry->size);
    545          		if(ret < 0) goto ABORT;
    546          	}
    547          
    548          	words = entry->size / 2;
    549          	for(i=0; i<words; i++) {
    550          		val  = (unsigned int)QRinput_lookAnTable(entry->data[i*2  ]) * 45;
    551          		val += (unsigned int)QRinput_lookAnTable(entry->data[i*2+1]);
    552          
    553          		ret = BitStream_appendNum(entry->bstream, 11, val);
    554          		if(ret < 0) goto ABORT;
    555          	}
    556          
    557          	if(entry->size & 1) {
    558          		val = (unsigned int)QRinput_lookAnTable(entry->data[words * 2]);
    559          
    560          		ret = BitStream_appendNum(entry->bstream, 6, val);
    561          		if(ret < 0) goto ABORT;
    562          	}
    563          
    564          	return 0;
    565          ABORT:
    566          	BitStream_free(entry->bstream);
   \                     ??QRinput_encodeModeAn_3: (+1)
   \   0000002A   0x68E0             LDR      R0,[R4, #+12]
   \   0000002C   0x.... 0x....      BL       BitStream_free
    567          	entry->bstream = NULL;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x60E0             STR      R0,[R4, #+12]
    568          	return -1;
   \   00000034   0xF04F 0x30FF      MOV      R0,#-1
   \   00000038   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??QRinput_encodeModeAn_2: (+1)
   \   0000003A   0x2201             MOVS     R2,#+1
   \   0000003C   0x1E69             SUBS     R1,R5,#+1
   \   0000003E   0x.... 0x....      BL       BitStream_appendNum
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD4F1             BMI.N    ??QRinput_encodeModeAn_3
   \   00000046   0x4629             MOV      R1,R5
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0x.... 0x....      BL       MQRspec_lengthIndicator
   \   0000004E   0x4601             MOV      R1,R0
   \   00000050   0x6862             LDR      R2,[R4, #+4]
   \   00000052   0x68E0             LDR      R0,[R4, #+12]
   \   00000054   0x.... 0x....      BL       BitStream_appendNum
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD511             BPL.N    ??QRinput_encodeModeAn_4
   \   0000005C   0xE7E5             B.N      ??QRinput_encodeModeAn_3
   \                     ??QRinput_encodeModeAn_1: (+1)
   \   0000005E   0x2202             MOVS     R2,#+2
   \   00000060   0x2104             MOVS     R1,#+4
   \   00000062   0x.... 0x....      BL       BitStream_appendNum
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD4DF             BMI.N    ??QRinput_encodeModeAn_3
   \   0000006A   0x4629             MOV      R1,R5
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0x.... 0x....      BL       QRspec_lengthIndicator
   \   00000072   0x6862             LDR      R2,[R4, #+4]
   \   00000074   0x4601             MOV      R1,R0
   \   00000076   0x68E0             LDR      R0,[R4, #+12]
   \   00000078   0x.... 0x....      BL       BitStream_appendNum
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD4D4             BMI.N    ??QRinput_encodeModeAn_3
   \                     ??QRinput_encodeModeAn_4: (+1)
   \   00000080   0x6860             LDR      R0,[R4, #+4]
   \   00000082   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   00000086   0x1045             ASRS     R5,R0,#+1
   \   00000088   0x2600             MOVS     R6,#+0
   \   0000008A   0xE00A             B.N      ??QRinput_encodeModeAn_5
   \                     ??QRinput_encodeModeAn_6: (+1)
   \   0000008C   0x.... 0x....      ADR.W    R2,QRinput_anTable
   \   00000090   0x5680             LDRSB    R0,[R0, R2]
   \                     ??QRinput_encodeModeAn_7: (+1)
   \   00000092   0x1842             ADDS     R2,R0,R1
   \   00000094   0x210B             MOVS     R1,#+11
   \   00000096   0x68E0             LDR      R0,[R4, #+12]
   \   00000098   0x.... 0x....      BL       BitStream_appendNum
   \   0000009C   0x2800             CMP      R0,#+0
   \   0000009E   0xD4C4             BMI.N    ??QRinput_encodeModeAn_3
   \   000000A0   0x1C76             ADDS     R6,R6,#+1
   \                     ??QRinput_encodeModeAn_5: (+1)
   \   000000A2   0x42AE             CMP      R6,R5
   \   000000A4   0xDA14             BGE.N    ??QRinput_encodeModeAn_8
   \   000000A6   0x68A0             LDR      R0,[R4, #+8]
   \   000000A8   0xF810 0x1016      LDRB     R1,[R0, R6, LSL #+1]
   \   000000AC   0x060A             LSLS     R2,R1,#+24
   \   000000AE   0xD502             BPL.N    ??QRinput_encodeModeAn_9
   \   000000B0   0xF04F 0x31FF      MOV      R1,#-1
   \   000000B4   0xE002             B.N      ??QRinput_encodeModeAn_10
   \                     ??QRinput_encodeModeAn_9: (+1)
   \   000000B6   0x.... 0x....      ADR.W    R2,QRinput_anTable
   \   000000BA   0x5689             LDRSB    R1,[R1, R2]
   \                     ??QRinput_encodeModeAn_10: (+1)
   \   000000BC   0x222D             MOVS     R2,#+45
   \   000000BE   0x4351             MULS     R1,R2,R1
   \   000000C0   0xEB00 0x0046      ADD      R0,R0,R6, LSL #+1
   \   000000C4   0x7840             LDRB     R0,[R0, #+1]
   \   000000C6   0x0602             LSLS     R2,R0,#+24
   \   000000C8   0xD5E0             BPL.N    ??QRinput_encodeModeAn_6
   \   000000CA   0xF04F 0x30FF      MOV      R0,#-1
   \   000000CE   0xE7E0             B.N      ??QRinput_encodeModeAn_7
   \                     ??QRinput_encodeModeAn_8: (+1)
   \   000000D0   0x7920             LDRB     R0,[R4, #+4]
   \   000000D2   0x07C0             LSLS     R0,R0,#+31
   \   000000D4   0xD510             BPL.N    ??QRinput_encodeModeAn_11
   \   000000D6   0x68A0             LDR      R0,[R4, #+8]
   \   000000D8   0xF810 0x0015      LDRB     R0,[R0, R5, LSL #+1]
   \   000000DC   0x0601             LSLS     R1,R0,#+24
   \   000000DE   0xD502             BPL.N    ??QRinput_encodeModeAn_12
   \   000000E0   0xF04F 0x32FF      MOV      R2,#-1
   \   000000E4   0xE002             B.N      ??QRinput_encodeModeAn_13
   \                     ??QRinput_encodeModeAn_12: (+1)
   \   000000E6   0x.... 0x....      ADR.W    R1,QRinput_anTable
   \   000000EA   0x5642             LDRSB    R2,[R0, R1]
   \                     ??QRinput_encodeModeAn_13: (+1)
   \   000000EC   0x2106             MOVS     R1,#+6
   \   000000EE   0x68E0             LDR      R0,[R4, #+12]
   \   000000F0   0x.... 0x....      BL       BitStream_appendNum
   \   000000F4   0x2800             CMP      R0,#+0
   \   000000F6   0xD498             BMI.N    ??QRinput_encodeModeAn_3
   \                     ??QRinput_encodeModeAn_11: (+1)
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0xBD70             POP      {R4-R6,PC}
    569          }
    570          
    571          /******************************************************************************
    572           * 8 bit data
    573           *****************************************************************************/
    574          
    575          /**
    576           * Estimates the length of the encoded bit stream of 8 bit data.
    577           * @param size
    578           * @return number of bits
    579           */

   \                                 In section .text, align 2, keep-with-next
    580          int QRinput_estimateBitsMode8(int size)
    581          {
    582          	return size * 8;
   \                     QRinput_estimateBitsMode8: (+1)
   \   00000000   0x00C0             LSLS     R0,R0,#+3
   \   00000002   0x4770             BX       LR               ;; return
    583          }
    584          
    585          /**
    586           * Convert the 8bits data to a bit stream.
    587           * @param entry
    588           * @param mqr
    589           * @retval 0 success
    590           * @retval -1 an error occurred and errno is set to indeicate the error.
    591           *            See Execptions for the details.
    592           * @throw ENOMEM unable to allocate memory.
    593           */

   \                                 In section .text, align 2, keep-with-next
    594          static int QRinput_encodeMode8(QRinput_List *entry, int version, int mqr)
    595          {
   \                     QRinput_encodeMode8: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    596          	int ret;
    597          
    598          	entry->bstream = BitStream_new();
   \   00000008   0x.... 0x....      BL       BitStream_new
   \   0000000C   0x60E0             STR      R0,[R4, #+12]
    599          	if(entry->bstream == NULL) return -1;
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD102             BNE.N    ??QRinput_encodeMode8_0
   \   00000012   0xF04F 0x30FF      MOV      R0,#-1
   \   00000016   0xBD70             POP      {R4-R6,PC}
    600          
    601          	if(mqr) {
   \                     ??QRinput_encodeMode8_0: (+1)
   \   00000018   0x2E00             CMP      R6,#+0
   \   0000001A   0xD020             BEQ.N    ??QRinput_encodeMode8_1
    602          		if(version < 3) {
   \   0000001C   0x2D03             CMP      R5,#+3
   \   0000001E   0xDA0C             BGE.N    ??QRinput_encodeMode8_2
    603          			errno = EINVAL;
   \   00000020   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000024   0xF04F 0x31FF      MOV      R1,#-1
   \   00000028   0x6001             STR      R1,[R0, #+0]
    604          			goto ABORT;
    605          		}
    606          		ret = BitStream_appendNum(entry->bstream, version - 1, MQRSPEC_MODEID_8);
    607          		if(ret < 0) goto ABORT;
    608          		ret = BitStream_appendNum(entry->bstream, MQRspec_lengthIndicator(QR_MODE_8, version), entry->size);
    609          		if(ret < 0) goto ABORT;
    610          	} else {
    611          		ret = BitStream_appendNum(entry->bstream, 4, QRSPEC_MODEID_8);
    612          		if(ret < 0) goto ABORT;
    613          		ret = BitStream_appendNum(entry->bstream, QRspec_lengthIndicator(QR_MODE_8, version), entry->size);
    614          		if(ret < 0) goto ABORT;
    615          	}
    616          
    617          	ret = BitStream_appendBytes(entry->bstream, entry->size, entry->data);
    618          	if(ret < 0) goto ABORT;
    619          
    620          	return 0;
    621          ABORT:
    622          	BitStream_free(entry->bstream);
   \                     ??QRinput_encodeMode8_3: (+1)
   \   0000002A   0x68E0             LDR      R0,[R4, #+12]
   \   0000002C   0x.... 0x....      BL       BitStream_free
    623          	entry->bstream = NULL;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x60E0             STR      R0,[R4, #+12]
    624          	return -1;
   \   00000034   0xF04F 0x30FF      MOV      R0,#-1
   \   00000038   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??QRinput_encodeMode8_2: (+1)
   \   0000003A   0x2202             MOVS     R2,#+2
   \   0000003C   0x1E69             SUBS     R1,R5,#+1
   \   0000003E   0x.... 0x....      BL       BitStream_appendNum
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD4F1             BMI.N    ??QRinput_encodeMode8_3
   \   00000046   0x4629             MOV      R1,R5
   \   00000048   0x2002             MOVS     R0,#+2
   \   0000004A   0x.... 0x....      BL       MQRspec_lengthIndicator
   \   0000004E   0x4601             MOV      R1,R0
   \   00000050   0x6862             LDR      R2,[R4, #+4]
   \   00000052   0x68E0             LDR      R0,[R4, #+12]
   \   00000054   0x.... 0x....      BL       BitStream_appendNum
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD511             BPL.N    ??QRinput_encodeMode8_4
   \   0000005C   0xE7E5             B.N      ??QRinput_encodeMode8_3
   \                     ??QRinput_encodeMode8_1: (+1)
   \   0000005E   0x2204             MOVS     R2,#+4
   \   00000060   0x4611             MOV      R1,R2
   \   00000062   0x.... 0x....      BL       BitStream_appendNum
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD4DF             BMI.N    ??QRinput_encodeMode8_3
   \   0000006A   0x4629             MOV      R1,R5
   \   0000006C   0x2002             MOVS     R0,#+2
   \   0000006E   0x.... 0x....      BL       QRspec_lengthIndicator
   \   00000072   0x6862             LDR      R2,[R4, #+4]
   \   00000074   0x4601             MOV      R1,R0
   \   00000076   0x68E0             LDR      R0,[R4, #+12]
   \   00000078   0x.... 0x....      BL       BitStream_appendNum
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD4D4             BMI.N    ??QRinput_encodeMode8_3
   \                     ??QRinput_encodeMode8_4: (+1)
   \   00000080   0x68A2             LDR      R2,[R4, #+8]
   \   00000082   0x6861             LDR      R1,[R4, #+4]
   \   00000084   0x68E0             LDR      R0,[R4, #+12]
   \   00000086   0x.... 0x....      BL       BitStream_appendBytes
   \   0000008A   0x2800             CMP      R0,#+0
   \   0000008C   0xD4CD             BMI.N    ??QRinput_encodeMode8_3
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0xBD70             POP      {R4-R6,PC}
    625          }
    626          
    627          
    628          /******************************************************************************
    629           * Kanji data
    630           *****************************************************************************/
    631          
    632          /**
    633           * Estimates the length of the encoded bit stream of kanji data.
    634           * @param size
    635           * @return number of bits
    636           */

   \                                 In section .text, align 2, keep-with-next
    637          int QRinput_estimateBitsModeKanji(int size)
    638          {
    639          	return (size / 2) * 13;
   \                     QRinput_estimateBitsModeKanji: (+1)
   \   00000000   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   00000004   0x1040             ASRS     R0,R0,#+1
   \   00000006   0x210D             MOVS     R1,#+13
   \   00000008   0x4348             MULS     R0,R1,R0
   \   0000000A   0x4770             BX       LR               ;; return
    640          }
    641          
    642          /**
    643           * Check the input data.
    644           * @param size
    645           * @param data
    646           * @return result
    647           */

   \                                 In section .text, align 2, keep-with-next
    648          static int QRinput_checkModeKanji(int size, const unsigned char *data)
    649          {
   \                     QRinput_checkModeKanji: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    650          	int i;
    651          	unsigned int val;
    652          
    653          	if(size & 1)
   \   00000002   0x07C2             LSLS     R2,R0,#+31
   \   00000004   0xD417             BMI.N    ??QRinput_checkModeKanji_0
    654          		return -1;
    655          
    656          	for(i=0; i<size; i+=2) {
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0xF244 0x0543      MOVW     R5,#+16451
   \   0000000C   0xE000             B.N      ??QRinput_checkModeKanji_1
   \                     ??QRinput_checkModeKanji_2: (+1)
   \   0000000E   0x1C92             ADDS     R2,R2,#+2
   \                     ??QRinput_checkModeKanji_1: (+1)
   \   00000010   0x4282             CMP      R2,R0
   \   00000012   0xDA13             BGE.N    ??QRinput_checkModeKanji_3
    657          		val = ((unsigned int)data[i] << 8) | data[i+1];
   \   00000014   0x5C53             LDRB     R3,[R2, R1]
   \   00000016   0x1854             ADDS     R4,R2,R1
   \   00000018   0x7864             LDRB     R4,[R4, #+1]
   \   0000001A   0xEA44 0x2303      ORR      R3,R4,R3, LSL #+8
    658          		if(val < 0x8140 || (val > 0x9ffc && val < 0xe040) || val > 0xebbf) {
   \   0000001E   0xF248 0x1440      MOVW     R4,#+33088
   \   00000022   0x42A3             CMP      R3,R4
   \   00000024   0xD307             BCC.N    ??QRinput_checkModeKanji_0
   \   00000026   0x....             LDR.N    R4,??DataTable3_1  ;; 0xffff6003
   \   00000028   0x18E4             ADDS     R4,R4,R3
   \   0000002A   0x42AC             CMP      R4,R5
   \   0000002C   0xD303             BCC.N    ??QRinput_checkModeKanji_0
   \   0000002E   0xF64E 0x34C0      MOVW     R4,#+60352
   \   00000032   0x42A3             CMP      R3,R4
   \   00000034   0xD3EB             BCC.N    ??QRinput_checkModeKanji_2
    659          			return -1;
   \                     ??QRinput_checkModeKanji_0: (+1)
   \   00000036   0xF04F 0x30FF      MOV      R0,#-1
   \   0000003A   0xE000             B.N      ??QRinput_checkModeKanji_4
    660          		}
    661          	}
    662          
    663          	return 0;
   \                     ??QRinput_checkModeKanji_3: (+1)
   \   0000003C   0x2000             MOVS     R0,#+0
   \                     ??QRinput_checkModeKanji_4: (+1)
   \   0000003E   0xBC30             POP      {R4,R5}
   \   00000040   0x4770             BX       LR               ;; return
    664          }
    665          
    666          /**
    667           * Convert the kanji data to a bit stream.
    668           * @param entry
    669           * @param mqr
    670           * @retval 0 success
    671           * @retval -1 an error occurred and errno is set to indeicate the error.
    672           *            See Execptions for the details.
    673           * @throw ENOMEM unable to allocate memory.
    674           * @throw EINVAL invalid version.
    675           */

   \                                 In section .text, align 2, keep-with-next
    676          static int QRinput_encodeModeKanji(QRinput_List *entry, int version, int mqr)
    677          {
   \                     QRinput_encodeModeKanji: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    678          	int ret, i;
    679          	unsigned int val, h;
    680          
    681          	entry->bstream = BitStream_new();
   \   00000008   0x.... 0x....      BL       BitStream_new
   \   0000000C   0x60E0             STR      R0,[R4, #+12]
    682          	if(entry->bstream == NULL) return -1;
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD102             BNE.N    ??QRinput_encodeModeKanji_0
   \   00000012   0xF04F 0x30FF      MOV      R0,#-1
   \   00000016   0xBD70             POP      {R4-R6,PC}
    683          
    684          	if(mqr) {
   \                     ??QRinput_encodeModeKanji_0: (+1)
   \   00000018   0x2E00             CMP      R6,#+0
   \   0000001A   0xD023             BEQ.N    ??QRinput_encodeModeKanji_1
    685          		if(version < 2) {
   \   0000001C   0x2D02             CMP      R5,#+2
   \   0000001E   0xDA0C             BGE.N    ??QRinput_encodeModeKanji_2
    686          			errno = EINVAL;
   \   00000020   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000024   0xF04F 0x31FF      MOV      R1,#-1
   \   00000028   0x6001             STR      R1,[R0, #+0]
    687          			goto ABORT;
    688          		}
    689          		ret = BitStream_appendNum(entry->bstream, version - 1, MQRSPEC_MODEID_KANJI);
    690          		if(ret < 0) goto ABORT;
    691          		ret = BitStream_appendNum(entry->bstream, MQRspec_lengthIndicator(QR_MODE_KANJI, version), entry->size/2);
    692          		if(ret < 0) goto ABORT;
    693          	} else {
    694          		ret = BitStream_appendNum(entry->bstream, 4, QRSPEC_MODEID_KANJI);
    695          		if(ret < 0) goto ABORT;
    696          		ret = BitStream_appendNum(entry->bstream, QRspec_lengthIndicator(QR_MODE_KANJI, version), entry->size/2);
    697          		if(ret < 0) goto ABORT;
    698          	}
    699          
    700          	for(i=0; i<entry->size; i+=2) {
    701          		val = ((unsigned int)entry->data[i] << 8) | entry->data[i+1];
    702          		if(val <= 0x9ffc) {
    703          			val -= 0x8140;
    704          		} else {
    705          			val -= 0xc140;
    706          		}
    707          		h = (val >> 8) * 0xc0;
    708          		val = (val & 0xff) + h;
    709          
    710          		ret = BitStream_appendNum(entry->bstream, 13, val);
    711          		if(ret < 0) goto ABORT;
    712          	}
    713          
    714          	return 0;
    715          ABORT:
    716          	BitStream_free(entry->bstream);
   \                     ??QRinput_encodeModeKanji_3: (+1)
   \   0000002A   0x68E0             LDR      R0,[R4, #+12]
   \   0000002C   0x.... 0x....      BL       BitStream_free
    717          	entry->bstream = NULL;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x60E0             STR      R0,[R4, #+12]
    718          	return -1;
   \   00000034   0xF04F 0x30FF      MOV      R0,#-1
   \   00000038   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??QRinput_encodeModeKanji_2: (+1)
   \   0000003A   0x2203             MOVS     R2,#+3
   \   0000003C   0x1E69             SUBS     R1,R5,#+1
   \   0000003E   0x.... 0x....      BL       BitStream_appendNum
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD4F1             BMI.N    ??QRinput_encodeModeKanji_3
   \   00000046   0x4629             MOV      R1,R5
   \   00000048   0x2003             MOVS     R0,#+3
   \   0000004A   0x.... 0x....      BL       MQRspec_lengthIndicator
   \   0000004E   0x4601             MOV      R1,R0
   \   00000050   0x6860             LDR      R0,[R4, #+4]
   \   00000052   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   00000056   0x1042             ASRS     R2,R0,#+1
   \   00000058   0x68E0             LDR      R0,[R4, #+12]
   \   0000005A   0x.... 0x....      BL       BitStream_appendNum
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD514             BPL.N    ??QRinput_encodeModeKanji_4
   \   00000062   0xE7E2             B.N      ??QRinput_encodeModeKanji_3
   \                     ??QRinput_encodeModeKanji_1: (+1)
   \   00000064   0x2208             MOVS     R2,#+8
   \   00000066   0x2104             MOVS     R1,#+4
   \   00000068   0x.... 0x....      BL       BitStream_appendNum
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD4DC             BMI.N    ??QRinput_encodeModeKanji_3
   \   00000070   0x4629             MOV      R1,R5
   \   00000072   0x2003             MOVS     R0,#+3
   \   00000074   0x.... 0x....      BL       QRspec_lengthIndicator
   \   00000078   0x6861             LDR      R1,[R4, #+4]
   \   0000007A   0xEB01 0x71D1      ADD      R1,R1,R1, LSR #+31
   \   0000007E   0x104A             ASRS     R2,R1,#+1
   \   00000080   0x4601             MOV      R1,R0
   \   00000082   0x68E0             LDR      R0,[R4, #+12]
   \   00000084   0x.... 0x....      BL       BitStream_appendNum
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD4CE             BMI.N    ??QRinput_encodeModeKanji_3
   \                     ??QRinput_encodeModeKanji_4: (+1)
   \   0000008C   0x2500             MOVS     R5,#+0
   \   0000008E   0xE00E             B.N      ??QRinput_encodeModeKanji_5
   \                     ??QRinput_encodeModeKanji_6: (+1)
   \   00000090   0x....             LDR.N    R1,??DataTable3_2  ;; 0xffff3ec0
   \   00000092   0x1808             ADDS     R0,R1,R0
   \                     ??QRinput_encodeModeKanji_7: (+1)
   \   00000094   0xB2C1             UXTB     R1,R0
   \   00000096   0x0A00             LSRS     R0,R0,#+8
   \   00000098   0xEB00 0x0240      ADD      R2,R0,R0, LSL #+1
   \   0000009C   0xEB01 0x1282      ADD      R2,R1,R2, LSL #+6
   \   000000A0   0x210D             MOVS     R1,#+13
   \   000000A2   0x68E0             LDR      R0,[R4, #+12]
   \   000000A4   0x.... 0x....      BL       BitStream_appendNum
   \   000000A8   0x2800             CMP      R0,#+0
   \   000000AA   0xD4BE             BMI.N    ??QRinput_encodeModeKanji_3
   \   000000AC   0x1CAD             ADDS     R5,R5,#+2
   \                     ??QRinput_encodeModeKanji_5: (+1)
   \   000000AE   0x6860             LDR      R0,[R4, #+4]
   \   000000B0   0x4285             CMP      R5,R0
   \   000000B2   0xDA0C             BGE.N    ??QRinput_encodeModeKanji_8
   \   000000B4   0x68A0             LDR      R0,[R4, #+8]
   \   000000B6   0x5C29             LDRB     R1,[R5, R0]
   \   000000B8   0x1828             ADDS     R0,R5,R0
   \   000000BA   0x7840             LDRB     R0,[R0, #+1]
   \   000000BC   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   000000C0   0xF649 0x71FD      MOVW     R1,#+40957
   \   000000C4   0x4288             CMP      R0,R1
   \   000000C6   0xD2E3             BCS.N    ??QRinput_encodeModeKanji_6
   \   000000C8   0x....             LDR.N    R1,??DataTable3_3  ;; 0xffff7ec0
   \   000000CA   0x1808             ADDS     R0,R1,R0
   \   000000CC   0xE7E2             B.N      ??QRinput_encodeModeKanji_7
   \                     ??QRinput_encodeModeKanji_8: (+1)
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0xBD70             POP      {R4-R6,PC}
    719          }
    720          
    721          /******************************************************************************
    722           * Structured Symbol
    723           *****************************************************************************/
    724          
    725          /**
    726           * Convert a structure symbol code to a bit stream.
    727           * @param entry
    728           * @param mqr
    729           * @retval 0 success
    730           * @retval -1 an error occurred and errno is set to indeicate the error.
    731           *            See Execptions for the details.
    732           * @throw ENOMEM unable to allocate memory.
    733           * @throw EINVAL invalid entry.
    734           */

   \                                 In section .text, align 2, keep-with-next
    735          static int QRinput_encodeModeStructure(QRinput_List *entry, int mqr)
    736          {
   \                     QRinput_encodeModeStructure: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    737          	int ret;
    738          
    739          	if(mqr) {
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD006             BEQ.N    ??QRinput_encodeModeStructure_0
    740          		errno = EINVAL;
   \   00000008   0x.... 0x....      BL       __aeabi_errno_addr
   \   0000000C   0xF04F 0x31FF      MOV      R1,#-1
   \   00000010   0x6001             STR      R1,[R0, #+0]
    741          		return -1;
   \   00000012   0x4608             MOV      R0,R1
   \   00000014   0xBD10             POP      {R4,PC}
    742          	}
    743          	entry->bstream = BitStream_new();
   \                     ??QRinput_encodeModeStructure_0: (+1)
   \   00000016   0x.... 0x....      BL       BitStream_new
   \   0000001A   0x60E0             STR      R0,[R4, #+12]
    744          	if(entry->bstream == NULL) return -1;
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD102             BNE.N    ??QRinput_encodeModeStructure_1
   \   00000020   0xF04F 0x30FF      MOV      R0,#-1
   \   00000024   0xBD10             POP      {R4,PC}
    745          
    746          	ret = BitStream_appendNum(entry->bstream, 4, QRSPEC_MODEID_STRUCTURE);
    747          	if(ret < 0) goto ABORT;
   \                     ??QRinput_encodeModeStructure_1: (+1)
   \   00000026   0x2203             MOVS     R2,#+3
   \   00000028   0x2104             MOVS     R1,#+4
   \   0000002A   0x.... 0x....      BL       BitStream_appendNum
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD41B             BMI.N    ??QRinput_encodeModeStructure_2
    748          	ret = BitStream_appendNum(entry->bstream, 4, entry->data[1] - 1);
    749          	if(ret < 0) goto ABORT;
   \   00000032   0x68A0             LDR      R0,[R4, #+8]
   \   00000034   0x7840             LDRB     R0,[R0, #+1]
   \   00000036   0x1E42             SUBS     R2,R0,#+1
   \   00000038   0x2104             MOVS     R1,#+4
   \   0000003A   0x68E0             LDR      R0,[R4, #+12]
   \   0000003C   0x.... 0x....      BL       BitStream_appendNum
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD412             BMI.N    ??QRinput_encodeModeStructure_2
    750          	ret = BitStream_appendNum(entry->bstream, 4, entry->data[0] - 1);
    751          	if(ret < 0) goto ABORT;
   \   00000044   0x68A0             LDR      R0,[R4, #+8]
   \   00000046   0x7800             LDRB     R0,[R0, #+0]
   \   00000048   0x1E42             SUBS     R2,R0,#+1
   \   0000004A   0x2104             MOVS     R1,#+4
   \   0000004C   0x68E0             LDR      R0,[R4, #+12]
   \   0000004E   0x.... 0x....      BL       BitStream_appendNum
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD409             BMI.N    ??QRinput_encodeModeStructure_2
    752          	ret = BitStream_appendNum(entry->bstream, 8, entry->data[2]);
    753          	if(ret < 0) goto ABORT;
   \   00000056   0x68A0             LDR      R0,[R4, #+8]
   \   00000058   0x7882             LDRB     R2,[R0, #+2]
   \   0000005A   0x2108             MOVS     R1,#+8
   \   0000005C   0x68E0             LDR      R0,[R4, #+12]
   \   0000005E   0x.... 0x....      BL       BitStream_appendNum
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD401             BMI.N    ??QRinput_encodeModeStructure_2
    754          
    755          	return 0;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0xBD10             POP      {R4,PC}
    756          ABORT:
    757          	BitStream_free(entry->bstream);
   \                     ??QRinput_encodeModeStructure_2: (+1)
   \   0000006A   0x68E0             LDR      R0,[R4, #+12]
   \   0000006C   0x.... 0x....      BL       BitStream_free
    758          	entry->bstream = NULL;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x60E0             STR      R0,[R4, #+12]
    759          	return -1;
   \   00000074   0xF04F 0x30FF      MOV      R0,#-1
   \   00000078   0xBD10             POP      {R4,PC}          ;; return
    760          }
    761          
    762          /******************************************************************************
    763           * FNC1
    764           *****************************************************************************/
    765          

   \                                 In section .text, align 2, keep-with-next
    766          static int QRinput_checkModeFNC1Second(int size, const unsigned char *data)
    767          {
    768          	if(size != 1) return -1;
   \                     QRinput_checkModeFNC1Second: (+1)
   \   00000000   0x2801             CMP      R0,#+1
   \   00000002   0xD002             BEQ.N    ??QRinput_checkModeFNC1Second_0
   \   00000004   0xF04F 0x30FF      MOV      R0,#-1
   \   00000008   0x4770             BX       LR
    769          
    770          	return 0;
   \                     ??QRinput_checkModeFNC1Second_0: (+1)
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x4770             BX       LR               ;; return
    771          }
    772          

   \                                 In section .text, align 2, keep-with-next
    773          static int QRinput_encodeModeFNC1Second(QRinput_List *entry, int version)
    774          {
   \                     QRinput_encodeModeFNC1Second: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    775          	int ret;
    776          
    777          	entry->bstream = BitStream_new();
   \   00000004   0x.... 0x....      BL       BitStream_new
   \   00000008   0x60E0             STR      R0,[R4, #+12]
    778          	if(entry->bstream == NULL) return -1;
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD102             BNE.N    ??QRinput_encodeModeFNC1Second_0
   \   0000000E   0xF04F 0x30FF      MOV      R0,#-1
   \   00000012   0xBD10             POP      {R4,PC}
    779          
    780          	ret = BitStream_appendNum(entry->bstream, 4, QRSPEC_MODEID_FNC1SECOND);
    781          	if(ret < 0) goto ABORT;
   \                     ??QRinput_encodeModeFNC1Second_0: (+1)
   \   00000014   0x2209             MOVS     R2,#+9
   \   00000016   0x2104             MOVS     R1,#+4
   \   00000018   0x.... 0x....      BL       BitStream_appendNum
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD408             BMI.N    ??QRinput_encodeModeFNC1Second_1
    782          	
    783          	ret = BitStream_appendBytes(entry->bstream, 1, entry->data);
    784          	if(ret < 0) goto ABORT;
   \   00000020   0x68A2             LDR      R2,[R4, #+8]
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0x68E0             LDR      R0,[R4, #+12]
   \   00000026   0x.... 0x....      BL       BitStream_appendBytes
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD401             BMI.N    ??QRinput_encodeModeFNC1Second_1
    785          
    786          	return 0;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xBD10             POP      {R4,PC}
    787          ABORT:
    788          	BitStream_free(entry->bstream);
   \                     ??QRinput_encodeModeFNC1Second_1: (+1)
   \   00000032   0x68E0             LDR      R0,[R4, #+12]
   \   00000034   0x.... 0x....      BL       BitStream_free
    789          	entry->bstream = NULL;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x60E0             STR      R0,[R4, #+12]
    790          	return -1;
   \   0000003C   0xF04F 0x30FF      MOV      R0,#-1
   \   00000040   0xBD10             POP      {R4,PC}          ;; return
    791          }
    792          
    793          /******************************************************************************
    794           * ECI header
    795           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    796          static unsigned int QRinput_decodeECIfromByteArray(unsigned char *data)
    797          {
    798          	int i;
    799          	unsigned int ecinum;
    800          
    801          	ecinum = 0;
   \                     QRinput_decodeECIfromByteArray: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    802          	for(i=0; i<4; i++) {
   \   00000002   0x460A             MOV      R2,R1
   \   00000004   0xE005             B.N      ??QRinput_decodeECIfromByteArray_0
    803          		ecinum = ecinum << 8;
    804          		ecinum |= data[3-i];
   \                     ??QRinput_decodeECIfromByteArray_1: (+1)
   \   00000006   0x4253             RSBS     R3,R2,#+0
   \   00000008   0x181B             ADDS     R3,R3,R0
   \   0000000A   0x78DB             LDRB     R3,[R3, #+3]
   \   0000000C   0xEA43 0x2101      ORR      R1,R3,R1, LSL #+8
    805          	}
   \   00000010   0x1C52             ADDS     R2,R2,#+1
   \                     ??QRinput_decodeECIfromByteArray_0: (+1)
   \   00000012   0x2A04             CMP      R2,#+4
   \   00000014   0xDBF7             BLT.N    ??QRinput_decodeECIfromByteArray_1
    806          
    807          	return ecinum;
   \   00000016   0x4608             MOV      R0,R1
   \   00000018   0x4770             BX       LR               ;; return
    808          }
    809          

   \                                 In section .text, align 2, keep-with-next
    810          int QRinput_estimateBitsModeECI(unsigned char *data)
    811          {
   \                     QRinput_estimateBitsModeECI: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    812          	unsigned int ecinum;
    813          
    814          	ecinum = QRinput_decodeECIfromByteArray(data);;
   \   00000002   0x.... 0x....      BL       QRinput_decodeECIfromByteArray
    815          
    816          	/* See Table 4 of JISX 0510:2004 pp.17. */
    817          	if(ecinum < 128) {
   \   00000006   0x2880             CMP      R0,#+128
   \   00000008   0xD201             BCS.N    ??QRinput_estimateBitsModeECI_0
    818          		return MODE_INDICATOR_SIZE + 8;
   \   0000000A   0x200C             MOVS     R0,#+12
   \   0000000C   0xBD02             POP      {R1,PC}
    819          	} else if(ecinum < 16384) {
   \                     ??QRinput_estimateBitsModeECI_0: (+1)
   \   0000000E   0xF5B0 0x4F80      CMP      R0,#+16384
   \   00000012   0xD201             BCS.N    ??QRinput_estimateBitsModeECI_1
    820          		return MODE_INDICATOR_SIZE + 16;
   \   00000014   0x2014             MOVS     R0,#+20
   \   00000016   0xBD02             POP      {R1,PC}
    821          	} else {
    822          		return MODE_INDICATOR_SIZE + 24;
   \                     ??QRinput_estimateBitsModeECI_1: (+1)
   \   00000018   0x201C             MOVS     R0,#+28
   \   0000001A   0xBD02             POP      {R1,PC}          ;; return
    823          	}
    824          }
    825          

   \                                 In section .text, align 2, keep-with-next
    826          static int QRinput_encodeModeECI(QRinput_List *entry, int version)
    827          {
   \                     QRinput_encodeModeECI: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    828          	int ret, words;
    829          	unsigned int ecinum, code;
    830          
    831          	entry->bstream = BitStream_new();
   \   00000004   0x.... 0x....      BL       BitStream_new
   \   00000008   0x60E0             STR      R0,[R4, #+12]
    832          	if(entry->bstream == NULL) return -1;
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD102             BNE.N    ??QRinput_encodeModeECI_0
   \   0000000E   0xF04F 0x30FF      MOV      R0,#-1
   \   00000012   0xBD70             POP      {R4-R6,PC}
    833          
    834          	ecinum = QRinput_decodeECIfromByteArray(entry->data);;
   \                     ??QRinput_encodeModeECI_0: (+1)
   \   00000014   0x68A0             LDR      R0,[R4, #+8]
   \   00000016   0x.... 0x....      BL       QRinput_decodeECIfromByteArray
   \   0000001A   0x4605             MOV      R5,R0
    835          
    836          	/* See Table 4 of JISX 0510:2004 pp.17. */
    837          	if(ecinum < 128) {
   \   0000001C   0x2D80             CMP      R5,#+128
   \   0000001E   0xD201             BCS.N    ??QRinput_encodeModeECI_1
    838          		words = 1;
   \   00000020   0x2601             MOVS     R6,#+1
    839          		code = ecinum;
   \   00000022   0xE009             B.N      ??QRinput_encodeModeECI_2
    840          	} else if(ecinum < 16384) {
   \                     ??QRinput_encodeModeECI_1: (+1)
   \   00000024   0xF5B5 0x4F80      CMP      R5,#+16384
   \   00000028   0xD203             BCS.N    ??QRinput_encodeModeECI_3
    841          		words = 2;
   \   0000002A   0x2602             MOVS     R6,#+2
    842          		code = 0x8000 + ecinum;
   \   0000002C   0xF505 0x4500      ADD      R5,R5,#+32768
   \   00000030   0xE002             B.N      ??QRinput_encodeModeECI_2
    843          	} else {
    844          		words = 3;
   \                     ??QRinput_encodeModeECI_3: (+1)
   \   00000032   0x2603             MOVS     R6,#+3
    845          		code = 0xc0000 + ecinum;
   \   00000034   0xF505 0x2540      ADD      R5,R5,#+786432
    846          	}
    847          
    848          	ret = BitStream_appendNum(entry->bstream, 4, QRSPEC_MODEID_ECI);
    849          	if(ret < 0) goto ABORT;
   \                     ??QRinput_encodeModeECI_2: (+1)
   \   00000038   0x2207             MOVS     R2,#+7
   \   0000003A   0x2104             MOVS     R1,#+4
   \   0000003C   0x68E0             LDR      R0,[R4, #+12]
   \   0000003E   0x.... 0x....      BL       BitStream_appendNum
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD408             BMI.N    ??QRinput_encodeModeECI_4
    850          	
    851          	ret = BitStream_appendNum(entry->bstream, words * 8, code);
    852          	if(ret < 0) goto ABORT;
   \   00000046   0x462A             MOV      R2,R5
   \   00000048   0x00F1             LSLS     R1,R6,#+3
   \   0000004A   0x68E0             LDR      R0,[R4, #+12]
   \   0000004C   0x.... 0x....      BL       BitStream_appendNum
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD401             BMI.N    ??QRinput_encodeModeECI_4
    853          
    854          	return 0;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xBD70             POP      {R4-R6,PC}
    855          ABORT:
    856          	BitStream_free(entry->bstream);
   \                     ??QRinput_encodeModeECI_4: (+1)
   \   00000058   0x68E0             LDR      R0,[R4, #+12]
   \   0000005A   0x.... 0x....      BL       BitStream_free
    857          	entry->bstream = NULL;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x60E0             STR      R0,[R4, #+12]
    858          	return -1;
   \   00000062   0xF04F 0x30FF      MOV      R0,#-1
   \   00000066   0xBD70             POP      {R4-R6,PC}       ;; return
    859          }
    860          
    861          /******************************************************************************
    862           * Validation
    863           *****************************************************************************/
    864          

   \                                 In section .text, align 4, keep-with-next
    865          int QRinput_check(QRencodeMode mode, int size, const unsigned char *data)
    866          {
   \                     QRinput_check: (+1)
   \   00000000   0x460B             MOV      R3,R1
   \   00000002   0x4611             MOV      R1,R2
    867          	if((mode == QR_MODE_FNC1FIRST && size < 0) || size <= 0) return -1;
   \   00000004   0x2806             CMP      R0,#+6
   \   00000006   0xD101             BNE.N    ??QRinput_check_1
   \   00000008   0x2B00             CMP      R3,#+0
   \   0000000A   0xD413             BMI.N    ??QRinput_check_2
   \                     ??QRinput_check_1: (+1)
   \   0000000C   0x2B01             CMP      R3,#+1
   \   0000000E   0xDB11             BLT.N    ??QRinput_check_2
    868          
    869          	switch(mode) {
   \   00000010   0x2807             CMP      R0,#+7
   \   00000012   0xD80F             BHI.N    ??QRinput_check_2
   \   00000014   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??QRinput_check_0:
   \   00000018   0x04 0x06          DC8      0x4,0x6,0xA,0x8
   \              0x0A 0x08    
   \   0000001C   0x0A 0x0A          DC8      0xA,0xA,0xA,0xC
   \              0x0A 0x0C    
    870          		case QR_MODE_NUM:
    871          			return QRinput_checkModeNum(size, (const char *)data);
   \                     ??QRinput_check_3: (+1)
   \   00000020   0x4618             MOV      R0,R3
   \   00000022   0x....             B.N      QRinput_checkModeNum
    872          		case QR_MODE_AN:
    873          			return QRinput_checkModeAn(size, (const char *)data);
   \                     ??QRinput_check_4: (+1)
   \   00000024   0x4618             MOV      R0,R3
   \   00000026   0x....             B.N      QRinput_checkModeAn
    874          		case QR_MODE_KANJI:
    875          			return QRinput_checkModeKanji(size, data);
   \                     ??QRinput_check_5: (+1)
   \   00000028   0x4618             MOV      R0,R3
   \   0000002A   0x....             B.N      QRinput_checkModeKanji
    876          		case QR_MODE_8:
    877          			return 0;
    878          		case QR_MODE_STRUCTURE:
    879          			return 0;
    880          		case QR_MODE_ECI:
    881          			return 0;
    882          		case QR_MODE_FNC1FIRST:
    883          			return 0;
   \                     ??QRinput_check_6: (+1)
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x4770             BX       LR
    884          		case QR_MODE_FNC1SECOND:
    885          			return QRinput_checkModeFNC1Second(size, data);
   \                     ??QRinput_check_7: (+1)
   \   00000030   0x4618             MOV      R0,R3
   \   00000032   0x....             B.N      QRinput_checkModeFNC1Second
    886          		case QR_MODE_NUL:
    887          			break;
    888          	}
    889          
    890          	return -1;
   \                     ??QRinput_check_2: (+1)
   \   00000034   0xF04F 0x30FF      MOV      R0,#-1
   \   00000038   0x4770             BX       LR               ;; return
    891          }
    892          
    893          /******************************************************************************
    894           * Estimation of the bit length
    895           *****************************************************************************/
    896          
    897          /**
    898           * Estimates the length of the encoded bit stream on the current version.
    899           * @param entry
    900           * @param version version of the symbol
    901           * @param mqr
    902           * @return number of bits
    903           */

   \                                 In section .text, align 4, keep-with-next
    904          static int QRinput_estimateBitStreamSizeOfEntry(QRinput_List *entry, int version, int mqr)
    905          {
   \                     QRinput_estimateBitStreamSizeOfEntry: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4617             MOV      R7,R2
    906          	int bits = 0;
    907          	int l, m;
    908          	int num;
    909          
    910          	if(version == 0) version = 1;
   \   00000008   0x2E00             CMP      R6,#+0
   \   0000000A   0xD100             BNE.N    ??QRinput_estimateBitStreamSizeOfEntry_1
   \   0000000C   0x2601             MOVS     R6,#+1
    911          
    912          	switch(entry->mode) {
   \                     ??QRinput_estimateBitStreamSizeOfEntry_1: (+1)
   \   0000000E   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   00000012   0x2807             CMP      R0,#+7
   \   00000014   0xD82E             BHI.N    ??QRinput_estimateBitStreamSizeOfEntry_2
   \   00000016   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??QRinput_estimateBitStreamSizeOfEntry_0:
   \   0000001A   0x04 0x13          DC8      0x4,0x13,0x18,0x1D
   \              0x18 0x1D    
   \   0000001E   0x22 0x24          DC8      0x22,0x24,0x29,0x2B
   \              0x29 0x2B    
    913          		case QR_MODE_NUM:
    914          			bits = QRinput_estimateBitsModeNum(entry->size);
   \                     ??QRinput_estimateBitStreamSizeOfEntry_3: (+1)
   \   00000022   0x6860             LDR      R0,[R4, #+4]
   \   00000024   0x.... 0x....      BL       QRinput_estimateBitsModeNum
   \   00000028   0x4605             MOV      R5,R0
    915          			break;
    916          		case QR_MODE_AN:
    917          			bits = QRinput_estimateBitsModeAn(entry->size);
    918          			break;
    919          		case QR_MODE_8:
    920          			bits = QRinput_estimateBitsMode8(entry->size);
    921          			break;
    922          		case QR_MODE_KANJI:
    923          			bits = QRinput_estimateBitsModeKanji(entry->size);
    924          			break;
    925          		case QR_MODE_STRUCTURE:
    926          			return STRUCTURE_HEADER_SIZE;
    927          		case QR_MODE_ECI:
    928          			bits = QRinput_estimateBitsModeECI(entry->data);
    929          			break;
    930          		case QR_MODE_FNC1FIRST:
    931          			return MODE_INDICATOR_SIZE;
    932          		case QR_MODE_FNC1SECOND:
    933          			return MODE_INDICATOR_SIZE + 8;
    934          		default:
    935          			return 0;
    936          	}
    937          
    938          	if(mqr) {
   \                     ??QRinput_estimateBitStreamSizeOfEntry_4: (+1)
   \   0000002A   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   0000002E   0x2F00             CMP      R7,#+0
   \   00000030   0x4631             MOV      R1,R6
   \   00000032   0xD021             BEQ.N    ??QRinput_estimateBitStreamSizeOfEntry_5
    939          		l = QRspec_lengthIndicator(entry->mode, version);
    940          		m = version - 1;
    941          		bits += l + m;
   \   00000034   0x.... 0x....      BL       QRspec_lengthIndicator
   \   00000038   0x1830             ADDS     R0,R6,R0
   \   0000003A   0x1E40             SUBS     R0,R0,#+1
   \   0000003C   0x1940             ADDS     R0,R0,R5
   \   0000003E   0xBDF2             POP      {R1,R4-R7,PC}
    942          	} else {
   \                     ??QRinput_estimateBitStreamSizeOfEntry_6: (+1)
   \   00000040   0x6860             LDR      R0,[R4, #+4]
   \   00000042   0x.... 0x....      BL       QRinput_estimateBitsModeAn
   \   00000046   0x4605             MOV      R5,R0
   \   00000048   0xE7EF             B.N      ??QRinput_estimateBitStreamSizeOfEntry_4
   \                     ??QRinput_estimateBitStreamSizeOfEntry_7: (+1)
   \   0000004A   0x6860             LDR      R0,[R4, #+4]
   \   0000004C   0x.... 0x....      BL       QRinput_estimateBitsMode8
   \   00000050   0x4605             MOV      R5,R0
   \   00000052   0xE7EA             B.N      ??QRinput_estimateBitStreamSizeOfEntry_4
   \                     ??QRinput_estimateBitStreamSizeOfEntry_8: (+1)
   \   00000054   0x6860             LDR      R0,[R4, #+4]
   \   00000056   0x.... 0x....      BL       QRinput_estimateBitsModeKanji
   \   0000005A   0x4605             MOV      R5,R0
   \   0000005C   0xE7E5             B.N      ??QRinput_estimateBitStreamSizeOfEntry_4
   \                     ??QRinput_estimateBitStreamSizeOfEntry_9: (+1)
   \   0000005E   0x2014             MOVS     R0,#+20
   \   00000060   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??QRinput_estimateBitStreamSizeOfEntry_10: (+1)
   \   00000062   0x68A0             LDR      R0,[R4, #+8]
   \   00000064   0x.... 0x....      BL       QRinput_estimateBitsModeECI
   \   00000068   0x4605             MOV      R5,R0
   \   0000006A   0xE7DE             B.N      ??QRinput_estimateBitStreamSizeOfEntry_4
   \                     ??QRinput_estimateBitStreamSizeOfEntry_11: (+1)
   \   0000006C   0x2004             MOVS     R0,#+4
   \   0000006E   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??QRinput_estimateBitStreamSizeOfEntry_12: (+1)
   \   00000070   0x200C             MOVS     R0,#+12
   \   00000072   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??QRinput_estimateBitStreamSizeOfEntry_2: (+1)
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xBDF2             POP      {R1,R4-R7,PC}
    943          		l = QRspec_lengthIndicator(entry->mode, version);
   \                     ??QRinput_estimateBitStreamSizeOfEntry_5: (+1)
   \   00000078   0x.... 0x....      BL       QRspec_lengthIndicator
    944          		m = 1 << l;
   \   0000007C   0x2101             MOVS     R1,#+1
   \   0000007E   0x4081             LSLS     R1,R1,R0
    945          		num = (entry->size + m - 1) / m;
    946          
    947          		bits += num * (MODE_INDICATOR_SIZE + l);
   \   00000080   0x6862             LDR      R2,[R4, #+4]
   \   00000082   0x188A             ADDS     R2,R1,R2
   \   00000084   0x1E52             SUBS     R2,R2,#+1
   \   00000086   0xFB92 0xF1F1      SDIV     R1,R2,R1
   \   0000008A   0x1D00             ADDS     R0,R0,#+4
   \   0000008C   0xFB00 0x5001      MLA      R0,R0,R1,R5
    948          	}
    949          
    950          	return bits;
   \   00000090   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    951          }
    952          
    953          /**
    954           * Estimates the length of the encoded bit stream of the data.
    955           * @param input input data
    956           * @param version version of the symbol
    957           * @return number of bits
    958           */

   \                                 In section .text, align 2, keep-with-next
    959          static int QRinput_estimateBitStreamSize(QRinput *input, int version)
    960          {
   \                     QRinput_estimateBitStreamSize: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    961          	QRinput_List *list;
    962          	int bits = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    963          
    964          	list = input->head;
   \   00000008   0x68A7             LDR      R7,[R4, #+8]
   \   0000000A   0xE006             B.N      ??QRinput_estimateBitStreamSize_0
    965          	while(list != NULL) {
    966          		bits += QRinput_estimateBitStreamSizeOfEntry(list, version, input->mqr);
   \                     ??QRinput_estimateBitStreamSize_1: (+1)
   \   0000000C   0x6922             LDR      R2,[R4, #+16]
   \   0000000E   0x4629             MOV      R1,R5
   \   00000010   0x4638             MOV      R0,R7
   \   00000012   0x.... 0x....      BL       QRinput_estimateBitStreamSizeOfEntry
   \   00000016   0x1986             ADDS     R6,R0,R6
    967          		list = list->next;
   \   00000018   0x693F             LDR      R7,[R7, #+16]
    968          	}
   \                     ??QRinput_estimateBitStreamSize_0: (+1)
   \   0000001A   0x2F00             CMP      R7,#+0
   \   0000001C   0xD1F6             BNE.N    ??QRinput_estimateBitStreamSize_1
    969          
    970          	return bits;
   \   0000001E   0x4630             MOV      R0,R6
   \   00000020   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    971          }
    972          
    973          /**
    974           * Estimates the required version number of the symbol.
    975           * @param input input data
    976           * @return required version number
    977           */

   \                                 In section .text, align 2, keep-with-next
    978          static int QRinput_estimateVersion(QRinput *input)
    979          {
   \                     QRinput_estimateVersion: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    980          	int bits;
    981          	int version, prev;
    982          
    983          	version = 0;
   \   00000004   0x2000             MOVS     R0,#+0
    984          	do {
    985          		prev = version;
   \                     ??QRinput_estimateVersion_0: (+1)
   \   00000006   0x4605             MOV      R5,R0
    986          		bits = QRinput_estimateBitStreamSize(input, prev);
    987          		version = QRspec_getMinimumVersion((bits + 7) / 8, input->level);
   \   00000008   0x4629             MOV      R1,R5
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       QRinput_estimateBitStreamSize
   \   00000010   0x1DC0             ADDS     R0,R0,#+7
   \   00000012   0xF994 0x1004      LDRSB    R1,[R4, #+4]
   \   00000016   0x1082             ASRS     R2,R0,#+2
   \   00000018   0xEB00 0x7052      ADD      R0,R0,R2, LSR #+29
   \   0000001C   0x10C0             ASRS     R0,R0,#+3
   \   0000001E   0x.... 0x....      BL       QRspec_getMinimumVersion
    988          		if (version < 0) {
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD502             BPL.N    ??QRinput_estimateVersion_1
    989          			return -1;
   \   00000026   0xF04F 0x30FF      MOV      R0,#-1
   \   0000002A   0xBD32             POP      {R1,R4,R5,PC}
    990          		}
    991          	} while (version > prev);
   \                     ??QRinput_estimateVersion_1: (+1)
   \   0000002C   0x4285             CMP      R5,R0
   \   0000002E   0xDBEA             BLT.N    ??QRinput_estimateVersion_0
    992          
    993          	return version;
   \   00000030   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    994          }
    995          
    996          /**
    997           * Returns required length in bytes for specified mode, version and bits.
    998           * @param mode
    999           * @param version
   1000           * @param bits
   1001           * @return required length of code words in bytes.
   1002           */

   \                                 In section .text, align 4, keep-with-next
   1003          static int QRinput_lengthOfCode(QRencodeMode mode, int version, int bits)
   1004          {
   \                     QRinput_lengthOfCode: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460C             MOV      R4,R1
   1005          	int payload, size, chunks, remain, maxsize;
   1006          
   1007          	payload = bits - 4 - QRspec_lengthIndicator(mode, version);
   \   00000006   0x1F16             SUBS     R6,R2,#+4
   \   00000008   0x.... 0x....      BL       QRspec_lengthIndicator
   \   0000000C   0x1A30             SUBS     R0,R6,R0
   1008          	switch(mode) {
   \   0000000E   0x4629             MOV      R1,R5
   \   00000010   0x2904             CMP      R1,#+4
   \   00000012   0xD82A             BHI.N    ??QRinput_lengthOfCode_1
   \   00000014   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??QRinput_lengthOfCode_0:
   \   00000018   0x03 0x14          DC8      0x3,0x14,0x24,0x1F
   \              0x24 0x1F    
   \   0000001C   0x24 0x00          DC8      0x24,0x0
   1009          		case QR_MODE_NUM:
   1010          			chunks = payload / 10;
   \                     ??QRinput_lengthOfCode_2: (+1)
   \   0000001E   0x210A             MOVS     R1,#+10
   \   00000020   0xFB90 0xF1F1      SDIV     R1,R0,R1
   1011          			remain = payload - chunks * 10;
   \   00000024   0xEB01 0x0281      ADD      R2,R1,R1, LSL #+2
   \   00000028   0xEBA0 0x0042      SUB      R0,R0,R2, LSL #+1
   1012          			size = chunks * 3;
   \   0000002C   0xEB01 0x0641      ADD      R6,R1,R1, LSL #+1
   1013          			if(remain >= 7) {
   \   00000030   0x2807             CMP      R0,#+7
   \   00000032   0xDB01             BLT.N    ??QRinput_lengthOfCode_3
   1014          				size += 2;
   \   00000034   0x1CB6             ADDS     R6,R6,#+2
   \   00000036   0xE019             B.N      ??QRinput_lengthOfCode_4
   1015          			} else if(remain >= 4) {
   \                     ??QRinput_lengthOfCode_3: (+1)
   \   00000038   0x2804             CMP      R0,#+4
   \   0000003A   0xDB17             BLT.N    ??QRinput_lengthOfCode_4
   1016          				size += 1;
   \   0000003C   0x1C76             ADDS     R6,R6,#+1
   \   0000003E   0xE015             B.N      ??QRinput_lengthOfCode_4
   1017          			}
   1018          			break;
   1019          		case QR_MODE_AN:
   1020          			chunks = payload / 11;
   \                     ??QRinput_lengthOfCode_5: (+1)
   \   00000040   0x210B             MOVS     R1,#+11
   \   00000042   0xFB90 0xF1F1      SDIV     R1,R0,R1
   1021          			remain = payload - chunks * 11;
   1022          			size = chunks * 2;
   \   00000046   0x004E             LSLS     R6,R1,#+1
   1023          			if(remain >= 6) size++;
   \   00000048   0x220B             MOVS     R2,#+11
   \   0000004A   0xFB02 0x0011      MLS      R0,R2,R1,R0
   \   0000004E   0x2806             CMP      R0,#+6
   \   00000050   0xDB0C             BLT.N    ??QRinput_lengthOfCode_4
   \   00000052   0x1C76             ADDS     R6,R6,#+1
   \   00000054   0xE00A             B.N      ??QRinput_lengthOfCode_4
   1024          			break;
   1025          		case QR_MODE_8:
   1026          			size = payload / 8;
   1027          			break;
   1028          		case QR_MODE_KANJI:
   1029          			size = (payload / 13) * 2;
   \                     ??QRinput_lengthOfCode_6: (+1)
   \   00000056   0x210D             MOVS     R1,#+13
   \   00000058   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000005C   0x0046             LSLS     R6,R0,#+1
   1030          			break;
   \   0000005E   0xE005             B.N      ??QRinput_lengthOfCode_4
   1031          		case QR_MODE_STRUCTURE:
   1032          			size = payload / 8;
   \                     ??QRinput_lengthOfCode_7: (+1)
   \   00000060   0x1081             ASRS     R1,R0,#+2
   \   00000062   0xEB00 0x7051      ADD      R0,R0,R1, LSR #+29
   \   00000066   0x10C6             ASRS     R6,R0,#+3
   1033          			break;
   \   00000068   0xE000             B.N      ??QRinput_lengthOfCode_4
   1034          		default:
   1035          			size = 0;
   \                     ??QRinput_lengthOfCode_1: (+1)
   \   0000006A   0x2600             MOVS     R6,#+0
   1036          			break;
   1037          	}
   1038          	maxsize = QRspec_maximumWords(mode, version);
   \                     ??QRinput_lengthOfCode_4: (+1)
   \   0000006C   0x4621             MOV      R1,R4
   \   0000006E   0x4628             MOV      R0,R5
   \   00000070   0x.... 0x....      BL       QRspec_maximumWords
   1039          	if(size < 0) size = 0;
   \   00000074   0x2E00             CMP      R6,#+0
   \   00000076   0xD500             BPL.N    ??QRinput_lengthOfCode_8
   \   00000078   0x2600             MOVS     R6,#+0
   1040          	if(maxsize > 0 && size > maxsize) size = maxsize;
   \                     ??QRinput_lengthOfCode_8: (+1)
   \   0000007A   0x2801             CMP      R0,#+1
   \   0000007C   0xDB02             BLT.N    ??QRinput_lengthOfCode_9
   \   0000007E   0x42B0             CMP      R0,R6
   \   00000080   0xDC00             BGT.N    ??QRinput_lengthOfCode_9
   \   00000082   0x4606             MOV      R6,R0
   1041          
   1042          	return size;
   \                     ??QRinput_lengthOfCode_9: (+1)
   \   00000084   0x4630             MOV      R0,R6
   \   00000086   0xBD70             POP      {R4-R6,PC}       ;; return
   1043          }
   1044          
   1045          /******************************************************************************
   1046           * Data conversion
   1047           *****************************************************************************/
   1048          
   1049          /**
   1050           * Convert the input data in the data chunk to a bit stream.
   1051           * @param entry
   1052           * @return number of bits (>0) or -1 for failure.
   1053           */

   \                                 In section .text, align 4, keep-with-next
   1054          static int QRinput_encodeBitStream(QRinput_List *entry, int version, int mqr)
   1055          {
   \                     QRinput_encodeBitStream: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   1056          	int words, ret;
   1057          	QRinput_List *st1 = NULL, *st2 = NULL;
   \   0000000A   0x2700             MOVS     R7,#+0
   1058          
   1059          	if(entry->bstream != NULL) {
   \   0000000C   0x68E0             LDR      R0,[R4, #+12]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD003             BEQ.N    ??QRinput_encodeBitStream_1
   1060          		BitStream_free(entry->bstream);
   \   00000012   0x.... 0x....      BL       BitStream_free
   1061          		entry->bstream = NULL;
   \   00000016   0x4638             MOV      R0,R7
   \   00000018   0x60E0             STR      R0,[R4, #+12]
   1062          	}
   1063          
   1064          	words = QRspec_maximumWords(entry->mode, version);
   \                     ??QRinput_encodeBitStream_1: (+1)
   \   0000001A   0x4629             MOV      R1,R5
   \   0000001C   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   00000020   0x.... 0x....      BL       QRspec_maximumWords
   \   00000024   0x4680             MOV      R8,R0
   1065          	if(words != 0 && entry->size > words) {
   \   00000026   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000002A   0xD040             BEQ.N    ??QRinput_encodeBitStream_2
   \   0000002C   0x6860             LDR      R0,[R4, #+4]
   \   0000002E   0x4580             CMP      R8,R0
   \   00000030   0xDA3D             BGE.N    ??QRinput_encodeBitStream_2
   1066          		st1 = QRinput_List_newEntry(entry->mode, words, entry->data);
   \   00000032   0x68A2             LDR      R2,[R4, #+8]
   \   00000034   0x4641             MOV      R1,R8
   \   00000036   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   0000003A   0x.... 0x....      BL       QRinput_List_newEntry
   \   0000003E   0x4681             MOV      R9,R0
   1067          		if(st1 == NULL) goto ABORT;
   \   00000040   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000044   0xD069             BEQ.N    ??QRinput_encodeBitStream_3
   1068          		st2 = QRinput_List_newEntry(entry->mode, entry->size - words, &entry->data[words]);
   \   00000046   0x68A0             LDR      R0,[R4, #+8]
   \   00000048   0xEB08 0x0200      ADD      R2,R8,R0
   \   0000004C   0x6860             LDR      R0,[R4, #+4]
   \   0000004E   0xEBA0 0x0108      SUB      R1,R0,R8
   \   00000052   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   00000056   0x.... 0x....      BL       QRinput_List_newEntry
   \   0000005A   0x0007             MOVS     R7,R0
   1069          		if(st2 == NULL) goto ABORT;
   \   0000005C   0xD05D             BEQ.N    ??QRinput_encodeBitStream_3
   1070          
   1071          		ret = QRinput_encodeBitStream(st1, version, mqr);
   1072          		if(ret < 0) goto ABORT;
   \   0000005E   0x4632             MOV      R2,R6
   \   00000060   0x4629             MOV      R1,R5
   \   00000062   0x4648             MOV      R0,R9
   \   00000064   0xF7FF 0xFFCC      BL       QRinput_encodeBitStream
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD456             BMI.N    ??QRinput_encodeBitStream_3
   1073          		ret = QRinput_encodeBitStream(st2, version, mqr);
   1074          		if(ret < 0) goto ABORT;
   \   0000006C   0x4632             MOV      R2,R6
   \   0000006E   0x4629             MOV      R1,R5
   \   00000070   0x4638             MOV      R0,R7
   \   00000072   0xF7FF 0xFFC5      BL       QRinput_encodeBitStream
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD44F             BMI.N    ??QRinput_encodeBitStream_3
   1075          		entry->bstream = BitStream_new();
   \   0000007A   0x.... 0x....      BL       BitStream_new
   \   0000007E   0x60E0             STR      R0,[R4, #+12]
   1076          		if(entry->bstream == NULL) goto ABORT;
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD04A             BEQ.N    ??QRinput_encodeBitStream_3
   1077          		ret = BitStream_append(entry->bstream, st1->bstream);
   1078          		if(ret < 0) goto ABORT;
   \   00000084   0xF8D9 0x100C      LDR      R1,[R9, #+12]
   \   00000088   0x.... 0x....      BL       BitStream_append
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD444             BMI.N    ??QRinput_encodeBitStream_3
   1079          		ret = BitStream_append(entry->bstream, st2->bstream);
   1080          		if(ret < 0) goto ABORT;
   \   00000090   0x68F9             LDR      R1,[R7, #+12]
   \   00000092   0x68E0             LDR      R0,[R4, #+12]
   \   00000094   0x.... 0x....      BL       BitStream_append
   \   00000098   0x2800             CMP      R0,#+0
   \   0000009A   0xD43E             BMI.N    ??QRinput_encodeBitStream_3
   1081          		QRinput_List_freeEntry(st1);
   \   0000009C   0x4648             MOV      R0,R9
   \   0000009E   0x.... 0x....      BL       QRinput_List_freeEntry
   1082          		QRinput_List_freeEntry(st2);
   \   000000A2   0x4638             MOV      R0,R7
   \   000000A4   0x.... 0x....      BL       QRinput_List_freeEntry
   1083          	} else {
   1084          		ret = 0;
   1085          		switch(entry->mode) {
   1086          			case QR_MODE_NUM:
   1087          				ret = QRinput_encodeModeNum(entry, version, mqr);
   1088          				break;
   1089          			case QR_MODE_AN:
   1090          				ret = QRinput_encodeModeAn(entry, version, mqr);
   1091          				break;
   1092          			case QR_MODE_8:
   1093          				ret = QRinput_encodeMode8(entry, version, mqr);
   1094          				break;
   1095          			case QR_MODE_KANJI:
   1096          				ret = QRinput_encodeModeKanji(entry, version, mqr);
   1097          				break;
   1098          			case QR_MODE_STRUCTURE:
   1099          				ret = QRinput_encodeModeStructure(entry, mqr);
   1100          				break;
   1101          			case QR_MODE_ECI:
   1102          				ret = QRinput_encodeModeECI(entry, version);
   1103          				break;
   1104          			case QR_MODE_FNC1SECOND:
   1105          				ret = QRinput_encodeModeFNC1Second(entry, version);
   1106          				break;
   1107          			default:
   1108          				break;
   1109          		}
   1110          		if(ret < 0) return -1;
   1111          	}
   1112          
   1113          	return BitStream_size(entry->bstream);
   \                     ??QRinput_encodeBitStream_4: (+1)
   \   000000A8   0x68E0             LDR      R0,[R4, #+12]
   \   000000AA   0x6800             LDR      R0,[R0, #+0]
   \   000000AC   0xE03D             B.N      ??QRinput_encodeBitStream_5
   \                     ??QRinput_encodeBitStream_2: (+1)
   \   000000AE   0x4638             MOV      R0,R7
   \   000000B0   0xF994 0x1000      LDRSB    R1,[R4, #+0]
   \   000000B4   0x2907             CMP      R1,#+7
   \   000000B6   0xD82B             BHI.N    ??QRinput_encodeBitStream_6
   \   000000B8   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??QRinput_encodeBitStream_0:
   \   000000BC   0x04 0x0A          DC8      0x4,0xA,0x10,0x16
   \              0x10 0x16    
   \   000000C0   0x1C 0x21          DC8      0x1C,0x21,0x2A,0x26
   \              0x2A 0x26    
   \                     ??QRinput_encodeBitStream_7: (+1)
   \   000000C4   0x4632             MOV      R2,R6
   \   000000C6   0x4629             MOV      R1,R5
   \   000000C8   0x4620             MOV      R0,R4
   \   000000CA   0x.... 0x....      BL       QRinput_encodeModeNum
   \   000000CE   0xE01F             B.N      ??QRinput_encodeBitStream_6
   \                     ??QRinput_encodeBitStream_8: (+1)
   \   000000D0   0x4632             MOV      R2,R6
   \   000000D2   0x4629             MOV      R1,R5
   \   000000D4   0x4620             MOV      R0,R4
   \   000000D6   0x.... 0x....      BL       QRinput_encodeModeAn
   \   000000DA   0xE019             B.N      ??QRinput_encodeBitStream_6
   \                     ??QRinput_encodeBitStream_9: (+1)
   \   000000DC   0x4632             MOV      R2,R6
   \   000000DE   0x4629             MOV      R1,R5
   \   000000E0   0x4620             MOV      R0,R4
   \   000000E2   0x.... 0x....      BL       QRinput_encodeMode8
   \   000000E6   0xE013             B.N      ??QRinput_encodeBitStream_6
   \                     ??QRinput_encodeBitStream_10: (+1)
   \   000000E8   0x4632             MOV      R2,R6
   \   000000EA   0x4629             MOV      R1,R5
   \   000000EC   0x4620             MOV      R0,R4
   \   000000EE   0x.... 0x....      BL       QRinput_encodeModeKanji
   \   000000F2   0xE00D             B.N      ??QRinput_encodeBitStream_6
   \                     ??QRinput_encodeBitStream_11: (+1)
   \   000000F4   0x4631             MOV      R1,R6
   \   000000F6   0x4620             MOV      R0,R4
   \   000000F8   0x.... 0x....      BL       QRinput_encodeModeStructure
   \   000000FC   0xE008             B.N      ??QRinput_encodeBitStream_6
   \                     ??QRinput_encodeBitStream_12: (+1)
   \   000000FE   0x4629             MOV      R1,R5
   \   00000100   0x4620             MOV      R0,R4
   \   00000102   0x.... 0x....      BL       QRinput_encodeModeECI
   \   00000106   0xE003             B.N      ??QRinput_encodeBitStream_6
   \                     ??QRinput_encodeBitStream_13: (+1)
   \   00000108   0x4629             MOV      R1,R5
   \   0000010A   0x4620             MOV      R0,R4
   \   0000010C   0x.... 0x....      BL       QRinput_encodeModeFNC1Second
   \                     ??QRinput_encodeBitStream_6: (+1)
   \   00000110   0x2800             CMP      R0,#+0
   \   00000112   0xD5C9             BPL.N    ??QRinput_encodeBitStream_4
   \   00000114   0xF04F 0x30FF      MOV      R0,#-1
   \   00000118   0xE007             B.N      ??QRinput_encodeBitStream_5
   1114          ABORT:
   1115          	QRinput_List_freeEntry(st1);
   \                     ??QRinput_encodeBitStream_3: (+1)
   \   0000011A   0x4648             MOV      R0,R9
   \   0000011C   0x.... 0x....      BL       QRinput_List_freeEntry
   1116          	QRinput_List_freeEntry(st2);
   \   00000120   0x4638             MOV      R0,R7
   \   00000122   0x.... 0x....      BL       QRinput_List_freeEntry
   1117          	return -1;
   \   00000126   0xF04F 0x30FF      MOV      R0,#-1
   \                     ??QRinput_encodeBitStream_5: (+1)
   \   0000012A   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1118          }
   1119          
   1120          /**
   1121           * Convert the input data to a bit stream.
   1122           * @param input input data.
   1123           * @retval 0 success
   1124           * @retval -1 an error occurred and errno is set to indeicate the error.
   1125           *            See Execptions for the details.
   1126           * @throw ENOMEM unable to allocate memory.
   1127           */

   \                                 In section .text, align 2, keep-with-next
   1128          static int QRinput_createBitStream(QRinput *input)
   1129          {
   \                     QRinput_createBitStream: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   1130          	QRinput_List *list;
   1131          	int bits, total = 0;
   \   00000004   0x2500             MOVS     R5,#+0
   1132          
   1133          	list = input->head;
   \   00000006   0x68A6             LDR      R6,[R4, #+8]
   \   00000008   0xE001             B.N      ??QRinput_createBitStream_0
   1134          	while(list != NULL) {
   1135          		bits = QRinput_encodeBitStream(list, input->version, input->mqr);
   1136          		if(bits < 0) return -1;
   1137          		total += bits;
   \                     ??QRinput_createBitStream_1: (+1)
   \   0000000A   0x1945             ADDS     R5,R0,R5
   1138          		list = list->next;
   \   0000000C   0x6936             LDR      R6,[R6, #+16]
   \                     ??QRinput_createBitStream_0: (+1)
   \   0000000E   0x2E00             CMP      R6,#+0
   \   00000010   0xD009             BEQ.N    ??QRinput_createBitStream_2
   \   00000012   0x6922             LDR      R2,[R4, #+16]
   \   00000014   0x6821             LDR      R1,[R4, #+0]
   \   00000016   0x4630             MOV      R0,R6
   \   00000018   0x.... 0x....      BL       QRinput_encodeBitStream
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD5F4             BPL.N    ??QRinput_createBitStream_1
   \   00000020   0xF04F 0x30FF      MOV      R0,#-1
   \   00000024   0xBD70             POP      {R4-R6,PC}
   1139          	}
   1140          
   1141          	return total;
   \                     ??QRinput_createBitStream_2: (+1)
   \   00000026   0x4628             MOV      R0,R5
   \   00000028   0xBD70             POP      {R4-R6,PC}       ;; return
   1142          }
   1143          
   1144          /**
   1145           * Convert the input data to a bit stream.
   1146           * When the version number is given and that is not sufficient, it is increased
   1147           * automatically.
   1148           * @param input input data.
   1149           * @retval 0 success
   1150           * @retval -1 an error occurred and errno is set to indeicate the error.
   1151           *            See Execptions for the details.
   1152           * @throw ENOMEM unable to allocate memory.
   1153           * @throw ERANGE input is too large.
   1154           */

   \                                 In section .text, align 2, keep-with-next
   1155          static int QRinput_convertData(QRinput *input)
   1156          {
   \                     QRinput_convertData: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1157          	int bits;
   1158          	int ver;
   1159          
   1160          	ver = QRinput_estimateVersion(input);
   \   00000004   0x.... 0x....      BL       QRinput_estimateVersion
   \   00000008   0x4605             MOV      R5,R0
   1161          	if(ver > QRinput_getVersion(input)) {
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       QRinput_getVersion
   \   00000010   0x42A8             CMP      R0,R5
   \   00000012   0xDA08             BGE.N    ??QRinput_convertData_0
   1162          		QRinput_setVersion(input, ver);
   \   00000014   0x4629             MOV      R1,R5
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       QRinput_setVersion
   \   0000001C   0xE003             B.N      ??QRinput_convertData_0
   1163          	}
   1164          
   1165          	for(;;) {
   1166          		bits = QRinput_createBitStream(input);
   1167          		if(bits < 0) return -1;
   1168          		ver = QRspec_getMinimumVersion((bits + 7) / 8, input->level);
   1169          		if(ver < 0) {
   1170          			errno = ERANGE;
   1171          			return -1;
   1172          		} else if(ver > QRinput_getVersion(input)) {
   1173          			QRinput_setVersion(input, ver);
   \                     ??QRinput_convertData_1: (+1)
   \   0000001E   0x4629             MOV      R1,R5
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       QRinput_setVersion
   1174          		} else {
   \                     ??QRinput_convertData_0: (+1)
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       QRinput_createBitStream
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD502             BPL.N    ??QRinput_convertData_2
   \   00000030   0xF04F 0x30FF      MOV      R0,#-1
   \   00000034   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??QRinput_convertData_2: (+1)
   \   00000036   0x1DC0             ADDS     R0,R0,#+7
   \   00000038   0xF994 0x1004      LDRSB    R1,[R4, #+4]
   \   0000003C   0x1082             ASRS     R2,R0,#+2
   \   0000003E   0xEB00 0x7052      ADD      R0,R0,R2, LSR #+29
   \   00000042   0x10C0             ASRS     R0,R0,#+3
   \   00000044   0x.... 0x....      BL       QRspec_getMinimumVersion
   \   00000048   0x0005             MOVS     R5,R0
   \   0000004A   0xD506             BPL.N    ??QRinput_convertData_3
   \   0000004C   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000050   0x2122             MOVS     R1,#+34
   \   00000052   0x6001             STR      R1,[R0, #+0]
   \   00000054   0xF04F 0x30FF      MOV      R0,#-1
   \   00000058   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??QRinput_convertData_3: (+1)
   \   0000005A   0x4620             MOV      R0,R4
   \   0000005C   0x.... 0x....      BL       QRinput_getVersion
   \   00000060   0x42A8             CMP      R0,R5
   \   00000062   0xDBDC             BLT.N    ??QRinput_convertData_1
   1175          			break;
   1176          		}
   1177          	}
   1178          
   1179          	return 0;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1180          }
   1181          
   1182          /**
   1183           * Append padding bits for the input data.
   1184           * @param bstream Bitstream to be appended.
   1185           * @param input input data.
   1186           * @retval 0 success
   1187           * @retval -1 an error occurred and errno is set to indeicate the error.
   1188           *            See Execptions for the details.
   1189           * @throw ERANGE input data is too large.
   1190           * @throw ENOMEM unable to allocate memory.
   1191           */

   \                                 In section .text, align 2, keep-with-next
   1192          static int QRinput_appendPaddingBit(BitStream *bstream, QRinput *input)
   1193          {
   \                     QRinput_appendPaddingBit: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4608             MOV      R0,R1
   1194          	int bits, maxbits, words, maxwords, i, ret;
   1195          	BitStream *padding = NULL;
   \   00000008   0x2500             MOVS     R5,#+0
   1196          	unsigned char *padbuf;
   1197          	int padlen;
   1198          
   1199          	bits = BitStream_size(bstream);
   \   0000000A   0x6826             LDR      R6,[R4, #+0]
   1200          	maxwords = QRspec_getDataLength(input->version, input->level);
   \   0000000C   0xF990 0x1004      LDRSB    R1,[R0, #+4]
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x.... 0x....      BL       QRspec_getDataLength
   \   00000016   0x4607             MOV      R7,R0
   1201          	maxbits = maxwords * 8;
   \   00000018   0x00F8             LSLS     R0,R7,#+3
   1202          
   1203          	if(maxbits < bits) {
   \   0000001A   0x42B0             CMP      R0,R6
   \   0000001C   0xDA06             BGE.N    ??QRinput_appendPaddingBit_0
   1204          		errno = ERANGE;
   \   0000001E   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000022   0x2122             MOVS     R1,#+34
   \   00000024   0x6001             STR      R1,[R0, #+0]
   1205          		return -1;
   \   00000026   0xF04F 0x30FF      MOV      R0,#-1
   \   0000002A   0xE04B             B.N      ??QRinput_appendPaddingBit_1
   1206          	}
   1207          	if(maxbits == bits) {
   \                     ??QRinput_appendPaddingBit_0: (+1)
   \   0000002C   0xD101             BNE.N    ??QRinput_appendPaddingBit_2
   1208          		return 0;
   \   0000002E   0x4628             MOV      R0,R5
   \   00000030   0xE048             B.N      ??QRinput_appendPaddingBit_1
   1209          	}
   1210          
   1211          	if(maxbits - bits <= 4) {
   \                     ??QRinput_appendPaddingBit_2: (+1)
   \   00000032   0x1B81             SUBS     R1,R0,R6
   \   00000034   0x2905             CMP      R1,#+5
   \   00000036   0xDA05             BGE.N    ??QRinput_appendPaddingBit_3
   1212          		ret = BitStream_appendNum(bstream, maxbits - bits, 0);
   \   00000038   0x462A             MOV      R2,R5
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x.... 0x....      BL       BitStream_appendNum
   \   00000040   0x4606             MOV      R6,R0
   1213          		goto DONE;
   \   00000042   0xE03B             B.N      ??QRinput_appendPaddingBit_4
   1214          	}
   1215          
   1216          	words = (bits + 4 + 7) / 8;
   \                     ??QRinput_appendPaddingBit_3: (+1)
   \   00000044   0xF106 0x000B      ADD      R0,R6,#+11
   \   00000048   0x1081             ASRS     R1,R0,#+2
   \   0000004A   0xEB00 0x7051      ADD      R0,R0,R1, LSR #+29
   \   0000004E   0xEA4F 0x08E0      ASR      R8,R0,#+3
   1217          
   1218          	padding = BitStream_new();
   \   00000052   0x.... 0x....      BL       BitStream_new
   \   00000056   0x0005             MOVS     R5,R0
   1219          	if(padding == NULL) return -1;
   \   00000058   0xD102             BNE.N    ??QRinput_appendPaddingBit_5
   \   0000005A   0xF04F 0x30FF      MOV      R0,#-1
   \   0000005E   0xE031             B.N      ??QRinput_appendPaddingBit_1
   1220          	ret = BitStream_appendNum(padding, words * 8 - bits, 0);
   \                     ??QRinput_appendPaddingBit_5: (+1)
   \   00000060   0x2200             MOVS     R2,#+0
   \   00000062   0xEBC6 0x01C8      RSB      R1,R6,R8, LSL #+3
   \   00000066   0x.... 0x....      BL       BitStream_appendNum
   \   0000006A   0x0006             MOVS     R6,R0
   1221          	if(ret < 0) goto DONE;
   \   0000006C   0xD426             BMI.N    ??QRinput_appendPaddingBit_4
   1222          
   1223          	padlen = maxwords - words;
   \   0000006E   0xEBA7 0x0608      SUB      R6,R7,R8
   1224          	if(padlen > 0) {
   \   00000072   0x2E01             CMP      R6,#+1
   \   00000074   0xDB1D             BLT.N    ??QRinput_appendPaddingBit_6
   1225          		padbuf = (unsigned char *)malloc(padlen);
   \   00000076   0x4630             MOV      R0,R6
   \   00000078   0x.... 0x....      BL       malloc
   \   0000007C   0x0007             MOVS     R7,R0
   1226          		if(padbuf == NULL) {
   \   0000007E   0xD102             BNE.N    ??QRinput_appendPaddingBit_7
   1227          			ret = -1;
   \   00000080   0xF04F 0x36FF      MOV      R6,#-1
   1228          			goto DONE;
   \   00000084   0xE01A             B.N      ??QRinput_appendPaddingBit_4
   1229          		}
   1230          		for(i=0; i<padlen; i++) {
   \                     ??QRinput_appendPaddingBit_7: (+1)
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0xE002             B.N      ??QRinput_appendPaddingBit_8
   1231          			padbuf[i] = (i&1)?0x11:0xec;
   \                     ??QRinput_appendPaddingBit_9: (+1)
   \   0000008A   0x21EC             MOVS     R1,#+236
   \                     ??QRinput_appendPaddingBit_10: (+1)
   \   0000008C   0x55C1             STRB     R1,[R0, R7]
   \   0000008E   0x1C40             ADDS     R0,R0,#+1
   \                     ??QRinput_appendPaddingBit_8: (+1)
   \   00000090   0x42B0             CMP      R0,R6
   \   00000092   0xDA03             BGE.N    ??QRinput_appendPaddingBit_11
   \   00000094   0x07C1             LSLS     R1,R0,#+31
   \   00000096   0xD5F8             BPL.N    ??QRinput_appendPaddingBit_9
   \   00000098   0x2111             MOVS     R1,#+17
   \   0000009A   0xE7F7             B.N      ??QRinput_appendPaddingBit_10
   1232          		}
   1233          		ret = BitStream_appendBytes(padding, padlen, padbuf);
   \                     ??QRinput_appendPaddingBit_11: (+1)
   \   0000009C   0x463A             MOV      R2,R7
   \   0000009E   0x4631             MOV      R1,R6
   \   000000A0   0x4628             MOV      R0,R5
   \   000000A2   0x.... 0x....      BL       BitStream_appendBytes
   \   000000A6   0x4606             MOV      R6,R0
   1234          		free(padbuf);
   \   000000A8   0x4638             MOV      R0,R7
   \   000000AA   0x.... 0x....      BL       free
   1235          		if(ret < 0) {
   \   000000AE   0x2E00             CMP      R6,#+0
   \   000000B0   0xD404             BMI.N    ??QRinput_appendPaddingBit_4
   1236          			goto DONE;
   1237          		}
   1238          	}
   1239          
   1240          	ret = BitStream_append(bstream, padding);
   \                     ??QRinput_appendPaddingBit_6: (+1)
   \   000000B2   0x4629             MOV      R1,R5
   \   000000B4   0x4620             MOV      R0,R4
   \   000000B6   0x.... 0x....      BL       BitStream_append
   \   000000BA   0x4606             MOV      R6,R0
   1241          
   1242          DONE:
   1243          	BitStream_free(padding);
   \                     ??QRinput_appendPaddingBit_4: (+1)
   \   000000BC   0x4628             MOV      R0,R5
   \   000000BE   0x.... 0x....      BL       BitStream_free
   1244          	return ret;
   \   000000C2   0x4630             MOV      R0,R6
   \                     ??QRinput_appendPaddingBit_1: (+1)
   \   000000C4   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1245          }
   1246          
   1247          /**
   1248           * Append padding bits for the input data - Micro QR Code version.
   1249           * @param bstream Bitstream to be appended.
   1250           * @param input input data.
   1251           * @retval 0 success
   1252           * @retval -1 an error occurred and errno is set to indeicate the error.
   1253           *            See Execptions for the details.
   1254           * @throw ERANGE input data is too large.
   1255           * @throw ENOMEM unable to allocate memory.
   1256           */

   \                                 In section .text, align 2, keep-with-next
   1257          static int QRinput_appendPaddingBitMQR(BitStream *bstream, QRinput *input)
   1258          {
   \                     QRinput_appendPaddingBitMQR: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4689             MOV      R9,R1
   1259          	int bits, maxbits, words, maxwords, i, ret, termbits;
   1260          	BitStream *padding = NULL;
   \   00000008   0x2500             MOVS     R5,#+0
   1261          	unsigned char *padbuf;
   1262          	int padlen;
   1263          
   1264          	bits = BitStream_size(bstream);
   \   0000000A   0xF8D4 0x8000      LDR      R8,[R4, #+0]
   1265          	maxbits = MQRspec_getDataLengthBit(input->version, input->level);
   \   0000000E   0xF999 0x1004      LDRSB    R1,[R9, #+4]
   \   00000012   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   00000016   0x.... 0x....      BL       MQRspec_getDataLengthBit
   \   0000001A   0x4606             MOV      R6,R0
   1266          	maxwords = maxbits / 8;
   \   0000001C   0x10B0             ASRS     R0,R6,#+2
   \   0000001E   0xEB06 0x7050      ADD      R0,R6,R0, LSR #+29
   \   00000022   0x10C7             ASRS     R7,R0,#+3
   1267          
   1268          	if(maxbits < bits) {
   \   00000024   0x4546             CMP      R6,R8
   \   00000026   0xDA06             BGE.N    ??QRinput_appendPaddingBitMQR_0
   1269          		errno = ERANGE;
   \   00000028   0x.... 0x....      BL       __aeabi_errno_addr
   \   0000002C   0x2122             MOVS     R1,#+34
   \   0000002E   0x6001             STR      R1,[R0, #+0]
   1270          		return -1;
   \   00000030   0xF04F 0x30FF      MOV      R0,#-1
   \   00000034   0xE074             B.N      ??QRinput_appendPaddingBitMQR_1
   1271          	}
   1272          	if(maxbits == bits) {
   \                     ??QRinput_appendPaddingBitMQR_0: (+1)
   \   00000036   0xD101             BNE.N    ??QRinput_appendPaddingBitMQR_2
   1273          		return 0;
   \   00000038   0x4628             MOV      R0,R5
   \   0000003A   0xE071             B.N      ??QRinput_appendPaddingBitMQR_1
   1274          	}
   1275          
   1276          	termbits = input->version * 2 + 1;
   \                     ??QRinput_appendPaddingBitMQR_2: (+1)
   \   0000003C   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   00000040   0x0040             LSLS     R0,R0,#+1
   \   00000042   0xF100 0x0901      ADD      R9,R0,#+1
   1277          
   1278          	if(maxbits - bits <= termbits) {
   \   00000046   0xEBA6 0x0108      SUB      R1,R6,R8
   \   0000004A   0x4589             CMP      R9,R1
   \   0000004C   0xDB05             BLT.N    ??QRinput_appendPaddingBitMQR_3
   1279          		ret = BitStream_appendNum(bstream, maxbits - bits, 0);
   \   0000004E   0x462A             MOV      R2,R5
   \   00000050   0x4620             MOV      R0,R4
   \   00000052   0x.... 0x....      BL       BitStream_appendNum
   \   00000056   0x4681             MOV      R9,R0
   1280          		goto DONE;
   \   00000058   0xE05E             B.N      ??QRinput_appendPaddingBitMQR_4
   1281          	}
   1282          
   1283          	bits += termbits;
   \                     ??QRinput_appendPaddingBitMQR_3: (+1)
   \   0000005A   0x44C8             ADD      R8,R9,R8
   1284          
   1285          	words = (bits + 7) / 8;
   \   0000005C   0xF108 0x0007      ADD      R0,R8,#+7
   \   00000060   0x1081             ASRS     R1,R0,#+2
   \   00000062   0xEB00 0x7051      ADD      R0,R0,R1, LSR #+29
   \   00000066   0xEA4F 0x0AE0      ASR      R10,R0,#+3
   1286          	if(maxbits - words * 8 > 0) {
   \   0000006A   0xEB09 0x01CA      ADD      R1,R9,R10, LSL #+3
   \   0000006E   0xEBA1 0x0908      SUB      R9,R1,R8
   \   00000072   0xEBB6 0x01CA      SUBS     R1,R6,R10, LSL #+3
   \   00000076   0x2901             CMP      R1,#+1
   \   00000078   0xDB05             BLT.N    ??QRinput_appendPaddingBitMQR_5
   1287          		termbits += words * 8 - bits;
   1288          		if(words == maxwords) termbits += maxbits - words * 8;
   \   0000007A   0x45BA             CMP      R10,R7
   \   0000007C   0xD103             BNE.N    ??QRinput_appendPaddingBitMQR_5
   \   0000007E   0xEB06 0x0109      ADD      R1,R6,R9
   \   00000082   0xEBA1 0x09CA      SUB      R9,R1,R10, LSL #+3
   1289          	} else {
   1290          		termbits += words * 8 - bits;
   1291          	}
   1292          	padding = BitStream_new();
   \                     ??QRinput_appendPaddingBitMQR_5: (+1)
   \   00000086   0x.... 0x....      BL       BitStream_new
   \   0000008A   0x0005             MOVS     R5,R0
   1293          	if(padding == NULL) return -1;
   \   0000008C   0xD102             BNE.N    ??QRinput_appendPaddingBitMQR_6
   \   0000008E   0xF04F 0x30FF      MOV      R0,#-1
   \   00000092   0xE045             B.N      ??QRinput_appendPaddingBitMQR_1
   1294          	ret = BitStream_appendNum(padding, termbits, 0);
   \                     ??QRinput_appendPaddingBitMQR_6: (+1)
   \   00000094   0x2200             MOVS     R2,#+0
   \   00000096   0x4649             MOV      R1,R9
   \   00000098   0x.... 0x....      BL       BitStream_appendNum
   \   0000009C   0x4681             MOV      R9,R0
   1295          	if(ret < 0) goto DONE;
   \   0000009E   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000A2   0xD439             BMI.N    ??QRinput_appendPaddingBitMQR_4
   1296          
   1297          	padlen = maxwords - words;
   \   000000A4   0xEBA7 0x090A      SUB      R9,R7,R10
   1298          	if(padlen > 0) {
   \   000000A8   0xF1B9 0x0F01      CMP      R9,#+1
   \   000000AC   0xDB2F             BLT.N    ??QRinput_appendPaddingBitMQR_7
   1299          		padbuf = (unsigned char *)malloc(padlen);
   \   000000AE   0x4648             MOV      R0,R9
   \   000000B0   0x.... 0x....      BL       malloc
   \   000000B4   0x4680             MOV      R8,R0
   1300          		if(padbuf == NULL) {
   \   000000B6   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000BA   0xD102             BNE.N    ??QRinput_appendPaddingBitMQR_8
   1301          			ret = -1;
   \   000000BC   0xF04F 0x39FF      MOV      R9,#-1
   1302          			goto DONE;
   \   000000C0   0xE02A             B.N      ??QRinput_appendPaddingBitMQR_4
   1303          		}
   1304          		for(i=0; i<padlen; i++) {
   \                     ??QRinput_appendPaddingBitMQR_8: (+1)
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0xE003             B.N      ??QRinput_appendPaddingBitMQR_9
   1305          			padbuf[i] = (i&1)?0x11:0xec;
   \                     ??QRinput_appendPaddingBitMQR_10: (+1)
   \   000000C6   0x21EC             MOVS     R1,#+236
   \                     ??QRinput_appendPaddingBitMQR_11: (+1)
   \   000000C8   0xF800 0x1008      STRB     R1,[R0, R8]
   \   000000CC   0x1C40             ADDS     R0,R0,#+1
   \                     ??QRinput_appendPaddingBitMQR_9: (+1)
   \   000000CE   0x4548             CMP      R0,R9
   \   000000D0   0xDA03             BGE.N    ??QRinput_appendPaddingBitMQR_12
   \   000000D2   0x07C1             LSLS     R1,R0,#+31
   \   000000D4   0xD5F7             BPL.N    ??QRinput_appendPaddingBitMQR_10
   \   000000D6   0x2111             MOVS     R1,#+17
   \   000000D8   0xE7F6             B.N      ??QRinput_appendPaddingBitMQR_11
   1306          		}
   1307          		ret = BitStream_appendBytes(padding, padlen, padbuf);
   \                     ??QRinput_appendPaddingBitMQR_12: (+1)
   \   000000DA   0x4642             MOV      R2,R8
   \   000000DC   0x4649             MOV      R1,R9
   \   000000DE   0x4628             MOV      R0,R5
   \   000000E0   0x.... 0x....      BL       BitStream_appendBytes
   \   000000E4   0x4681             MOV      R9,R0
   1308          		free(padbuf);
   \   000000E6   0x4640             MOV      R0,R8
   \   000000E8   0x.... 0x....      BL       free
   1309          		if(ret < 0) {
   \   000000EC   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000F0   0xD412             BMI.N    ??QRinput_appendPaddingBitMQR_4
   1310          			goto DONE;
   1311          		}
   1312          		termbits = maxbits - maxwords * 8;
   \   000000F2   0xEBA6 0x09C7      SUB      R9,R6,R7, LSL #+3
   1313          		if(termbits > 0) {
   \   000000F6   0xF1B9 0x0F01      CMP      R9,#+1
   \   000000FA   0xDB08             BLT.N    ??QRinput_appendPaddingBitMQR_7
   1314          			ret = BitStream_appendNum(padding, termbits, 0);
   \   000000FC   0x2200             MOVS     R2,#+0
   \   000000FE   0x4649             MOV      R1,R9
   \   00000100   0x4628             MOV      R0,R5
   \   00000102   0x.... 0x....      BL       BitStream_appendNum
   \   00000106   0x4681             MOV      R9,R0
   1315          			if(ret < 0) goto DONE;
   \   00000108   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000010C   0xD404             BMI.N    ??QRinput_appendPaddingBitMQR_4
   1316          		}
   1317          	}
   1318          
   1319          	ret = BitStream_append(bstream, padding);
   \                     ??QRinput_appendPaddingBitMQR_7: (+1)
   \   0000010E   0x4629             MOV      R1,R5
   \   00000110   0x4620             MOV      R0,R4
   \   00000112   0x.... 0x....      BL       BitStream_append
   \   00000116   0x4681             MOV      R9,R0
   1320          
   1321          DONE:
   1322          	BitStream_free(padding);
   \                     ??QRinput_appendPaddingBitMQR_4: (+1)
   \   00000118   0x4628             MOV      R0,R5
   \   0000011A   0x.... 0x....      BL       BitStream_free
   1323          	return ret;
   \   0000011E   0x4648             MOV      R0,R9
   \                     ??QRinput_appendPaddingBitMQR_1: (+1)
   \   00000120   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   1324          }
   1325          

   \                                 In section .text, align 2, keep-with-next
   1326          static int QRinput_insertFNC1Header(QRinput *input)
   1327          {
   \                     QRinput_insertFNC1Header: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1328          	QRinput_List *entry = NULL;
   \   00000004   0x2000             MOVS     R0,#+0
   1329          
   1330          	if(input->fnc1 == 1) {
   \   00000006   0x6961             LDR      R1,[R4, #+20]
   \   00000008   0x2901             CMP      R1,#+1
   \   0000000A   0xD105             BNE.N    ??QRinput_insertFNC1Header_0
   1331          		entry = QRinput_List_newEntry(QR_MODE_FNC1FIRST, 0, NULL);
   \   0000000C   0x4602             MOV      R2,R0
   \   0000000E   0x4601             MOV      R1,R0
   \   00000010   0x2006             MOVS     R0,#+6
   \   00000012   0x.... 0x....      BL       QRinput_List_newEntry
   \   00000016   0xE007             B.N      ??QRinput_insertFNC1Header_1
   1332          	} else if(input->fnc1 == 2) {
   \                     ??QRinput_insertFNC1Header_0: (+1)
   \   00000018   0x2902             CMP      R1,#+2
   \   0000001A   0xD105             BNE.N    ??QRinput_insertFNC1Header_1
   1333          		entry = QRinput_List_newEntry(QR_MODE_FNC1SECOND, 1, &(input->appid));
   \   0000001C   0xF104 0x0218      ADD      R2,R4,#+24
   \   00000020   0x2101             MOVS     R1,#+1
   \   00000022   0x2007             MOVS     R0,#+7
   \   00000024   0x.... 0x....      BL       QRinput_List_newEntry
   1334          	}
   1335          	if(entry == NULL) {
   \                     ??QRinput_insertFNC1Header_1: (+1)
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD102             BNE.N    ??QRinput_insertFNC1Header_2
   1336          		return -1;
   \   0000002C   0xF04F 0x30FF      MOV      R0,#-1
   \   00000030   0xBD10             POP      {R4,PC}
   1337          	}
   1338          
   1339          	if(input->head->mode != QR_MODE_STRUCTURE || input->head->mode != QR_MODE_ECI) {
   \                     ??QRinput_insertFNC1Header_2: (+1)
   \   00000032   0x68A1             LDR      R1,[R4, #+8]
   \   00000034   0xF991 0x2000      LDRSB    R2,[R1, #+0]
   \   00000038   0x2A04             CMP      R2,#+4
   \   0000003A   0xD101             BNE.N    ??QRinput_insertFNC1Header_3
   \   0000003C   0x2A05             CMP      R2,#+5
   \   0000003E   0xD002             BEQ.N    ??QRinput_insertFNC1Header_4
   1340          		entry->next = input->head;
   \                     ??QRinput_insertFNC1Header_3: (+1)
   \   00000040   0x6101             STR      R1,[R0, #+16]
   1341          		input->head = entry;
   \   00000042   0x60A0             STR      R0,[R4, #+8]
   \   00000044   0xE003             B.N      ??QRinput_insertFNC1Header_5
   1342          	} else {
   1343          		entry->next = input->head->next;
   \                     ??QRinput_insertFNC1Header_4: (+1)
   \   00000046   0x6909             LDR      R1,[R1, #+16]
   \   00000048   0x6101             STR      R1,[R0, #+16]
   1344          		input->head->next = entry;
   \   0000004A   0x68A1             LDR      R1,[R4, #+8]
   \   0000004C   0x6108             STR      R0,[R1, #+16]
   1345          	}
   1346          
   1347          	return 0;
   \                     ??QRinput_insertFNC1Header_5: (+1)
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xBD10             POP      {R4,PC}          ;; return
   1348          }
   1349          
   1350          /**
   1351           * Merge all bit streams in the input data.
   1352           * @param input input data.
   1353           * @return merged bit stream
   1354           */
   1355          

   \                                 In section .text, align 2, keep-with-next
   1356          static BitStream *QRinput_mergeBitStream(QRinput *input)
   1357          {
   \                     QRinput_mergeBitStream: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1358          	BitStream *bstream;
   1359          	QRinput_List *list;
   1360          	int ret;
   1361          
   1362          	if(input->mqr) {
   \   00000004   0x6920             LDR      R0,[R4, #+16]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD005             BEQ.N    ??QRinput_mergeBitStream_0
   1363          		if(QRinput_createBitStream(input) < 0) {
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       QRinput_createBitStream
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD50D             BPL.N    ??QRinput_mergeBitStream_1
   \   00000014   0xE010             B.N      ??QRinput_mergeBitStream_2
   1364          			return NULL;
   1365          		}
   1366          	} else {
   1367          		if(input->fnc1) {
   \                     ??QRinput_mergeBitStream_0: (+1)
   \   00000016   0x6960             LDR      R0,[R4, #+20]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD004             BEQ.N    ??QRinput_mergeBitStream_3
   1368          			if(QRinput_insertFNC1Header(input) < 0) {
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       QRinput_insertFNC1Header
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD408             BMI.N    ??QRinput_mergeBitStream_2
   1369          				return NULL;
   1370          			}
   1371          		}
   1372          		if(QRinput_convertData(input) < 0) {
   \                     ??QRinput_mergeBitStream_3: (+1)
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       QRinput_convertData
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD403             BMI.N    ??QRinput_mergeBitStream_2
   1373          			return NULL;
   1374          		}
   1375          	}
   1376          
   1377          	bstream = BitStream_new();
   \                     ??QRinput_mergeBitStream_1: (+1)
   \   00000030   0x.... 0x....      BL       BitStream_new
   \   00000034   0x0005             MOVS     R5,R0
   1378          	if(bstream == NULL) return NULL;
   \   00000036   0xD101             BNE.N    ??QRinput_mergeBitStream_4
   \                     ??QRinput_mergeBitStream_2: (+1)
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xBD32             POP      {R1,R4,R5,PC}
   1379          
   1380          	list = input->head;
   \                     ??QRinput_mergeBitStream_4: (+1)
   \   0000003C   0x68A4             LDR      R4,[R4, #+8]
   \   0000003E   0xE000             B.N      ??QRinput_mergeBitStream_5
   1381          	while(list != NULL) {
   1382          		ret = BitStream_append(bstream, list->bstream);
   1383          		if(ret < 0) {
   1384          			BitStream_free(bstream);
   1385          			return NULL;
   1386          		}
   1387          		list = list->next;
   \                     ??QRinput_mergeBitStream_6: (+1)
   \   00000040   0x6924             LDR      R4,[R4, #+16]
   \                     ??QRinput_mergeBitStream_5: (+1)
   \   00000042   0x2C00             CMP      R4,#+0
   \   00000044   0xD00A             BEQ.N    ??QRinput_mergeBitStream_7
   \   00000046   0x68E1             LDR      R1,[R4, #+12]
   \   00000048   0x4628             MOV      R0,R5
   \   0000004A   0x.... 0x....      BL       BitStream_append
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD5F6             BPL.N    ??QRinput_mergeBitStream_6
   \   00000052   0x4628             MOV      R0,R5
   \   00000054   0x.... 0x....      BL       BitStream_free
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xBD32             POP      {R1,R4,R5,PC}
   1388          	}
   1389          
   1390          	return bstream;
   \                     ??QRinput_mergeBitStream_7: (+1)
   \   0000005C   0x4628             MOV      R0,R5
   \   0000005E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1391          }
   1392          
   1393          /**
   1394           * Merge all bit streams in the input data and append padding bits
   1395           * @param input input data.
   1396           * @return padded merged bit stream
   1397           */
   1398          

   \                                 In section .text, align 2, keep-with-next
   1399          static BitStream *QRinput_getBitStream(QRinput *input)
   1400          {
   \                     QRinput_getBitStream: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1401          	BitStream *bstream;
   1402          	int ret;
   1403          
   1404          	bstream = QRinput_mergeBitStream(input);
   \   00000004   0x.... 0x....      BL       QRinput_mergeBitStream
   \   00000008   0x0005             MOVS     R5,R0
   1405          	if(bstream == NULL) {
   \   0000000A   0xD101             BNE.N    ??QRinput_getBitStream_0
   1406          		return NULL;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xBD32             POP      {R1,R4,R5,PC}
   1407          	}
   1408          	if(input->mqr) {
   \                     ??QRinput_getBitStream_0: (+1)
   \   00000010   0x6920             LDR      R0,[R4, #+16]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0x4621             MOV      R1,R4
   \   00000016   0x4628             MOV      R0,R5
   \   00000018   0xD002             BEQ.N    ??QRinput_getBitStream_1
   1409          		ret = QRinput_appendPaddingBitMQR(bstream, input);
   \   0000001A   0x.... 0x....      BL       QRinput_appendPaddingBitMQR
   \   0000001E   0xE001             B.N      ??QRinput_getBitStream_2
   1410          	} else {
   1411          		ret = QRinput_appendPaddingBit(bstream, input);
   \                     ??QRinput_getBitStream_1: (+1)
   \   00000020   0x.... 0x....      BL       QRinput_appendPaddingBit
   1412          	}
   1413          	if(ret < 0) {
   \                     ??QRinput_getBitStream_2: (+1)
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0x4628             MOV      R0,R5
   \   00000028   0xD502             BPL.N    ??QRinput_getBitStream_3
   1414          		BitStream_free(bstream);
   \   0000002A   0x.... 0x....      BL       BitStream_free
   1415          		return NULL;
   \   0000002E   0x2000             MOVS     R0,#+0
   1416          	}
   1417          
   1418          	return bstream;
   \                     ??QRinput_getBitStream_3: (+1)
   \   00000030   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1419          }
   1420          
   1421          /**
   1422           * Pack all bit streams padding bits into a byte array.
   1423           * @param input input data.
   1424           * @return padded merged byte stream
   1425           */
   1426          

   \                                 In section .text, align 2, keep-with-next
   1427          unsigned char *QRinput_getByteStream(QRinput *input)
   1428          {
   \                     QRinput_getByteStream: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1429          	BitStream *bstream;
   1430          	unsigned char *array;
   1431          
   1432          	bstream = QRinput_getBitStream(input);
   \   00000002   0x.... 0x....      BL       QRinput_getBitStream
   \   00000006   0x0004             MOVS     R4,R0
   1433          	if(bstream == NULL) {
   \   00000008   0xD101             BNE.N    ??QRinput_getByteStream_0
   1434          		return NULL;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xBD32             POP      {R1,R4,R5,PC}
   1435          	}
   1436          	array = BitStream_toByte(bstream);
   \                     ??QRinput_getByteStream_0: (+1)
   \   0000000E   0x.... 0x....      BL       BitStream_toByte
   \   00000012   0x4605             MOV      R5,R0
   1437          	BitStream_free(bstream);
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       BitStream_free
   1438          
   1439          	return array;
   \   0000001A   0x4628             MOV      R0,R5
   \   0000001C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1440          }
   1441          
   1442          /******************************************************************************
   1443           * Structured input data
   1444           *****************************************************************************/
   1445          

   \                                 In section .text, align 2, keep-with-next
   1446          static QRinput_InputList *QRinput_InputList_newEntry(QRinput *input)
   1447          {
   \                     QRinput_InputList_newEntry: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1448          	QRinput_InputList *entry;
   1449          
   1450          	entry = (QRinput_InputList *)malloc(sizeof(QRinput_InputList));
   \   00000004   0x2008             MOVS     R0,#+8
   \   00000006   0x.... 0x....      BL       malloc
   1451          	if(entry == NULL) return NULL;
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD101             BNE.N    ??QRinput_InputList_newEntry_0
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xBD10             POP      {R4,PC}
   1452          
   1453          	entry->input = input;
   \                     ??QRinput_InputList_newEntry_0: (+1)
   \   00000012   0x6004             STR      R4,[R0, #+0]
   1454          	entry->next = NULL;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x6041             STR      R1,[R0, #+4]
   1455          
   1456          	return entry;
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
   1457          }
   1458          

   \                                 In section .text, align 2, keep-with-next
   1459          static void QRinput_InputList_freeEntry(QRinput_InputList *entry)
   1460          {
   \                     QRinput_InputList_freeEntry: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1461          	if(entry != NULL) {
   \   00000004   0xD007             BEQ.N    ??QRinput_InputList_freeEntry_0
   1462          		QRinput_free(entry->input);
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       QRinput_free
   1463          		free(entry);
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000012   0x.... 0x....      B.W      free
   1464          	}
   1465          }
   \                     ??QRinput_InputList_freeEntry_0: (+1)
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
   1466          

   \                                 In section .text, align 2, keep-with-next
   1467          QRinput_Struct *QRinput_Struct_new(void)
   1468          {
   \                     QRinput_Struct_new: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1469          	QRinput_Struct *s;
   1470          
   1471          	s = (QRinput_Struct *)malloc(sizeof(QRinput_Struct));
   \   00000002   0x2010             MOVS     R0,#+16
   \   00000004   0x.... 0x....      BL       malloc
   1472          	if(s == NULL) return NULL;
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD101             BNE.N    ??QRinput_Struct_new_0
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xBD02             POP      {R1,PC}
   1473          
   1474          	s->size = 0;
   \                     ??QRinput_Struct_new_0: (+1)
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6001             STR      R1,[R0, #+0]
   1475          	s->parity = -1;
   \   00000014   0xF04F 0x31FF      MOV      R1,#-1
   \   00000018   0x6041             STR      R1,[R0, #+4]
   1476          	s->head = NULL;
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x6081             STR      R1,[R0, #+8]
   1477          	s->tail = NULL;
   \   0000001E   0x60C1             STR      R1,[R0, #+12]
   1478          
   1479          	return s;
   \   00000020   0xBD02             POP      {R1,PC}          ;; return
   1480          }
   1481          

   \                                 In section .text, align 2, keep-with-next
   1482          void QRinput_Struct_setParity(QRinput_Struct *s, unsigned char parity)
   1483          {
   1484          	s->parity = (int)parity;
   \                     QRinput_Struct_setParity: (+1)
   \   00000000   0x6041             STR      R1,[R0, #+4]
   1485          }
   \   00000002   0x4770             BX       LR               ;; return
   1486          

   \                                 In section .text, align 2, keep-with-next
   1487          int QRinput_Struct_appendInput(QRinput_Struct *s, QRinput *input)
   1488          {
   \                     QRinput_Struct_appendInput: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4608             MOV      R0,R1
   1489          	QRinput_InputList *e;
   1490          
   1491          	if(input->mqr) {
   \   00000006   0x6901             LDR      R1,[R0, #+16]
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD006             BEQ.N    ??QRinput_Struct_appendInput_0
   1492          		errno = EINVAL;
   \   0000000C   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000010   0xF04F 0x31FF      MOV      R1,#-1
   \   00000014   0x6001             STR      R1,[R0, #+0]
   1493          		return -1;
   \   00000016   0x4608             MOV      R0,R1
   \   00000018   0xBD10             POP      {R4,PC}
   1494          	}
   1495          
   1496          	e = QRinput_InputList_newEntry(input);
   \                     ??QRinput_Struct_appendInput_0: (+1)
   \   0000001A   0x.... 0x....      BL       QRinput_InputList_newEntry
   1497          	if(e == NULL) return -1;
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD102             BNE.N    ??QRinput_Struct_appendInput_1
   \   00000022   0xF04F 0x30FF      MOV      R0,#-1
   \   00000026   0xBD10             POP      {R4,PC}
   1498          
   1499          	s->size++;
   \                     ??QRinput_Struct_appendInput_1: (+1)
   \   00000028   0x6821             LDR      R1,[R4, #+0]
   \   0000002A   0x1C49             ADDS     R1,R1,#+1
   \   0000002C   0x6021             STR      R1,[R4, #+0]
   1500          	if(s->tail == NULL) {
   \   0000002E   0x68E1             LDR      R1,[R4, #+12]
   \   00000030   0x2900             CMP      R1,#+0
   \   00000032   0xD102             BNE.N    ??QRinput_Struct_appendInput_2
   1501          		s->head = e;
   \   00000034   0x60A0             STR      R0,[R4, #+8]
   1502          		s->tail = e;
   \   00000036   0x60E0             STR      R0,[R4, #+12]
   \   00000038   0xE001             B.N      ??QRinput_Struct_appendInput_3
   1503          	} else {
   1504          		s->tail->next = e;
   \                     ??QRinput_Struct_appendInput_2: (+1)
   \   0000003A   0x6048             STR      R0,[R1, #+4]
   1505          		s->tail = e;
   \   0000003C   0x60E0             STR      R0,[R4, #+12]
   1506          	}
   1507          
   1508          	return s->size;
   \                     ??QRinput_Struct_appendInput_3: (+1)
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0xBD10             POP      {R4,PC}          ;; return
   1509          }
   1510          

   \                                 In section .text, align 2, keep-with-next
   1511          void QRinput_Struct_free(QRinput_Struct *s)
   1512          {
   \                     QRinput_Struct_free: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1513          	QRinput_InputList *list, *next;
   1514          	
   1515          	if(s != NULL) {
   \   00000004   0xD00C             BEQ.N    ??QRinput_Struct_free_0
   1516          		list = s->head;
   \   00000006   0x68A0             LDR      R0,[R4, #+8]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xE003             B.N      ??QRinput_Struct_free_1
   1517          		while(list != NULL) {
   1518          			next = list->next;
   \                     ??QRinput_Struct_free_2: (+1)
   \   0000000C   0x6845             LDR      R5,[R0, #+4]
   1519          			QRinput_InputList_freeEntry(list);
   \   0000000E   0x.... 0x....      BL       QRinput_InputList_freeEntry
   1520          			list = next;
   \   00000012   0x0028             MOVS     R0,R5
   1521          		}
   \                     ??QRinput_Struct_free_1: (+1)
   \   00000014   0xD1FA             BNE.N    ??QRinput_Struct_free_2
   1522          		free(s);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000001C   0x.... 0x....      B.W      free
   1523          	}
   1524          }
   \                     ??QRinput_Struct_free_0: (+1)
   \   00000020   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1525          

   \                                 In section .text, align 2, keep-with-next
   1526          static unsigned char QRinput_Struct_calcParity(QRinput_Struct *s)
   1527          {
   \                     QRinput_Struct_calcParity: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   1528          	QRinput_InputList *list;
   1529          	unsigned char parity = 0;
   \   00000004   0x2500             MOVS     R5,#+0
   1530          
   1531          	list = s->head;
   \   00000006   0x68A6             LDR      R6,[R4, #+8]
   \   00000008   0xE004             B.N      ??QRinput_Struct_calcParity_0
   1532          	while(list != NULL) {
   1533          		parity ^= QRinput_calcParity(list->input);
   \                     ??QRinput_Struct_calcParity_1: (+1)
   \   0000000A   0x6830             LDR      R0,[R6, #+0]
   \   0000000C   0x.... 0x....      BL       QRinput_calcParity
   \   00000010   0x4045             EORS     R5,R0,R5
   1534          		list = list->next;
   \   00000012   0x6876             LDR      R6,[R6, #+4]
   1535          	}
   \                     ??QRinput_Struct_calcParity_0: (+1)
   \   00000014   0x2E00             CMP      R6,#+0
   \   00000016   0xD1F8             BNE.N    ??QRinput_Struct_calcParity_1
   1536          
   1537          	QRinput_Struct_setParity(s, parity);
   \   00000018   0x4629             MOV      R1,R5
   \   0000001A   0xB2C9             UXTB     R1,R1
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       QRinput_Struct_setParity
   1538          
   1539          	return parity;
   \   00000022   0x4628             MOV      R0,R5
   \   00000024   0xB2C0             UXTB     R0,R0
   \   00000026   0xBD70             POP      {R4-R6,PC}       ;; return
   1540          }
   1541          

   \                                 In section .text, align 2, keep-with-next
   1542          static int QRinput_List_shrinkEntry(QRinput_List *entry, int bytes)
   1543          {
   \                     QRinput_List_shrinkEntry: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1544          	unsigned char *data;
   1545          
   1546          	data = (unsigned char *)malloc(bytes);
   \   00000006   0x4628             MOV      R0,R5
   \   00000008   0x.... 0x....      BL       malloc
   \   0000000C   0x0006             MOVS     R6,R0
   1547          	if(data == NULL) return -1;
   \   0000000E   0xD102             BNE.N    ??QRinput_List_shrinkEntry_0
   \   00000010   0xF04F 0x30FF      MOV      R0,#-1
   \   00000014   0xBD70             POP      {R4-R6,PC}
   1548          
   1549          	memcpy(data, entry->data, bytes);
   \                     ??QRinput_List_shrinkEntry_0: (+1)
   \   00000016   0x462A             MOV      R2,R5
   \   00000018   0x68A1             LDR      R1,[R4, #+8]
   \   0000001A   0x.... 0x....      BL       memcpy
   1550          	free(entry->data);
   \   0000001E   0x68A0             LDR      R0,[R4, #+8]
   \   00000020   0x.... 0x....      BL       free
   1551          	entry->data = data;
   \   00000024   0x60A6             STR      R6,[R4, #+8]
   1552          	entry->size = bytes;
   \   00000026   0x6065             STR      R5,[R4, #+4]
   1553          
   1554          	return 0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xBD70             POP      {R4-R6,PC}       ;; return
   1555          }
   1556          

   \                                 In section .text, align 2, keep-with-next
   1557          static int QRinput_splitEntry(QRinput_List *entry, int bytes)
   1558          {
   \                     QRinput_splitEntry: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1559          	QRinput_List *e;
   1560          	int ret;
   1561          
   1562          	e = QRinput_List_newEntry(entry->mode, entry->size - bytes, entry->data + bytes);
   \   00000006   0x68A0             LDR      R0,[R4, #+8]
   \   00000008   0x182A             ADDS     R2,R5,R0
   \   0000000A   0x6860             LDR      R0,[R4, #+4]
   \   0000000C   0x1B41             SUBS     R1,R0,R5
   \   0000000E   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   00000012   0x.... 0x....      BL       QRinput_List_newEntry
   \   00000016   0x0006             MOVS     R6,R0
   1563          	if(e == NULL) {
   \   00000018   0xD102             BNE.N    ??QRinput_splitEntry_0
   1564          		return -1;
   \   0000001A   0xF04F 0x30FF      MOV      R0,#-1
   \   0000001E   0xBD70             POP      {R4-R6,PC}
   1565          	}
   1566          
   1567          	ret = QRinput_List_shrinkEntry(entry, bytes);
   1568          	if(ret < 0) {
   \                     ??QRinput_splitEntry_0: (+1)
   \   00000020   0x4629             MOV      R1,R5
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       QRinput_List_shrinkEntry
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD505             BPL.N    ??QRinput_splitEntry_1
   1569          		QRinput_List_freeEntry(e);
   \   0000002C   0x4630             MOV      R0,R6
   \   0000002E   0x.... 0x....      BL       QRinput_List_freeEntry
   1570          		return -1;
   \   00000032   0xF04F 0x30FF      MOV      R0,#-1
   \   00000036   0xBD70             POP      {R4-R6,PC}
   1571          	}
   1572          
   1573          	e->next = entry->next;
   \                     ??QRinput_splitEntry_1: (+1)
   \   00000038   0x6920             LDR      R0,[R4, #+16]
   \   0000003A   0x6130             STR      R0,[R6, #+16]
   1574          	entry->next = e;
   \   0000003C   0x6126             STR      R6,[R4, #+16]
   1575          
   1576          	return 0;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xBD70             POP      {R4-R6,PC}       ;; return
   1577          }
   1578          

   \                                 In section .text, align 2, keep-with-next
   1579          QRinput_Struct *QRinput_splitQRinputToStruct(QRinput *input)
   1580          {
   \                     QRinput_splitQRinputToStruct: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   1581          	QRinput *p;
   1582          	QRinput_Struct *s;
   1583          	int bits, maxbits, nextbits, bytes, ret;
   1584          	QRinput_List *list, *next, *prev;
   1585          
   1586          	if(input->mqr) {
   \   00000006   0x6920             LDR      R0,[R4, #+16]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD006             BEQ.N    ??QRinput_splitQRinputToStruct_0
   1587          		errno = EINVAL;
   \   0000000C   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000010   0xF04F 0x31FF      MOV      R1,#-1
   \   00000014   0x6001             STR      R1,[R0, #+0]
   1588          		return NULL;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE082             B.N      ??QRinput_splitQRinputToStruct_1
   1589          	}
   1590          
   1591          	s = QRinput_Struct_new();
   \                     ??QRinput_splitQRinputToStruct_0: (+1)
   \   0000001A   0x.... 0x....      BL       QRinput_Struct_new
   \   0000001E   0x0005             MOVS     R5,R0
   1592          	if(s == NULL) return NULL;
   \   00000020   0xD101             BNE.N    ??QRinput_splitQRinputToStruct_2
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xE07C             B.N      ??QRinput_splitQRinputToStruct_1
   1593          
   1594          	input = QRinput_dup(input);
   \                     ??QRinput_splitQRinputToStruct_2: (+1)
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       QRinput_dup
   \   0000002C   0x0004             MOVS     R4,R0
   1595          	if(input == NULL) {
   \   0000002E   0xF000 0x8093      BEQ.W    ??QRinput_splitQRinputToStruct_3
   1596          		QRinput_Struct_free(s);
   1597          		return NULL;
   1598          	}
   1599          
   1600          	QRinput_Struct_setParity(s, QRinput_calcParity(input));
   \   00000032   0x.... 0x....      BL       QRinput_calcParity
   \   00000036   0x4601             MOV      R1,R0
   \   00000038   0x4628             MOV      R0,R5
   \   0000003A   0x.... 0x....      BL       QRinput_Struct_setParity
   1601          	maxbits = QRspec_getDataLength(input->version, input->level) * 8 - STRUCTURE_HEADER_SIZE;
   \   0000003E   0xF994 0x1004      LDRSB    R1,[R4, #+4]
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x.... 0x....      BL       QRspec_getDataLength
   \   00000048   0x00C0             LSLS     R0,R0,#+3
   \   0000004A   0xF1A0 0x0614      SUB      R6,R0,#+20
   1602          
   1603          	if(maxbits <= 0) {
   \   0000004E   0x2E01             CMP      R6,#+1
   \   00000050   0xDA07             BGE.N    ??QRinput_splitQRinputToStruct_4
   1604          		QRinput_Struct_free(s);
   \   00000052   0x4628             MOV      R0,R5
   \   00000054   0x.... 0x....      BL       QRinput_Struct_free
   1605          		QRinput_free(input);
   \   00000058   0x4620             MOV      R0,R4
   \   0000005A   0x.... 0x....      BL       QRinput_free
   1606          		return NULL;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xE05E             B.N      ??QRinput_splitQRinputToStruct_1
   1607          	}
   1608          
   1609          	bits = 0;
   \                     ??QRinput_splitQRinputToStruct_4: (+1)
   \   00000062   0xF04F 0x0900      MOV      R9,#+0
   1610          	list = input->head;
   \   00000066   0xF8D4 0x8008      LDR      R8,[R4, #+8]
   1611          	prev = NULL;
   \   0000006A   0x464F             MOV      R7,R9
   \   0000006C   0xE00A             B.N      ??QRinput_splitQRinputToStruct_5
   1612          	while(list != NULL) {
   1613          		nextbits = QRinput_estimateBitStreamSizeOfEntry(list, input->version, input->mqr);
   1614          		if(bits + nextbits <= maxbits) {
   1615          			ret = QRinput_encodeBitStream(list, input->version, input->mqr);
   \                     ??QRinput_splitQRinputToStruct_6: (+1)
   \   0000006E   0x6922             LDR      R2,[R4, #+16]
   \   00000070   0x4651             MOV      R1,R10
   \   00000072   0x4640             MOV      R0,R8
   \   00000074   0x.... 0x....      BL       QRinput_encodeBitStream
   1616          			if(ret < 0) goto ABORT;
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD44A             BMI.N    ??QRinput_splitQRinputToStruct_7
   1617          			bits += ret;
   \   0000007C   0x4481             ADD      R9,R0,R9
   1618          			prev = list;
   \   0000007E   0x4647             MOV      R7,R8
   1619          			list = list->next;
   \   00000080   0xF8D8 0x8010      LDR      R8,[R8, #+16]
   1620          		} else {
   \                     ??QRinput_splitQRinputToStruct_5: (+1)
   \   00000084   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000088   0xD050             BEQ.N    ??QRinput_splitQRinputToStruct_8
   \   0000008A   0xF8D4 0xA000      LDR      R10,[R4, #+0]
   \   0000008E   0x6922             LDR      R2,[R4, #+16]
   \   00000090   0x4651             MOV      R1,R10
   \   00000092   0x4640             MOV      R0,R8
   \   00000094   0x.... 0x....      BL       QRinput_estimateBitStreamSizeOfEntry
   \   00000098   0x4448             ADD      R0,R0,R9
   \   0000009A   0x4286             CMP      R6,R0
   \   0000009C   0xDAE7             BGE.N    ??QRinput_splitQRinputToStruct_6
   1621          			bytes = QRinput_lengthOfCode(list->mode, input->version, maxbits - bits);
   \   0000009E   0xEBA6 0x0209      SUB      R2,R6,R9
   \   000000A2   0x4651             MOV      R1,R10
   \   000000A4   0xF998 0x0000      LDRSB    R0,[R8, #+0]
   \   000000A8   0x.... 0x....      BL       QRinput_lengthOfCode
   \   000000AC   0x4682             MOV      R10,R0
   1622          			p = QRinput_new2(input->version, input->level);
   \   000000AE   0xF994 0x1004      LDRSB    R1,[R4, #+4]
   \   000000B2   0x6820             LDR      R0,[R4, #+0]
   \   000000B4   0x.... 0x....      BL       QRinput_new2
   \   000000B8   0x4681             MOV      R9,R0
   1623          			if(p == NULL) goto ABORT;
   \   000000BA   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000BE   0xD028             BEQ.N    ??QRinput_splitQRinputToStruct_7
   1624          			if(bytes > 0) {
   \   000000C0   0xF1BA 0x0F01      CMP      R10,#+1
   \   000000C4   0xDB14             BLT.N    ??QRinput_splitQRinputToStruct_9
   1625          				/* Splits this entry into 2 entries. */
   1626          				ret = QRinput_splitEntry(list, bytes);
   1627          				if(ret < 0) {
   \   000000C6   0x4651             MOV      R1,R10
   \   000000C8   0x4640             MOV      R0,R8
   \   000000CA   0x.... 0x....      BL       QRinput_splitEntry
   \   000000CE   0x2800             CMP      R0,#+0
   \   000000D0   0xD41C             BMI.N    ??QRinput_splitQRinputToStruct_10
   1628          					QRinput_free(p);
   1629          					goto ABORT;
   1630          				}
   1631          				/* First half is the tail of the current input. */
   1632          				next = list->next;
   \   000000D2   0xF8D8 0x0010      LDR      R0,[R8, #+16]
   1633          				list->next = NULL;
   \   000000D6   0x2100             MOVS     R1,#+0
   \   000000D8   0xF8C8 0x1010      STR      R1,[R8, #+16]
   1634          				/* Second half is the head of the next input, p.*/
   1635          				p->head = next;
   \   000000DC   0xF8C9 0x0008      STR      R0,[R9, #+8]
   1636          				/* Renew QRinput.tail. */
   1637          				p->tail = input->tail;
   \   000000E0   0x68E1             LDR      R1,[R4, #+12]
   \   000000E2   0xF8C9 0x100C      STR      R1,[R9, #+12]
   1638          				input->tail = list;
   \   000000E6   0xF8C4 0x800C      STR      R8,[R4, #+12]
   1639          				/* Point to the next entry. */
   1640          				prev = list;
   \   000000EA   0x4647             MOV      R7,R8
   1641          				list = next;
   \   000000EC   0x4680             MOV      R8,R0
   \   000000EE   0xE007             B.N      ??QRinput_splitQRinputToStruct_11
   1642          			} else {
   1643          				/* Current entry will go to the next input. */
   1644          				prev->next = NULL;
   \                     ??QRinput_splitQRinputToStruct_9: (+1)
   \   000000F0   0x2000             MOVS     R0,#+0
   \   000000F2   0x6138             STR      R0,[R7, #+16]
   1645          				p->head = list;
   \   000000F4   0xF8C9 0x8008      STR      R8,[R9, #+8]
   1646          				p->tail = input->tail;
   \   000000F8   0x68E0             LDR      R0,[R4, #+12]
   \   000000FA   0xF8C9 0x000C      STR      R0,[R9, #+12]
   1647          				input->tail = prev;
   \   000000FE   0x60E7             STR      R7,[R4, #+12]
   1648          			}
   1649          			ret = QRinput_Struct_appendInput(s, input);
   1650          			if(ret < 0) {
   \                     ??QRinput_splitQRinputToStruct_11: (+1)
   \   00000100   0x4621             MOV      R1,R4
   \   00000102   0x4628             MOV      R0,R5
   \   00000104   0x.... 0x....      BL       QRinput_Struct_appendInput
   \   00000108   0x2800             CMP      R0,#+0
   \   0000010A   0xD50B             BPL.N    ??QRinput_splitQRinputToStruct_12
   1651          				QRinput_free(p);
   \                     ??QRinput_splitQRinputToStruct_10: (+1)
   \   0000010C   0x4648             MOV      R0,R9
   \   0000010E   0x.... 0x....      BL       QRinput_free
   1652          				goto ABORT;
   1653          			}
   1654          			input = p;
   1655          			bits = 0;
   1656          		}
   1657          	}
   1658          	ret = QRinput_Struct_appendInput(s, input);
   1659          	if(ret < 0) goto ABORT;
   1660          	if(s->size > MAX_STRUCTURED_SYMBOLS) {
   1661          		QRinput_Struct_free(s);
   1662          		errno = ERANGE;
   1663          		return NULL;
   1664          	}
   1665          	ret = QRinput_Struct_insertStructuredAppendHeaders(s);
   1666          	if(ret < 0) {
   1667          		QRinput_Struct_free(s);
   1668          		return NULL;
   1669          	}
   1670          
   1671          	return s;
   1672          
   1673          ABORT:
   1674          	QRinput_free(input);
   \                     ??QRinput_splitQRinputToStruct_7: (+1)
   \   00000112   0x4620             MOV      R0,R4
   \   00000114   0x.... 0x....      BL       QRinput_free
   1675          	QRinput_Struct_free(s);
   \   00000118   0x4628             MOV      R0,R5
   \   0000011A   0x.... 0x....      BL       QRinput_Struct_free
   1676          	return NULL;
   \   0000011E   0x2000             MOVS     R0,#+0
   \                     ??QRinput_splitQRinputToStruct_1: (+1)
   \   00000120   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   \                     ??QRinput_splitQRinputToStruct_12: (+1)
   \   00000124   0x464C             MOV      R4,R9
   \   00000126   0xF04F 0x0900      MOV      R9,#+0
   \   0000012A   0xE7AB             B.N      ??QRinput_splitQRinputToStruct_5
   \                     ??QRinput_splitQRinputToStruct_8: (+1)
   \   0000012C   0x4621             MOV      R1,R4
   \   0000012E   0x4628             MOV      R0,R5
   \   00000130   0x.... 0x....      BL       QRinput_Struct_appendInput
   \   00000134   0x2800             CMP      R0,#+0
   \   00000136   0xD4EC             BMI.N    ??QRinput_splitQRinputToStruct_7
   \   00000138   0x6828             LDR      R0,[R5, #+0]
   \   0000013A   0x2811             CMP      R0,#+17
   \   0000013C   0x4628             MOV      R0,R5
   \   0000013E   0xDB07             BLT.N    ??QRinput_splitQRinputToStruct_13
   \   00000140   0x.... 0x....      BL       QRinput_Struct_free
   \   00000144   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000148   0x2122             MOVS     R1,#+34
   \   0000014A   0x6001             STR      R1,[R0, #+0]
   \   0000014C   0x2000             MOVS     R0,#+0
   \   0000014E   0xE7E7             B.N      ??QRinput_splitQRinputToStruct_1
   \                     ??QRinput_splitQRinputToStruct_13: (+1)
   \   00000150   0x.... 0x....      BL       QRinput_Struct_insertStructuredAppendHeaders
   \   00000154   0x2800             CMP      R0,#+0
   \   00000156   0xD504             BPL.N    ??QRinput_splitQRinputToStruct_14
   \                     ??QRinput_splitQRinputToStruct_3: (+1)
   \   00000158   0x4628             MOV      R0,R5
   \   0000015A   0x.... 0x....      BL       QRinput_Struct_free
   \   0000015E   0x2000             MOVS     R0,#+0
   \   00000160   0xE7DE             B.N      ??QRinput_splitQRinputToStruct_1
   \                     ??QRinput_splitQRinputToStruct_14: (+1)
   \   00000162   0x4628             MOV      R0,R5
   \   00000164   0xE7DC             B.N      ??QRinput_splitQRinputToStruct_1
   1677          }
   1678          

   \                                 In section .text, align 2, keep-with-next
   1679          int QRinput_Struct_insertStructuredAppendHeaders(QRinput_Struct *s)
   1680          {
   \                     QRinput_Struct_insertStructuredAppendHeaders: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   1681          	int i;
   1682          	QRinput_InputList *list;
   1683          
   1684          	if(s->size == 1) {
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD018             BEQ.N    ??QRinput_Struct_insertStructuredAppendHeaders_0
   1685          		return 0;
   1686          	}
   1687          
   1688          	if(s->parity < 0) {
   \   0000000A   0x6860             LDR      R0,[R4, #+4]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD502             BPL.N    ??QRinput_Struct_insertStructuredAppendHeaders_1
   1689          		QRinput_Struct_calcParity(s);
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       QRinput_Struct_calcParity
   1690          	}
   1691          	i = 1;
   \                     ??QRinput_Struct_insertStructuredAppendHeaders_1: (+1)
   \   00000016   0x2501             MOVS     R5,#+1
   1692          	list = s->head;
   \   00000018   0x68A6             LDR      R6,[R4, #+8]
   \   0000001A   0xE001             B.N      ??QRinput_Struct_insertStructuredAppendHeaders_2
   1693          	while(list != NULL) {
   1694          		if(QRinput_insertStructuredAppendHeader(list->input, s->size, i, s->parity))
   1695          			return -1;
   1696          		i++;
   \                     ??QRinput_Struct_insertStructuredAppendHeaders_3: (+1)
   \   0000001C   0x1C6D             ADDS     R5,R5,#+1
   1697          		list = list->next;
   \   0000001E   0x6876             LDR      R6,[R6, #+4]
   \                     ??QRinput_Struct_insertStructuredAppendHeaders_2: (+1)
   \   00000020   0x2E00             CMP      R6,#+0
   \   00000022   0xD00B             BEQ.N    ??QRinput_Struct_insertStructuredAppendHeaders_0
   \   00000024   0x6863             LDR      R3,[R4, #+4]
   \   00000026   0xB2DB             UXTB     R3,R3
   \   00000028   0x462A             MOV      R2,R5
   \   0000002A   0x6821             LDR      R1,[R4, #+0]
   \   0000002C   0x6830             LDR      R0,[R6, #+0]
   \   0000002E   0x.... 0x....      BL       QRinput_insertStructuredAppendHeader
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD0F2             BEQ.N    ??QRinput_Struct_insertStructuredAppendHeaders_3
   \   00000036   0xF04F 0x30FF      MOV      R0,#-1
   \   0000003A   0xBD70             POP      {R4-R6,PC}
   1698          	}
   1699          
   1700          	return 0;
   \                     ??QRinput_Struct_insertStructuredAppendHeaders_0: (+1)
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xBD70             POP      {R4-R6,PC}       ;; return
   1701          }
   1702          
   1703          /******************************************************************************
   1704           * Extended encoding mode (FNC1 and ECI)
   1705           *****************************************************************************/
   1706          

   \                                 In section .text, align 2, keep-with-next
   1707          int QRinput_setFNC1First(QRinput *input)
   1708          {
   \                     QRinput_setFNC1First: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1709          	if(input->mqr) {
   \   00000002   0x6901             LDR      R1,[R0, #+16]
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD006             BEQ.N    ??QRinput_setFNC1First_0
   1710          		errno = EINVAL;
   \   00000008   0x.... 0x....      BL       __aeabi_errno_addr
   \   0000000C   0xF04F 0x31FF      MOV      R1,#-1
   \   00000010   0x6001             STR      R1,[R0, #+0]
   1711          		return -1;
   \   00000012   0x4608             MOV      R0,R1
   \   00000014   0xBD02             POP      {R1,PC}
   1712          	}
   1713          	input->fnc1 = 1;
   \                     ??QRinput_setFNC1First_0: (+1)
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0x6141             STR      R1,[R0, #+20]
   1714          
   1715          	return 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xBD02             POP      {R1,PC}          ;; return
   1716          }
   1717          

   \                                 In section .text, align 2, keep-with-next
   1718          int QRinput_setFNC1Second(QRinput *input, unsigned char appid)
   1719          {
   \                     QRinput_setFNC1Second: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1720          	if(input->mqr) {
   \   00000002   0x6902             LDR      R2,[R0, #+16]
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD006             BEQ.N    ??QRinput_setFNC1Second_0
   1721          		errno = EINVAL;
   \   00000008   0x.... 0x....      BL       __aeabi_errno_addr
   \   0000000C   0xF04F 0x31FF      MOV      R1,#-1
   \   00000010   0x6001             STR      R1,[R0, #+0]
   1722          		return -1;
   \   00000012   0x4608             MOV      R0,R1
   \   00000014   0xBD02             POP      {R1,PC}
   1723          	}
   1724          	input->fnc1 = 2;
   \                     ??QRinput_setFNC1Second_0: (+1)
   \   00000016   0x2202             MOVS     R2,#+2
   \   00000018   0x6142             STR      R2,[R0, #+20]
   1725          	input->appid = appid;
   \   0000001A   0x7601             STRB     R1,[R0, #+24]
   1726          
   1727          	return 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xBD02             POP      {R1,PC}          ;; return
   1728          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0xFFFF6003         DC32     0xffff6003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0xFFFF3EC0         DC32     0xffff3ec0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0xFFFF7EC0         DC32     0xffff7ec0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   QRinput_InputList_freeEntry
         8   -> QRinput_free
         0   -> free
       8   QRinput_InputList_newEntry
         8   -> malloc
      16   QRinput_List_dup
        16   -> free
        16   -> malloc
        16   -> memcpy
       8   QRinput_List_freeEntry
         8   -> BitStream_free
         0   -> free
         8   -> free
      24   QRinput_List_newEntry
        24   -> QRinput_check
        24   -> __aeabi_errno_addr
        24   -> free
        24   -> malloc
        24   -> memcpy
      16   QRinput_List_shrinkEntry
        16   -> free
        16   -> malloc
        16   -> memcpy
       8   QRinput_Struct_appendInput
         8   -> QRinput_InputList_newEntry
         8   -> __aeabi_errno_addr
      16   QRinput_Struct_calcParity
        16   -> QRinput_Struct_setParity
        16   -> QRinput_calcParity
      16   QRinput_Struct_free
        16   -> QRinput_InputList_freeEntry
         0   -> free
      16   QRinput_Struct_insertStructuredAppendHeaders
        16   -> QRinput_Struct_calcParity
        16   -> QRinput_insertStructuredAppendHeader
       8   QRinput_Struct_new
         8   -> malloc
       0   QRinput_Struct_setParity
       8   QRinput_append
         8   -> QRinput_List_newEntry
         8   -> QRinput_appendEntry
       8   QRinput_appendECIheader
         8   -> QRinput_append
         8   -> __aeabi_errno_addr
       0   QRinput_appendEntry
      24   QRinput_appendPaddingBit
        24   -> BitStream_append
        24   -> BitStream_appendBytes
        24   -> BitStream_appendNum
        24   -> BitStream_free
        24   -> BitStream_new
        24   -> QRspec_getDataLength
        24   -> __aeabi_errno_addr
        24   -> free
        24   -> malloc
      32   QRinput_appendPaddingBitMQR
        32   -> BitStream_append
        32   -> BitStream_appendBytes
        32   -> BitStream_appendNum
        32   -> BitStream_free
        32   -> BitStream_new
        32   -> MQRspec_getDataLengthBit
        32   -> __aeabi_errno_addr
        32   -> free
        32   -> malloc
       0   QRinput_calcParity
       0   QRinput_check
         0   -> QRinput_checkModeAn
         0   -> QRinput_checkModeFNC1Second
         0   -> QRinput_checkModeKanji
         0   -> QRinput_checkModeNum
       4   QRinput_checkModeAn
       0   QRinput_checkModeFNC1Second
       8   QRinput_checkModeKanji
       0   QRinput_checkModeNum
      16   QRinput_convertData
        16   -> QRinput_createBitStream
        16   -> QRinput_estimateVersion
        16   -> QRinput_getVersion
        16   -> QRinput_setVersion
        16   -> QRspec_getMinimumVersion
        16   -> __aeabi_errno_addr
      16   QRinput_createBitStream
        16   -> QRinput_encodeBitStream
       0   QRinput_decodeECIfromByteArray
      16   QRinput_dup
        16   -> QRinput_List_dup
        16   -> QRinput_appendEntry
        16   -> QRinput_free
        16   -> QRinput_new2
        16   -> QRinput_newMQR
      32   QRinput_encodeBitStream
        32   -> BitStream_append
        32   -> BitStream_free
        32   -> BitStream_new
        32   -> QRinput_List_freeEntry
        32   -> QRinput_List_newEntry
        32   -> QRinput_encodeBitStream
        32   -> QRinput_encodeMode8
        32   -> QRinput_encodeModeAn
        32   -> QRinput_encodeModeECI
        32   -> QRinput_encodeModeFNC1Second
        32   -> QRinput_encodeModeKanji
        32   -> QRinput_encodeModeNum
        32   -> QRinput_encodeModeStructure
        32   -> QRspec_maximumWords
      16   QRinput_encodeMode8
        16   -> BitStream_appendBytes
        16   -> BitStream_appendNum
        16   -> BitStream_free
        16   -> BitStream_new
        16   -> MQRspec_lengthIndicator
        16   -> QRspec_lengthIndicator
        16   -> __aeabi_errno_addr
      16   QRinput_encodeModeAn
        16   -> BitStream_appendNum
        16   -> BitStream_free
        16   -> BitStream_new
        16   -> MQRspec_lengthIndicator
        16   -> QRspec_lengthIndicator
        16   -> __aeabi_errno_addr
      16   QRinput_encodeModeECI
        16   -> BitStream_appendNum
        16   -> BitStream_free
        16   -> BitStream_new
        16   -> QRinput_decodeECIfromByteArray
       8   QRinput_encodeModeFNC1Second
         8   -> BitStream_appendBytes
         8   -> BitStream_appendNum
         8   -> BitStream_free
         8   -> BitStream_new
      16   QRinput_encodeModeKanji
        16   -> BitStream_appendNum
        16   -> BitStream_free
        16   -> BitStream_new
        16   -> MQRspec_lengthIndicator
        16   -> QRspec_lengthIndicator
        16   -> __aeabi_errno_addr
      24   QRinput_encodeModeNum
        24   -> BitStream_appendNum
        24   -> BitStream_free
        24   -> BitStream_new
        24   -> MQRspec_lengthIndicator
        24   -> QRspec_lengthIndicator
       8   QRinput_encodeModeStructure
         8   -> BitStream_appendNum
         8   -> BitStream_free
         8   -> BitStream_new
         8   -> __aeabi_errno_addr
      24   QRinput_estimateBitStreamSize
        24   -> QRinput_estimateBitStreamSizeOfEntry
      24   QRinput_estimateBitStreamSizeOfEntry
        24   -> QRinput_estimateBitsMode8
        24   -> QRinput_estimateBitsModeAn
        24   -> QRinput_estimateBitsModeECI
        24   -> QRinput_estimateBitsModeKanji
        24   -> QRinput_estimateBitsModeNum
        24   -> QRspec_lengthIndicator
       0   QRinput_estimateBitsMode8
       0   QRinput_estimateBitsModeAn
       8   QRinput_estimateBitsModeECI
         8   -> QRinput_decodeECIfromByteArray
       0   QRinput_estimateBitsModeKanji
       0   QRinput_estimateBitsModeNum
      16   QRinput_estimateVersion
        16   -> QRinput_estimateBitStreamSize
        16   -> QRspec_getMinimumVersion
      16   QRinput_free
        16   -> QRinput_List_freeEntry
         0   -> free
      16   QRinput_getBitStream
        16   -> BitStream_free
        16   -> QRinput_appendPaddingBit
        16   -> QRinput_appendPaddingBitMQR
        16   -> QRinput_mergeBitStream
      16   QRinput_getByteStream
        16   -> BitStream_free
        16   -> BitStream_toByte
        16   -> QRinput_getBitStream
       0   QRinput_getErrorCorrectionLevel
       0   QRinput_getVersion
       8   QRinput_insertFNC1Header
         8   -> QRinput_List_newEntry
      16   QRinput_insertStructuredAppendHeader
        16   -> QRinput_List_newEntry
        16   -> __aeabi_errno_addr
       0   QRinput_isSplittableMode
      16   QRinput_lengthOfCode
        16   -> QRspec_lengthIndicator
        16   -> QRspec_maximumWords
      16   QRinput_mergeBitStream
        16   -> BitStream_append
        16   -> BitStream_free
        16   -> BitStream_new
        16   -> QRinput_convertData
        16   -> QRinput_createBitStream
        16   -> QRinput_insertFNC1Header
       0   QRinput_new
         0   -> QRinput_new2
      16   QRinput_new2
        16   -> __aeabi_errno_addr
        16   -> malloc
      16   QRinput_newMQR
        16   -> MQRspec_getECCLength
        16   -> QRinput_new2
        16   -> __aeabi_errno_addr
       8   QRinput_setErrorCorrectionLevel
         8   -> __aeabi_errno_addr
       8   QRinput_setFNC1First
         8   -> __aeabi_errno_addr
       8   QRinput_setFNC1Second
         8   -> __aeabi_errno_addr
       8   QRinput_setVersion
         8   -> __aeabi_errno_addr
      16   QRinput_setVersionAndErrorCorrectionLevel
        16   -> MQRspec_getECCLength
        16   -> __aeabi_errno_addr
      16   QRinput_splitEntry
        16   -> QRinput_List_freeEntry
        16   -> QRinput_List_newEntry
        16   -> QRinput_List_shrinkEntry
      32   QRinput_splitQRinputToStruct
        32   -> QRinput_Struct_appendInput
        32   -> QRinput_Struct_free
        32   -> QRinput_Struct_insertStructuredAppendHeaders
        32   -> QRinput_Struct_new
        32   -> QRinput_Struct_setParity
        32   -> QRinput_calcParity
        32   -> QRinput_dup
        32   -> QRinput_encodeBitStream
        32   -> QRinput_estimateBitStreamSizeOfEntry
        32   -> QRinput_free
        32   -> QRinput_lengthOfCode
        32   -> QRinput_new2
        32   -> QRinput_splitEntry
        32   -> QRspec_getDataLength
        32   -> __aeabi_errno_addr


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
      24  QRinput_InputList_freeEntry
      26  QRinput_InputList_newEntry
      64  QRinput_List_dup
      30  QRinput_List_freeEntry
      92  QRinput_List_newEntry
      44  QRinput_List_shrinkEntry
      66  QRinput_Struct_appendInput
      40  QRinput_Struct_calcParity
      34  QRinput_Struct_free
      64  QRinput_Struct_insertStructuredAppendHeaders
      34  QRinput_Struct_new
       4  QRinput_Struct_setParity
     128  QRinput_anTable
      34  QRinput_append
      60  QRinput_appendECIheader
      22  QRinput_appendEntry
     200  QRinput_appendPaddingBit
     292  QRinput_appendPaddingBitMQR
      44  QRinput_calcParity
      58  QRinput_check
      46  QRinput_checkModeAn
      14  QRinput_checkModeFNC1Second
      66  QRinput_checkModeKanji
      28  QRinput_checkModeNum
     104  QRinput_convertData
      42  QRinput_createBitStream
      26  QRinput_decodeECIfromByteArray
      80  QRinput_dup
     302  QRinput_encodeBitStream
     146  QRinput_encodeMode8
     252  QRinput_encodeModeAn
     104  QRinput_encodeModeECI
      66  QRinput_encodeModeFNC1Second
     210  QRinput_encodeModeKanji
     254  QRinput_encodeModeNum
     122  QRinput_encodeModeStructure
      34  QRinput_estimateBitStreamSize
     146  QRinput_estimateBitStreamSizeOfEntry
       4  QRinput_estimateBitsMode8
      20  QRinput_estimateBitsModeAn
      28  QRinput_estimateBitsModeECI
      12  QRinput_estimateBitsModeKanji
      38  QRinput_estimateBitsModeNum
      50  QRinput_estimateVersion
      34  QRinput_free
      50  QRinput_getBitStream
      30  QRinput_getByteStream
       6  QRinput_getErrorCorrectionLevel
       4  QRinput_getVersion
      82  QRinput_insertFNC1Header
      88  QRinput_insertStructuredAppendHeader
       8  QRinput_isSplittableMode
     136  QRinput_lengthOfCode
      96  QRinput_mergeBitStream
       4  QRinput_new
      58  QRinput_new2
      58  QRinput_newMQR
      32  QRinput_setErrorCorrectionLevel
      30  QRinput_setFNC1First
      32  QRinput_setFNC1Second
      32  QRinput_setVersion
      62  QRinput_setVersionAndErrorCorrectionLevel
      66  QRinput_splitEntry
     358  QRinput_splitQRinputToStruct

 
 4 836 bytes in section .text
 
 4 836 bytes of CODE memory

Errors: none
Warnings: none
