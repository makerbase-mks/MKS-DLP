###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  11:56:39
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\cardreader.cpp
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\cardreader.cpp
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --eec++ -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\cardreader.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\cardreader.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\cardreader.cpp
      1          /**
      2           * Marlin 3D Printer Firmware
      3           * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
      4           *
      5           * Based on Sprinter and grbl.
      6           * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
      7           *
      8           * This program is free software: you can redistribute it and/or modify
      9           * it under the terms of the GNU General Public License as published by
     10           * the Free Software Foundation, either version 3 of the License, or
     11           * (at your option) any later version.
     12           *
     13           * This program is distributed in the hope that it will be useful,
     14           * but WITHOUT ANY WARRANTY; without even the implied warranty of
     15           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     16           * GNU General Public License for more details.
     17           *
     18           * You should have received a copy of the GNU General Public License
     19           * along with this program.  If not, see <http://www.gnu.org/licenses/>.
     20           *
     21           */
     22          #include "Marlin.h"

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp char const *strstr(char const *, char const *)
   \                     _Z6strstrPKcS0_: (+1)
   \   00000000   0x.... 0x....      B.W      __iar_Strstr

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp char *strchr(char *, int)
   \                     _Z6strchrPci: (+1)
   \   00000000   0x.... 0x....      B.W      __iar_Strchr

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp char *strstr(char *, char const *)
   \                     _Z6strstrPcPKc: (+1)
   \   00000000   0x.... 0x....      B.W      __iar_Strstr

    #define MIN_SOFTWARE_ENDSTOPS mksCfg.min_software_endstops	/*--mks cfg--*/
            ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\Configuration.h",824  Warning[Pe047]: 
          incompatible redefinition of macro "MIN_SOFTWARE_ENDSTOPS" (declared
          at line 819)

    #define MAX_SOFTWARE_ENDSTOPS mksCfg.max_software_endstops	/*--mks cfg--*/
            ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\Configuration.h",834  Warning[Pe047]: 
          incompatible redefinition of macro "MAX_SOFTWARE_ENDSTOPS" (declared
          at line 829)

  #define UNUSED(x) ((void)(x))
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_def.h",87  Warning[Pe047]: 
          incompatible redefinition of macro "UNUSED" (declared at line 101 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\macros.h")

  		volatile volatile float desireBedTempBak;
  		         ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Inc\mks_cfg.h",351  Warning[Pe083]: 
          type qualifier specified more than once

  #define strcpy_P(dest, src) strcpy((dest), (src))
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",23  Warning[Pe047]: 
          incompatible redefinition of macro "strcpy_P" (declared at line 93
          of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\Marlin_export.h")

  #define strstr_P(a, b) strstr((a), (b))
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",26  Warning[Pe047]: 
          incompatible redefinition of macro "strstr_P" (declared at line 94
          of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\Marlin_export.h")

  #define sprintf_P(s, f, ...) sprintf((s), (f), __VA_ARGS__)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",28  Warning[Pe047]: 
          incompatible redefinition of macro "sprintf_P" (declared at line 95
          of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\Marlin_export.h")

  #define pgm_read_word_near(addr) pgm_read_word(addr)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",38  Warning[Pe047]: 
          incompatible redefinition of macro "pgm_read_word_near" (declared at
          line 65 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\Marlin_export.h")

  #define IS_IWDG_PRESCALER(PRESCALER) (((PRESCALER) == IWDG_Prescaler_4)  || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_iwdg.h",80  Warning[Pe047]: 
          incompatible redefinition of macro "IS_IWDG_PRESCALER" (declared at
          line 209 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_iwdg.h")

  #define IS_IWDG_RELOAD(RELOAD) ((RELOAD) <= 0xFFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_iwdg.h",97  Warning[Pe047]: 
          incompatible redefinition of macro "IS_IWDG_RELOAD" (declared at
          line 222 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_iwdg.h")

  #define IS_FSMC_NORSRAM_BANK(BANK) (((BANK) == FSMC_Bank1_NORSRAM1) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",272  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_NORSRAM_BANK" (declared
          at line 834 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_NAND_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",277  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_NAND_BANK" (declared at
          line 855 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_MUX(MUX) (((MUX) == FSMC_DataAddressMux_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",298  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_MUX" (declared at line
          839 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_MEMORY(MEMORY) (((MEMORY) == FSMC_MemoryType_SRAM) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",311  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_MEMORY" (declared at
          line 842 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_BURSTMODE(STATE) (((STATE) == FSMC_BurstAccessMode_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",336  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_BURSTMODE" (declared at
          line 894 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ASYNWAIT(STATE) (((STATE) == FSMC_AsynchronousWait_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",347  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ASYNWAIT" (declared at
          line 915 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAIT_POLARITY(POLARITY) (((POLARITY) == FSMC_WaitSignalPolarity_Low) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",358  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAIT_POLARITY" (declared
          at line 897 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WRAP_MODE(MODE) (((MODE) == FSMC_WrapMode_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",369  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WRAP_MODE" (declared at
          line 900 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAIT_SIGNAL_ACTIVE(ACTIVE) (((ACTIVE) == FSMC_WaitSignalActive_BeforeWaitState) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",380  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAIT_SIGNAL_ACTIVE"
          (declared at line 903 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WRITE_OPERATION(OPERATION) (((OPERATION) == FSMC_WriteOperation_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",391  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WRITE_OPERATION"
          (declared at line 906 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAITE_SIGNAL(SIGNAL) (((SIGNAL) == FSMC_WaitSignal_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",402  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAITE_SIGNAL" (declared
          at line 909 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_EXTENDED_MODE(MODE) (((MODE) == FSMC_ExtendedMode_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",414  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_EXTENDED_MODE" (declared
          at line 912 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WRITE_BURST(BURST) (((BURST) == FSMC_WriteBurst_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",426  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WRITE_BURST" (declared
          at line 920 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ADDRESS_SETUP_TIME(TIME) ((TIME) <= 0xF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",435  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ADDRESS_SETUP_TIME"
          (declared at line 923 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ADDRESS_HOLD_TIME(TIME) ((TIME) <= 0xF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",443  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ADDRESS_HOLD_TIME"
          (declared at line 925 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_DATASETUP_TIME(TIME) (((TIME) > 0) && ((TIME) <= 0xFF))
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",451  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_DATASETUP_TIME"
          (declared at line 927 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_TURNAROUND_TIME(TIME) ((TIME) <= 0xF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",459  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_TURNAROUND_TIME"
          (declared at line 929 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_CLK_DIV(DIV) ((DIV) <= 0xF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",467  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_CLK_DIV" (declared at
          line 934 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_DATA_LATENCY(LATENCY) ((LATENCY) <= 0xF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",475  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_DATA_LATENCY" (declared
          at line 918 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ACCESS_MODE(MODE) (((MODE) == FSMC_AccessMode_A) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",487  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ACCESS_MODE" (declared
          at line 850 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAIT_FEATURE(FEATURE) (((FEATURE) == FSMC_Waitfeature_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",508  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAIT_FEATURE" (declared
          at line 858 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ECC_STATE(STATE) (((STATE) == FSMC_ECC_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",520  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ECC_STATE" (declared at
          line 864 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ECCPAGE_SIZE(SIZE) (((SIZE) == FSMC_ECCPageSize_256Bytes) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",535  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ECCPAGE_SIZE" (declared
          at line 867 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_TCLR_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",548  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_TCLR_TIME" (declared at
          line 874 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_TAR_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",556  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_TAR_TIME" (declared at
          line 876 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_SETUP_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",564  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_SETUP_TIME" (declared at
          line 878 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAIT_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",572  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAIT_TIME" (declared at
          line 880 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_HOLD_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",580  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_HOLD_TIME" (declared at
          line 882 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_HIZ_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",588  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_HIZ_TIME" (declared at
          line 884 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define FSMC_FLAG_FEMPT                          ((uint32_t)0x00000040)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",613  Warning[Pe047]: 
          incompatible redefinition of macro "FSMC_FLAG_FEMPT" (declared at
          line 530 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

    #define assert_param(expr) ((void)0)        
            ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\stm32f4xx_conf.h",149  Warning[Pe047]: 
          incompatible redefinition of macro "assert_param" (declared at line
          431 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\stm32f4x
          x_hal_conf.h")

   \                                 In section .text, align 4
   \   __interwork __softfp void serialprintPGM(char const *)
   \                     _Z14serialprintPGMPKc: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xE003             B.N      ??serialprintPGM_0
   \                     ??serialprintPGM_1: (+1)
   \   00000006   0xB2C9             UXTB     R1,R1
   \   00000008   0x4803             LDR.N    R0,??serialprintPGM_2
   \   0000000A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??serialprintPGM_0: (+1)
   \   0000000E   0xF914 0x1B01      LDRSB    R1,[R4], #+1
   \   00000012   0x0008             MOVS     R0,R1
   \   00000014   0xD1F7             BNE.N    ??serialprintPGM_1
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
   \                     ??serialprintPGM_2:
   \   00000018   0x........         DC32     Serial6
     23          #include "MarlinConfig.h"
     24          #include "fatfs.h"
     25          #include "mks_cfg.h"
     26          #include "mks_reprint.h"

  #define SD_DETECT_INVERTED false
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\cardreader.h",27  Warning[Pe047]: 
          incompatible redefinition of macro "SD_DETECT_INVERTED" (declared at
          line 512 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\Configuration_adv.h")

  #define PSTR(s) s
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\cardreader.h",31  Warning[Pe047]: 
          incompatible redefinition of macro "PSTR" (declared at line 63 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\Marlin.h")

  #define pgm_read_byte(x) (*(char*)x)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\cardreader.h",32  Warning[Pe047]: 
          incompatible redefinition of macro "pgm_read_byte" (declared at line
          64 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\Marlin_export.h")

      static constexpr int8_t next_block_index(const int8_t block_index) { return BLOCK_MOD(block_index + 1); }
             ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\planner.h",582  Warning[Pe815]: 
          type qualifier on return type is meaningless

      static constexpr int8_t prev_block_index(const int8_t block_index) { return BLOCK_MOD(block_index - 1); }
             ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\planner.h",583  Warning[Pe815]: 
          type qualifier on return type is meaningless

        target_temperature[HOTEND_INDEX] = celsius;
                                         ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\temperature.h",397  Warning[Pa093]: 
          implicit conversion from floating point to integer

  #define LONG_FILENAME_LENGTH (13*MAX_VFAT_ENTRIES+1)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\cardreader.h",61  Warning[Pe047]: 
          incompatible redefinition of macro "LONG_FILENAME_LENGTH" (declared
          at line 119 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\SdFatConfig.h")

  #define ALLOW_DEPRECATED_FUNCTIONS 0
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\SdFat.h",635  Warning[Pe047]: 
          incompatible redefinition of macro "ALLOW_DEPRECATED_FUNCTIONS"
          (declared at line 67 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\SdFatConfig.h")

  #define SPI_SD_INIT_RATE 11
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\SdFat.h",647  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_SD_INIT_RATE" (declared at
          line 79 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\SdFatConfig.h")

   \                                 In section .text, align 2
   \   __code __interwork __softfp SdBaseFile::SdBaseFile()
   \                     _ZN10SdBaseFileC1Ev: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x7001             STRB     R1,[R0, #+0]
   \   00000004   0x70C1             STRB     R1,[R0, #+3]
   \   00000006   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp bool CardReader::isFileOpen()
   \                     _ZN10CardReader10isFileOpenEv: (+1)
   \   00000000   0xF8D0 0x0200      LDR      R0,[R0, #+512]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD001             BEQ.N    ??isFileOpen_0
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x4770             BX       LR
   \                     ??isFileOpen_0: (+1)
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return
     27          #include "usb_host.h"
     28          
     29          #include "draw_ui.h"

  #define IS_SPI_MODE(MODE) (((MODE) == SPI_Mode_Master) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_spi.h",173  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_MODE" (declared at line
          511 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_spi.h")

  #define IS_SPI_DATASIZE(DATASIZE) (((DATASIZE) == SPI_DataSize_16b) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_spi.h",185  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_DATASIZE" (declared at
          line 523 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_spi.h")

  #define IS_SPI_CPOL(CPOL) (((CPOL) == SPI_CPOL_Low) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_spi.h",197  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_CPOL" (declared at line
          526 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_spi.h")

  #define IS_SPI_CPHA(CPHA) (((CPHA) == SPI_CPHA_1Edge) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_spi.h",209  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_CPHA" (declared at line
          529 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_spi.h")

  #define IS_SPI_NSS(NSS) (((NSS) == SPI_NSS_Soft) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_spi.h",221  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_NSS" (declared at line
          532 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_spi.h")

  #define IS_SPI_BAUDRATE_PRESCALER(PRESCALER) (((PRESCALER) == SPI_BaudRatePrescaler_2) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_spi.h",239  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_BAUDRATE_PRESCALER"
          (declared at line 536 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_spi.h")

  #define IS_SPI_FIRST_BIT(BIT) (((BIT) == SPI_FirstBit_MSB) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_spi.h",257  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_FIRST_BIT" (declared at
          line 545 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_spi.h")

  #define IS_SPI_DIRECTION(DIRECTION) (((DIRECTION) == SPI_Direction_Rx) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_spi.h",400  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_DIRECTION" (declared at
          line 514 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_spi.h")

  #define SPI_FLAG_CRCERR                 ((uint16_t)0x0010)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_spi.h",442  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_FLAG_CRCERR" (declared at
          line 293 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_spi.h")

  #define SPI_FLAG_MODF                   ((uint16_t)0x0020)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_spi.h",443  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_FLAG_MODF" (declared at line
          294 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_spi.h")

  #define IS_SPI_CRC_POLYNOMIAL(POLYNOMIAL) ((POLYNOMIAL) >= 0x1)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_spi.h",462  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_CRC_POLYNOMIAL" (declared
          at line 554 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_spi.h")

  #define SPI_IT_TXE                   SPI_I2S_IT_TXE
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_spi.h",473  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_IT_TXE" (declared at line
          280 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_spi.h")

  #define SPI_IT_RXNE                  SPI_I2S_IT_RXNE
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_spi.h",474  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_IT_RXNE" (declared at line
          281 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_spi.h")

  #define SPI_IT_ERR                   SPI_I2S_IT_ERR
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_spi.h",475  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_IT_ERR" (declared at line
          282 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_spi.h")

  #define SPI_FLAG_RXNE                SPI_I2S_FLAG_RXNE
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_spi.h",477  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_FLAG_RXNE" (declared at line
          290 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_spi.h")

  #define SPI_FLAG_TXE                 SPI_I2S_FLAG_TXE
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_spi.h",478  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_FLAG_TXE" (declared at line
          291 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_spi.h")

  #define SPI_FLAG_OVR                 SPI_I2S_FLAG_OVR
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_spi.h",479  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_FLAG_OVR" (declared at line
          295 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_spi.h")

  #define SPI_FLAG_BSY                 SPI_I2S_FLAG_BSY
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_spi.h",480  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_FLAG_BSY" (declared at line
          292 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_spi.h")

    #define FILAMENT_CHANGE_TEXT_EN				"Please click <Load> \nor <unload>,After \npinter pause."
            ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\User\ui\Multi_language\Language_en.h",165  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_EN"
          (declared at line 143)

  #define DIALOG_UNBIND_PRINTER_CN            "Ëß£Èô§ÁªëÂÆö?"
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\User\ui\Multi_language\Language_s_cn.h",248  Warning[Pe047]: 
          incompatible redefinition of macro "DIALOG_UNBIND_PRINTER_CN"
          (declared at line 243)

    #define FILAMENT_CHANGE_TEXT_T_CN				"ÂæÖÊâìÂç∞Ê©üÊö´ÂÅúÂêé,\nË´ãÊåâ<ÈÄ≤Êñô>Êàñ<ÈÄÄÊñô>"
            ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\User\ui\Multi_language\Language_t_cn.h",157  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_T_CN"
          (declared at line 143)

    #define FILAMENT_CHANGE_TEXT_RU				"Please click <Load> \nor <unload>,After \npinter pause."
            ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\User\ui\Multi_language\Language_ru.h",163  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_RU"
          (declared at line 143)

  #define DIALOG_UNBIND_PRINTER_RU            "Unbind the printer?"
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\User\ui\Multi_language\Language_ru.h",260  Warning[Pe047]: 
          incompatible redefinition of macro "DIALOG_UNBIND_PRINTER_RU"
          (declared at line 255)

    #define FILAMENT_CHANGE_TEXT_FR				"Please click <Load> \nor <unload>,After \npinter pause."
            ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\User\ui\Multi_language\Language_fr.h",163  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_FR"
          (declared at line 143)

  #define DIALOG_UNBIND_PRINTER_FR        "Unbind the printer?"
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\User\ui\Multi_language\Language_fr.h",263  Warning[Pe047]: 
          incompatible redefinition of macro "DIALOG_UNBIND_PRINTER_FR"
          (declared at line 259)

    #define FILAMENT_CHANGE_TEXT_SP				"Please click <Load> \nor <unload>,After \npinter pause."
            ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\User\ui\Multi_language\Language_sp.h",162  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_SP"
          (declared at line 143)

    #define FILAMENT_CHANGE_TEXT_IT				"Please click <Load> \nor <unload>,After \npinter pause."
            ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\User\ui\Multi_language\Language_it.h",163  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_IT"
          (declared at line 143)

  #define DIALOG_UNBIND_PRINTER_IT                "Unbind the printer?"
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\User\ui\Multi_language\Language_it.h",259  Warning[Pe047]: 
          incompatible redefinition of macro "DIALOG_UNBIND_PRINTER_IT"
          (declared at line 254)

  #define FILAMENT_CHANGE_TEXT_JP				"Please click <Load> \nor <unload>,After \npinter pause."
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\User\ui\Multi_language\Multi_language.h",688  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_JP"
          (declared at line 681)

  #define FILAMENT_CHANGE_TEXT_GN				"Please click <Load> \nor <unload>,After \npinter pause."
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\User\ui\Multi_language\Multi_language.h",896  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_GN"
          (declared at line 890)

  #define Simple_Dec"ºı…Ÿ"
                    ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\User\ui\draw_ui.h",387  Warning[Pe1649]: 
          white space is required between the macro name "Simple_Dec" and its
          replacement text

  #define Simple_Speed "ÀŸ∂»"
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\User\ui\draw_ui.h",442  Warning[Pe047]: 
          incompatible redefinition of macro "Simple_Speed" (declared at line
          439)

  #define Complex_Speed "ÀŸ∂»"
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\User\ui\draw_ui.h",443  Warning[Pe047]: 
          incompatible redefinition of macro "Complex_Speed" (declared at line
          440)
     30          
     31          
     32          #if ENABLED(SDSUPPORT)
     33          
     34          
     35          #include "cardreader.h"
     36          
     37          //#include "ultralcd.h"
     38          //#include "stepper.h"
     39          //#include "language.h"
     40          
     41          //#define LONGEST_FILENAME (longFilename[0] ? longFilename : filename)
     42          

   \                                 In section .text, align 2, keep-with-next
     43          CardReader::CardReader() {
   \                     _ZN10CardReaderC1Ev: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xF504 0x608E      ADD      R0,R4,#+1136
   \   00000008   0x.... 0x....      BL       _ZN10SdBaseFileC1Ev
     44              sdmode = 0;			
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xF884 0x046C      STRB     R0,[R4, #+1132]
     45          	sdprinting = false;
   \   00000012   0xF884 0x09B8      STRB     R0,[R4, #+2488]
     46          	cardOK = false;	
   \   00000016   0xF604 0x10B8      ADDW     R0,R4,#+2488
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x70C1             STRB     R1,[R0, #+3]
     47          	usbOK = false;
   \   0000001E   0x7101             STRB     R1,[R0, #+4]
     48              savetosd = false;
   \   00000020   0xF884 0x146D      STRB     R1,[R4, #+1133]
     49          	udisk_start_tick = 0;
   \   00000024   0x6081             STR      R1,[R0, #+8]
     50          }
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
     51          

   \                                 In section .text, align 2, keep-with-next
     52          void CardReader::automount()	{}
   \                     _ZN10CardReader9automountEv: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
     53          void CardReader::checkautostart(bool force)
     54          {
   \                     _ZN10CardReader14checkautostartEb: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
     55            if(usbOK == false)        //U?®¨??®ÆD1®∞??
   \   00000004   0xF604 0x15B8      ADDW     R5,R4,#+2488
   \   00000008   0x7928             LDRB     R0,[R5, #+4]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD115             BNE.N    ??checkautostart_0
     56            {
     57              if (SD_DET_IP != SD_DETECT_INVERTED)    
     58              {
     59                  if(cardOK || sdprinting)   // Card removed
   \   0000000E   0x78E8             LDRB     R0,[R5, #+3]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD103             BNE.N    ??checkautostart_1
   \   00000014   0xF894 0x09B8      LDRB     R0,[R4, #+2488]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD00E             BEQ.N    ??checkautostart_0
     60                  {
     61          			SERIAL_ECHO_START();
   \                     ??checkautostart_1: (+1)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable45_3
   \   00000020   0x.... 0x....      BL       _Z14serialprintPGMPKc
     62          			SERIAL_ECHOLNPGM("SD card removed");
   \   00000024   0x.... 0x....      ADR.W    R0,`?<Constant "SD card removed\\n">`
   \   00000028   0x.... 0x....      BL       _Z14serialprintPGMPKc
     63                      
     64                      FATFS_UnLinkDriver(SD_Path); 
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable45_4
   \   00000030   0x.... 0x....      BL       FATFS_UnLinkDriver
     65                      unmount();
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0x.... 0x....      BL       _ZN10CardReader7unmountEv
     66                  }
     67              }
     68              else
     69              {
     70                  if(!cardOK)
     71                  {
     72          			SERIAL_ECHO_START();
     73          			SERIAL_ECHOLNPGM("SD card inserted");
     74                      
     75                      FATFS_LinkDriver(&SD_Driver, SD_Path);
     76                      initsd();
     77                  }
     78              }
     79            }
     80              
     81            if (SD_DET_IP != SD_DETECT_INVERTED)  //?TSD?°ß,?®¨2a¶Ã?U?®¨°Í?1®∞??
     82            {
     83              if((usbOK == false)&& (Appli_state == APPLICATION_READY))
   \                     ??checkautostart_0: (+1)
   \   0000003A   0x.... 0x....      LDR.W    R6,??DataTable45_5
   \   0000003E   0x7928             LDRB     R0,[R5, #+4]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD11C             BNE.N    ??checkautostart_2
   \   00000044   0xF996 0x0000      LDRSB    R0,[R6, #+0]
   \   00000048   0x2802             CMP      R0,#+2
   \   0000004A   0xD118             BNE.N    ??checkautostart_2
     84              {
     85          		SERIAL_ECHO_START();
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable45_3
   \   00000050   0x.... 0x....      BL       _Z14serialprintPGMPKc
     86          		SERIAL_ECHOLNPGM("USB inserted");
   \   00000054   0x.... 0x....      ADR.W    R0,`?<Constant "USB inserted\\n">`
   \   00000058   0x.... 0x....      BL       _Z14serialprintPGMPKc
     87                  
     88                  FATFS_LinkDriver(&USBH_Driver, USBH_Path);
   \   0000005C   0x.... 0x....      LDR.W    R7,??DataTable45_6
   \   00000060   0x4639             MOV      R1,R7
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable45_7
   \   00000066   0x.... 0x....      BL       FATFS_LinkDriver
     89                
     90                  f_mount(&fs, (TCHAR const*)USBH_Path, 0);
   \   0000006A   0x2200             MOVS     R2,#+0
   \   0000006C   0x4639             MOV      R1,R7
   \   0000006E   0xF504 0x700B      ADD      R0,R4,#+556
   \   00000072   0x.... 0x....      BL       f_mount
     91          		usbOK = true;
   \   00000076   0x2001             MOVS     R0,#+1
   \   00000078   0x7128             STRB     R0,[R5, #+4]
     92                  Appli_state = APPLICATION_IDLE;
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x7030             STRB     R0,[R6, #+0]
     93                
     94              }
     95            } 
     96            
     97            if((Appli_state == APPLICATION_DISCONNECT) &&(usbOK == true))     //?®¨2a¶Ã?U?®¨???a°Í?D???
   \                     ??checkautostart_2: (+1)
   \   0000007E   0xF996 0x0000      LDRSB    R0,[R6, #+0]
   \   00000082   0x2803             CMP      R0,#+3
   \   00000084   0xD114             BNE.N    ??checkautostart_3
   \   00000086   0x7928             LDRB     R0,[R5, #+4]
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD011             BEQ.N    ??checkautostart_3
     98            {
     99              //unmount();
    100              sdprinting = false;
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0xF884 0x09B8      STRB     R0,[R4, #+2488]
    101          	usbOK = false;
   \   00000092   0x7128             STRB     R0,[R5, #+4]
    102          	SERIAL_ECHO_START();
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable45_3
   \   00000098   0x.... 0x....      BL       _Z14serialprintPGMPKc
    103          	SERIAL_ECHOLNPGM("USB removed");
   \   0000009C   0x.... 0x....      ADR.W    R0,`?<Constant "USB removed\\n">`
   \   000000A0   0x.... 0x....      BL       _Z14serialprintPGMPKc
    104              
    105              FATFS_UnLinkDriver(USBH_Path);
   \   000000A4   0x.... 0x....      LDR.W    R0,??DataTable45_6
   \   000000A8   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   000000AC   0x.... 0x....      B.W      FATFS_UnLinkDriver
    106            }
    107          }
   \                     ??checkautostart_3: (+1)
   \   000000B0   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    108          
    109          #if 0
    110          void CardReader::checkFilesys(unsigned char filesys)
    111          {
    112          
    113          	switch(filesys)
    114          	{
    115          	case FILE_SYS_SD:
    116          	  //if(filesys == FILE_SYS_SD)        //U?®¨??®ÆD1®∞??
    117          	  {
    118          	      if (SD_DET_IP != SD_DETECT_INVERTED)    
    119          	      {
    120          	        if(cardOK || sdprinting)   // Card removed
    121          	        {
    122          				SERIAL_ECHO_START();
    123          				SERIAL_ECHOLNPGM("SD card removed");
    124          	            
    125          	            FATFS_UnLinkDriver(SD_Path); 
    126          	            unmount();
    127          	        }
    128          	      }
    129          	      else
    130          	      {
    131          	        if(!cardOK)
    132          	        {
    133          				SERIAL_ECHO_START();
    134          				SERIAL_ECHOLNPGM("Select SD file system");
    135          	            FATFS_LinkDriver_sd(&SD_Driver, SD_Path);
    136          	            initsd();
    137          				usbOK = false;
    138          	        }
    139          	      }
    140          	  }
    141          	 break;
    142          	 case FILE_SYS_USB:
    143          	  //if (SD_DET_IP != SD_DETECT_INVERTED)  //?TSD?°ß,?®¨2a¶Ã?U?®¨°Í?1®∞??
    144          		  {
    145          		    if((usbOK == false)&& (Appli_state == APPLICATION_READY))
    146          		    {
    147          				SERIAL_ECHO_START();
    148          				SERIAL_ECHOLNPGM("Select USB file system");
    149          		        FATFS_LinkDriver_usb(&USBH_Driver, USBH_Path);
    150          		      
    151          		        f_mount(&fs, (TCHAR const*)USBH_Path, 0);
    152          				usbOK = true;
    153          				cardOK = false;
    154          		        Appli_state = APPLICATION_IDLE;
    155          		      
    156          		    }
    157          		  } 
    158          	  	  if((Appli_state == APPLICATION_DISCONNECT) &&(usbOK == true))     //?®¨2a¶Ã?U?®¨???a°Í?D???
    159          		  {
    160          		    //unmount();
    161          		    sdprinting = false;
    162          			usbOK = false;
    163          			SERIAL_ECHO_START();
    164          			SERIAL_ECHOLNPGM("USB removed");
    165          		    
    166          		    FATFS_UnLinkDriver(USBH_Path);
    167          		  }
    168          	  break;
    169          	  default:break;
    170          	}
    171          }
    172          #else

   \                                 In section .text, align 4, keep-with-next
    173          void CardReader::udiskReset()
    174          {
   \                     _ZN10CardReader10udiskResetEv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    175          	card.usbOK = false;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable45_8
   \   0000000A   0xF881 0x09BC      STRB     R0,[R1, #+2492]
    176          	SERIAL_ECHO_START();
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable45_3
   \   00000012   0x.... 0x....      BL       _Z14serialprintPGMPKc
    177          	SERIAL_ECHOLNPGM("USB Reset!");
   \   00000016   0x.... 0x....      ADR.W    R0,`?<Constant "USB Reset!\\n">`
   \   0000001A   0x.... 0x....      BL       _Z14serialprintPGMPKc
    178          	FATFS_UnLinkDriver(USBH_Path);
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable45_6
   \   00000022   0x.... 0x....      BL       FATFS_UnLinkDriver
    179          	MX_USB_HOST_DeInit();
   \   00000026   0x.... 0x....      BL       MX_USB_HOST_DeInit
    180          	VUSB_ENA_OP = 0;
   \   0000002A   0x.... 0x....      LDR.W    R5,??DataTable45_9  ;; 0x4241828c
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x6028             STR      R0,[R5, #+0]
    181          	HAL_Delay(500);
   \   00000032   0xF44F 0x70FA      MOV      R0,#+500
   \   00000036   0x.... 0x....      BL       HAL_Delay
    182          	VUSB_ENA_OP = 1;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x6028             STR      R0,[R5, #+0]
    183          	MX_USB_HOST_Init();
   \   0000003E   0x.... 0x....      BL       MX_USB_HOST_Init
    184          	HAL_Delay(500);
   \   00000042   0xF44F 0x70FA      MOV      R0,#+500
   \   00000046   0x.... 0x....      BL       HAL_Delay
    185          
    186          #if 0
    187          for(int i=0;i<5000;i++)		//skyblue modify 2018-10
    188          	{
    189          	MX_USB_HOST_Process();
    190          	card.checkFilesys(FILE_SYS_USB);
    191          	if(card.usbOK) 
    192          		break;
    193          	HAL_Delay(1);
    194          	}
    195          if(card.usbOK)
    196          	{
    197          	card.initusb();
    198          	}
    199          #endif
    200          	cli();
   \   0000004A   0xB672             cpsid i
    201          	udisk_start_tick = 0;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xF8C4 0x09C0      STR      R0,[R4, #+2496]
    202          	sei();
   \   00000052   0xB662             cpsie i
    203          
    204          	
    205          }
   \   00000054   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
    206          void CardReader::udiskState_Polling()
    207          {
    208          	if(udisk_start_tick > 3000)
   \                     _ZN10CardReader18udiskState_PollingEv: (+1)
   \   00000000   0xF8D0 0x19C0      LDR      R1,[R0, #+2496]
   \   00000004   0xF640 0x32B9      MOVW     R2,#+3001
   \   00000008   0x4291             CMP      R1,R2
   \   0000000A   0xD305             BCC.N    ??udiskState_Polling_0
    209          		{
    210          		cli();
   \   0000000C   0xB672             cpsid i
    211          		udisk_start_tick = 0;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0xF8C0 0x19C0      STR      R1,[R0, #+2496]
    212          		sei();
   \   00000014   0xB662             cpsie i
    213          		udiskReset();
   \   00000016   0x....             B.N      _ZN10CardReader10udiskResetEv
    214          		}
    215          }
   \                     ??udiskState_Polling_0: (+1)
   \   00000018   0x4770             BX       LR               ;; return
    216          

   \                                 In section .text, align 2, keep-with-next
    217          void CardReader::checkFilesys(unsigned char filesys)
    218          {
   \                     _ZN10CardReader12checkFilesysEh: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    219          
    220          	if((usbOK == false)&& (Appli_state == APPLICATION_READY))
   \   00000004   0xF604 0x15B8      ADDW     R5,R4,#+2488
   \   00000008   0x.... 0x....      LDR.W    R6,??DataTable45_5
   \   0000000C   0x7928             LDRB     R0,[R5, #+4]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD121             BNE.N    ??checkFilesys_0
   \   00000012   0xF996 0x0000      LDRSB    R0,[R6, #+0]
   \   00000016   0x2802             CMP      R0,#+2
   \   00000018   0xD11D             BNE.N    ??checkFilesys_0
    221          		{
    222          			SERIAL_ECHO_START();
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable45_3
   \   0000001E   0x.... 0x....      BL       _Z14serialprintPGMPKc
    223          			SERIAL_ECHOLNPGM("USB inserted");
   \   00000022   0x.... 0x....      ADR.W    R0,`?<Constant "USB inserted\\n">`
   \   00000026   0x.... 0x....      BL       _Z14serialprintPGMPKc
    224          			FATFS_LinkDriver_usb(&USBH_Driver, USBH_Path);
   \   0000002A   0x.... 0x....      LDR.W    R7,??DataTable45_6
   \   0000002E   0x4639             MOV      R1,R7
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable45_7
   \   00000034   0x.... 0x....      BL       FATFS_LinkDriver_usb
    225          		      
    226          			f_mount(&fs, (TCHAR const*)USBH_Path, 0);
   \   00000038   0x2200             MOVS     R2,#+0
   \   0000003A   0x4639             MOV      R1,R7
   \   0000003C   0xF504 0x700B      ADD      R0,R4,#+556
   \   00000040   0x.... 0x....      BL       f_mount
    227          			usbOK = true;
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0x7128             STRB     R0,[R5, #+4]
    228          			cardOK = false;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x70E8             STRB     R0,[R5, #+3]
    229          			Appli_state = APPLICATION_IDLE;
   \   0000004C   0x7030             STRB     R0,[R6, #+0]
    230          			card.udisk_start_tick = 0;
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable45_8
   \   00000052   0xF8C1 0x09C0      STR      R0,[R1, #+2496]
    231          		}
    232          	if((Appli_state == APPLICATION_DISCONNECT) &&(usbOK == true))     //?®¨2a¶Ã?U?®¨???a°Í?D???
   \                     ??checkFilesys_0: (+1)
   \   00000056   0xF996 0x0000      LDRSB    R0,[R6, #+0]
   \   0000005A   0x2803             CMP      R0,#+3
   \   0000005C   0xD123             BNE.N    ??checkFilesys_1
   \   0000005E   0x7928             LDRB     R0,[R5, #+4]
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD020             BEQ.N    ??checkFilesys_1
    233          		{
    234          			//unmount();
    235          		    sdprinting = false;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xF884 0x09B8      STRB     R0,[R4, #+2488]
    236          			usbOK = false;
   \   0000006A   0x7128             STRB     R0,[R5, #+4]
    237          			SERIAL_ECHO_START();
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable45_3
   \   00000070   0x.... 0x....      BL       _Z14serialprintPGMPKc
    238          			SERIAL_ECHOLNPGM("USB removed");
   \   00000074   0x.... 0x....      ADR.W    R0,`?<Constant "USB removed\\n">`
   \   00000078   0x.... 0x....      BL       _Z14serialprintPGMPKc
    239          		    
    240          		    FATFS_UnLinkDriver(USBH_Path);      //’‚¿Ô…Ë÷√∂œµ„£¨π€≤ÏµΩ Appli_state = APPLICATION_START
   \   0000007C   0x.... 0x....      LDR.W    R0,??DataTable45_6
   \   00000080   0x.... 0x....      BL       FATFS_UnLinkDriver
    241          			card.udisk_start_tick = 0;			//‘Ÿ¥Œ∞Œ≤ÂU≈Ã≤ª∂¡»°£¨–Ë÷ÿ∆Ù
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x.... 0x....      LDR.W    R1,??DataTable45_8
   \   0000008A   0xF8C1 0x09C0      STR      R0,[R1, #+2496]
    242          
    243          			if(Appli_state == APPLICATION_START)
   \   0000008E   0xF996 0x0000      LDRSB    R0,[R6, #+0]
   \   00000092   0x2801             CMP      R0,#+1
   \   00000094   0xD107             BNE.N    ??checkFilesys_1
    244          				{
    245          				MX_USB_HOST_DeInit();
   \   00000096   0x.... 0x....      BL       MX_USB_HOST_DeInit
    246          				SERIAL_ECHOLNPGM("USB DeInit!");
   \   0000009A   0x.... 0x....      ADR.W    R0,`?<Constant "USB DeInit!\\n">`
   \   0000009E   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   000000A2   0x.... 0x....      B.W      _Z14serialprintPGMPKc
    247          				}
    248          		}
    249          #if 0	
    250          	if(usbOK == false && Appli_state == APPLICATION_START && _dwTickCount>10000)	
    251          		{
    252          			//while(1)
    253          				for(int i=0;i<5000;i++)
    254          				{
    255          				MX_USB_HOST_Process();
    256          				if(Appli_state == APPLICATION_READY)
    257          					break;
    258          				HAL_Delay(1);
    259          				}
    260          				
    261          				if(Appli_state == APPLICATION_START)
    262          					udiskReset();
    263          				
    264          		}
    265          #endif	
    266          }
   \                     ??checkFilesys_1: (+1)
   \   000000A6   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    267          
    268          #endif
    269          #if 0
    270          char *createFilename(char *buffer, const dir_t &p) { //buffer > 12characters
    271            char *pos = buffer;
    272            for (uint8_t i = 0; i < 11; i++) {
    273              if (p.name[i] == ' ') continue;
    274              if (i == 8) *pos++ = '.';
    275              *pos++ = p.name[i];
    276            }
    277            *pos++ = 0;
    278            return buffer;
    279          }
    280          
    281          /**
    282           * Dive into a folder and recurse depth-first to perform a pre-set operation lsAction:
    283           *   LS_Count       - Add +1 to nrFiles for every file within the parent
    284           *   LS_GetFilename - Get the filename of the file indexed by nrFile_index
    285           *   LS_SerialPrint - Print the full path and size of each file to serial output
    286           */
    287          
    288          uint16_t nrFile_index;
    289          
    290          void CardReader::lsDive(const char *prepend, SdFile parent, const char * const match/*=NULL*/) {
    291            dir_t p;
    292            uint8_t cnt = 0;
    293          
    294            // Read the next entry from a directory
    295            while (parent.readDir(p, longFilename) > 0) {
    296          
    297              // If the entry is a directory and the action is LS_SerialPrint
    298              if (DIR_IS_SUBDIR(&p) && lsAction != LS_Count && lsAction != LS_GetFilename) {
    299          
    300                // Get the short name for the item, which we know is a folder
    301                char lfilename[FILENAME_LENGTH];
    302                createFilename(lfilename, p);
    303          
    304                // Allocate enough stack space for the full path to a folder, trailing slash, and nul
    305                bool prepend_is_empty = (prepend[0] == '\0');
    306                int len = (prepend_is_empty ? 1 : strlen(prepend)) + strlen(lfilename) + 1 + 1;
    307                char path[len];
    308          
    309                // Append the FOLDERNAME12/ to the passed string.
    310                // It contains the full path to the "parent" argument.
    311                // We now have the full path to the item in this folder.
    312                strcpy(path, prepend_is_empty ? "/" : prepend); // root slash if prepend is empty
    313                strcat(path, lfilename); // FILENAME_LENGTH-1 characters maximum
    314                strcat(path, "/");       // 1 character
    315          
    316                // Serial.print(path);
    317          
    318                // Get a new directory object using the full path
    319                // and dive recursively into it.
    320                SdFile dir;
    321                if (!dir.open(parent, lfilename, O_READ)) {
    322                  if (lsAction == LS_SerialPrint) {
    323                    SERIAL_ECHO_START();
    324                    SERIAL_ECHOPGM(MSG_SD_CANT_OPEN_SUBDIR);
    325                    SERIAL_ECHOLN(lfilename);
    326                  }
    327                }
    328                lsDive(path, dir);
    329                // close() is done automatically by destructor of SdFile
    330              }
    331              else {
    332                uint8_t pn0 = p.name[0];
    333                if (pn0 == DIR_NAME_FREE) break;
    334                if (pn0 == DIR_NAME_DELETED || pn0 == '.') continue;
    335                if (longFilename[0] == '.') continue;
    336          
    337                if (!DIR_IS_FILE_OR_SUBDIR(&p) || (p.attributes & DIR_ATT_HIDDEN)) continue;
    338          
    339                filenameIsDir = DIR_IS_SUBDIR(&p);
    340          
    341                if (!filenameIsDir && (p.name[8] != 'G' || p.name[9] == '~')) continue;
    342          
    343                switch (lsAction) {  // 1 based file count
    344                  case LS_Count:
    345                    nrFiles++;
    346                    break;
    347          
    348                  case LS_SerialPrint:
    349                    createFilename(filename, p);
    350                    SERIAL_PROTOCOL(prepend);
    351                    SERIAL_PROTOCOL(filename);
    352                    SERIAL_PROTOCOLCHAR(' ');
    353                    SERIAL_PROTOCOLLN(p.fileSize);
    354                    break;
    355          
    356                  case LS_GetFilename:
    357                    createFilename(filename, p);
    358                    if (match != NULL) {
    359                      if (strcasecmp(match, filename) == 0) return;
    360                    }
    361                    else if (cnt == nrFile_index) return;  // 0 based index
    362                    cnt++;
    363                    break;
    364                }
    365          
    366              }
    367            } // while readDir
    368          }
    369          
    370          void CardReader::ls() {
    371            lsAction = LS_SerialPrint;
    372            root.rewind();
    373            lsDive("", root);
    374          }
    375          
    376          #if ENABLED(LONG_FILENAME_HOST_SUPPORT)
    377          
    378            /**
    379             * Get a long pretty path based on a DOS 8.3 path
    380             */
    381            void CardReader::printLongPath(char *path) {
    382              lsAction = LS_GetFilename;
    383          
    384              int i, pathLen = strlen(path);
    385          
    386              // SERIAL_ECHOPGM("Full Path: "); SERIAL_ECHOLN(path);
    387          
    388              // Zero out slashes to make segments
    389              for (i = 0; i < pathLen; i++) if (path[i] == '/') path[i] = '\0';
    390          
    391              SdFile diveDir = root; // start from the root for segment 1
    392              for (i = 0; i < pathLen;) {
    393          
    394                if (path[i] == '\0') i++; // move past a single nul
    395          
    396                char *segment = &path[i]; // The segment after most slashes
    397          
    398                // If a segment is empty (extra-slash) then exit
    399                if (!*segment) break;
    400          
    401                // Go to the next segment
    402                while (path[++i]) { }
    403          
    404                // SERIAL_ECHOPGM("Looking for segment: "); SERIAL_ECHOLN(segment);
    405          
    406                // Find the item, setting the long filename
    407                diveDir.rewind();
    408                lsDive("", diveDir, segment);
    409          
    410                // Print /LongNamePart to serial output
    411                SERIAL_PROTOCOLCHAR('/');
    412                SERIAL_PROTOCOL(longFilename[0] ? longFilename : "???");
    413          
    414                // If the filename was printed then that's it
    415                if (!filenameIsDir) break;
    416          
    417                // SERIAL_ECHOPGM("Opening dir: "); SERIAL_ECHOLN(segment);
    418          
    419                // Open the sub-item as the new dive parent
    420                SdFile dir;
    421                if (!dir.open(diveDir, segment, O_READ)) {
    422                  SERIAL_EOL();
    423                  SERIAL_ECHO_START();
    424                  SERIAL_ECHOPGM(MSG_SD_CANT_OPEN_SUBDIR);
    425                  SERIAL_ECHO(segment);
    426                  break;
    427                }
    428          
    429                diveDir.close();
    430                diveDir = dir;
    431          
    432              } // while i<pathLen
    433          
    434              SERIAL_EOL();
    435            }
    436          
    437          #endif // LONG_FILENAME_HOST_SUPPORT
    438          
    439          void CardReader::setroot() {
    440            /*if (!workDir.openRoot(&volume)) {
    441              SERIAL_ECHOLNPGM(MSG_SD_WORKDIR_FAIL);
    442            }*/
    443            workDir = root;
    444            curDir = &workDir;
    445            #if ENABLED(SDCARD_SORT_ALPHA)
    446              presort();
    447            #endif
    448          }
    449          
    450          #endif

   \                                 In section .text, align 2, keep-with-next
    451          void CardReader::initsd()
    452          {
    453          	FRESULT mksMountState = FR_DISK_ERR;
    454          	cardOK = false;
   \                     _ZN10CardReader6initsdEv: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xF880 0x19BB      STRB     R1,[R0, #+2491]
    455          	
    456          	if( SD_DET_IP != SD_DETECT_INVERTED)
    457          		return;
   \   00000006   0x4770             BX       LR               ;; return
    458          
    459          	if(f_mount(&fs, (TCHAR const*)SD_Path, 0) != FR_OK)	
                 	^
Warning[Pe111]: statement is unreachable

  	FRESULT mksMountState = FR_DISK_ERR;
  	        ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\cardreader.cpp",453  Warning[Pe177]: 
          variable "mksMountState" was declared but never referenced
    460          	{
    461          		SERIAL_ECHO_START();
    462          		SERIAL_ECHOLNPGM(MSG_SD_INIT_FAIL);
    463          	}
    464          	else
    465          	{
    466          		SERIAL_ECHO_START();
    467          		SERIAL_ECHOLNPGM(MSG_SD_CARD_OK);
    468          		cardOK = true;
    469          	}
    470          }
    471          #if 1
    472          

   \                                 In section .text, align 2, keep-with-next
    473          void CardReader::initusb()
    474          {
   \                     _ZN10CardReader7initusbEv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    475          	FRESULT mksMountState = FR_DISK_ERR;
                 	        ^
Warning[Pe177]: variable "mksMountState" was declared but never referenced
    476          	usbOK = false;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF884 0x09BC      STRB     R0,[R4, #+2492]
    477          
    478          	if(f_mount(&fs, (TCHAR const*)USBH_Path, 0) != FR_OK)	
   \   0000000A   0x.... 0x....      LDR.W    R5,??DataTable45_3
   \   0000000E   0x4602             MOV      R2,R0
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable45_6
   \   00000014   0xF504 0x700B      ADD      R0,R4,#+556
   \   00000018   0x.... 0x....      BL       f_mount
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0x4628             MOV      R0,R5
   \   00000020   0xD007             BEQ.N    ??initusb_0
    479          	{
    480          		SERIAL_ECHO_START();
   \   00000022   0x.... 0x....      BL       _Z14serialprintPGMPKc
    481          		SERIAL_ECHOLNPGM("USB init fail");
   \   00000026   0x.... 0x....      ADR.W    R0,`?<Constant "USB init fail\\n">`
   \   0000002A   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000002E   0x.... 0x....      B.W      _Z14serialprintPGMPKc
    482          	}
    483          	else
    484          	{
    485          		SERIAL_ECHO_START();
   \                     ??initusb_0: (+1)
   \   00000032   0x.... 0x....      BL       _Z14serialprintPGMPKc
    486          		SERIAL_ECHOLNPGM("USB OK");
   \   00000036   0x.... 0x....      ADR.W    R0,`?<Constant "USB OK\\n">`
   \   0000003A   0x.... 0x....      BL       _Z14serialprintPGMPKc
    487          		usbOK = true;
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0xF884 0x09BC      STRB     R0,[R4, #+2492]
    488          	}
    489          }
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    490          #endif

   \                                 In section .text, align 2, keep-with-next
    491          void CardReader::mount()
    492          {
    493              sdmode = false;	sdprinting = false;
   \                     _ZN10CardReader5mountEv: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xF880 0x146C      STRB     R1,[R0, #+1132]
   \   00000006   0xF880 0x19B8      STRB     R1,[R0, #+2488]
    494              initsd();
   \   0000000A   0x....             B.N      _ZN10CardReader6initsdEv
    495          }
    496          

   \                                 In section .text, align 2, keep-with-next
    497          void CardReader::unmount()
    498          {
    499              sdmode = false;		sdprinting = false;
   \                     _ZN10CardReader7unmountEv: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xF880 0x146C      STRB     R1,[R0, #+1132]
   \   00000006   0xF880 0x19B8      STRB     R1,[R0, #+2488]
    500          	cardOK = false;
   \   0000000A   0xF880 0x19BB      STRB     R1,[R0, #+2491]
    501              savetosd = false;	
   \   0000000E   0xF880 0x146D      STRB     R1,[R0, #+1133]
    502           #if 0   //lite mask   
    503          #if UI_DISPLAY_TYPE!=0 && SDSUPPORT
    504              uid.cwd[0]='/';
    505              uid.cwd[1]=0;
    506              uid.folderLevel=0;
    507          #endif
    508          #endif    //lite mask
    509          }
   \   00000012   0x4770             BX       LR               ;; return
    510          
    511          
    512          

   \                                 In section .text, align 2, keep-with-next
    513          void CardReader::release() {
    514              sdmode = false;		
   \                     _ZN10CardReader7releaseEv: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xF880 0x146C      STRB     R1,[R0, #+1132]
    515          	sdprinting = false;	
   \   00000006   0xF880 0x19B8      STRB     R1,[R0, #+2488]
    516          	cardOK = false;
   \   0000000A   0xF880 0x19BB      STRB     R1,[R0, #+2491]
    517              savetosd = false;	
   \   0000000E   0xF880 0x146D      STRB     R1,[R0, #+1133]
    518          
    519          }
   \   00000012   0x4770             BX       LR               ;; return
    520          #if 0
    521          void CardReader::openAndPrintFile(const char *name) {
    522            char cmd[4 + strlen(name) + 1]; // Room for "M23 ", filename, and null
    523            sprintf_P(cmd, PSTR("M23 %s"), name);
    524            for (char *c = &cmd[4]; *c; c++) *c = tolower(*c);
    525            enqueue_and_echo_command(cmd);
    526            enqueue_and_echo_commands_P(PSTR("M24"));
    527          }
    528          #endif
    529          

   \                                 In section .text, align 2, keep-with-next
    530          void CardReader::startPrint()
    531          {
    532              if(!cardOK) return;
   \                     _ZN10CardReader10startPrintEv: (+1)
   \   00000000   0xF890 0x19BB      LDRB     R1,[R0, #+2491]
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD004             BEQ.N    ??startPrint_0
    533              sdmode = true;	
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0xF880 0x146C      STRB     R1,[R0, #+1132]
    534          	sdprinting = true;
   \   0000000E   0xF880 0x19B8      STRB     R1,[R0, #+2488]
    535          }
   \                     ??startPrint_0: (+1)
   \   00000012   0x4770             BX       LR               ;; return
    536          

   \                                 In section .bss, align 4
    537          volatile int textt;
   \                     textt:
   \   00000000                      DS8 4

   \                                 In section .text, align 2, keep-with-next
    538          void CardReader::startFileprint() {
   \                     _ZN10CardReader14startFileprintEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    539            if (cardOK || usbOK) {
   \   00000002   0xF600 0x11B8      ADDW     R1,R0,#+2488
   \   00000006   0x78CA             LDRB     R2,[R1, #+3]
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD102             BNE.N    ??startFileprint_0
   \   0000000C   0x7909             LDRB     R1,[R1, #+4]
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD019             BEQ.N    ??startFileprint_1
    540              sdprinting = true; sdmode = true;
   \                     ??startFileprint_0: (+1)
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0xF880 0x19B8      STRB     R1,[R0, #+2488]
   \   00000018   0xF880 0x146C      STRB     R1,[R0, #+1132]
    541              #if ENABLED(SDCARD_SORT_ALPHA)
    542                flush_presort();
    543              #endif
    544          
    545          	mksReprint.mks_printer_state = MKS_WORKING;
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable45_10
   \   00000020   0x21A7             MOVS     R1,#+167
   \   00000022   0xF880 0x1058      STRB     R1,[R0, #+88]
    546              //if(gCfgItems.pwroff_save_mode != 1)
    547              {
    548          	    epr_write_data(EPR_SAV_FLAG, (uint8_t *)&mksReprint.mks_printer_state,sizeof(mksReprint.mks_printer_state));
   \   00000026   0x2201             MOVS     R2,#+1
   \   00000028   0xF100 0x0158      ADD      R1,R0,#+88
   \   0000002C   0xF44F 0x707A      MOV      R0,#+1000
   \   00000030   0x.... 0x....      BL       epr_write_data
    549               }
    550              epr_read_data(EPR_SAV_FLAG, (uint8_t *)&textt,sizeof(mksReprint.mks_printer_state));
   \   00000034   0x2201             MOVS     R2,#+1
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable45_11
   \   0000003A   0xF44F 0x707A      MOV      R0,#+1000
   \   0000003E   0xE8BD 0x4008      POP      {R3,LR}
   \   00000042   0x.... 0x....      B.W      epr_read_data
    551            }
    552          }
   \                     ??startFileprint_1: (+1)
   \   00000046   0xBD01             POP      {R0,PC}          ;; return
    553          

   \                                 In section .text, align 2, keep-with-next
    554          void CardReader::pausePrint(bool intern)
    555          {
    556              if(!card.cardOK) return;
   \                     _ZN10CardReader10pausePrintEb: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable45_8
   \   00000004   0xF891 0x19BB      LDRB     R1,[R1, #+2491]
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD002             BEQ.N    ??pausePrint_0
    557              sdmode = 2; // finish running line
   \   0000000C   0x2102             MOVS     R1,#+2
   \   0000000E   0xF880 0x146C      STRB     R1,[R0, #+1132]
    558          
    559          	/*...*/
    560          	
    561          }
   \                     ??pausePrint_0: (+1)
   \   00000012   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    562          void CardReader::pauseSDPrint()
    563          {
    564            if(sdprinting)
   \                     _ZN10CardReader12pauseSDPrintEv: (+1)
   \   00000000   0xF890 0x19B8      LDRB     R1,[R0, #+2488]
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD005             BEQ.N    ??pauseSDPrint_0
    565            {
    566              sdprinting = false;	sdmode = 2;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0xF880 0x19B8      STRB     R1,[R0, #+2488]
   \   0000000E   0x2102             MOVS     R1,#+2
   \   00000010   0xF880 0x146C      STRB     R1,[R0, #+1132]
    567            }
    568          }
   \                     ??pauseSDPrint_0: (+1)
   \   00000014   0x4770             BX       LR               ;; return
    569          
    570          

   \                                 In section .text, align 2, keep-with-next
    571          void CardReader::continuePrint(bool intern)
    572          {
    573              if(!card.cardOK) return;
    574          #if 0
    575              if(intern) {
    576                 // GCode::executeFString(PSTR(PAUSE_END_COMMANDS));
    577                  Printer::GoToMemoryPosition(true, true, false, false, Printer::maxFeedrate[X_AXIS]);
    578                  Printer::GoToMemoryPosition(false, false, true, false, Printer::maxFeedrate[Z_AXIS] / 2.0f);
    579                  Printer::GoToMemoryPosition(false, false, false, true, Printer::maxFeedrate[E_AXIS] / 2.0f);
    580              }
    581              //Printer::setMenuMode(MENU_MODE_SD_PAUSED, false);
    582              sdmode = 1;
    583              FALA_5V_CTRL = FALA_ON;    // °‰®∞?a°§°ß®§-¶Ã?®®Y
    584          #endif    
    585          }
   \                     _ZN10CardReader13continuePrintEb: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    586          void CardReader::stopSDPrint() {
   \                     _ZN10CardReader11stopSDPrintEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    587            sdprinting = false;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF884 0x09B8      STRB     R0,[R4, #+2488]
    588            if (isFileOpen()) closefile();
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       _ZN10CardReader10isFileOpenEv
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD004             BEQ.N    ??stopSDPrint_0
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001C   0x....             B.N      _ZN10CardReader9closefileEb
    589          }
   \                     ??stopSDPrint_0: (+1)
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
    590          void CardReader::stopPrint()
    591          {
    592              if(!card.cardOK) return;
   \                     _ZN10CardReader9stopPrintEv: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable45_8
   \   00000004   0xF891 0x19BB      LDRB     R1,[R1, #+2491]
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD004             BEQ.N    ??stopPrint_0
    593              sdmode = 0;	sdprinting = false;	
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0xF880 0x146C      STRB     R1,[R0, #+1132]
   \   00000012   0xF880 0x19B8      STRB     R1,[R0, #+2488]
    594          }
   \                     ??stopPrint_0: (+1)
   \   00000016   0x4770             BX       LR               ;; return
    595          

   \                                 In section .text, align 2, keep-with-next
    596          void CardReader::operatePrint()
    597          {
    598               
    599          }
   \                     _ZN10CardReader12operatePrintEv: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    600          char *CardReader::createFilename(char *buffer,const dir_t &p)
    601          {
   \                     _ZN10CardReader14createFilenameEPcRK14directoryEntry: (+1)
   \   00000000   0xB410             PUSH     {R4}
    602              char *pos = buffer,*src = (char*)p.name;
    603              for (uint8_t i = 0; i < 11; i++,src++)
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0xE00D             B.N      ??createFilename_0
    604              {
    605                  if (*src == ' ') continue;
   \                     ??createFilename_1: (+1)
   \   00000006   0xF992 0x4000      LDRSB    R4,[R2, #+0]
   \   0000000A   0x2C20             CMP      R4,#+32
   \   0000000C   0xD007             BEQ.N    ??createFilename_2
    606                  if (i == 8)
   \   0000000E   0x2B08             CMP      R3,#+8
   \   00000010   0xD102             BNE.N    ??createFilename_3
    607                      *pos++ = '.';
   \   00000012   0x232E             MOVS     R3,#+46
   \   00000014   0xF801 0x3B01      STRB     R3,[R1], #+1
    608                  *pos++ = *src;
   \                     ??createFilename_3: (+1)
   \   00000018   0x7813             LDRB     R3,[R2, #+0]
   \   0000001A   0xF801 0x3B01      STRB     R3,[R1], #+1
    609              }
   \                     ??createFilename_2: (+1)
   \   0000001E   0x1C40             ADDS     R0,R0,#+1
   \   00000020   0x1C52             ADDS     R2,R2,#+1
   \                     ??createFilename_0: (+1)
   \   00000022   0xB2C0             UXTB     R0,R0
   \   00000024   0x4603             MOV      R3,R0
   \   00000026   0x2B0B             CMP      R3,#+11
   \   00000028   0xDBED             BLT.N    ??createFilename_1
    610              *pos = 0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x7008             STRB     R0,[R1, #+0]
    611              return pos;
   \   0000002E   0x4608             MOV      R0,R1
   \   00000030   0xBC10             POP      {R4}
   \   00000032   0x4770             BX       LR               ;; return
    612          }

   \                                 In section .text, align 2, keep-with-next
    613          bool CardReader::showFilename(const uint8_t *name)
    614          {
    615              if (*name == DIR_NAME_DELETED || *name == '.') return false;
   \                     _ZN10CardReader12showFilenameEPKh: (+1)
   \   00000000   0x7808             LDRB     R0,[R1, #+0]
   \   00000002   0x28E5             CMP      R0,#+229
   \   00000004   0xD001             BEQ.N    ??showFilename_0
   \   00000006   0x282E             CMP      R0,#+46
   \   00000008   0xD101             BNE.N    ??showFilename_1
   \                     ??showFilename_0: (+1)
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x4770             BX       LR
    616              return true;
   \                     ??showFilename_1: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x4770             BX       LR               ;; return
    617          }
    618          

   \                                 In section .text, align 2, keep-with-next
    619          int8_t RFstricmp(const char* s1, const char* s2)
    620          {
   \                     _Z9RFstricmpPKcS0_: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0xE001             B.N      ??RFstricmp_0
    621              while(*s1 && (tolower(*s1) == tolower(*s2)))
    622                  s1++,s2++;
   \                     ??RFstricmp_1: (+1)
   \   00000008   0x1C64             ADDS     R4,R4,#+1
   \   0000000A   0x1C6D             ADDS     R5,R5,#+1
   \                     ??RFstricmp_0: (+1)
   \   0000000C   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD008             BEQ.N    ??RFstricmp_2
   \   00000014   0x.... 0x....      BL       tolower
   \   00000018   0x4606             MOV      R6,R0
   \   0000001A   0xF995 0x0000      LDRSB    R0,[R5, #+0]
   \   0000001E   0x.... 0x....      BL       tolower
   \   00000022   0x4286             CMP      R6,R0
   \   00000024   0xD0F0             BEQ.N    ??RFstricmp_1
    623              return (const uint8_t)tolower(*s1)-(const uint8_t)tolower(*s2);
                             ^
Warning[Pe191]: type qualifier is meaningless on cast type

      return (const uint8_t)tolower(*s1)-(const uint8_t)tolower(*s2);
                                          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\cardreader.cpp",623  Warning[Pe191]: 
          type qualifier is meaningless on cast type
   \                     ??RFstricmp_2: (+1)
   \   00000026   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   0000002A   0x.... 0x....      BL       tolower
   \   0000002E   0x4604             MOV      R4,R0
   \   00000030   0xF995 0x0000      LDRSB    R0,[R5, #+0]
   \   00000034   0x.... 0x....      BL       tolower
   \   00000038   0x1A20             SUBS     R0,R4,R0
   \   0000003A   0xB240             SXTB     R0,R0
   \   0000003C   0xBD70             POP      {R4-R6,PC}       ;; return
    624          }
    625          

   \                                 In section .text, align 2, keep-with-next
    626          int8_t RFstrnicmp(const char* s1, const char* s2, size_t n)
    627          {
   \                     _Z10RFstrnicmpPKcS0_j: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0xE001             B.N      ??RFstrnicmp_0
    628              while(n--)
    629              {
    630                  if(tolower(*s1)!=tolower(*s2))
    631                      return (uint8_t)tolower(*s1) - (uint8_t)tolower(*s2);
    632                  s1++;
   \                     ??RFstrnicmp_1: (+1)
   \   0000000A   0x1C64             ADDS     R4,R4,#+1
    633                  s2++;
   \   0000000C   0x1C6D             ADDS     R5,R5,#+1
   \                     ??RFstrnicmp_0: (+1)
   \   0000000E   0x4630             MOV      R0,R6
   \   00000010   0x1E46             SUBS     R6,R0,#+1
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD016             BEQ.N    ??RFstrnicmp_2
   \   00000016   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   0000001A   0x.... 0x....      BL       tolower
   \   0000001E   0x4607             MOV      R7,R0
   \   00000020   0xF995 0x0000      LDRSB    R0,[R5, #+0]
   \   00000024   0x.... 0x....      BL       tolower
   \   00000028   0x4287             CMP      R7,R0
   \   0000002A   0xD0EE             BEQ.N    ??RFstrnicmp_1
   \   0000002C   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   00000030   0x.... 0x....      BL       tolower
   \   00000034   0x4604             MOV      R4,R0
   \   00000036   0xF995 0x0000      LDRSB    R0,[R5, #+0]
   \   0000003A   0x.... 0x....      BL       tolower
   \   0000003E   0x1A20             SUBS     R0,R4,R0
   \   00000040   0xB240             SXTB     R0,R0
   \   00000042   0xBDF2             POP      {R1,R4-R7,PC}
    634              }
    635              return 0;
   \                     ??RFstrnicmp_2: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    636          }
    637          

   \                                 In section .text, align 2, keep-with-next
    638          void CardReader::ls()
    639          {
    640              if ((SD_DET_IP == SD_DETECT_INVERTED)&&(usbOK == false))
    641                get_file_list(SD_Path);
    642              else
    643                get_file_list(USBH_Path);
   \                     _ZN10CardReader2lsEv: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable45_6
   \   00000004   0x....             B.N      _ZN10CardReader13get_file_listEPc
    644          }
    645          

   \                                 In section .text, align 2, keep-with-next
    646          bool CardReader::selectFile(char *filename, bool silent){}
                                                                          ^
Warning[Pe940]: missing return statement at end of non-void function
          "CardReader::selectFile"
   \                     _ZN10CardReader10selectFileEPcb: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    647          

   \                                 In section .text, align 2, keep-with-next
    648          bool CardReader::openFile(char* filename,bool silent, bool replace_current/*=true*/)
    649          {
   \                     _ZN10CardReader8openFileEPcbb: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB092             SUB      SP,SP,#+72
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    650              SdBaseFile parent;
   \   00000008   0xA808             ADD      R0,SP,#+32
   \   0000000A   0x.... 0x....      BL       _ZN10SdBaseFileC1Ev
    651              char *oldP;
                           ^
Warning[Pe177]: variable "oldP" was declared but never referenced
    652              boolean bFound;
                             ^
Warning[Pe177]: variable "bFound" was declared but never referenced
    653              
    654              char newname[30]={0};
   \   0000000E   0xA800             ADD      R0,SP,#+0
   \   00000010   0x2120             MOVS     R1,#+32
   \   00000012   0x.... 0x....      BL       __aeabi_memclr4
    655                
    656          	  if(sdprinting)			return false;
   \   00000016   0xF894 0x09B8      LDRB     R0,[R4, #+2488]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD001             BEQ.N    ??openFile_0
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE05A             B.N      ??openFile_1
    657          	  f_close(&curFile);
   \                     ??openFile_0: (+1)
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       f_close
    658          
    659            if(filename[2] != '/')     //???t??2?°‰??®¨°§??°§??
   \   00000028   0xF995 0x0002      LDRSB    R0,[R5, #+2]
   \   0000002C   0x282F             CMP      R0,#+47
   \   0000002E   0xD00A             BEQ.N    ??openFile_2
    660            {    
    661             if(card.cardOK)
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable45_8
   \   00000034   0xF890 0x19BB      LDRB     R1,[R0, #+2491]
   \   00000038   0x2900             CMP      R1,#+0
   \   0000003A   0xD033             BEQ.N    ??openFile_3
    662          	   strcat(newname,SD_Path);
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable45_4
   \   00000040   0xA800             ADD      R0,SP,#+0
   \   00000042   0x.... 0x....      BL       strcat
    663             else if(card.usbOK)
    664          	   strcat(newname,USBH_Path);
    665             else
    666                    return false;
    667            }
    668          	strcat(newname,filename);
   \                     ??openFile_2: (+1)
   \   00000046   0x4629             MOV      R1,R5
   \   00000048   0xA800             ADD      R0,SP,#+0
   \   0000004A   0x.... 0x....      BL       strcat
    669          
    670             mks_saveFileName(newname);
   \   0000004E   0x.... 0x....      BL       mks_saveFileName
    671          
    672          	if(f_open(&curFile, (const TCHAR *)newname, FA_OPEN_EXISTING | FA_READ) == FR_OK)					
   \   00000052   0x.... 0x....      LDR.W    R6,??DataTable45_12
   \   00000056   0x2201             MOVS     R2,#+1
   \   00000058   0xA900             ADD      R1,SP,#+0
   \   0000005A   0x4620             MOV      R0,R4
   \   0000005C   0x.... 0x....      BL       f_open
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD12B             BNE.N    ??openFile_4
    673                {
    674          
    675                  if(!silent)
    676                  {
    677                  }
    678          		
    679                  sdpos = 0;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xF8C4 0x0460      STR      R0,[R4, #+1120]
    680                  filesize = curFile.fsize;
   \   0000006A   0xF8D4 0x020C      LDR      R0,[R4, #+524]
   \   0000006E   0xF8C4 0x045C      STR      R0,[R4, #+1116]
    681                  SERIAL_PROTOCOLPAIR(MSG_SD_FILE_OPENED, filename);
   \   00000072   0x4629             MOV      R1,R5
   \   00000074   0x.... 0x....      ADR.W    R0,`?<Constant "File opened: ">`
   \   00000078   0x.... 0x....      BL       _Z17serial_echopair_PPKcS0_
    682          		SERIAL_PROTOCOLPGM(MSG_SD_SIZE);
   \   0000007C   0x.... 0x....      ADR.W    R0,`?<Constant " Size: ">`
   \   00000080   0x.... 0x....      BL       _Z14serialprintPGMPKc
    683          		SERIAL_PROTOCOL(filesize);
   \   00000084   0x220A             MOVS     R2,#+10
   \   00000086   0xF8D4 0x145C      LDR      R1,[R4, #+1116]
   \   0000008A   0x4630             MOV      R0,R6
   \   0000008C   0x.... 0x....      BL       _ZN5Print5printEji
    684                  SERIAL_EOL();
   \   00000090   0x210A             MOVS     R1,#+10
   \   00000092   0x4630             MOV      R0,R6
   \   00000094   0x.... 0x....      BL       _ZN10USARTClass5writeEh
    685          		SERIAL_PROTOCOLLNPGM(MSG_SD_FILE_SELECTED);
   \   00000098   0x.... 0x....      ADR.W    R0,`?<Constant "File selected\\n">`
   \   0000009C   0x.... 0x....      BL       _Z14serialprintPGMPKc
    686                  return true;
   \   000000A0   0x2001             MOVS     R0,#+1
   \   000000A2   0xE019             B.N      ??openFile_1
    687              }
   \                     ??openFile_3: (+1)
   \   000000A4   0xF890 0x09BC      LDRB     R0,[R0, #+2492]
   \   000000A8   0x2800             CMP      R0,#+0
   \   000000AA   0xD005             BEQ.N    ??openFile_5
   \   000000AC   0x.... 0x....      LDR.W    R1,??DataTable45_6
   \   000000B0   0xA800             ADD      R0,SP,#+0
   \   000000B2   0x.... 0x....      BL       strcat
   \   000000B6   0xE7C6             B.N      ??openFile_2
   \                     ??openFile_5: (+1)
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0xE00D             B.N      ??openFile_1
    688              else
    689              {
    690          		SERIAL_PROTOCOLPAIR(MSG_SD_OPEN_FILE_FAIL, filename);
   \                     ??openFile_4: (+1)
   \   000000BC   0x4629             MOV      R1,R5
   \   000000BE   0x.... 0x....      ADR.W    R0,`?<Constant "open failed, File: ">`
   \   000000C2   0x.... 0x....      BL       _Z17serial_echopair_PPKcS0_
    691          		SERIAL_PROTOCOLCHAR('.');
   \   000000C6   0x212E             MOVS     R1,#+46
   \   000000C8   0x4630             MOV      R0,R6
   \   000000CA   0x.... 0x....      BL       _ZN10USARTClass5writeEh
    692          		SERIAL_EOL();
   \   000000CE   0x210A             MOVS     R1,#+10
   \   000000D0   0x4630             MOV      R0,R6
   \   000000D2   0x.... 0x....      BL       _ZN10USARTClass5writeEh
    693              
    694                  if(!silent){}
    695             //         Com::printFLN(Com::tFileOpenFailed);
    696                  return false;
   \   000000D6   0x2000             MOVS     R0,#+0
   \                     ??openFile_1: (+1)
   \   000000D8   0xB012             ADD      SP,SP,#+72
   \   000000DA   0xBD70             POP      {R4-R6,PC}       ;; return
    697              }
    698          }
    699          

   \                                 In section .text, align 2, keep-with-next
    700          void CardReader::printStatus()
    701          {
    702          #if 0
    703              if(sdactive)
    704              {
    705                  Com::printF(Com::tSDPrintingByte, sdpos);
    706                  Com::printFLN(Com::tSlash, filesize);
    707              }
    708              else
    709              {
    710                  Com::printFLN(Com::tNotSDPrinting);
    711              }
    712          #endif	
    713          
    714          }
   \                     _ZN10CardReader11printStatusEv: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    715          

   \                                 In section .text, align 2, keep-with-next
    716          void CardReader::getStatus()
    717          {
   \                     _ZN10CardReader9getStatusEv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    718            if(cardOK || usbOK){
   \   00000004   0xF894 0x09BB      LDRB     R0,[R4, #+2491]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD103             BNE.N    ??getStatus_0
   \   0000000C   0xF894 0x09BC      LDRB     R0,[R4, #+2492]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD01A             BEQ.N    ??getStatus_1
    719              SERIAL_PROTOCOLPGM(MSG_SD_PRINTING_BYTE);
   \                     ??getStatus_0: (+1)
   \   00000014   0x.... 0x....      ADR.W    R0,`?<Constant "SD printing byte ">`
   \   00000018   0x.... 0x....      BL       _Z14serialprintPGMPKc
    720              SERIAL_PROTOCOL(sdpos);
   \   0000001C   0x.... 0x....      LDR.W    R5,??DataTable45_12
   \   00000020   0x220A             MOVS     R2,#+10
   \   00000022   0xF8D4 0x1460      LDR      R1,[R4, #+1120]
   \   00000026   0x4628             MOV      R0,R5
   \   00000028   0x.... 0x....      BL       _ZN5Print5printEji
    721              SERIAL_PROTOCOLPGM("/");
   \   0000002C   0x....             ADR.N    R0,??DataTable42  ;; "/"
   \   0000002E   0x.... 0x....      BL       _Z14serialprintPGMPKc
    722              SERIAL_PROTOCOLLN(filesize);
   \   00000032   0x220A             MOVS     R2,#+10
   \   00000034   0xF8D4 0x145C      LDR      R1,[R4, #+1116]
   \   00000038   0x4628             MOV      R0,R5
   \   0000003A   0x.... 0x....      BL       _ZN5Print5printEji
   \   0000003E   0x210A             MOVS     R1,#+10
   \   00000040   0x4628             MOV      R0,R5
   \   00000042   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000046   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
    723            }
    724            else{
    725              SERIAL_PROTOCOLLNPGM(MSG_SD_NOT_PRINTING);
   \                     ??getStatus_1: (+1)
   \   0000004A   0x.... 0x....      ADR.W    R0,`?<Constant "Not SD printing\\n">`
   \   0000004E   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000052   0x.... 0x....      B.W      _Z14serialprintPGMPKc
    726            }
    727          }
    728          
    729          

   \                                 In section .text, align 2, keep-with-next
    730          void CardReader::startWrite(char *filename)
    731          {
   \                     _ZN10CardReader10startWriteEPc: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    732           //char sdFileName[100];
    733            //memset(sdFileName,0,sizeof(sdFileName));
    734            
    735              if(!cardOK && ! usbOK) return;
   \   00000006   0xF604 0x10B8      ADDW     R0,R4,#+2488
   \   0000000A   0x78C1             LDRB     R1,[R0, #+3]
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD102             BNE.N    ??startWrite_0
   \   00000010   0x7900             LDRB     R0,[R0, #+4]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD012             BEQ.N    ??startWrite_1
    736                f_close(&card.curFile);
   \                     ??startWrite_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable45_8
   \   0000001A   0x.... 0x....      BL       f_close
    737              sdmode = false;    sdprinting = false;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xF884 0x046C      STRB     R0,[R4, #+1132]
   \   00000024   0xF884 0x09B8      STRB     R0,[R4, #+2488]
    738              
    739              //fat.chdir();
    740          	
    741              //if(!file.open(filename, O_CREAT | O_APPEND | O_WRITE | O_TRUNC))
    742                  //strcat(sdFileName,SD_Path);
    743                  //strcat(sdFileName,filename);
    744          	if(f_open(&curFile, (const TCHAR *)filename, FA_CREATE_ALWAYS | FA_WRITE | FA_READ)  != FR_OK)
   \   00000028   0x220B             MOVS     R2,#+11
   \   0000002A   0x4629             MOV      R1,R5
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       f_open
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD102             BNE.N    ??startWrite_1
    745              {
    746               ///   Com::printFLN(Com::tOpenFailedFile,filename);
    747              }
    748              else
    749              {
    750            ///      UI_STATUS(UI_TEXT_UPLOADING);
    751                  savetosd = true;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0xF884 0x046D      STRB     R0,[R4, #+1133]
    752             ///     Com::printFLN(Com::tWritingToFile,filename);
    753              }
    754          }
   \                     ??startWrite_1: (+1)
   \   0000003C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    755          

   \                                 In section .text, align 2, keep-with-next
    756          void CardReader::finishWrite()
    757          {
   \                     _ZN10CardReader11finishWriteEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    758              if(!savetosd) return; // already closed or never opened
   \   00000004   0xF894 0x046D      LDRB     R0,[R4, #+1133]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD008             BEQ.N    ??finishWrite_0
    759              //file.sync();
    760              //file.close();
    761              f_sync(&curFile);
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       f_sync
    762          	f_close(&curFile);
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       f_close
    763              savetosd = false;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF884 0x046D      STRB     R0,[R4, #+1133]
    764           ///   Com::printFLN(Com::tDoneSavingFile);
    765              //UI_CLEAR_STATUS;
    766          }
   \                     ??finishWrite_0: (+1)
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
    767          
    768          

   \                                 In section .text, align 2, keep-with-next
    769          void CardReader::deleteFile(char *filename)	{}
   \                     _ZN10CardReader10deleteFileEPc: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    770          void CardReader::removeFile(char* filename) 
    771          {
   \                     _ZN10CardReader10removeFileEPc: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    772              if(!cardOK && !usbOK) return;
   \   00000006   0xF604 0x10B8      ADDW     R0,R4,#+2488
   \   0000000A   0x78C1             LDRB     R1,[R0, #+3]
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD102             BNE.N    ??removeFile_0
   \   00000010   0x7900             LDRB     R0,[R0, #+4]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD02B             BEQ.N    ??removeFile_1
    773              sdmode = false; sdprinting = false;
   \                     ??removeFile_0: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF884 0x046C      STRB     R0,[R4, #+1132]
   \   0000001C   0xF884 0x09B8      STRB     R0,[R4, #+2488]
    774          	
    775              f_close(&curFile);
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       f_close
    776              /*if(fat.remove(filename))
    777              {
    778                  Com::printFLN(Com::tFileDeleted);
    779              }
    780              else
    781              {
    782                  if(fat.rmdir(filename))
    783                      Com::printFLN(Com::tFileDeleted);
    784                  else
    785                      Com::printFLN(Com::tDeletionFailed);
    786              }*/
    787              if(f_unlink((const TCHAR *)filename) == FR_OK)
   \   00000026   0x.... 0x....      LDR.W    R6,??DataTable45_12
   \   0000002A   0x4628             MOV      R0,R5
   \   0000002C   0x.... 0x....      BL       f_unlink
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD10F             BNE.N    ??removeFile_2
    788          	{
    789            ///      Com::printFLN(Com::tFileDeleted);
    790            	SERIAL_PROTOCOLPGM("File deleted:");
   \   00000034   0x.... 0x....      ADR.W    R0,`?<Constant "File deleted:">`
   \   00000038   0x.... 0x....      BL       _Z14serialprintPGMPKc
    791            	SERIAL_PROTOCOLLN(filename);
   \   0000003C   0x4629             MOV      R1,R5
   \   0000003E   0x4630             MOV      R0,R6
   \   00000040   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   00000044   0x210A             MOVS     R1,#+10
   \   00000046   0x4630             MOV      R0,R6
   \   00000048   0x.... 0x....      BL       _ZN10USARTClass5writeEh
    792            	sdpos = 0;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xF8C4 0x0460      STR      R0,[R4, #+1120]
   \   00000052   0xBD70             POP      {R4-R6,PC}
    793            
    794              }
    795          	else
    796          	{
    797          ///		Com::printFLN(Com::tDeletionFailed);
    798          	SERIAL_PROTOCOLPGM("Deletion failed, File: ");
   \                     ??removeFile_2: (+1)
   \   00000054   0x.... 0x....      ADR.W    R0,`?<Constant "Deletion failed, File: ">`
   \   00000058   0x.... 0x....      BL       _Z14serialprintPGMPKc
    799          	SERIAL_PROTOCOL(filename);
   \   0000005C   0x4629             MOV      R1,R5
   \   0000005E   0x4630             MOV      R0,R6
   \   00000060   0x.... 0x....      BL       _ZN5Print5printEPKc
    800          	SERIAL_PROTOCOLLNPGM(".");
   \   00000064   0x....             ADR.N    R0,??DataTable43  ;; 0x2E, 0x0A, 0x00, 0x00
   \   00000066   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000006A   0x.... 0x....      B.W      _Z14serialprintPGMPKc
    801          
    802          	}
    803          }
   \                     ??removeFile_1: (+1)
   \   0000006E   0xBD70             POP      {R4-R6,PC}       ;; return
    804          

   \                                 In section .text, align 2, keep-with-next
    805          void CardReader::makeDirectory(char *filename)
    806          {
   \                     _ZN10CardReader13makeDirectoryEPc: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
    807              if(!cardOK && !usbOK) return;
   \   00000004   0xF600 0x11B8      ADDW     R1,R0,#+2488
   \   00000008   0x78CA             LDRB     R2,[R1, #+3]
   \   0000000A   0x2A00             CMP      R2,#+0
   \   0000000C   0xD102             BNE.N    ??makeDirectory_0
   \   0000000E   0x7909             LDRB     R1,[R1, #+4]
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD023             BEQ.N    ??makeDirectory_1
    808              sdmode = false;	sdprinting = false;
   \                     ??makeDirectory_0: (+1)
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0xF880 0x146C      STRB     R1,[R0, #+1132]
   \   0000001A   0xF880 0x19B8      STRB     R1,[R0, #+2488]
    809              //file.close();
    810              f_close(&curFile);
   \   0000001E   0x.... 0x....      BL       f_close
    811              //if(fat.mkdir(filename))
    812              if(f_mkdir((const TCHAR *)filename) == FR_OK)
   \   00000022   0x.... 0x....      LDR.W    R5,??DataTable45_12
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       f_mkdir
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD10A             BNE.N    ??makeDirectory_2
    813              {
    814           ///       Com::printFLN(Com::tDirectoryCreated);
    815           		SERIAL_PROTOCOLLN("Directory created");
   \   00000030   0x.... 0x....      ADR.W    R1,`?<Constant "Directory created">`
   \   00000034   0x4628             MOV      R0,R5
   \   00000036   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   0000003A   0x210A             MOVS     R1,#+10
   \   0000003C   0x4628             MOV      R0,R5
   \   0000003E   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000042   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
    816              }
    817              else
    818              {
    819            ///      Com::printFLN(Com::tCreationFailed);
    820            SERIAL_PROTOCOLLN("Creation failed");
   \                     ??makeDirectory_2: (+1)
   \   00000046   0x.... 0x....      ADR.W    R1,`?<Constant "Creation failed">`
   \   0000004A   0x4628             MOV      R0,R5
   \   0000004C   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   00000050   0x210A             MOVS     R1,#+10
   \   00000052   0x4628             MOV      R0,R5
   \   00000054   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000058   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
    821              }
    822          }
   \                     ??makeDirectory_1: (+1)
   \   0000005C   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
    823          void CardReader::get_file_list(char *path)
    824          {
    825          	if( path == 0)
   \                     _ZN10CardReader13get_file_listEPc: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0xD001             BEQ.N    ??get_file_list_0
    826          	{
    827          		return;
    828          	}
    829          
    830          	Explore_Disk(path, 0);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x....             B.N      _ZN10CardReader12Explore_DiskEPch
   \                     ??get_file_list_0: (+1)
   \   00000008   0x4770             BX       LR               ;; return
    831          	
    832          	
    833          }
    834          

   \                                 In section .text, align 2, keep-with-next
    835          uint8_t CardReader::Explore_Disk (char* path , uint8_t recu_level)
    836          {
   \                     _ZN10CardReader12Explore_DiskEPch: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xF5AD 0x7D76      SUB      SP,SP,#+984
   \   00000008   0x460C             MOV      R4,R1
   \   0000000A   0x4615             MOV      R5,R2
    837          
    838            FILINFO fno;
    839            DIR dir;
    840           // SD_CardInfo cardinfo;
    841            TCHAR *fn;
    842            char tmp[200];
    843            char Fstream[200];
    844          	int local_offset;
    845          	int file_offset = 0;
   \   0000000C   0x2700             MOVS     R7,#+0
    846          	FRESULT res;
    847          	
    848            #if _USE_LFN
    849              static TCHAR lfn[_MAX_LFN + 1];
    850              fno.lfname = lfn;
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable45_13
   \   00000012   0x9106             STR      R1,[SP, #+24]
    851              fno.lfsize = sizeof(lfn);
   \   00000014   0xF44F 0x7180      MOV      R1,#+256
   \   00000018   0x9107             STR      R1,[SP, #+28]
    852          #endif
    853          
    854          	if(path == 0)
   \   0000001A   0x2C00             CMP      R4,#+0
   \   0000001C   0xD101             BNE.N    ??Explore_Disk_0
    855          		return 0;
   \   0000001E   0x4638             MOV      R0,R7
   \   00000020   0xE018             B.N      ??Explore_Disk_1
    856          /*
    857          	if(path[0] == '0')               //skyblue 2016-12-13
    858          		f_mount(0, &fs);
    859          	else if(path[0] == '1')
    860          		f_mount(1, &fs);
    861          	else
    862          		return;
    863          */	
    864                  f_mount(&fs, (char *)path, 0);     //skyblue 2016-12-13
   \                     ??Explore_Disk_0: (+1)
   \   00000022   0x463A             MOV      R2,R7
   \   00000024   0x4621             MOV      R1,R4
   \   00000026   0xF500 0x700B      ADD      R0,R0,#+556
   \   0000002A   0x.... 0x....      BL       f_mount
   \   0000002E   0xE007             B.N      ??Explore_Disk_2
    865                  
    866          	for(;;)
    867          	{
    868          		local_offset = 0;
    869          		
    870          		if (f_opendir(&dir, (const TCHAR *)path) == FR_OK) 
    871          	  	{
    872          
    873          		    while(1)
    874          		    {
    875          				res = f_readdir(&dir, &fno);
    876          				if (res != FR_OK || fno.fname[0] == 0) 
    877          				{
    878          					return;
                 					      ^
Warning[Pe117]: non-void function "CardReader::Explore_Disk" should return a
          value
    879          				}
    880          				if (fno.fname[0] == '.')
    881          				{
    882          					continue;
    883          				}
    884          
    885          				
    886          
    887          
    888          				if(local_offset >= file_offset)
    889          				{
    890          					file_offset++;
    891          					break;
    892          				}
    893          
    894          				local_offset++;
    895          		    }
    896          			
    897          		    if ((fno.lfname[0] == 0) || (fno.lfname == 0))
    898          				fn = fno.fname;
    899          			else
    900          				fn = fno.lfname;
    901          				
    902          		      	if((strstr((const char *)fn, ".gco")) || (strstr((const char *)fn, ".GCO")) || (strstr(fn, ".mdl"))|| (strstr(fn, ".MDL"))|| (fno.fattrib & AM_DIR))
    903          				{
    904          					  
    905          					  tmp[0] = '\0';
    906          					 // strcpy(tmp, path);
    907          					 // strcat(tmp, "/");
    908          					  strcat((char *)tmp, (char *)fn);
    909          
    910          					memset(Fstream, 0, sizeof(Fstream));
    911          					strcpy(Fstream, tmp);
    912          					  if((fno.fattrib & AM_DIR)&&(recu_level <= 10))
    913          				      {
    914          				      //  Explore_Disk(tmp, recu_level + 1);
    915          				      	
    916          						
    917          						strcat(Fstream, ".DIR\r\n");
   \                     ??Explore_Disk_3: (+1)
   \   00000030   0x.... 0x....      ADR.W    R1,`?<Constant ".DIR\\r\\n">`
   \   00000034   0x.... 0x....      BL       strcat
    918          						//send_to_wifi(Fstream, strlen(Fstream));
    919          					//Com::print(Fstream);
    920                             	//Com::printF(Com::tSlash);
    921          					
    922          						SERIAL_PROTOCOL(Fstream);
   \   00000038   0xA908             ADD      R1,SP,#+32
   \   0000003A   0x....             LDR.N    R0,??DataTable45_12
   \   0000003C   0x.... 0x....      BL       _ZN5Print5printEPKc
    923          						//SERIAL_PROTOCOLLNPGM("/");
    924          
    925          
    926          				      }
   \                     ??Explore_Disk_2: (+1)
   \   00000040   0xF04F 0x0800      MOV      R8,#+0
   \   00000044   0x4621             MOV      R1,R4
   \   00000046   0xA86C             ADD      R0,SP,#+432
   \   00000048   0x.... 0x....      BL       f_opendir
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD007             BEQ.N    ??Explore_Disk_4
    927          					  else
    928          					  {					
    929          						strcat(Fstream, "\r\n");
    930          						//send_to_wifi(Fstream, strlen(Fstream));
    931          ///						Com::print(Fstream);
    932          ///                     	Com::printF(Com::tSlash);
    933          						SERIAL_PROTOCOL(Fstream);
    934          						//SERIAL_PROTOCOLLNPGM("/");
    935          
    936          					  }
    937          				}
    938          		  
    939          		      
    940          
    941          		     
    942          		    }
    943          				else
    944          					break;
    945          	
    946            	
    947          	}
    948           return res;
   \   00000050   0x4630             MOV      R0,R6
   \   00000052   0xB2C0             UXTB     R0,R0
   \                     ??Explore_Disk_1: (+1)
   \   00000054   0xF50D 0x7D76      ADD      SP,SP,#+984
   \   00000058   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   \                     ??Explore_Disk_5: (+1)
   \   0000005C   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??Explore_Disk_4: (+1)
   \   00000060   0xA900             ADD      R1,SP,#+0
   \   00000062   0xA86C             ADD      R0,SP,#+432
   \   00000064   0x.... 0x....      BL       f_readdir
   \   00000068   0x0006             MOVS     R6,R0
   \   0000006A   0xD1F3             BNE.N    ??Explore_Disk_1
   \   0000006C   0xF99D 0x0009      LDRSB    R0,[SP, #+9]
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD0EF             BEQ.N    ??Explore_Disk_1
   \   00000074   0x282E             CMP      R0,#+46
   \   00000076   0xD0F3             BEQ.N    ??Explore_Disk_4
   \   00000078   0x45B8             CMP      R8,R7
   \   0000007A   0xDBEF             BLT.N    ??Explore_Disk_5
   \   0000007C   0x1C7F             ADDS     R7,R7,#+1
   \   0000007E   0xF8DD 0x8018      LDR      R8,[SP, #+24]
   \   00000082   0xF998 0x0000      LDRSB    R0,[R8, #+0]
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD002             BEQ.N    ??Explore_Disk_6
   \   0000008A   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000008E   0xD101             BNE.N    ??Explore_Disk_7
   \                     ??Explore_Disk_6: (+1)
   \   00000090   0xF10D 0x0809      ADD      R8,SP,#+9
   \                     ??Explore_Disk_7: (+1)
   \   00000094   0x.... 0x....      ADR.W    R1,`?<Constant ".gco">`
   \   00000098   0x4640             MOV      R0,R8
   \   0000009A   0x.... 0x....      BL       _Z6strstrPKcS0_
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD118             BNE.N    ??Explore_Disk_8
   \   000000A2   0x.... 0x....      ADR.W    R1,`?<Constant ".GCO">`
   \   000000A6   0x4640             MOV      R0,R8
   \   000000A8   0x.... 0x....      BL       _Z6strstrPKcS0_
   \   000000AC   0x2800             CMP      R0,#+0
   \   000000AE   0xD111             BNE.N    ??Explore_Disk_8
   \   000000B0   0x.... 0x....      ADR.W    R1,`?<Constant ".mdl">`
   \   000000B4   0x4640             MOV      R0,R8
   \   000000B6   0x.... 0x....      BL       _Z6strstrPcPKc
   \   000000BA   0x2800             CMP      R0,#+0
   \   000000BC   0xD10A             BNE.N    ??Explore_Disk_8
   \   000000BE   0x.... 0x....      ADR.W    R1,`?<Constant ".MDL">`
   \   000000C2   0x4640             MOV      R0,R8
   \   000000C4   0x.... 0x....      BL       _Z6strstrPcPKc
   \   000000C8   0x2800             CMP      R0,#+0
   \   000000CA   0xD103             BNE.N    ??Explore_Disk_8
   \   000000CC   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000000D0   0x06C0             LSLS     R0,R0,#+27
   \   000000D2   0xD5B5             BPL.N    ??Explore_Disk_2
   \                     ??Explore_Disk_8: (+1)
   \   000000D4   0x2000             MOVS     R0,#+0
   \   000000D6   0xF88D 0x00E8      STRB     R0,[SP, #+232]
   \   000000DA   0x4641             MOV      R1,R8
   \   000000DC   0xA83A             ADD      R0,SP,#+232
   \   000000DE   0x.... 0x....      BL       strcat
   \   000000E2   0x22C8             MOVS     R2,#+200
   \   000000E4   0x2100             MOVS     R1,#+0
   \   000000E6   0xA808             ADD      R0,SP,#+32
   \   000000E8   0x.... 0x....      BL       memset
   \   000000EC   0xA93A             ADD      R1,SP,#+232
   \   000000EE   0xA808             ADD      R0,SP,#+32
   \   000000F0   0x.... 0x....      BL       strcpy
   \   000000F4   0xF89D 0x1008      LDRB     R1,[SP, #+8]
   \   000000F8   0x06C9             LSLS     R1,R1,#+27
   \   000000FA   0xD501             BPL.N    ??Explore_Disk_9
   \   000000FC   0x2D0B             CMP      R5,#+11
   \   000000FE   0xDB97             BLT.N    ??Explore_Disk_3
   \                     ??Explore_Disk_9: (+1)
   \   00000100   0x....             ADR.N    R1,??DataTable45  ;; 0x0D, 0x0A, 0x00, 0x00
   \   00000102   0xA808             ADD      R0,SP,#+32
   \   00000104   0x.... 0x....      BL       strcat
   \   00000108   0xA908             ADD      R1,SP,#+32
   \   0000010A   0x....             LDR.N    R0,??DataTable45_12
   \   0000010C   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   00000110   0xE796             B.N      ??Explore_Disk_2
    949          }

   \                                 In section .bss, align 4
   \                     ??lfn:
   \   00000000                      DS8 256
    950          

   \                                 In section .text, align 2, keep-with-next
    951          void CardReader::ShowSDFiles(void)
    952          	{
   \                     _ZN10CardReader11ShowSDFilesEv: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xF5AD 0x7D44      SUB      SP,SP,#+784
   \   00000008   0x4604             MOV      R4,R0
    953          	  FILINFO fno;
    954          	  DIR dir;
    955          	  TCHAR *fn;
    956                const TCHAR gFileName[5] = {'.', 'g', 'c', 'o', '\0'};
                                   ^
Warning[Pe177]: variable "gFileName" was declared but never referenced
    957                const TCHAR gFileNameCap[5] = {'.', 'G', 'C', 'O', '\0'};
                                   ^
Warning[Pe177]: variable "gFileNameCap" was declared but never referenced
    958          	  TCHAR tmp[200];
    959          	  int res;
    960          	
    961            #if _USE_LFN
    962          		static TCHAR lfn[_MAX_LFN + 1];
    963          		fno.lfname = lfn;
   \   0000000A   0x....             LDR.N    R0,??DataTable45_14
   \   0000000C   0x9006             STR      R0,[SP, #+24]
    964          		fno.lfsize = _MAX_LFN + 1;
   \   0000000E   0xF44F 0x7080      MOV      R0,#+256
   \   00000012   0x9007             STR      R0,[SP, #+28]
    965          #endif
    966          	 
    967          	
    968          	 //f_mount(1, &fs);
    969          	 #if 0//
    970                    if ((SD_DET_IP == SD_DETECT_INVERTED)&&(usbOK == false))                 
    971                      f_mount(&fs, (TCHAR const*)SD_Path, 0);     //skyblue 2016-12-13
    972                    else
    973                      f_mount(&fs, (TCHAR const*)USBH_Path, 0);
    974          	#else  
    975          	if (gCfgItems.fileSysType == FILE_SYS_SD)                 
   \   00000014   0xF504 0x700B      ADD      R0,R4,#+556
   \   00000018   0x....             LDR.N    R1,??DataTable45_15
   \   0000001A   0xF991 0x10DA      LDRSB    R1,[R1, #+218]
   \   0000001E   0x2901             CMP      R1,#+1
   \   00000020   0xD104             BNE.N    ??ShowSDFiles_0
    976                   f_mount(&fs, (TCHAR const*)SD_Path, 0);     //skyblue 2016-12-13
   \   00000022   0x2200             MOVS     R2,#+0
   \   00000024   0x....             LDR.N    R1,??DataTable45_4
   \   00000026   0x.... 0x....      BL       f_mount
   \   0000002A   0xE003             B.N      ??ShowSDFiles_1
    977               else
    978                   f_mount(&fs, (TCHAR const*)USBH_Path, 0);	
   \                     ??ShowSDFiles_0: (+1)
   \   0000002C   0x2200             MOVS     R2,#+0
   \   0000002E   0x....             LDR.N    R1,??DataTable45_6
   \   00000030   0x.... 0x....      BL       f_mount
    979          	 #endif
    980          	 if (f_opendir(&dir, gCurDir) == FR_OK) 
   \                     ??ShowSDFiles_1: (+1)
   \   00000034   0xF604 0x15B6      ADDW     R5,R4,#+2486
   \   00000038   0xF204 0x469C      ADDW     R6,R4,#+1180
   \   0000003C   0x4631             MOV      R1,R6
   \   0000003E   0xA83A             ADD      R0,SP,#+232
   \   00000040   0x.... 0x....      BL       f_opendir
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD174             BNE.N    ??ShowSDFiles_2
    981          	  {
    982          		Sd_file_cnt = 0;
   \   00000048   0xF204 0x4794      ADDW     R7,R4,#+1172
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x6078             STR      R0,[R7, #+4]
    983          			gcodeFileList.listVaild= 2;
   \   00000050   0x2002             MOVS     R0,#+2
   \   00000052   0x7068             STRB     R0,[R5, #+1]
   \   00000054   0xE001             B.N      ??ShowSDFiles_3
    984          		for (;;) 
    985          		{
    986          			res = f_readdir(&dir, &fno);
    987          			if (res != FR_OK || fno.fname[0] == 0) 
    988          			{
    989          				gcodeFileList.listVaild= 2;
    990          				break;
    991          			}
    992          			if ( fno.fname[0] == '.') 
    993          				continue;
    994          	
    995          			if ((fno.lfname[0] == 0) || (fno.lfname == 0))
    996          				fn = fno.fname;
    997          			else
    998          				fn = fno.lfname;
    999          	
   1000          			/*	 if (fno.fattrib & AM_DIR) 
   1001          			{
   1002          			continue;
   1003          			} 
   1004          			else */
   1005          			if(Sd_file_cnt == Sd_file_offset)
   1006          			{
   1007          				//Sd_file_offset++;
   1008          				#if _LFN_UNICODE
   1009          				if((wcsstr((const wchar_t *)fn, (const wchar_t *)gFileName)) || (wcsstr((const wchar_t *)fn, (const wchar_t *)gFileNameCap)) || (fno.fattrib & AM_DIR))
   1010          				#else
   1011          					if((strstr(fn, ".gco")) || (strstr(fn, ".GCO")) || (strstr(fn, ".mdl"))|| (strstr(fn, ".MDL"))|| (fno.fattrib & AM_DIR))
   1012          				#endif
   1013          				{
   1014          					  //Sd_display_file_cnt++;
   1015          					  
   1016          					  tmp[0] = '\0';
   1017          					  strcpy(tmp, (char const*)gCurDir);
   1018          					  strcat(tmp, "/");
   1019          					  #if _LFN_UNICODE
   1020          					  wcscat((wchar_t *)tmp, (const wchar_t *)fn);
   1021          					  #else
   1022          					  strcat(tmp, fn);
   1023          					  #endif
   1024          	
   1025          					  gcodeFileList.listVaild= 1;
   1026          	
   1027          					if(fno.fattrib & AM_DIR)
   1028          					{
   1029          						gcodeFileList.fileAttr[gcodeFileList.index] = 1;
   1030          					}
   1031          					else
   1032          					{
   1033          						gcodeFileList.fileAttr[gcodeFileList.index] = 0;
   1034          					}
   1035          	
   1036          					#if _LFN_UNICODE
   1037          					wcscpy((wchar_t *)gcodeFileList.fileName[gcodeFileList.index], (const wchar_t *)tmp);
   1038          					#else
   1039          					strcpy((char *)gcodeFileList.fileName[gcodeFileList.index], (const char *)tmp);
   1040          					#endif
   1041          					gcodeFileList.index++;
   1042          					
   1043          					
   1044          				}
   1045          				else
   1046          				{
   1047          					gcodeFileList.listVaild= 0;
   1048          				}
   1049          				break;
   1050          			}
   1051          			
   1052          			Sd_file_cnt++;
   \                     ??ShowSDFiles_4: (+1)
   \   00000056   0x1C40             ADDS     R0,R0,#+1
   \   00000058   0x6078             STR      R0,[R7, #+4]
   \                     ??ShowSDFiles_3: (+1)
   \   0000005A   0xA900             ADD      R1,SP,#+0
   \   0000005C   0xA83A             ADD      R0,SP,#+232
   \   0000005E   0x.... 0x....      BL       f_readdir
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD165             BNE.N    ??ShowSDFiles_2
   \   00000066   0xF99D 0x0009      LDRSB    R0,[SP, #+9]
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD061             BEQ.N    ??ShowSDFiles_2
   \   0000006E   0x282E             CMP      R0,#+46
   \   00000070   0xD0F3             BEQ.N    ??ShowSDFiles_3
   \   00000072   0xF8DD 0x8018      LDR      R8,[SP, #+24]
   \   00000076   0xF998 0x0000      LDRSB    R0,[R8, #+0]
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD002             BEQ.N    ??ShowSDFiles_5
   \   0000007E   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000082   0xD101             BNE.N    ??ShowSDFiles_6
   \                     ??ShowSDFiles_5: (+1)
   \   00000084   0xF10D 0x0809      ADD      R8,SP,#+9
   \                     ??ShowSDFiles_6: (+1)
   \   00000088   0x6878             LDR      R0,[R7, #+4]
   \   0000008A   0xF8D4 0x1494      LDR      R1,[R4, #+1172]
   \   0000008E   0x4288             CMP      R0,R1
   \   00000090   0xD1E1             BNE.N    ??ShowSDFiles_4
   \   00000092   0x.... 0x....      ADR.W    R1,`?<Constant ".gco">`
   \   00000096   0x4640             MOV      R0,R8
   \   00000098   0x.... 0x....      BL       _Z6strstrPcPKc
   \   0000009C   0x2800             CMP      R0,#+0
   \   0000009E   0xD118             BNE.N    ??ShowSDFiles_7
   \   000000A0   0x.... 0x....      ADR.W    R1,`?<Constant ".GCO">`
   \   000000A4   0x4640             MOV      R0,R8
   \   000000A6   0x.... 0x....      BL       _Z6strstrPcPKc
   \   000000AA   0x2800             CMP      R0,#+0
   \   000000AC   0xD111             BNE.N    ??ShowSDFiles_7
   \   000000AE   0x.... 0x....      ADR.W    R1,`?<Constant ".mdl">`
   \   000000B2   0x4640             MOV      R0,R8
   \   000000B4   0x.... 0x....      BL       _Z6strstrPcPKc
   \   000000B8   0x2800             CMP      R0,#+0
   \   000000BA   0xD10A             BNE.N    ??ShowSDFiles_7
   \   000000BC   0x.... 0x....      ADR.W    R1,`?<Constant ".MDL">`
   \   000000C0   0x4640             MOV      R0,R8
   \   000000C2   0x.... 0x....      BL       _Z6strstrPcPKc
   \   000000C6   0x2800             CMP      R0,#+0
   \   000000C8   0xD103             BNE.N    ??ShowSDFiles_7
   \   000000CA   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000000CE   0x06C0             LSLS     R0,R0,#+27
   \   000000D0   0xD52C             BPL.N    ??ShowSDFiles_8
   \                     ??ShowSDFiles_7: (+1)
   \   000000D2   0x2000             MOVS     R0,#+0
   \   000000D4   0xF88D 0x0020      STRB     R0,[SP, #+32]
   \   000000D8   0x4631             MOV      R1,R6
   \   000000DA   0xA808             ADD      R0,SP,#+32
   \   000000DC   0x.... 0x....      BL       strcpy
   \   000000E0   0x....             ADR.N    R1,??DataTable45_1  ;; "/"
   \   000000E2   0x.... 0x....      BL       strcat
   \   000000E6   0x4641             MOV      R1,R8
   \   000000E8   0xA808             ADD      R0,SP,#+32
   \   000000EA   0x.... 0x....      BL       strcat
   \   000000EE   0x2001             MOVS     R0,#+1
   \   000000F0   0x7068             STRB     R0,[R5, #+1]
   \   000000F2   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000000F6   0xF000 0x0010      AND      R0,R0,#0x10
   \   000000FA   0x1E41             SUBS     R1,R0,#+1
   \   000000FC   0x4189             SBCS     R1,R1,R1
   \   000000FE   0x43C9             MVNS     R1,R1
   \   00000100   0x0FC9             LSRS     R1,R1,#+31
   \   00000102   0xF894 0x09B6      LDRB     R0,[R4, #+2486]
   \   00000106   0x1900             ADDS     R0,R0,R4
   \   00000108   0xF880 0x19B0      STRB     R1,[R0, #+2480]
   \   0000010C   0xA908             ADD      R1,SP,#+32
   \   0000010E   0xF894 0x09B6      LDRB     R0,[R4, #+2486]
   \   00000112   0x22C8             MOVS     R2,#+200
   \   00000114   0xFB12 0x4000      SMLABB   R0,R2,R0,R4
   \   00000118   0xF500 0x60A0      ADD      R0,R0,#+1280
   \   0000011C   0x.... 0x....      BL       strcpy
   \   00000120   0xF894 0x09B6      LDRB     R0,[R4, #+2486]
   \   00000124   0x1C40             ADDS     R0,R0,#+1
   \   00000126   0xF884 0x09B6      STRB     R0,[R4, #+2486]
   \   0000012A   0xE004             B.N      ??ShowSDFiles_9
   \                     ??ShowSDFiles_8: (+1)
   \   0000012C   0x2000             MOVS     R0,#+0
   \   0000012E   0x7068             STRB     R0,[R5, #+1]
   \   00000130   0xE001             B.N      ??ShowSDFiles_9
   1053          			
   1054          			 
   1055          		}
   1056          #if 0
   1057          		while (f_readdir(&dirs, &finfo) == FR_OK)  
   1058          		{
   1059          		  if (finfo.fattrib & AM_ARC) 
   1060          		  {
   1061          			if(!finfo.fname[0]) 
   1062          			  break;		 
   1063          			  printf("\n\r file name is: %s\n",finfo.fname);
   1064          			  printf("\n\r file size is: %d ", finfo.fsize); 
   1065          	
   1066          			  if(File_type_Check( (u8 *)finfo.fname, "txt"))
   1067          			  { 
   1068          				BufferSet(buffer, 0, 100);
   1069          				res = f_open(&fsrc, finfo.fname, FA_OPEN_EXISTING | FA_READ);
   1070          				res = f_read(&fsrc, buffer, 100, &br);
   1071          				printf("\n\r file contex is: \n\r%s\n\r", buffer); 
   1072          				f_close(&fsrc); 							  
   1073          			  }
   1074          		  }
   1075          		  else
   1076          		  {
   1077          			printf("\n\r Path name is: %s", finfo.fname); 
   1078          			continue;//break;
   1079          		  }
   1080          		} 
   1081          		  res = f_open(&fsrc, "armjishu.txt", FA_CREATE_ALWAYS | FA_WRITE);
   1082          		  res = f_write(&fsrc, &armjishu, sizeof(armjishu), &bw);
   1083          		  f_close(&fsrc);
   1084          	#endif
   1085          	  
   1086          	 }
   1087          	 else
   1088          		 gcodeFileList.listVaild= 2;
   \                     ??ShowSDFiles_2: (+1)
   \   00000132   0x2002             MOVS     R0,#+2
   \   00000134   0x7068             STRB     R0,[R5, #+1]
   1089          	 
   1090          	}
   \                     ??ShowSDFiles_9: (+1)
   \   00000136   0xF50D 0x7D44      ADD      SP,SP,#+784
   \   0000013A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .bss, align 4
   \                     ??lfn_1:
   \   00000000                      DS8 256
   1091          

   \                                 In section .text, align 2, keep-with-next
   1092          int CardReader::ascii2dec(char *ascii, char width)
   1093          {
   \                     _ZN10CardReader9ascii2decEPcc: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   1094          	int i = 0;
   \   00000002   0x2300             MOVS     R3,#+0
   1095          	int result = 0;
   \   00000004   0x4618             MOV      R0,R3
   1096          
   1097          	if(ascii == 0)
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD105             BNE.N    ??ascii2dec_0
   1098          		return 0;
   1099          	
   1100          	while(i < width)
   1101          	{		
   1102          		result = result << 4;
   1103          		
   1104          		if(*(ascii + i) >= '0' && *(ascii + i) <= '9')
   1105          			result += *(ascii + i) - '0';
   1106          		else if(*(ascii + i) >= 'a' && *(ascii + i) <= 'f')
   1107          			result += *(ascii + i) - 'a' + 0x0a;
   1108          		else if(*(ascii + i) >= 'A' && *(ascii + i) <= 'F')
   1109          			result += *(ascii + i) - 'A' + 0x0a;
   1110          		else
   1111          			return 0;
   \                     ??ascii2dec_1: (+1)
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xE01A             B.N      ??ascii2dec_2
   \                     ??ascii2dec_3: (+1)
   \   0000000E   0x3C30             SUBS     R4,R4,#+48
   \   00000010   0xEB14 0x1000      ADDS     R0,R4,R0, LSL #+4
   1112          		
   1113          		i++;
   \                     ??ascii2dec_4: (+1)
   \   00000014   0x1C5B             ADDS     R3,R3,#+1
   \                     ??ascii2dec_0: (+1)
   \   00000016   0x4293             CMP      R3,R2
   \   00000018   0xDA14             BGE.N    ??ascii2dec_2
   \   0000001A   0x565C             LDRSB    R4,[R3, R1]
   \   0000001C   0x4625             MOV      R5,R4
   \   0000001E   0xF1A5 0x0630      SUB      R6,R5,#+48
   \   00000022   0x2E0A             CMP      R6,#+10
   \   00000024   0xD3F3             BCC.N    ??ascii2dec_3
   \   00000026   0xF1A5 0x0661      SUB      R6,R5,#+97
   \   0000002A   0x2E06             CMP      R6,#+6
   \   0000002C   0xD203             BCS.N    ??ascii2dec_5
   \   0000002E   0x3C57             SUBS     R4,R4,#+87
   \   00000030   0xEB14 0x1000      ADDS     R0,R4,R0, LSL #+4
   \   00000034   0xE7EE             B.N      ??ascii2dec_4
   \                     ??ascii2dec_5: (+1)
   \   00000036   0x3D41             SUBS     R5,R5,#+65
   \   00000038   0x2D06             CMP      R5,#+6
   \   0000003A   0xD2E6             BCS.N    ??ascii2dec_1
   \   0000003C   0x3C37             SUBS     R4,R4,#+55
   \   0000003E   0xEB14 0x1000      ADDS     R0,R4,R0, LSL #+4
   \   00000042   0xE7E7             B.N      ??ascii2dec_4
   1114          	}
   1115          	return result;
   \                     ??ascii2dec_2: (+1)
   \   00000044   0xBC70             POP      {R4-R6}
   \   00000046   0x4770             BX       LR               ;; return
   1116          }
   1117          
   1118          /*---------------------------------mks add begin-------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   1119          uint32_t CardReader::getsdpos()
   1120          {
   1121          	//sdpos = file.curPosition();
   1122          	return sdpos;
   \                     _ZN10CardReader8getsdposEv: (+1)
   \   00000000   0xF8D0 0x0460      LDR      R0,[R0, #+1120]
   \   00000004   0x4770             BX       LR               ;; return
   1123          }

   \                                 In section .text, align 2, keep-with-next
   1124          void CardReader::printingHasFinished()
   1125          {
   \                     _ZN10CardReader19printingHasFinishedEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1126              stepper.synchronize();
   \   00000004   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   1127          	f_close(&curFile);
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0x.... 0x....      BL       f_close
   1128          
   1129              sdprinting = false;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF884 0x09B8      STRB     R0,[R4, #+2488]
   1130          	sdmode = 0;
   \   00000014   0xF884 0x046C      STRB     R0,[R4, #+1132]
   1131              if (SD_FINISHED_STEPPERRELEASE)
   1132                enqueue_and_echo_commands_P(PSTR(SD_FINISHED_RELEASECOMMAND));
   \   00000018   0x.... 0x....      ADR.W    R0,`?<Constant "M84 X Y Z E">`
   \   0000001C   0x.... 0x....      BL       _Z27enqueue_and_echo_commands_PPKc
   1133              print_job_timer.stop();
   \   00000020   0x....             LDR.N    R4,??DataTable45_16
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       _ZN9Stopwatch4stopEv
   1134          
   1135              if (print_job_timer.duration() > 60)
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       _ZN9Stopwatch8durationEv
   \   0000002E   0x283D             CMP      R0,#+61
   \   00000030   0xD304             BCC.N    ??printingHasFinished_0
   1136                enqueue_and_echo_commands_P(PSTR("M31"));
   \   00000032   0x....             ADR.N    R0,??DataTable45_2  ;; "M31"
   \   00000034   0xE8BD 0x4010      POP      {R4,LR}
   \   00000038   0x.... 0x....      B.W      _Z27enqueue_and_echo_commands_PPKc
   1137          }
   \                     ??printingHasFinished_0: (+1)
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return
   1138          
   1139          
   1140          
   1141          
   1142          
   1143          

   \                                 In section .text, align 2, keep-with-next
   1144          void CardReader::closefile(bool store_location)
   1145          {
   \                     _ZN10CardReader9closefileEb: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1146            f_close(&curFile);
   \   00000004   0x.... 0x....      BL       f_close
   1147            saving = false;  
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF884 0x09B9      STRB     R0,[R4, #+2489]
   1148            logging = false;
   \   0000000E   0xF884 0x09BA      STRB     R0,[R4, #+2490]
   1149            
   1150          }
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
   1151          

   \                                 In section .text, align 2, keep-with-next
   1152          void CardReader::openLogFile(char* name)
   1153          {
   1154            logging = true;
   \                     _ZN10CardReader11openLogFileEPc: (+1)
   \   00000000   0x2201             MOVS     R2,#+1
   \   00000002   0xF880 0x29BA      STRB     R2,[R0, #+2490]
   1155            openFile(name, false);
   \   00000006   0x4613             MOV      R3,R2
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x....             B.N      _ZN10CardReader8openFileEPcbb
   1156          }
   1157          

   \                                 In section .text, align 2, keep-with-next
   1158          void CardReader::write_command(char *buf)
   1159          {
   \                     _ZN10CardReader13write_commandEPc: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   1160            unsigned int lastBufferEntry = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x9001             STR      R0,[SP, #+4]
   1161            FRESULT writeStatus;
   1162            char* begin = buf;
   1163            char* npos = 0;
   1164            char* end = buf + strlen(buf) - 1;
   \   0000000C   0x4628             MOV      R0,R5
   \   0000000E   0x.... 0x....      BL       strlen
   \   00000012   0x1940             ADDS     R0,R0,R5
   \   00000014   0x1E46             SUBS     R6,R0,#+1
   1165          	
   1166          	memset(&writeStatus, 0, sizeof(FRESULT));
   \   00000016   0x2201             MOVS     R2,#+1
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0xA800             ADD      R0,SP,#+0
   \   0000001C   0x.... 0x....      BL       memset
   1167          
   1168            if((npos = strchr(buf, 'N')) != NULL)
   \   00000020   0x214E             MOVS     R1,#+78
   \   00000022   0x4628             MOV      R0,R5
   \   00000024   0x.... 0x....      BL       _Z6strchrPci
   \   00000028   0x0007             MOVS     R7,R0
   \   0000002A   0xD008             BEQ.N    ??write_command_0
   1169            {
   1170              begin = strchr(npos, ' ') + 1;
   \   0000002C   0x2120             MOVS     R1,#+32
   \   0000002E   0x.... 0x....      BL       _Z6strchrPci
   \   00000032   0x1C45             ADDS     R5,R0,#+1
   1171              end = strchr(npos, '*') - 1;
   \   00000034   0x212A             MOVS     R1,#+42
   \   00000036   0x4638             MOV      R0,R7
   \   00000038   0x.... 0x....      BL       _Z6strchrPci
   \   0000003C   0x1E46             SUBS     R6,R0,#+1
   1172            }
   1173            end[1] = '\r';
   \                     ??write_command_0: (+1)
   \   0000003E   0x200D             MOVS     R0,#+13
   \   00000040   0x7070             STRB     R0,[R6, #+1]
   1174            end[2] = '\n';
   \   00000042   0x200A             MOVS     R0,#+10
   \   00000044   0x70B0             STRB     R0,[R6, #+2]
   1175            
   1176            writeStatus = f_write(&curFile, begin, &(end[2]) - begin + 1, &lastBufferEntry);
   \   00000046   0x1CB0             ADDS     R0,R6,#+2
   \   00000048   0x1B40             SUBS     R0,R0,R5
   \   0000004A   0x1C46             ADDS     R6,R0,#+1
   \   0000004C   0xAB01             ADD      R3,SP,#+4
   \   0000004E   0x4632             MOV      R2,R6
   \   00000050   0x4629             MOV      R1,R5
   \   00000052   0x4620             MOV      R0,R4
   \   00000054   0x.... 0x....      BL       f_write
   \   00000058   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1177            if( 	(writeStatus != FR_OK) ||
   1178          		(lastBufferEntry != (unsigned int)(&(end[2]) - begin + 1)))
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD102             BNE.N    ??write_command_1
   \   00000060   0x9801             LDR      R0,[SP, #+4]
   \   00000062   0x42B0             CMP      R0,R6
   \   00000064   0xD006             BEQ.N    ??write_command_2
   1179            {
   1180              SERIAL_ERROR_START();
   \                     ??write_command_1: (+1)
   \   00000066   0x....             LDR.N    R0,??DataTable45_17
   \   00000068   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1181              SERIAL_ERRORLNPGM(MSG_SD_ERR_WRITE_TO_FILE);
   \   0000006C   0x.... 0x....      ADR.W    R0,`?<Constant "error writing to file\\n">`
   \   00000070   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1182            }
   1183          }
   \                     ??write_command_2: (+1)
   \   00000074   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "M31">`:
   \   00000000   0x4D 0x33          DC8 "M31"
   \              0x31 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {'\\000'}>`:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant "/">`:
   \   00000000   0x2F 0x00          DC8 "/"

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant ".\\n">`:
   \   00000000   0x2E 0x0A          DC8 ".\012"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "\\r\\n">`:
   \   00000000   0x0D 0x0A          DC8 "\015\012"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp CardReader::subobject CardReader()
   \                     _ZN10CardReaderC2Ev: (+1)
   \   00000000   0xBF00             Nop      
   \   00000002                      REQUIRE _ZN10CardReaderC1Ev
   \   00000002                      ;; // Fall through to label CardReader::CardReader()

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42:
   \   00000000   0x2F 0x00          DC8      "/",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43:
   \   00000000   0x2E 0x0A          DC8      0x2E, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45:
   \   00000000   0x0D 0x0A          DC8      0x0D, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45_1:
   \   00000000   0x2F 0x00          DC8      "/",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45_2:
   \   00000000   0x4D 0x33          DC8      "M31"
   \              0x31 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45_3:
   \   00000000   0x........         DC32     echomagic

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45_4:
   \   00000000   0x........         DC32     SD_Path

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45_5:
   \   00000000   0x........         DC32     Appli_state

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45_6:
   \   00000000   0x........         DC32     USBH_Path

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45_7:
   \   00000000   0x........         DC32     USBH_Driver

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45_8:
   \   00000000   0x........         DC32     card

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45_9:
   \   00000000   0x4241828C         DC32     0x4241828c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45_10:
   \   00000000   0x........         DC32     mksReprint

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45_11:
   \   00000000   0x........         DC32     textt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45_12:
   \   00000000   0x........         DC32     Serial6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45_13:
   \   00000000   0x........         DC32     ??lfn

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45_14:
   \   00000000   0x........         DC32     ??lfn_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45_15:
   \   00000000   0x........         DC32     gCfgItems

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45_16:
   \   00000000   0x........         DC32     print_job_timer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45_17:
   \   00000000   0x........         DC32     errormagic

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "USB init fail\\n">`:
   \   00000000   0x55 0x53          DC8 "USB init fail\012"
   \              0x42 0x20    
   \              0x69 0x6E    
   \              0x69 0x74    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x0A    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "USB OK\\n">`:
   \   00000000   0x55 0x53          DC8 "USB OK\012"
   \              0x42 0x20    
   \              0x4F 0x4B    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "M84 X Y Z E">`:
   \   00000000   0x4D 0x38          DC8 "M84 X Y Z E"
   \              0x34 0x20    
   \              0x58 0x20    
   \              0x59 0x20    
   \              0x5A 0x20    
   \              0x45 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "SD card removed\\n">`:
   \   00000000   0x53 0x44          DC8 "SD card removed\012"
   \              0x20 0x63    
   \              0x61 0x72    
   \              0x64 0x20    
   \              0x72 0x65    
   \              0x6D 0x6F    
   \              0x76 0x65    
   \              0x64 0x0A    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "USB inserted\\n">`:
   \   00000000   0x55 0x53          DC8 "USB inserted\012"
   \              0x42 0x20    
   \              0x69 0x6E    
   \              0x73 0x65    
   \              0x72 0x74    
   \              0x65 0x64    
   \              0x0A 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "USB removed\\n">`:
   \   00000000   0x55 0x53          DC8 "USB removed\012"
   \              0x42 0x20    
   \              0x72 0x65    
   \              0x6D 0x6F    
   \              0x76 0x65    
   \              0x64 0x0A    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "USB DeInit!\\n">`:
   \   00000000   0x55 0x53          DC8 "USB DeInit!\012"
   \              0x42 0x20    
   \              0x44 0x65    
   \              0x49 0x6E    
   \              0x69 0x74    
   \              0x21 0x0A    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "File opened: ">`:
   \   00000000   0x46 0x69          DC8 "File opened: "
   \              0x6C 0x65    
   \              0x20 0x6F    
   \              0x70 0x65    
   \              0x6E 0x65    
   \              0x64 0x3A    
   \              0x20 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " Size: ">`:
   \   00000000   0x20 0x53          DC8 " Size: "
   \              0x69 0x7A    
   \              0x65 0x3A    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "File selected\\n">`:
   \   00000000   0x46 0x69          DC8 "File selected\012"
   \              0x6C 0x65    
   \              0x20 0x73    
   \              0x65 0x6C    
   \              0x65 0x63    
   \              0x74 0x65    
   \              0x64 0x0A    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "open failed, File: ">`:
   \   00000000   0x6F 0x70          DC8 "open failed, File: "
   \              0x65 0x6E    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x2C    
   \              0x20 0x46    
   \              0x69 0x6C    
   \              0x65 0x3A    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "SD printing byte ">`:
   \   00000000   0x53 0x44          DC8 "SD printing byte "
   \              0x20 0x70    
   \              0x72 0x69    
   \              0x6E 0x74    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x62 0x79    
   \              0x74 0x65    
   \              0x20 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Not SD printing\\n">`:
   \   00000000   0x4E 0x6F          DC8 "Not SD printing\012"
   \              0x74 0x20    
   \              0x53 0x44    
   \              0x20 0x70    
   \              0x72 0x69    
   \              0x6E 0x74    
   \              0x69 0x6E    
   \              0x67 0x0A    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "File deleted:">`:
   \   00000000   0x46 0x69          DC8 "File deleted:"
   \              0x6C 0x65    
   \              0x20 0x64    
   \              0x65 0x6C    
   \              0x65 0x74    
   \              0x65 0x64    
   \              0x3A 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Deletion failed, File: ">`:
   \   00000000   0x44 0x65          DC8 "Deletion failed, File: "
   \              0x6C 0x65    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x2C    
   \              0x20 0x46    
   \              0x69 0x6C    
   \              0x65 0x3A    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "error writing to file\\n">`:
   \   00000000   0x65 0x72          DC8 "error writing to file\012"
   \              0x72 0x6F    
   \              0x72 0x20    
   \              0x77 0x72    
   \              0x69 0x74    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x74 0x6F    
   \              0x20 0x66    
   \              0x69 0x6C    
   \              0x65 0x0A    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "USB Reset!\\n">`:
   \   00000000   0x55 0x53          DC8 "USB Reset!\012"
   \              0x42 0x20    
   \              0x52 0x65    
   \              0x73 0x65    
   \              0x74 0x21    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Directory created">`:
   \   00000000   0x44 0x69          DC8 "Directory created"
   \              0x72 0x65    
   \              0x63 0x74    
   \              0x6F 0x72    
   \              0x79 0x20    
   \              0x63 0x72    
   \              0x65 0x61    
   \              0x74 0x65    
   \              0x64 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Creation failed">`:
   \   00000000   0x43 0x72          DC8 "Creation failed"
   \              0x65 0x61    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant ".gco">`:
   \   00000000   0x2E 0x67          DC8 ".gco"
   \              0x63 0x6F    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant ".GCO">`:
   \   00000000   0x2E 0x47          DC8 ".GCO"
   \              0x43 0x4F    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant ".mdl">`:
   \   00000000   0x2E 0x6D          DC8 ".mdl"
   \              0x64 0x6C    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant ".MDL">`:
   \   00000000   0x2E 0x4D          DC8 ".MDL"
   \              0x44 0x4C    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant ".DIR\\r\\n">`:
   \   00000000   0x2E 0x44          DC8 ".DIR\015\012"
   \              0x49 0x52    
   \              0x0D 0x0A    
   \              0x00         
   \   00000007   0x00               DC8 0
   1184          
   1185          #if 0
   1186          void CardReader::openLogFile(char* name) {
   1187            logging = true;
   1188            openFile(name, false);
   1189          }
   1190          
   1191          void appendAtom(SdFile &file, char *& dst, uint8_t &cnt) {
   1192            file.getFilename(dst);
   1193            while (*dst && cnt < MAXPATHNAMELENGTH) { dst++; cnt++; }
   1194            if (cnt < MAXPATHNAMELENGTH) { *dst = '/'; dst++; cnt++; }
   1195          }
   1196          
   1197          void CardReader::getAbsFilename(char *t) {
   1198            *t++ = '/';                                               // Root folder
   1199            uint8_t cnt = 1;
   1200          
   1201            for (uint8_t i = 0; i < workDirDepth; i++)                // Loop to current work dir
   1202              appendAtom(workDirParents[i], t, cnt);
   1203          
   1204            if (cnt < MAXPATHNAMELENGTH - (FILENAME_LENGTH)) {
   1205              appendAtom(file, t, cnt);
   1206              --t;
   1207            }
   1208            *t = '\0';
   1209          }
   1210          
   1211          void CardReader::openFile(char* name, const bool read, const bool subcall/*=false*/) {
   1212          
   1213            if (!cardOK) return;
   1214          
   1215            uint8_t doing = 0;
   1216            if (isFileOpen()) {                     // Replacing current file or doing a subroutine
   1217              if (subcall) {
   1218                if (file_subcall_ctr > SD_PROCEDURE_DEPTH - 1) {
   1219                  SERIAL_ERROR_START();
   1220                  SERIAL_ERRORPGM("trying to call sub-gcode files with too many levels. MAX level is:");
   1221                  SERIAL_ERRORLN(SD_PROCEDURE_DEPTH);
   1222                  kill(PSTR(MSG_KILLED));
   1223                  return;
   1224                }
   1225          
   1226                // Store current filename (based on workDirParents) and position
   1227                getAbsFilename(proc_filenames[file_subcall_ctr]);
   1228                filespos[file_subcall_ctr] = sdpos;
   1229          
   1230                SERIAL_ECHO_START();
   1231                SERIAL_ECHOPAIR("SUBROUTINE CALL target:\"", name);
   1232                SERIAL_ECHOPAIR("\" parent:\"", proc_filenames[file_subcall_ctr]);
   1233                SERIAL_ECHOLNPAIR("\" pos", sdpos);
   1234                file_subcall_ctr++;
   1235              }
   1236              else
   1237                doing = 1;
   1238            }
   1239            else if (subcall) {     // Returning from a subcall?
   1240              SERIAL_ECHO_START();
   1241              SERIAL_ECHOLNPGM("END SUBROUTINE");
   1242            }
   1243            else {                  // Opening fresh file
   1244              doing = 2;
   1245              file_subcall_ctr = 0; // Reset procedure depth in case user cancels print while in procedure
   1246            }
   1247          
   1248            if (doing) {
   1249              SERIAL_ECHO_START();
   1250              SERIAL_ECHOPGM("Now ");
   1251              serialprintPGM(doing == 1 ? PSTR("doing") : PSTR("fresh"));
   1252              SERIAL_ECHOLNPAIR(" file: ", name);
   1253            }
   1254          
   1255            stopSDPrint();
   1256          
   1257            SdFile myDir;
   1258            curDir = &root;
   1259            char *fname = name;
   1260            char *dirname_start, *dirname_end;
   1261          
   1262            if (name[0] == '/') {
   1263              dirname_start = &name[1];
   1264              while (dirname_start != NULL) {
   1265                dirname_end = strchr(dirname_start, '/');
   1266                //SERIAL_ECHOPGM("start:");SERIAL_ECHOLN((int)(dirname_start - name));
   1267                //SERIAL_ECHOPGM("end  :");SERIAL_ECHOLN((int)(dirname_end - name));
   1268                if (dirname_end != NULL && dirname_end > dirname_start) {
   1269                  char subdirname[FILENAME_LENGTH];
   1270                  strncpy(subdirname, dirname_start, dirname_end - dirname_start);
   1271                  subdirname[dirname_end - dirname_start] = '\0';
   1272                  if (!myDir.open(curDir, subdirname, O_READ)) {
   1273                    SERIAL_PROTOCOLPGM(MSG_SD_OPEN_FILE_FAIL);
   1274                    SERIAL_PROTOCOL(subdirname);
   1275                    SERIAL_PROTOCOLCHAR('.');
   1276                    return;
   1277                  }
   1278                  else {
   1279                    //SERIAL_ECHOLNPGM("dive ok");
   1280                  }
   1281          
   1282                  curDir = &myDir;
   1283                  dirname_start = dirname_end + 1;
   1284                }
   1285                else { // the remainder after all /fsa/fdsa/ is the filename
   1286                  fname = dirname_start;
   1287                  //SERIAL_ECHOLNPGM("remainder");
   1288                  //SERIAL_ECHOLN(fname);
   1289                  break;
   1290                }
   1291              }
   1292            }
   1293            else
   1294              curDir = &workDir; // Relative paths start in current directory
   1295          
   1296            if (read) {
   1297              if (file.open(curDir, fname, O_READ)) {
   1298                filesize = file.fileSize();
   1299                sdpos = 0;
   1300                SERIAL_PROTOCOLPAIR(MSG_SD_FILE_OPENED, fname);
   1301                SERIAL_PROTOCOLLNPAIR(MSG_SD_SIZE, filesize);
   1302                SERIAL_PROTOCOLLNPGM(MSG_SD_FILE_SELECTED);
   1303                getfilename(0, fname);
   1304                lcd_setstatus(longFilename[0] ? longFilename : fname);
   1305              }
   1306              else {
   1307                SERIAL_PROTOCOLPAIR(MSG_SD_OPEN_FILE_FAIL, fname);
   1308                SERIAL_PROTOCOLCHAR('.');
   1309                SERIAL_EOL();
   1310              }
   1311            }
   1312            else { //write
   1313              if (!file.open(curDir, fname, O_CREAT | O_APPEND | O_WRITE | O_TRUNC)) {
   1314                SERIAL_PROTOCOLPAIR(MSG_SD_OPEN_FILE_FAIL, fname);
   1315                SERIAL_PROTOCOLCHAR('.');
   1316                SERIAL_EOL();
   1317              }
   1318              else {
   1319                saving = true;
   1320                SERIAL_PROTOCOLLNPAIR(MSG_SD_WRITE_TO_FILE, name);
   1321                lcd_setstatus(fname);
   1322              }
   1323            }
   1324          }
   1325          
   1326          void CardReader::removeFile(const char * const name) {
   1327            if (!cardOK) return;
   1328          
   1329            stopSDPrint();
   1330          
   1331            SdFile myDir;
   1332            curDir = &root;
   1333            const char *fname = name;
   1334          
   1335            char *dirname_start, *dirname_end;
   1336            if (name[0] == '/') {
   1337              dirname_start = strchr(name, '/') + 1;
   1338              while (dirname_start != NULL) {
   1339                dirname_end = strchr(dirname_start, '/');
   1340                //SERIAL_ECHOPGM("start:");SERIAL_ECHOLN((int)(dirname_start - name));
   1341                //SERIAL_ECHOPGM("end  :");SERIAL_ECHOLN((int)(dirname_end - name));
   1342                if (dirname_end != NULL && dirname_end > dirname_start) {
   1343                  char subdirname[FILENAME_LENGTH];
   1344                  strncpy(subdirname, dirname_start, dirname_end - dirname_start);
   1345                  subdirname[dirname_end - dirname_start] = 0;
   1346                  SERIAL_ECHOLN(subdirname);
   1347                  if (!myDir.open(curDir, subdirname, O_READ)) {
   1348                    SERIAL_PROTOCOLPAIR(MSG_SD_OPEN_FILE_FAIL, subdirname);
   1349                    SERIAL_PROTOCOLCHAR('.');
   1350                    SERIAL_EOL();
   1351                    return;
   1352                  }
   1353          
   1354                  curDir = &myDir;
   1355                  dirname_start = dirname_end + 1;
   1356                }
   1357                else {
   1358                  fname = dirname_start;
   1359                  break;
   1360                }
   1361              }
   1362            }
   1363            else // Relative paths are rooted in the current directory
   1364              curDir = &workDir;
   1365          
   1366            if (file.remove(curDir, fname)) {
   1367              SERIAL_PROTOCOLPGM("File deleted:");
   1368              SERIAL_PROTOCOLLN(fname);
   1369              sdpos = 0;
   1370              #if ENABLED(SDCARD_SORT_ALPHA)
   1371                presort();
   1372              #endif
   1373            }
   1374            else {
   1375              SERIAL_PROTOCOLPGM("Deletion failed, File: ");
   1376              SERIAL_PROTOCOL(fname);
   1377              SERIAL_PROTOCOLCHAR('.');
   1378            }
   1379          }
   1380          
   1381          void CardReader::getStatus() {
   1382            if (cardOK) {
   1383              SERIAL_PROTOCOLPGM(MSG_SD_PRINTING_BYTE);
   1384              SERIAL_PROTOCOL(sdpos);
   1385              SERIAL_PROTOCOLCHAR('/');
   1386              SERIAL_PROTOCOLLN(filesize);
   1387            }
   1388            else
   1389              SERIAL_PROTOCOLLNPGM(MSG_SD_NOT_PRINTING);
   1390          }
   1391          
   1392          void CardReader::write_command(char *buf) {
   1393            char* begin = buf;
   1394            char* npos = NULL;
   1395            char* end = buf + strlen(buf) - 1;
   1396          
   1397            file.writeError = false;
   1398            if ((npos = strchr(buf, 'N')) != NULL) {
   1399              begin = strchr(npos, ' ') + 1;
   1400              end = strchr(npos, '*') - 1;
   1401            }
   1402            end[1] = '\r';
   1403            end[2] = '\n';
   1404            end[3] = '\0';
   1405            file.write(begin);
   1406            if (file.writeError) {
   1407              SERIAL_ERROR_START();
   1408              SERIAL_ERRORLNPGM(MSG_SD_ERR_WRITE_TO_FILE);
   1409            }
   1410          }
   1411          
   1412          void CardReader::checkautostart(bool force) {
   1413            if (!force && (!autostart_stilltocheck || PENDING(millis(), next_autostart_ms)))
   1414              return;
   1415          
   1416            autostart_stilltocheck = false;
   1417          
   1418            if (!cardOK) {
   1419              initsd();
   1420              if (!cardOK) return; // fail
   1421            }
   1422          
   1423            char autoname[10];
   1424            sprintf_P(autoname, PSTR("auto%i.g"), autostart_index);
   1425            for (int8_t i = 0; i < (int8_t)strlen(autoname); i++) autoname[i] = tolower(autoname[i]);
   1426          
   1427            dir_t p;
   1428          
   1429            root.rewind();
   1430          
   1431            bool found = false;
   1432            while (root.readDir(p, NULL) > 0) {
   1433              for (int8_t i = (int8_t)strlen((char*)p.name); i--;) p.name[i] = tolower(p.name[i]);
   1434              if (p.name[9] != '~' && strncmp((char*)p.name, autoname, 5) == 0) {
   1435                openAndPrintFile(autoname);
   1436                found = true;
   1437              }
   1438            }
   1439            if (!found)
   1440              autostart_index = -1;
   1441            else
   1442              autostart_index++;
   1443          }
   1444          
   1445          void CardReader::closefile(bool store_location) {
   1446            file.sync();
   1447            file.close();
   1448            saving = logging = false;
   1449          
   1450            if (store_location) {
   1451              //future: store printer state, filename and position for continuing a stopped print
   1452              // so one can unplug the printer and continue printing the next day.
   1453            }
   1454          }
   1455          
   1456          /**
   1457           * Get the name of a file in the current directory by index
   1458           */
   1459          void CardReader::getfilename(uint16_t nr, const char * const match/*=NULL*/) {
   1460            #if ENABLED(SDSORT_CACHE_NAMES)
   1461              if (match != NULL) {
   1462                while (nr < sort_count) {
   1463                  if (strcasecmp(match, sortshort[nr]) == 0) break;
   1464                  nr++;
   1465                }
   1466              }
   1467              if (nr < sort_count) {
   1468                strcpy(filename, sortshort[nr]);
   1469                strcpy(longFilename, sortnames[nr]);
   1470                filenameIsDir = TEST(isDir[nr>>3], nr & 0x07);
   1471                return;
   1472              }
   1473            #endif // SDSORT_CACHE_NAMES
   1474            curDir = &workDir;
   1475            lsAction = LS_GetFilename;
   1476            nrFile_index = nr;
   1477            curDir->rewind();
   1478            lsDive("", *curDir, match);
   1479          }
   1480          
   1481          uint16_t CardReader::getnrfilenames() {
   1482            curDir = &workDir;
   1483            lsAction = LS_Count;
   1484            nrFiles = 0;
   1485            curDir->rewind();
   1486            lsDive("", *curDir);
   1487            //SERIAL_ECHOLN(nrFiles);
   1488            return nrFiles;
   1489          }
   1490          
   1491          void CardReader::chdir(const char * relpath) {
   1492            SdFile newDir;
   1493            SdFile *parent = &root;
   1494          
   1495            if (workDir.isOpen()) parent = &workDir;
   1496          
   1497            if (!newDir.open(*parent, relpath, O_READ)) {
   1498              SERIAL_ECHO_START();
   1499              SERIAL_ECHOPGM(MSG_SD_CANT_ENTER_SUBDIR);
   1500              SERIAL_ECHOLN(relpath);
   1501            }
   1502            else {
   1503              workDir = newDir;
   1504              if (workDirDepth < MAX_DIR_DEPTH)
   1505                workDirParents[workDirDepth++] = workDir;
   1506              #if ENABLED(SDCARD_SORT_ALPHA)
   1507                presort();
   1508              #endif
   1509            }
   1510          }
   1511          
   1512          int8_t CardReader::updir() {
   1513            if (workDirDepth > 0) {                                               // At least 1 dir has been saved
   1514              workDir = --workDirDepth ? workDirParents[workDirDepth - 1] : root; // Use parent, or root if none
   1515              #if ENABLED(SDCARD_SORT_ALPHA)
   1516                presort();
   1517              #endif
   1518            }
   1519            return workDirDepth;
   1520          }
   1521          
   1522          
   1523          #if ENABLED(SDCARD_SORT_ALPHA)
   1524          
   1525            /**
   1526             * Get the name of a file in the current directory by sort-index
   1527             */
   1528            void CardReader::getfilename_sorted(const uint16_t nr) {
   1529              getfilename(
   1530                #if ENABLED(SDSORT_GCODE)
   1531                  sort_alpha &&
   1532                #endif
   1533                (nr < sort_count) ? sort_order[nr] : nr
   1534              );
   1535            }
   1536          
   1537            /**
   1538             * Read all the files and produce a sort key
   1539             *
   1540             * We can do this in 3 ways...
   1541             *  - Minimal RAM: Read two filenames at a time sorting along...
   1542             *  - Some RAM: Buffer the directory just for this sort
   1543             *  - Most RAM: Buffer the directory and return filenames from RAM
   1544             */
   1545            void CardReader::presort() {
   1546          
   1547              // Sorting may be turned off
   1548              #if ENABLED(SDSORT_GCODE)
   1549                if (!sort_alpha) return;
   1550              #endif
   1551          
   1552              // Throw away old sort index
   1553              flush_presort();
   1554          
   1555              // If there are files, sort up to the limit
   1556              uint16_t fileCnt = getnrfilenames();
   1557              if (fileCnt > 0) {
   1558          
   1559                // Never sort more than the max allowed
   1560                // If you use folders to organize, 20 may be enough
   1561                if (fileCnt > SDSORT_LIMIT) fileCnt = SDSORT_LIMIT;
   1562          
   1563                // Sort order is always needed. May be static or dynamic.
   1564                #if ENABLED(SDSORT_DYNAMIC_RAM)
   1565                  sort_order = new uint8_t[fileCnt];
   1566                #endif
   1567          
   1568                // Use RAM to store the entire directory during pre-sort.
   1569                // SDSORT_LIMIT should be set to prevent over-allocation.
   1570                #if ENABLED(SDSORT_USES_RAM)
   1571          
   1572                  // If using dynamic ram for names, allocate on the heap.
   1573                  #if ENABLED(SDSORT_CACHE_NAMES)
   1574                    #if ENABLED(SDSORT_DYNAMIC_RAM)
   1575                      sortshort = new char*[fileCnt];
   1576                      sortnames = new char*[fileCnt];
   1577                    #endif
   1578                  #elif ENABLED(SDSORT_USES_STACK)
   1579                    char sortnames[fileCnt][SORTED_LONGNAME_MAXLEN];
   1580                  #endif
   1581          
   1582                  // Folder sorting needs 1 bit per entry for flags.
   1583                  #if HAS_FOLDER_SORTING
   1584                    #if ENABLED(SDSORT_DYNAMIC_RAM)
   1585                      isDir = new uint8_t[(fileCnt + 7) >> 3];
   1586                    #elif ENABLED(SDSORT_USES_STACK)
   1587                      uint8_t isDir[(fileCnt + 7) >> 3];
   1588                    #endif
   1589                  #endif
   1590          
   1591                #else // !SDSORT_USES_RAM
   1592          
   1593                  // By default re-read the names from SD for every compare
   1594                  // retaining only two filenames at a time. This is very
   1595                  // slow but is safest and uses minimal RAM.
   1596                  char name1[LONG_FILENAME_LENGTH + 1];
   1597          
   1598                #endif
   1599          
   1600                if (fileCnt > 1) {
   1601          
   1602                  // Init sort order.
   1603                  for (uint16_t i = 0; i < fileCnt; i++) {
   1604                    sort_order[i] = i;
   1605                    // If using RAM then read all filenames now.
   1606                    #if ENABLED(SDSORT_USES_RAM)
   1607                      getfilename(i);
   1608                      #if ENABLED(SDSORT_DYNAMIC_RAM)
   1609                        // Use dynamic method to copy long filename
   1610                        sortnames[i] = strdup(LONGEST_FILENAME);
   1611                        #if ENABLED(SDSORT_CACHE_NAMES)
   1612                          // When caching also store the short name, since
   1613                          // we're replacing the getfilename() behavior.
   1614                          sortshort[i] = strdup(filename);
   1615                        #endif
   1616                      #else
   1617                        // Copy filenames into the static array
   1618                        #if SORTED_LONGNAME_MAXLEN != LONG_FILENAME_LENGTH
   1619                          strncpy(sortnames[i], LONGEST_FILENAME, SORTED_LONGNAME_MAXLEN);
   1620                          sortnames[i][SORTED_LONGNAME_MAXLEN - 1] = '\0';
   1621                        #else
   1622                          strncpy(sortnames[i], LONGEST_FILENAME, SORTED_LONGNAME_MAXLEN);
   1623                        #endif
   1624                        #if ENABLED(SDSORT_CACHE_NAMES)
   1625                          strcpy(sortshort[i], filename);
   1626                        #endif
   1627                      #endif
   1628                      // char out[30];
   1629                      // sprintf_P(out, PSTR("---- %i %s %s"), i, filenameIsDir ? "D" : " ", sortnames[i]);
   1630                      // SERIAL_ECHOLN(out);
   1631                      #if HAS_FOLDER_SORTING
   1632                        const uint16_t bit = i & 0x07, ind = i >> 3;
   1633                        if (bit == 0) isDir[ind] = 0x00;
   1634                        if (filenameIsDir) isDir[ind] |= _BV(bit);
   1635                      #endif
   1636                    #endif
   1637                  }
   1638          
   1639                  // Bubble Sort
   1640                  for (uint16_t i = fileCnt; --i;) {
   1641                    bool didSwap = false;
   1642                    for (uint16_t j = 0; j < i; ++j) {
   1643                      const uint16_t o1 = sort_order[j], o2 = sort_order[j + 1];
   1644          
   1645                      // Compare names from the array or just the two buffered names
   1646                      #if ENABLED(SDSORT_USES_RAM)
   1647                        #define _SORT_CMP_NODIR() (strcasecmp(sortnames[o1], sortnames[o2]) > 0)
   1648                      #else
   1649                        #define _SORT_CMP_NODIR() (strcasecmp(name1, name2) > 0)
   1650                      #endif
   1651          
   1652                      #if HAS_FOLDER_SORTING
   1653                        #if ENABLED(SDSORT_USES_RAM)
   1654                          // Folder sorting needs an index and bit to test for folder-ness.
   1655                          const uint8_t ind1 = o1 >> 3, bit1 = o1 & 0x07,
   1656                                        ind2 = o2 >> 3, bit2 = o2 & 0x07;
   1657                          #define _SORT_CMP_DIR(fs) \
   1658                            (((isDir[ind1] & _BV(bit1)) != 0) == ((isDir[ind2] & _BV(bit2)) != 0) \
   1659                              ? _SORT_CMP_NODIR() \
   1660                              : (isDir[fs > 0 ? ind1 : ind2] & (fs > 0 ? _BV(bit1) : _BV(bit2))) != 0)
   1661                        #else
   1662                          #define _SORT_CMP_DIR(fs) ((dir1 == filenameIsDir) ? _SORT_CMP_NODIR() : (fs > 0 ? dir1 : !dir1))
   1663                        #endif
   1664                      #endif
   1665          
   1666                      // The most economical method reads names as-needed
   1667                      // throughout the loop. Slow if there are many.
   1668                      #if DISABLED(SDSORT_USES_RAM)
   1669                        getfilename(o1);
   1670                        strcpy(name1, LONGEST_FILENAME); // save (or getfilename below will trounce it)
   1671                        #if HAS_FOLDER_SORTING
   1672                          bool dir1 = filenameIsDir;
   1673                        #endif
   1674                        getfilename(o2);
   1675                        char *name2 = LONGEST_FILENAME; // use the string in-place
   1676                      #endif // !SDSORT_USES_RAM
   1677          
   1678                      // Sort the current pair according to settings.
   1679                      if (
   1680                        #if HAS_FOLDER_SORTING
   1681                          #if ENABLED(SDSORT_GCODE)
   1682                            sort_folders ? _SORT_CMP_DIR(sort_folders) : _SORT_CMP_NODIR()
   1683                          #else
   1684                            _SORT_CMP_DIR(FOLDER_SORTING)
   1685                          #endif
   1686                        #else
   1687                          _SORT_CMP_NODIR()
   1688                        #endif
   1689                      ) {
   1690                        sort_order[j] = o2;
   1691                        sort_order[j + 1] = o1;
   1692                        didSwap = true;
   1693                      }
   1694                    }
   1695                    if (!didSwap) break;
   1696                  }
   1697                  // Using RAM but not keeping names around
   1698                  #if ENABLED(SDSORT_USES_RAM) && DISABLED(SDSORT_CACHE_NAMES)
   1699                    #if ENABLED(SDSORT_DYNAMIC_RAM)
   1700                      for (uint16_t i = 0; i < fileCnt; ++i) free(sortnames[i]);
   1701                      #if HAS_FOLDER_SORTING
   1702                        free(isDir);
   1703                      #endif
   1704                    #endif
   1705                  #endif
   1706                }
   1707                else {
   1708                  sort_order[0] = 0;
   1709                  #if ENABLED(SDSORT_USES_RAM) && ENABLED(SDSORT_CACHE_NAMES)
   1710                    getfilename(0);
   1711                    #if ENABLED(SDSORT_DYNAMIC_RAM)
   1712                      sortnames = new char*[1];
   1713                      sortnames[0] = strdup(LONGEST_FILENAME); // malloc
   1714                      #if ENABLED(SDSORT_CACHE_NAMES)
   1715                        sortshort = new char*[1];
   1716                        sortshort[0] = strdup(filename);       // malloc
   1717                      #endif
   1718                      isDir = new uint8_t[1];
   1719                    #else
   1720                      #if SORTED_LONGNAME_MAXLEN != LONG_FILENAME_LENGTH
   1721                        strncpy(sortnames[0], LONGEST_FILENAME, SORTED_LONGNAME_MAXLEN);
   1722                        sortnames[0][SORTED_LONGNAME_MAXLEN - 1] = '\0';
   1723                      #else
   1724                        strncpy(sortnames[0], LONGEST_FILENAME, SORTED_LONGNAME_MAXLEN);
   1725                      #endif
   1726                      #if ENABLED(SDSORT_CACHE_NAMES)
   1727                        strcpy(sortshort[0], filename);
   1728                      #endif
   1729                    #endif
   1730                    isDir[0] = filenameIsDir ? 0x01 : 0x00;
   1731                  #endif
   1732                }
   1733          
   1734                sort_count = fileCnt;
   1735              }
   1736            }
   1737          
   1738            void CardReader::flush_presort() {
   1739              if (sort_count > 0) {
   1740                #if ENABLED(SDSORT_DYNAMIC_RAM)
   1741                  delete sort_order;
   1742                  #if ENABLED(SDSORT_CACHE_NAMES)
   1743                    for (uint8_t i = 0; i < sort_count; ++i) {
   1744                      free(sortshort[i]); // strdup
   1745                      free(sortnames[i]); // strdup
   1746                    }
   1747                    delete sortshort;
   1748                    delete sortnames;
   1749                  #endif
   1750                #endif
   1751                sort_count = 0;
   1752              }
   1753            }
   1754          
   1755          #endif // SDCARD_SORT_ALPHA
   1756          
   1757          uint16_t CardReader::get_num_Files() {
   1758            return
   1759              #if ENABLED(SDCARD_SORT_ALPHA) && SDSORT_USES_RAM && SDSORT_CACHE_NAMES
   1760                nrFiles // no need to access the SD card for filenames
   1761              #else
   1762                getnrfilenames()
   1763              #endif
   1764            ;
   1765          }
   1766          
   1767          void CardReader::printingHasFinished() {
   1768            stepper.synchronize();
   1769            file.close();
   1770            if (file_subcall_ctr > 0) { // Heading up to a parent file that called current as a procedure.
   1771              file_subcall_ctr--;
   1772              openFile(proc_filenames[file_subcall_ctr], true, true);
   1773              setIndex(filespos[file_subcall_ctr]);
   1774              startFileprint();
   1775            }
   1776            else {
   1777              sdprinting = false;
   1778              #if ENABLED(SD_FINISHED_STEPPERRELEASE) && defined(SD_FINISHED_RELEASECOMMAND)
   1779                stepper.cleaning_buffer_counter = 1; // The command will fire from the Stepper ISR
   1780              #endif
   1781              print_job_timer.stop();
   1782              if (print_job_timer.duration() > 60)
   1783                enqueue_and_echo_commands_P(PSTR("M31"));
   1784              #if ENABLED(SDCARD_SORT_ALPHA)
   1785                presort();
   1786              #endif
   1787          
   1788              #if ENABLED(SD_REPRINT_LAST_SELECTED_FILE)
   1789                lcd_reselect_last_file();
   1790              #endif
   1791            }
   1792          }
   1793          #endif
   1794          
   1795          #endif // SDSUPPORT

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   CardReader::CardReader()
         8   -> SdBaseFile::SdBaseFile()
    1008   CardReader::Explore_Disk(char *, uint8_t)
      1008   -> Print::print(char const *)
      1008   -> f_mount
      1008   -> f_opendir
      1008   -> f_readdir
      1008   -> memset
      1008   -> strcat
      1008   -> strcpy
      1008   -> strstr(char *, char const *)
      1008   -> strstr(char const *, char const *)
     808   CardReader::ShowSDFiles()
       808   -> f_mount
       808   -> f_opendir
       808   -> f_readdir
       808   -> strcat
       808   -> strcpy
       808   -> strstr(char *, char const *)
      12   CardReader::ascii2dec(char *, char)
       0   CardReader::automount()
      24   CardReader::checkFilesys(unsigned char)
        24   -> FATFS_LinkDriver_usb
        24   -> FATFS_UnLinkDriver
        24   -> MX_USB_HOST_DeInit
        24   -> f_mount
         0   -> serialprintPGM(char const *)
        24   -> serialprintPGM(char const *)
      24   CardReader::checkautostart(bool)
        24   -> CardReader::unmount()
        24   -> FATFS_LinkDriver
         0   -> FATFS_UnLinkDriver
        24   -> FATFS_UnLinkDriver
        24   -> f_mount
        24   -> serialprintPGM(char const *)
       8   CardReader::closefile(bool)
         8   -> f_close
       0   CardReader::continuePrint(bool)
       4   CardReader::createFilename(char *, dir_t const &)
       0   CardReader::deleteFile(char *)
       8   CardReader::finishWrite()
         8   -> f_close
         8   -> f_sync
      16   CardReader::getStatus()
        16   -> Print::print(unsigned int, int)
         0   -> USARTClass::write(uint8_t)
         0   -> serialprintPGM(char const *)
        16   -> serialprintPGM(char const *)
       0   CardReader::get_file_list(char *)
         0   -> CardReader::Explore_Disk(char *, uint8_t)
       0   CardReader::getsdpos()
       0   CardReader::initsd()
      16   CardReader::initusb()
        16   -> f_mount
         0   -> serialprintPGM(char const *)
        16   -> serialprintPGM(char const *)
       0   CardReader::isFileOpen()
       0   CardReader::ls()
         0   -> CardReader::get_file_list(char *)
      16   CardReader::makeDirectory(char *)
        16   -> Print::print(char const *)
         0   -> USARTClass::write(uint8_t)
        16   -> f_close
        16   -> f_mkdir
       0   CardReader::mount()
         0   -> CardReader::initsd()
      88   CardReader::openFile(char *, bool, bool)
        88   -> Print::print(unsigned int, int)
        88   -> SdBaseFile::SdBaseFile()
        88   -> USARTClass::write(uint8_t)
        88   -> __aeabi_memclr4
        88   -> f_close
        88   -> f_open
        88   -> mks_saveFileName
        88   -> serial_echopair_P(char const *, char const *)
        88   -> serialprintPGM(char const *)
        88   -> strcat
       0   CardReader::openLogFile(char *)
         0   -> CardReader::openFile(char *, bool, bool)
       0   CardReader::operatePrint()
       0   CardReader::pausePrint(bool)
       0   CardReader::pauseSDPrint()
       0   CardReader::printStatus()
       8   CardReader::printingHasFinished()
         8   -> Stepper::synchronize()
         8   -> Stopwatch::duration()
         8   -> Stopwatch::stop()
         0   -> enqueue_and_echo_commands_P(char const *)
         8   -> enqueue_and_echo_commands_P(char const *)
         8   -> f_close
       0   CardReader::release()
      16   CardReader::removeFile(char *)
        16   -> Print::print(char const *)
        16   -> USARTClass::write(uint8_t)
        16   -> f_close
        16   -> f_unlink
         0   -> serialprintPGM(char const *)
        16   -> serialprintPGM(char const *)
       0   CardReader::selectFile(char *, bool)
       0   CardReader::showFilename(uint8_t const *)
       8   CardReader::startFileprint()
         0   -> epr_read_data
         8   -> epr_write_data
       0   CardReader::startPrint()
      16   CardReader::startWrite(char *)
        16   -> f_close
        16   -> f_open
       0   CardReader::stopPrint()
       8   CardReader::stopSDPrint()
         0   -> CardReader::closefile(bool)
         8   -> CardReader::isFileOpen()
       0   CardReader::subobject CardReader()
         0   -> CardReader::CardReader()
      16   CardReader::udiskReset()
        16   -> FATFS_UnLinkDriver
        16   -> HAL_Delay
        16   -> MX_USB_HOST_DeInit
        16   -> MX_USB_HOST_Init
        16   -> serialprintPGM(char const *)
       0   CardReader::udiskState_Polling()
         0   -> CardReader::udiskReset()
       0   CardReader::unmount()
      32   CardReader::write_command(char *)
        32   -> f_write
        32   -> memset
        32   -> serialprintPGM(char const *)
        32   -> strchr(char *, int)
        32   -> strlen
      16   RFstricmp(char const *, char const *)
        16   -> tolower
      24   RFstrnicmp(char const *, char const *, size_t)
        24   -> tolower
       0   SdBaseFile::SdBaseFile()
       8   serialprintPGM(char const *)
         8   -> USARTClass::write(uint8_t)
       0   strchr(char *, int)
         0   -> __iar_Strchr
       0   strstr(char *, char const *)
         0   -> __iar_Strstr
       0   strstr(char const *, char const *)
         0   -> __iar_Strstr


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       8  ?<Constant " Size: ">
       8  ?<Constant ".DIR\r\n">
       8  ?<Constant ".GCO">
       8  ?<Constant ".MDL">
       4  ?<Constant ".\n">
       8  ?<Constant ".gco">
       8  ?<Constant ".mdl">
       2  ?<Constant "/">
      16  ?<Constant "Creation failed">
      24  ?<Constant "Deletion failed, File: ">
      20  ?<Constant "Directory created">
      16  ?<Constant "File deleted:">
      16  ?<Constant "File opened: ">
      16  ?<Constant "File selected\n">
       4  ?<Constant "M31">
      12  ?<Constant "M84 X Y Z E">
      20  ?<Constant "Not SD printing\n">
      20  ?<Constant "SD card removed\n">
      20  ?<Constant "SD printing byte ">
      16  ?<Constant "USB DeInit!\n">
       8  ?<Constant "USB OK\n">
      12  ?<Constant "USB Reset!\n">
      16  ?<Constant "USB init fail\n">
      16  ?<Constant "USB inserted\n">
      16  ?<Constant "USB removed\n">
       4  ?<Constant "\r\n">
      24  ?<Constant "error writing to file\n">
      20  ?<Constant "open failed, File: ">
      32  ?<Constant {'\000'}>
       4  ??DataTable42
       4  ??DataTable43
       4  ??DataTable45
       4  ??DataTable45_1
       4  ??DataTable45_10
       4  ??DataTable45_11
       4  ??DataTable45_12
       4  ??DataTable45_13
       4  ??DataTable45_14
       4  ??DataTable45_15
       4  ??DataTable45_16
       4  ??DataTable45_17
       4  ??DataTable45_2
       4  ??DataTable45_3
       4  ??DataTable45_4
       4  ??DataTable45_5
       4  ??DataTable45_6
       4  ??DataTable45_7
       4  ??DataTable45_8
       4  ??DataTable45_9
      42  CardReader::CardReader()
     274  CardReader::Explore_Disk(char *, uint8_t)
     318  CardReader::ShowSDFiles()
      72  CardReader::ascii2dec(char *, char)
       2  CardReader::automount()
     168  CardReader::checkFilesys(unsigned char)
     178  CardReader::checkautostart(bool)
      20  CardReader::closefile(bool)
       2  CardReader::continuePrint(bool)
      52  CardReader::createFilename(char *, dir_t const &)
       2  CardReader::deleteFile(char *)
      32  CardReader::finishWrite()
      86  CardReader::getStatus()
      10  CardReader::get_file_list(char *)
       6  CardReader::getsdpos()
       8  CardReader::initsd()
      70  CardReader::initusb()
      16  CardReader::isFileOpen()
       6  CardReader::ls()
      94  CardReader::makeDirectory(char *)
      12  CardReader::mount()
     220  CardReader::openFile(char *, bool, bool)
      12  CardReader::openLogFile(char *)
       2  CardReader::operatePrint()
      20  CardReader::pausePrint(bool)
      22  CardReader::pauseSDPrint()
       2  CardReader::printStatus()
      62  CardReader::printingHasFinished()
      20  CardReader::release()
     112  CardReader::removeFile(char *)
       2  CardReader::selectFile(char *, bool)
      18  CardReader::showFilename(uint8_t const *)
      72  CardReader::startFileprint()
      20  CardReader::startPrint()
      62  CardReader::startWrite(char *)
      24  CardReader::stopPrint()
      32  CardReader::stopSDPrint()
       2  CardReader::subobject CardReader()
      86  CardReader::udiskReset()
      26  CardReader::udiskState_Polling()
      20  CardReader::unmount()
     118  CardReader::write_command(char *)
      62  RFstricmp(char const *, char const *)
      72  RFstrnicmp(char const *, char const *, size_t)
       8  SdBaseFile::SdBaseFile()
     256  lfn
     256  lfn
      28  serialprintPGM(char const *)
       4  strchr(char *, int)
       4  strstr(char *, char const *)
       4  strstr(char const *, char const *)
       4  textt
       1  -- Other

 
   516 bytes in section .bss
    47 bytes in section .rodata
 3 042 bytes in section .text
 
 2 978 bytes of CODE  memory (+ 64 bytes shared)
    46 bytes of CONST memory (+  1 byte  shared)
   516 bytes of DATA  memory

Errors: none
Warnings: 94
