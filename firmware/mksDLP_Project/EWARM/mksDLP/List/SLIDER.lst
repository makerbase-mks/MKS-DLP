###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  10:59:23
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Widget\SLIDER.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Widget\SLIDER.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\SLIDER.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\SLIDER.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Widget\SLIDER.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              µC/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : SLIDER.c
     16          Purpose     : Implementation of slider widget
     17          ---------------------------END-OF-HEADER------------------------------
     18          */
     19          
     20          #include <stdlib.h>
     21          #include <string.h>
     22          #include "GUI_Protected.h"
     23          #include "SLIDER.h"
     24          #include "WIDGET.h"
     25          
     26          #if GUI_WINSUPPORT
     27          
     28          /*********************************************************************
     29          *
     30          *       Private config defaults
     31          *
     32          **********************************************************************
     33          */
     34          
     35          #ifndef SLIDER_SUPPORT_TRANSPARENCY
     36            #define SLIDER_SUPPORT_TRANSPARENCY WM_SUPPORT_TRANSPARENCY
     37          #endif
     38          
     39          /* Support for 3D effects */
     40          #ifndef SLIDER_USE_3D
     41            #define SLIDER_USE_3D 1
     42          #endif
     43          
     44          /* Define colors */
     45          #ifndef SLIDER_BKCOLOR0_DEFAULT
     46            #define SLIDER_BKCOLOR0_DEFAULT 0xc0c0c0
     47          #endif
     48          
     49          #ifndef SLIDER_BKCOLOR1_DEFAULT
     50            #define SLIDER_BKCOLOR1_DEFAULT GUI_WHITE
     51          #endif
     52          
     53          #ifndef SLIDER_COLOR0_DEFAULT
     54            #define SLIDER_COLOR0_DEFAULT 0xc0c0c0
     55          #endif
     56          
     57          #ifndef SLIDER_COLOR1_DEFAULT
     58            #define SLIDER_COLOR1_DEFAULT GUI_BLACK
     59          #endif
     60          
     61          /*********************************************************************
     62          *
     63          *       Object definition
     64          *
     65          **********************************************************************
     66          */
     67          
     68          typedef struct {
     69            WIDGET Widget;
     70            GUI_COLOR aBkColor[2];
     71            GUI_COLOR aColor[2];
     72            int Min, Max, v;
     73            int Flags;
     74            int NumTicks;
     75            I16 Width;
     76            #if GUI_DEBUG_LEVEL >1
     77              int DebugId;
     78            #endif  
     79          } SLIDER_Obj;
     80          
     81          /*********************************************************************
     82          *
     83          *       Macros for internal use
     84          *
     85          **********************************************************************
     86          */
     87          
     88          #define SLIDER_ID 0x4544   /* Magic numer, should be unique if possible */
     89          
     90          #define SLIDER_H2P(h) (SLIDER_Obj*) GUI_ALLOC_h2p(h)
     91          
     92          #if GUI_DEBUG_LEVEL > 1
     93            #define SLIDER_ASSERT_IS_VALID_PTR(p) DEBUG_ERROROUT_IF(p->DebugId != SLIDER_ID, "SLIDER.c: Wrong handle type or Object not init'ed")
     94            #define SLIDER_INIT_ID(p)   p->DebugId = SLIDER_ID
     95            #define SLIDER_DEINIT_ID(p) p->DebugId = SLIDER_ID+1
     96          #else
     97            #define SLIDER_ASSERT_IS_VALID_PTR(p)
     98            #define SLIDER_INIT_ID(p)
     99            #define SLIDER_DEINIT_ID(p)
    100          #endif
    101          
    102          
    103          /*********************************************************************
    104          *
    105          *       Static data
    106          *
    107          **********************************************************************
    108          */
    109          

   \                                 In section .data, align 4
    110          static GUI_COLOR _DefaultBkColor = SLIDER_BKCOLOR0_DEFAULT;
   \                     _DefaultBkColor:
   \   00000000   0x00C0C0C0         DC32 12632256
    111          
    112          /*********************************************************************
    113          *
    114          *       Static routines
    115          *
    116          **********************************************************************
    117          */
    118          /*********************************************************************
    119          *
    120          *       _Paint
    121          */

   \                                 In section .text, align 2, keep-with-next
    122          static void _Paint(SLIDER_Obj* pObj, WM_HWIN hObj) {
   \                     _Paint: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB089             SUB      SP,SP,#+36
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x4689             MOV      R9,R1
    123            GUI_RECT r, rFocus, rSlider, rSlot;
    124            int x0, xsize, i, Range, NumTicks;
    125            WIDGET__GetClientRect(&pObj->Widget, &rFocus);
   \   0000000A   0xA906             ADD      R1,SP,#+24
   \   0000000C   0x.... 0x....      BL       WIDGET__GetClientRect
    126            GUI__ReduceRect(&r, &rFocus, 1);
   \   00000010   0x2201             MOVS     R2,#+1
   \   00000012   0xA906             ADD      R1,SP,#+24
   \   00000014   0xA804             ADD      R0,SP,#+16
   \   00000016   0x.... 0x....      BL       GUI__ReduceRect
    127            NumTicks = pObj->NumTicks;
   \   0000001A   0x6CA5             LDR      R5,[R4, #+72]
    128            xsize    = r.x1 - r.x0  + 1 - pObj->Width;
   \   0000001C   0xF9B4 0x004C      LDRSH    R0,[R4, #+76]
   \   00000020   0xF9BD 0x1010      LDRSH    R1,[SP, #+16]
   \   00000024   0xF9BD 0x2014      LDRSH    R2,[SP, #+20]
   \   00000028   0x1A52             SUBS     R2,R2,R1
   \   0000002A   0x1C52             ADDS     R2,R2,#+1
   \   0000002C   0x1A16             SUBS     R6,R2,R0
    129            x0       = r.x0 + pObj->Width / 2;
   \   0000002E   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   00000032   0xEB01 0x0760      ADD      R7,R1,R0, ASR #+1
    130            Range    = pObj->Max - pObj->Min;
   \   00000036   0x6BE0             LDR      R0,[R4, #+60]
   \   00000038   0x6BA1             LDR      R1,[R4, #+56]
   \   0000003A   0xEBB0 0x0801      SUBS     R8,R0,R1
    131            if (Range == 0) {
   \   0000003E   0xD101             BNE.N    ??_Paint_0
    132              Range = 1;
   \   00000040   0xF04F 0x0801      MOV      R8,#+1
    133            }
    134            /* Fill with parents background color */
    135            #if !SLIDER_SUPPORT_TRANSPARENCY   /* Not needed any more, since window is transparent*/
    136              if (pObj->aBkColor[0] == GUI_INVALID_COLOR) {
    137                LCD_SetBkColor(WIDGET__GetBkColor(hObj));
    138              } else {
    139                LCD_SetBkColor(pObj->aBkColor[0]);
    140              }
    141              GUI_Clear();
    142            #else
    143              if (!WM_GetHasTrans(hObj)) {
   \                     ??_Paint_0: (+1)
   \   00000044   0x4648             MOV      R0,R9
   \   00000046   0x.... 0x....      BL       WM_GetHasTrans
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD104             BNE.N    ??_Paint_1
    144                LCD_SetBkColor(pObj->aBkColor[0]);
   \   0000004E   0x6AA0             LDR      R0,[R4, #+40]
   \   00000050   0x.... 0x....      BL       LCD_SetBkColor
    145                GUI_Clear();
   \   00000054   0x.... 0x....      BL       GUI_Clear
    146              }
    147            #endif
    148            /* Calculate Slider position */
    149            rSlider    = r;
   \                     ??_Paint_1: (+1)
   \   00000058   0xE9DD 0x0104      LDRD     R0,R1,[SP, #+16]
   \   0000005C   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
    150            rSlider.y0 = 5;
   \   00000060   0x2005             MOVS     R0,#+5
   \   00000062   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    151            rSlider.x0 = x0 + (U32)xsize * (U32)(pObj->v - pObj->Min) / Range - pObj->Width / 2;
   \   00000066   0xF9B4 0x004C      LDRSH    R0,[R4, #+76]
   \   0000006A   0x6C21             LDR      R1,[R4, #+64]
   \   0000006C   0x6BA2             LDR      R2,[R4, #+56]
   \   0000006E   0x1A89             SUBS     R1,R1,R2
   \   00000070   0x4371             MULS     R1,R1,R6
   \   00000072   0xFBB1 0xF1F8      UDIV     R1,R1,R8
   \   00000076   0x19C9             ADDS     R1,R1,R7
   \   00000078   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   0000007C   0xEBA1 0x0060      SUB      R0,R1,R0, ASR #+1
   \   00000080   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    152            rSlider.x1 = rSlider.x0 + pObj->Width;
   \   00000084   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000088   0xF8B4 0x104C      LDRH     R1,[R4, #+76]
   \   0000008C   0x1808             ADDS     R0,R1,R0
   \   0000008E   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    153            /* Calculate Slot position */
    154            rSlot.x0 = x0;
   \   00000092   0x4638             MOV      R0,R7
   \   00000094   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    155            rSlot.x1 = x0 + xsize;
   \   00000098   0x19F0             ADDS     R0,R6,R7
   \   0000009A   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    156            rSlot.y0 = (rSlider.y0 + rSlider.y1) / 2 - 1;
   \   0000009E   0xF9BD 0x0002      LDRSH    R0,[SP, #+2]
   \   000000A2   0xF9BD 0x1006      LDRSH    R1,[SP, #+6]
   \   000000A6   0xFA01 0xF080      SXTAH    R0,R1,R0
   \   000000AA   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   000000AE   0x1040             ASRS     R0,R0,#+1
   \   000000B0   0x1E40             SUBS     R0,R0,#+1
   \   000000B2   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    157            rSlot.y1 = rSlot.y0 + 3;
   \   000000B6   0x1CC0             ADDS     R0,R0,#+3
   \   000000B8   0xF8AD 0x000E      STRH     R0,[SP, #+14]
    158            WIDGET__EFFECT_DrawDownRect(&pObj->Widget, &rSlot);        /* Draw slot */
   \   000000BC   0xA902             ADD      R1,SP,#+8
   \   000000BE   0x4620             MOV      R0,R4
   \   000000C0   0x.... 0x....      BL       WIDGET__EFFECT_DrawDownRect
    159            /* Draw the ticks */
    160            if (NumTicks < 0) {
   \   000000C4   0x2D00             CMP      R5,#+0
   \   000000C6   0xD507             BPL.N    ??_Paint_2
    161              NumTicks = Range + 1;
   \   000000C8   0xF108 0x0501      ADD      R5,R8,#+1
    162              if (NumTicks > (xsize / 5)) {
   \   000000CC   0x2005             MOVS     R0,#+5
   \   000000CE   0xFB96 0xF0F0      SDIV     R0,R6,R0
   \   000000D2   0x42A8             CMP      R0,R5
   \   000000D4   0xDA00             BGE.N    ??_Paint_2
    163                NumTicks = 11;
   \   000000D6   0x250B             MOVS     R5,#+11
    164              }
    165            }
    166            if (NumTicks > 1) {
   \                     ??_Paint_2: (+1)
   \   000000D8   0x2D02             CMP      R5,#+2
   \   000000DA   0xDB14             BLT.N    ??_Paint_3
    167              LCD_SetColor(GUI_BLACK);
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0x.... 0x....      BL       LCD_SetColor
    168              for (i = 0; i < NumTicks; i++) {
   \   000000E2   0xF04F 0x0800      MOV      R8,#+0
   \   000000E6   0xE00C             B.N      ??_Paint_4
    169                int x = x0 + xsize * i / (NumTicks - 1);
    170                WIDGET__DrawVLine(&pObj->Widget, x, 1, 3);
   \                     ??_Paint_5: (+1)
   \   000000E8   0x2303             MOVS     R3,#+3
   \   000000EA   0x2201             MOVS     R2,#+1
   \   000000EC   0xFB08 0xF006      MUL      R0,R8,R6
   \   000000F0   0x1E69             SUBS     R1,R5,#+1
   \   000000F2   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000000F6   0x19C1             ADDS     R1,R0,R7
   \   000000F8   0x4620             MOV      R0,R4
   \   000000FA   0x.... 0x....      BL       WIDGET__DrawVLine
    171              }
   \   000000FE   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??_Paint_4: (+1)
   \   00000102   0x45A8             CMP      R8,R5
   \   00000104   0xDBF0             BLT.N    ??_Paint_5
    172            }
    173            /* Draw the slider itself */
    174            LCD_SetColor(pObj->aColor[0]);
   \                     ??_Paint_3: (+1)
   \   00000106   0x6B20             LDR      R0,[R4, #+48]
   \   00000108   0x.... 0x....      BL       LCD_SetColor
    175            WIDGET__FillRectEx(&pObj->Widget, &rSlider);
   \   0000010C   0xA900             ADD      R1,SP,#+0
   \   0000010E   0x4620             MOV      R0,R4
   \   00000110   0x.... 0x....      BL       WIDGET__FillRectEx
    176            LCD_SetColor(GUI_BLACK);
   \   00000114   0x2000             MOVS     R0,#+0
   \   00000116   0x.... 0x....      BL       LCD_SetColor
    177            WIDGET__EFFECT_DrawUpRect(&pObj->Widget, &rSlider);
   \   0000011A   0xA900             ADD      R1,SP,#+0
   \   0000011C   0x4620             MOV      R0,R4
   \   0000011E   0x.... 0x....      BL       WIDGET__EFFECT_DrawUpRect
    178            /* Draw focus */
    179            if (pObj->Widget.State & WIDGET_STATE_FOCUS) {
   \   00000122   0xF894 0x0026      LDRB     R0,[R4, #+38]
   \   00000126   0x07C0             LSLS     R0,R0,#+31
   \   00000128   0xD507             BPL.N    ??_Paint_6
    180              LCD_SetColor(GUI_BLACK);
   \   0000012A   0x2000             MOVS     R0,#+0
   \   0000012C   0x.... 0x....      BL       LCD_SetColor
    181              WIDGET__DrawFocusRect(&pObj->Widget, &rFocus, 0);
   \   00000130   0x2200             MOVS     R2,#+0
   \   00000132   0xA906             ADD      R1,SP,#+24
   \   00000134   0x4620             MOV      R0,R4
   \   00000136   0x.... 0x....      BL       WIDGET__DrawFocusRect
    182            }
    183          }
   \                     ??_Paint_6: (+1)
   \   0000013A   0xB009             ADD      SP,SP,#+36
   \   0000013C   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    184          
    185          /*********************************************************************
    186          *
    187          *       _SliderPressed
    188          */

   \                                 In section .text, align 2, keep-with-next
    189          static void _SliderPressed(SLIDER_Handle hObj, SLIDER_Obj* pObj) {
   \                     _SliderPressed: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    190            WIDGET_OrState(hObj, SLIDER_STATE_PRESSED);
   \   00000006   0xF44F 0x7180      MOV      R1,#+256
   \   0000000A   0x.... 0x....      BL       WIDGET_OrState
    191            if (pObj->Widget.Win.Status & WM_SF_ISVIS) {
   \   0000000E   0x7F28             LDRB     R0,[R5, #+28]
   \   00000010   0x0780             LSLS     R0,R0,#+30
   \   00000012   0xD505             BPL.N    ??_SliderPressed_0
    192              WM_NotifyParent(hObj, WM_NOTIFICATION_CLICKED);
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   0000001C   0x.... 0x....      B.W      WM_NotifyParent
    193            }
    194          }
   \                     ??_SliderPressed_0: (+1)
   \   00000020   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    195          
    196          /*********************************************************************
    197          *
    198          *       _SliderReleased
    199          */

   \                                 In section .text, align 2, keep-with-next
    200          static void _SliderReleased(SLIDER_Handle hObj, SLIDER_Obj* pObj) {
   \                     _SliderReleased: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    201            WIDGET_AndState(hObj, SLIDER_STATE_PRESSED);
   \   00000006   0xF44F 0x7180      MOV      R1,#+256
   \   0000000A   0x.... 0x....      BL       WIDGET_AndState
    202            if (pObj->Widget.Win.Status & WM_SF_ISVIS) {
   \   0000000E   0x7F28             LDRB     R0,[R5, #+28]
   \   00000010   0x0780             LSLS     R0,R0,#+30
   \   00000012   0xD505             BPL.N    ??_SliderReleased_0
    203              WM_NotifyParent(hObj, WM_NOTIFICATION_RELEASED);
   \   00000014   0x2102             MOVS     R1,#+2
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   0000001C   0x.... 0x....      B.W      WM_NotifyParent
    204            }
    205          }
   \                     ??_SliderReleased_0: (+1)
   \   00000020   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    206          
    207          /*********************************************************************
    208          *
    209          *       _OnTouch
    210          */

   \                                 In section .text, align 2, keep-with-next
    211          static void _OnTouch(SLIDER_Handle hObj, SLIDER_Obj* pObj, WM_MESSAGE*pMsg) {
   \                     _OnTouch: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    212            const GUI_PID_STATE* pState = (const GUI_PID_STATE*)pMsg->Data.p;
   \   00000008   0x6890             LDR      R0,[R2, #+8]
    213            if (pMsg->Data.p) {  /* Something happened in our area (pressed or released) */
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD04C             BEQ.N    ??_OnTouch_0
    214              if (pState->Pressed) {
   \   0000000E   0x8CE9             LDRH     R1,[R5, #+38]
   \   00000010   0x7A02             LDRB     R2,[R0, #+8]
   \   00000012   0x2A00             CMP      R2,#+0
   \   00000014   0xD041             BEQ.N    ??_OnTouch_1
    215                int x0, xsize, x, Sel, Range;
    216                Range = (pObj->Max - pObj->Min);
   \   00000016   0x6BEA             LDR      R2,[R5, #+60]
   \   00000018   0x6BAB             LDR      R3,[R5, #+56]
   \   0000001A   0x1AD6             SUBS     R6,R2,R3
    217                x0    = 1 + pObj->Width / 2;  /* 1 pixel focus rectangle + width of actual slider */
   \   0000001C   0xF9B5 0x204C      LDRSH    R2,[R5, #+76]
   \   00000020   0xEB02 0x72D2      ADD      R2,R2,R2, LSR #+31
   \   00000024   0x1052             ASRS     R2,R2,#+1
   \   00000026   0x1C57             ADDS     R7,R2,#+1
    218                x     = (pObj->Widget.State & WIDGET_STATE_VERTICAL) ? pState->y : pState->x;
   \   00000028   0x0709             LSLS     R1,R1,#+28
   \   0000002A   0xD501             BPL.N    ??_OnTouch_2
   \   0000002C   0x6840             LDR      R0,[R0, #+4]
   \   0000002E   0xE000             B.N      ??_OnTouch_3
   \                     ??_OnTouch_2: (+1)
   \   00000030   0x6800             LDR      R0,[R0, #+0]
    219                x    -= x0;
   \                     ??_OnTouch_3: (+1)
   \   00000032   0xEBA0 0x0807      SUB      R8,R0,R7
    220                xsize = WIDGET__GetWindowSizeX(hObj) - 2 * x0;
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       WIDGET__GetWindowSizeX
   \   0000003C   0xEBA0 0x0047      SUB      R0,R0,R7, LSL #+1
    221                if (x <= 0) {
   \   00000040   0xF1B8 0x0F01      CMP      R8,#+1
   \   00000044   0xDA01             BGE.N    ??_OnTouch_4
    222                  Sel = pObj->Min;
   \   00000046   0x6BAE             LDR      R6,[R5, #+56]
   \   00000048   0xE00F             B.N      ??_OnTouch_5
    223                } else if (x >= xsize) {
   \                     ??_OnTouch_4: (+1)
   \   0000004A   0x4580             CMP      R8,R0
   \   0000004C   0xDB01             BLT.N    ??_OnTouch_6
    224                  Sel = pObj->Max;
   \   0000004E   0x6BEE             LDR      R6,[R5, #+60]
   \   00000050   0xE00B             B.N      ??_OnTouch_5
    225                } else {
    226                  int Div;
    227                  Div = xsize ? xsize : 1;     /* Make sure we do not divide by 0, even though xsize should never be 0 in this case anyhow */
   \                     ??_OnTouch_6: (+1)
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD100             BNE.N    ??_OnTouch_7
   \   00000056   0x2001             MOVS     R0,#+1
    228                  Sel = pObj->Min + ((U32)Range * (U32)x + Div / 2) / Div;
   \                     ??_OnTouch_7: (+1)
   \   00000058   0x6BA9             LDR      R1,[R5, #+56]
   \   0000005A   0xEB00 0x72D0      ADD      R2,R0,R0, LSR #+31
   \   0000005E   0x1052             ASRS     R2,R2,#+1
   \   00000060   0xFB08 0x2206      MLA      R2,R8,R6,R2
   \   00000064   0xFBB2 0xF0F0      UDIV     R0,R2,R0
   \   00000068   0x1846             ADDS     R6,R0,R1
    229                }
    230                if (WM_IsFocussable(hObj)) {
   \                     ??_OnTouch_5: (+1)
   \   0000006A   0x4620             MOV      R0,R4
   \   0000006C   0x.... 0x....      BL       WM_IsFocussable
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD002             BEQ.N    ??_OnTouch_8
    231                  WM_SetFocus(hObj);
   \   00000074   0x4620             MOV      R0,R4
   \   00000076   0x.... 0x....      BL       WM_SetFocus
    232                }
    233                WM_SetCapture(hObj, 1);
   \                     ??_OnTouch_8: (+1)
   \   0000007A   0x2101             MOVS     R1,#+1
   \   0000007C   0x4620             MOV      R0,R4
   \   0000007E   0x.... 0x....      BL       WM_SetCapture
    234                SLIDER_SetValue(hObj, Sel);
   \   00000082   0x4631             MOV      R1,R6
   \   00000084   0x4620             MOV      R0,R4
   \   00000086   0x.... 0x....      BL       SLIDER_SetValue
    235                if ((pObj->Widget.State & SLIDER_STATE_PRESSED) == 0){   
   \   0000008A   0x8CE8             LDRH     R0,[R5, #+38]
   \   0000008C   0x05C0             LSLS     R0,R0,#+23
   \   0000008E   0xD40B             BMI.N    ??_OnTouch_0
    236                  _SliderPressed(hObj, pObj);
   \   00000090   0x4629             MOV      R1,R5
   \   00000092   0x4620             MOV      R0,R4
   \   00000094   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   00000098   0x....             B.N      _SliderPressed
    237                }
    238              } else {
    239                /* React only if button was pressed before ... avoid problems with moving / hiding windows above (such as dropdown) */
    240                if (pObj->Widget.State & SLIDER_STATE_PRESSED) {   
   \                     ??_OnTouch_1: (+1)
   \   0000009A   0x05C8             LSLS     R0,R1,#+23
   \   0000009C   0xD504             BPL.N    ??_OnTouch_0
    241                  _SliderReleased(hObj, pObj);
   \   0000009E   0x4629             MOV      R1,R5
   \   000000A0   0x4620             MOV      R0,R4
   \   000000A2   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   000000A6   0x....             B.N      _SliderReleased
    242                }
    243              }
    244            }
    245          }
   \                     ??_OnTouch_0: (+1)
   \   000000A8   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    246          
    247          /*********************************************************************
    248          *
    249          *       _OnKey
    250          */

   \                                 In section .text, align 2, keep-with-next
    251          static void  _OnKey(SLIDER_Handle hObj, WM_MESSAGE*pMsg) {
    252            const WM_KEY_INFO* pKeyInfo;
    253            int Key;
    254            pKeyInfo = (const WM_KEY_INFO*)(pMsg->Data.p);
   \                     _OnKey: (+1)
   \   00000000   0x6889             LDR      R1,[R1, #+8]
    255            Key = pKeyInfo->Key;
    256            if (pKeyInfo->PressedCnt > 0) {
   \   00000002   0x684A             LDR      R2,[R1, #+4]
   \   00000004   0x2A01             CMP      R2,#+1
   \   00000006   0xDB05             BLT.N    ??_OnKey_0
    257              switch (Key) {
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x2910             CMP      R1,#+16
   \   0000000C   0xD003             BEQ.N    ??_OnKey_1
   \   0000000E   0x2912             CMP      R1,#+18
   \   00000010   0xD100             BNE.N    ??_OnKey_0
    258                case GUI_KEY_RIGHT:
    259                  SLIDER_Inc(hObj);
   \   00000012   0x....             B.N      SLIDER_Inc
    260                  break;                    /* Send to parent by not doing anything */
    261                case GUI_KEY_LEFT:
    262                  SLIDER_Dec(hObj);
    263                  break;                    /* Send to parent by not doing anything */
    264                default:
    265                  return;
    266              }
    267            }
    268          }
   \                     ??_OnKey_0: (+1)
   \   00000014   0x4770             BX       LR               ;; return
   \                     ??_OnKey_1: (+1)
   \   00000016   0x....             B.N      SLIDER_Dec
    269          
    270          /*********************************************************************
    271          *
    272          *       _SLIDER_Callback
    273          */

   \                                 In section .text, align 2, keep-with-next
    274          static void _SLIDER_Callback (WM_MESSAGE *pMsg) {
   \                     _SLIDER_Callback: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    275            SLIDER_Handle hObj;
    276            SLIDER_Obj* pObj;
    277            hObj = pMsg->hWin;
   \   00000004   0xF9B4 0x5004      LDRSH    R5,[R4, #+4]
    278            pObj = SLIDER_H2P(hObj);
   \   00000008   0x4628             MOV      R0,R5
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000000E   0x4606             MOV      R6,R0
    279            /* Let widget handle the standard messages */
    280            if (WIDGET_HandleActive(hObj, pMsg) == 0) {
   \   00000010   0x4621             MOV      R1,R4
   \   00000012   0x4628             MOV      R0,R5
   \   00000014   0x.... 0x....      BL       WIDGET_HandleActive
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD01A             BEQ.N    ??_SLIDER_Callback_0
    281              return;
    282            }
    283            switch (pMsg->MsgId) {
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x280C             CMP      R0,#+12
   \   00000020   0xD008             BEQ.N    ??_SLIDER_Callback_1
   \   00000022   0x280E             CMP      R0,#+14
   \   00000024   0xD00C             BEQ.N    ??_SLIDER_Callback_2
   \   00000026   0x280F             CMP      R0,#+15
   \   00000028   0xD10E             BNE.N    ??_SLIDER_Callback_3
    284            case WM_PAINT:
    285              GUI_DEBUG_LOG("SLIDER: _Callback(WM_PAINT)\n");
    286              _Paint(pObj, hObj);
   \   0000002A   0x4629             MOV      R1,R5
   \   0000002C   0x4630             MOV      R0,R6
   \   0000002E   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000032   0x....             B.N      _Paint
    287              return;
    288            case WM_TOUCH:
    289              _OnTouch(hObj, pObj, pMsg);
   \                     ??_SLIDER_Callback_1: (+1)
   \   00000034   0x4622             MOV      R2,R4
   \   00000036   0x4631             MOV      R1,R6
   \   00000038   0x4628             MOV      R0,R5
   \   0000003A   0x.... 0x....      BL       _OnTouch
    290              break;
   \   0000003E   0xE003             B.N      ??_SLIDER_Callback_3
    291            case WM_KEY:
    292              _OnKey(hObj, pMsg);
   \                     ??_SLIDER_Callback_2: (+1)
   \   00000040   0x4621             MOV      R1,R4
   \   00000042   0x4628             MOV      R0,R5
   \   00000044   0x.... 0x....      BL       _OnKey
    293              break;
    294            }
    295            WM_DefaultProc(pMsg);
   \                     ??_SLIDER_Callback_3: (+1)
   \   00000048   0x4620             MOV      R0,R4
   \   0000004A   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000004E   0x.... 0x....      B.W      WM_DefaultProc
   \                     ??_SLIDER_Callback_0: (+1)
   \   00000052   0xBD70             POP      {R4-R6,PC}       ;; return
    296          }
    297          
    298          /*********************************************************************
    299          *
    300          *       Exported routines:  Create
    301          *
    302          **********************************************************************
    303          */
    304          
    305          /* Note: the parameters to a create function may vary.
    306                   Some widgets may have multiple create functions */
    307          
    308          /*********************************************************************
    309          *
    310          *       SLIDER_CreateEx
    311          */

   \                                 In section .text, align 2, keep-with-next
    312          SLIDER_Handle SLIDER_CreateEx(int x0, int y0, int xsize, int ysize, WM_HWIN hParent,
    313                                        int WinFlags, int ExFlags, int Id)
    314          {
   \                     SLIDER_CreateEx: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    315            SLIDER_Handle hObj;
    316            /* Create the window */
    317            WM_LOCK();
    318            #if SLIDER_SUPPORT_TRANSPARENCY
    319              WinFlags |= WM_CF_HASTRANS;
    320            #endif
    321            hObj = WM_CreateWindowAsChild(x0, y0, xsize, ysize, hParent, WinFlags, _SLIDER_Callback, sizeof(SLIDER_Obj) - sizeof(WM_Obj));
   \   00000004   0x2430             MOVS     R4,#+48
   \   00000006   0x9403             STR      R4,[SP, #+12]
   \   00000008   0x....             LDR.N    R4,??DataTable1
   \   0000000A   0x9402             STR      R4,[SP, #+8]
   \   0000000C   0x9C09             LDR      R4,[SP, #+36]
   \   0000000E   0xF044 0x0401      ORR      R4,R4,#0x1
   \   00000012   0xB2A4             UXTH     R4,R4
   \   00000014   0x9401             STR      R4,[SP, #+4]
   \   00000016   0xF9BD 0x4020      LDRSH    R4,[SP, #+32]
   \   0000001A   0x9400             STR      R4,[SP, #+0]
   \   0000001C   0x.... 0x....      BL       WM_CreateWindowAsChild
   \   00000020   0x0004             MOVS     R4,R0
    322            if (hObj) {
   \   00000022   0xD020             BEQ.N    ??SLIDER_CreateEx_0
    323              SLIDER_Obj* pObj = SLIDER_H2P(hObj);
   \   00000024   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000028   0x4605             MOV      R5,R0
    324              U16 InitState;
    325              /* Handle SpecialFlags */
    326              InitState = WIDGET_STATE_FOCUSSABLE;
   \   0000002A   0x2210             MOVS     R2,#+16
    327              if (ExFlags & SLIDER_CF_VERTICAL) {
   \   0000002C   0x980A             LDR      R0,[SP, #+40]
   \   0000002E   0x0700             LSLS     R0,R0,#+28
   \   00000030   0xD500             BPL.N    ??SLIDER_CreateEx_1
    328                InitState |= WIDGET_CF_VERTICAL;
   \   00000032   0x2218             MOVS     R2,#+24
    329              }
    330              /* init widget specific variables */
    331              WIDGET__Init(&pObj->Widget, Id, InitState);
   \                     ??SLIDER_CreateEx_1: (+1)
   \   00000034   0x990B             LDR      R1,[SP, #+44]
   \   00000036   0x4628             MOV      R0,R5
   \   00000038   0x.... 0x....      BL       WIDGET__Init
    332              /* init member variables */
    333              SLIDER_INIT_ID(pObj);
    334              pObj->aBkColor[0] = _DefaultBkColor;
   \   0000003C   0x....             LDR.N    R0,??DataTable1_1
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x62A8             STR      R0,[R5, #+40]
    335              pObj->aBkColor[1] = SLIDER_BKCOLOR1_DEFAULT;
   \   00000042   0xF105 0x0028      ADD      R0,R5,#+40
   \   00000046   0xF06F 0x417F      MVN      R1,#-16777216
   \   0000004A   0x6041             STR      R1,[R0, #+4]
    336              pObj->aColor[0]   = SLIDER_COLOR0_DEFAULT;
   \   0000004C   0x....             LDR.N    R1,??DataTable1_2  ;; 0xc0c0c0
   \   0000004E   0x6081             STR      R1,[R0, #+8]
    337              pObj->aColor[1]   = SLIDER_COLOR1_DEFAULT;
   \   00000050   0x2100             MOVS     R1,#+0
   \   00000052   0x60C1             STR      R1,[R0, #+12]
    338              pObj->Width       = 8;
   \   00000054   0x2108             MOVS     R1,#+8
   \   00000056   0x8481             STRH     R1,[R0, #+36]
    339              pObj->Max         = 100;
   \   00000058   0x2164             MOVS     R1,#+100
   \   0000005A   0x6141             STR      R1,[R0, #+20]
    340              pObj->Min         = 0;
   \   0000005C   0x2100             MOVS     R1,#+0
   \   0000005E   0x6101             STR      R1,[R0, #+16]
    341              pObj->NumTicks    = -1;
   \   00000060   0xF04F 0x31FF      MOV      R1,#-1
   \   00000064   0x6201             STR      R1,[R0, #+32]
    342            } else {
    343              GUI_DEBUG_ERROROUT_IF(hObj==0, "SLIDER_Create failed")
    344            }
    345            WM_UNLOCK();
    346            return hObj;
   \                     ??SLIDER_CreateEx_0: (+1)
   \   00000066   0x4620             MOV      R0,R4
   \   00000068   0xB005             ADD      SP,SP,#+20
   \   0000006A   0xBD30             POP      {R4,R5,PC}       ;; return
    347          }
    348          
    349          /*********************************************************************
    350          *
    351          *       Exported routines:  Various methods
    352          *
    353          **********************************************************************
    354          */
    355          /*********************************************************************
    356          *
    357          *       SLIDER_Dec
    358          */

   \                                 In section .text, align 2, keep-with-next
    359          void SLIDER_Dec(SLIDER_Handle hObj) {
   \                     SLIDER_Dec: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    360            SLIDER_Obj* pObj;
    361            if (hObj) {
   \   00000004   0xD010             BEQ.N    ??SLIDER_Dec_0
    362              WM_LOCK();
    363              pObj = SLIDER_H2P(hObj);
   \   00000006   0x.... 0x....      BL       GUI_ALLOC_h2p
    364              if (pObj->v > pObj->Min) {
   \   0000000A   0x6C01             LDR      R1,[R0, #+64]
   \   0000000C   0x6B82             LDR      R2,[R0, #+56]
   \   0000000E   0x428A             CMP      R2,R1
   \   00000010   0xDA0A             BGE.N    ??SLIDER_Dec_0
    365                pObj->v--;
   \   00000012   0x1E49             SUBS     R1,R1,#+1
   \   00000014   0x6401             STR      R1,[R0, #+64]
    366                WM_InvalidateWindow(hObj);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       WM_InvalidateWindow
    367                WM_NotifyParent(hObj, WM_NOTIFICATION_VALUE_CHANGED);
   \   0000001C   0x2105             MOVS     R1,#+5
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0xE8BD 0x4010      POP      {R4,LR}
   \   00000024   0x.... 0x....      B.W      WM_NotifyParent
    368              }
    369              WM_UNLOCK();
    370            }
    371          }
   \                     ??SLIDER_Dec_0: (+1)
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    372          
    373          /*********************************************************************
    374          *
    375          *       SLIDER_Inc
    376          */

   \                                 In section .text, align 2, keep-with-next
    377          void SLIDER_Inc(SLIDER_Handle hObj) {
   \                     SLIDER_Inc: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    378            SLIDER_Obj* pObj;
    379            if (hObj) {
   \   00000004   0xD010             BEQ.N    ??SLIDER_Inc_0
    380              WM_LOCK();
    381              pObj = SLIDER_H2P(hObj);
   \   00000006   0x.... 0x....      BL       GUI_ALLOC_h2p
    382              if (pObj->v < pObj->Max) {
   \   0000000A   0x6C01             LDR      R1,[R0, #+64]
   \   0000000C   0x6BC2             LDR      R2,[R0, #+60]
   \   0000000E   0x4291             CMP      R1,R2
   \   00000010   0xDA0A             BGE.N    ??SLIDER_Inc_0
    383                pObj->v++;
   \   00000012   0x1C49             ADDS     R1,R1,#+1
   \   00000014   0x6401             STR      R1,[R0, #+64]
    384                WM_InvalidateWindow(hObj);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       WM_InvalidateWindow
    385                WM_NotifyParent(hObj, WM_NOTIFICATION_VALUE_CHANGED);
   \   0000001C   0x2105             MOVS     R1,#+5
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0xE8BD 0x4010      POP      {R4,LR}
   \   00000024   0x.... 0x....      B.W      WM_NotifyParent
    386              }
    387              WM_UNLOCK();
    388            }
    389          }
   \                     ??SLIDER_Inc_0: (+1)
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    390          
    391          /*********************************************************************
    392          *
    393          *       SLIDER_SetWidth
    394          */

   \                                 In section .text, align 2, keep-with-next
    395          void SLIDER_SetWidth(SLIDER_Handle hObj, int Width) {
   \                     SLIDER_SetWidth: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    396            SLIDER_Obj* pObj;
    397            if (hObj) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD00C             BEQ.N    ??SLIDER_SetWidth_0
    398              WM_LOCK();
    399              pObj = SLIDER_H2P(hObj);
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
    400              if (pObj->Width != Width) {
   \   0000000E   0xF9B0 0x104C      LDRSH    R1,[R0, #+76]
   \   00000012   0x42A9             CMP      R1,R5
   \   00000014   0xD006             BEQ.N    ??SLIDER_SetWidth_0
    401                pObj->Width = Width;
   \   00000016   0xF8A0 0x504C      STRH     R5,[R0, #+76]
    402                WM_InvalidateWindow(hObj);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000020   0x.... 0x....      B.W      WM_InvalidateWindow
    403              }
    404              WM_UNLOCK();
    405            }
    406          }
   \                     ??SLIDER_SetWidth_0: (+1)
   \   00000024   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    407          
    408          /*********************************************************************
    409          *
    410          *       SLIDER_SetValue
    411          */

   \                                 In section .text, align 2, keep-with-next
    412          void SLIDER_SetValue(SLIDER_Handle hObj, int v) {
   \                     SLIDER_SetValue: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    413            SLIDER_Obj* pObj;
    414            if (hObj) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD017             BEQ.N    ??SLIDER_SetValue_0
    415              WM_LOCK();
    416              pObj = SLIDER_H2P(hObj);
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
    417              /* Put in min/max range */
    418              if (v < pObj->Min) {
   \   0000000E   0x6B81             LDR      R1,[R0, #+56]
   \   00000010   0x428D             CMP      R5,R1
   \   00000012   0xDA00             BGE.N    ??SLIDER_SetValue_1
   \   00000014   0x460D             MOV      R5,R1
   \                     ??SLIDER_SetValue_1: (+1)
   \   00000016   0x4629             MOV      R1,R5
    419                v = pObj->Min;
    420              }
    421              if (v > pObj->Max) {
   \   00000018   0x6BC5             LDR      R5,[R0, #+60]
   \   0000001A   0x428D             CMP      R5,R1
   \   0000001C   0xDD00             BLE.N    ??SLIDER_SetValue_2
   \   0000001E   0x460D             MOV      R5,R1
    422                v = pObj->Max;
    423              }
    424              if (pObj->v != v) {
   \                     ??SLIDER_SetValue_2: (+1)
   \   00000020   0x6C01             LDR      R1,[R0, #+64]
   \   00000022   0x42A9             CMP      R1,R5
   \   00000024   0xD009             BEQ.N    ??SLIDER_SetValue_0
    425                pObj->v = v;
   \   00000026   0x6405             STR      R5,[R0, #+64]
    426                WM_InvalidateWindow(hObj);
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       WM_InvalidateWindow
    427                WM_NotifyParent(hObj, WM_NOTIFICATION_VALUE_CHANGED);
   \   0000002E   0x2105             MOVS     R1,#+5
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000036   0x.... 0x....      B.W      WM_NotifyParent
    428              }
    429              WM_UNLOCK();
    430            }
    431          }
   \                     ??SLIDER_SetValue_0: (+1)
   \   0000003A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    432          
    433          /*********************************************************************
    434          *
    435          *       SLIDER_SetRange
    436          */

   \                                 In section .text, align 2, keep-with-next
    437          void SLIDER_SetRange(SLIDER_Handle hObj, int Min, int Max) {
   \                     SLIDER_SetRange: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    438            if (hObj) {
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD014             BEQ.N    ??SLIDER_SetRange_0
    439              SLIDER_Obj* pObj;
    440              WM_LOCK();
    441              pObj = SLIDER_H2P(hObj);
   \   0000000C   0x.... 0x....      BL       GUI_ALLOC_h2p
    442              if (Max < Min) {
   \   00000010   0x42AE             CMP      R6,R5
   \   00000012   0xDA00             BGE.N    ??SLIDER_SetRange_1
   \   00000014   0x462E             MOV      R6,R5
    443                Max = Min;
    444              }
    445              pObj->Min = Min;
   \                     ??SLIDER_SetRange_1: (+1)
   \   00000016   0x6385             STR      R5,[R0, #+56]
    446              pObj->Max = Max;
   \   00000018   0x63C6             STR      R6,[R0, #+60]
    447              if (pObj->v < Min) {
   \   0000001A   0x6C01             LDR      R1,[R0, #+64]
   \   0000001C   0x42A9             CMP      R1,R5
   \   0000001E   0xDA00             BGE.N    ??SLIDER_SetRange_2
   \   00000020   0x4629             MOV      R1,R5
   \                     ??SLIDER_SetRange_2: (+1)
   \   00000022   0x6401             STR      R1,[R0, #+64]
    448                pObj->v = Min;
    449              }
    450              if (pObj->v > Max) {
   \   00000024   0x428E             CMP      R6,R1
   \   00000026   0xDD00             BLE.N    ??SLIDER_SetRange_3
   \   00000028   0x460E             MOV      R6,R1
   \                     ??SLIDER_SetRange_3: (+1)
   \   0000002A   0x6406             STR      R6,[R0, #+64]
    451                pObj->v = Max;
    452              }
    453              WM_InvalidateWindow(hObj);
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000032   0x.... 0x....      B.W      WM_InvalidateWindow
    454              WM_UNLOCK();
    455            }
    456          }
   \                     ??SLIDER_SetRange_0: (+1)
   \   00000036   0xBD70             POP      {R4-R6,PC}       ;; return
    457          
    458          /*********************************************************************
    459          *
    460          *       SLIDER_SetNumTicks
    461          */

   \                                 In section .text, align 2, keep-with-next
    462          void SLIDER_SetNumTicks(SLIDER_Handle hObj, int NumTicks) {
   \                     SLIDER_SetNumTicks: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    463            if (hObj && (NumTicks >= 0)) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD009             BEQ.N    ??SLIDER_SetNumTicks_0
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD407             BMI.N    ??SLIDER_SetNumTicks_0
    464              SLIDER_Obj* pObj;
    465              WM_LOCK();
    466              pObj = SLIDER_H2P(hObj);
   \   0000000E   0x.... 0x....      BL       GUI_ALLOC_h2p
    467              pObj->NumTicks = NumTicks;
   \   00000012   0x6485             STR      R5,[R0, #+72]
    468              WM_InvalidateWindow(hObj);
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000001A   0x.... 0x....      B.W      WM_InvalidateWindow
    469              WM_UNLOCK();
    470            }
    471          }
   \                     ??SLIDER_SetNumTicks_0: (+1)
   \   0000001E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    472          
    473          /*********************************************************************
    474          *
    475          *       SLIDER_SetBkColor
    476          */

   \                                 In section .text, align 2, keep-with-next
    477          void SLIDER_SetBkColor(SLIDER_Handle hObj, GUI_COLOR Color) {
   \                     SLIDER_SetBkColor: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    478            if (hObj) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD010             BEQ.N    ??SLIDER_SetBkColor_0
    479              SLIDER_Obj * pObj;
    480              WM_LOCK();
    481              pObj = SLIDER_H2P(hObj);
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
    482              pObj->aBkColor[0] = Color;
   \   0000000E   0x6285             STR      R5,[R0, #+40]
    483              #if SLIDER_SUPPORT_TRANSPARENCY
    484                if (Color <= 0xFFFFFF) {
   \   00000010   0xF1B5 0x7F80      CMP      R5,#+16777216
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0xD202             BCS.N    ??SLIDER_SetBkColor_1
    485                  WM_ClrHasTrans(hObj);
   \   00000018   0x.... 0x....      BL       WM_ClrHasTrans
   \   0000001C   0xE001             B.N      ??SLIDER_SetBkColor_2
    486                } else {
    487                  WM_SetHasTrans(hObj);
   \                     ??SLIDER_SetBkColor_1: (+1)
   \   0000001E   0x.... 0x....      BL       WM_SetHasTrans
    488                }
    489              #endif
    490              WM_InvalidateWindow(hObj);
   \                     ??SLIDER_SetBkColor_2: (+1)
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000028   0x.... 0x....      B.W      WM_InvalidateWindow
    491              WM_UNLOCK();
    492            }
    493          }
   \                     ??SLIDER_SetBkColor_0: (+1)
   \   0000002C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    494          
    495          /*********************************************************************
    496          *
    497          *       SLIDER_SetDefaultBkColor
    498          */

   \                                 In section .text, align 2, keep-with-next
    499          void SLIDER_SetDefaultBkColor(GUI_COLOR Color) {
    500            _DefaultBkColor = Color;
   \                     SLIDER_SetDefaultBkColor: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable1_1
   \   00000002   0x6008             STR      R0,[R1, #+0]
    501          }
   \   00000004   0x4770             BX       LR               ;; return
    502          
    503          /*********************************************************************
    504          *
    505          *       Query state
    506          *
    507          **********************************************************************
    508          */
    509          /*********************************************************************
    510          *
    511          *       SLIDER_GetValue
    512          */

   \                                 In section .text, align 2, keep-with-next
    513          int SLIDER_GetValue(SLIDER_Handle hObj) {
   \                     SLIDER_GetValue: (+1)
   \   00000000   0x4601             MOV      R1,R0
    514            int r = 0;
   \   00000002   0x2000             MOVS     R0,#+0
    515            SLIDER_Obj* pObj;
    516            if (hObj) {
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD100             BNE.N    ??SLIDER_GetValue_0
   \   00000008   0x4770             BX       LR
    517              WM_LOCK();
    518              pObj = SLIDER_H2P(hObj);
   \                     ??SLIDER_GetValue_0: (+1)
   \   0000000A   0xB580             PUSH     {R7,LR}
   \   0000000C   0x4608             MOV      R0,R1
   \   0000000E   0x.... 0x....      BL       GUI_ALLOC_h2p
    519              r = pObj->v;
   \   00000012   0x6C00             LDR      R0,[R0, #+64]
    520              WM_UNLOCK();
    521            }
    522            return r;
   \   00000014   0xBD02             POP      {R1,PC}          ;; return
    523          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     _SLIDER_Callback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x........         DC32     _DefaultBkColor

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x00C0C0C0         DC32     0xc0c0c0
    524          
    525          
    526          #else /* avoid empty object files */
    527          
    528          void SLIDER_C(void);
    529          void SLIDER_C(void){}
    530          
    531          #endif  /* #if GUI_WINSUPPORT */
    532          
    533          
    534          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   SLIDER_CreateEx
        32   -> GUI_ALLOC_h2p
        32   -> WIDGET__Init
        32   -> WM_CreateWindowAsChild
       8   SLIDER_Dec
         8   -> GUI_ALLOC_h2p
         8   -> WM_InvalidateWindow
         0   -> WM_NotifyParent
       8   SLIDER_GetValue
         8   -> GUI_ALLOC_h2p
       8   SLIDER_Inc
         8   -> GUI_ALLOC_h2p
         8   -> WM_InvalidateWindow
         0   -> WM_NotifyParent
      16   SLIDER_SetBkColor
        16   -> GUI_ALLOC_h2p
        16   -> WM_ClrHasTrans
         0   -> WM_InvalidateWindow
        16   -> WM_SetHasTrans
       0   SLIDER_SetDefaultBkColor
      16   SLIDER_SetNumTicks
        16   -> GUI_ALLOC_h2p
         0   -> WM_InvalidateWindow
      16   SLIDER_SetRange
        16   -> GUI_ALLOC_h2p
         0   -> WM_InvalidateWindow
      16   SLIDER_SetValue
        16   -> GUI_ALLOC_h2p
        16   -> WM_InvalidateWindow
         0   -> WM_NotifyParent
      16   SLIDER_SetWidth
        16   -> GUI_ALLOC_h2p
         0   -> WM_InvalidateWindow
       0   _OnKey
         0   -> SLIDER_Dec
         0   -> SLIDER_Inc
      24   _OnTouch
        24   -> SLIDER_SetValue
        24   -> WIDGET__GetWindowSizeX
        24   -> WM_IsFocussable
        24   -> WM_SetCapture
        24   -> WM_SetFocus
         0   -> _SliderPressed
         0   -> _SliderReleased
      64   _Paint
        64   -> GUI_Clear
        64   -> GUI__ReduceRect
        64   -> LCD_SetBkColor
        64   -> LCD_SetColor
        64   -> WIDGET__DrawFocusRect
        64   -> WIDGET__DrawVLine
        64   -> WIDGET__EFFECT_DrawDownRect
        64   -> WIDGET__EFFECT_DrawUpRect
        64   -> WIDGET__FillRectEx
        64   -> WIDGET__GetClientRect
        64   -> WM_GetHasTrans
      16   _SLIDER_Callback
        16   -> GUI_ALLOC_h2p
        16   -> WIDGET_HandleActive
         0   -> WM_DefaultProc
        16   -> _OnKey
        16   -> _OnTouch
         0   -> _Paint
      16   _SliderPressed
        16   -> WIDGET_OrState
         0   -> WM_NotifyParent
      16   _SliderReleased
        16   -> WIDGET_AndState
         0   -> WM_NotifyParent


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
     108  SLIDER_CreateEx
      42  SLIDER_Dec
      22  SLIDER_GetValue
      42  SLIDER_Inc
      46  SLIDER_SetBkColor
       6  SLIDER_SetDefaultBkColor
      32  SLIDER_SetNumTicks
      56  SLIDER_SetRange
      60  SLIDER_SetValue
      38  SLIDER_SetWidth
       4  _DefaultBkColor
      24  _OnKey
     172  _OnTouch
     320  _Paint
      84  _SLIDER_Callback
      34  _SliderPressed
      34  _SliderReleased

 
     4 bytes in section .data
 1 132 bytes in section .text
 
 1 132 bytes of CODE memory
     4 bytes of DATA memory

Errors: none
Warnings: none
