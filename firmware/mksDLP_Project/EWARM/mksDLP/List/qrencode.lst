###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        16/Jul/2019  17:00:12
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\User\ui\QRENCODE\qrencode.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\User\ui\QRENCODE\qrencode.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\qrencode.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\qrencode.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\User\ui\QRENCODE\qrencode.c
      1          /*
      2           * qrencode - QR Code encoder
      3           *
      4           * Copyright (C) 2006-2012 Kentaro Fukuchi <kentaro@fukuchi.org>
      5           *
      6           * This library is free software; you can redistribute it and/or
      7           * modify it under the terms of the GNU Lesser General Public
      8           * License as published by the Free Software Foundation; either
      9           * version 2.1 of the License, or any later version.
     10           *
     11           * This library is distributed in the hope that it will be useful,
     12           * but WITHOUT ANY WARRANTY; without even the implied warranty of
     13           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
     14           * Lesser General Public License for more details.
     15           *
     16           * You should have received a copy of the GNU Lesser General Public
     17           * License along with this library; if not, write to the Free Software
     18           * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
     19           */
     20          
     21          #if HAVE_CONFIG_H
     22          # include "config.h"
     23          #endif
     24          #include <stdio.h>
     25          #include <stdlib.h>
     26          #include <string.h>
     27          #include <errno.h>
     28          #include <integer.h>
     29          
     30          #include "qrencode.h"
     31          #include "qrspec.h"
     32          #include "mqrspec.h"
     33          #include "bitstream.h"
     34          #include "qrinput.h"
     35          #include "rscode.h"
     36          #include "split.h"
     37          #include "mask.h"
     38          #include "mmask.h"
     39          
     40          /******************************************************************************
     41           * Raw code
     42           *****************************************************************************/
     43          
     44          typedef struct {
     45          	int dataLength;
     46          	unsigned char *data;
     47          	int eccLength;
     48          	unsigned char *ecc;
     49          } RSblock;
     50          
     51          typedef struct {
     52          	int version;
     53          	int dataLength;
     54          	int eccLength;
     55          	unsigned char *datacode;
     56          	unsigned char *ecccode;
     57          	int b1;
     58          	int blocks;
     59          	RSblock *rsblock;
     60          	int count;
     61          } QRRawCode;
     62          

   \                                 In section .text, align 2, keep-with-next
     63          static void RSblock_initBlock(RSblock *block, int dl, unsigned char *data, int el, unsigned char *ecc, RS *rs)
     64          {
   \                     RSblock_initBlock: (+1)
   \   00000000   0xB418             PUSH     {R3,R4}
   \   00000002   0x4614             MOV      R4,R2
     65          	block->dataLength = dl;
   \   00000004   0x6001             STR      R1,[R0, #+0]
     66          	block->data = data;
   \   00000006   0x6044             STR      R4,[R0, #+4]
     67          	block->eccLength = el;
   \   00000008   0x6083             STR      R3,[R0, #+8]
   \   0000000A   0x9A02             LDR      R2,[SP, #+8]
     68          	block->ecc = ecc;
   \   0000000C   0x60C2             STR      R2,[R0, #+12]
     69          
     70          	encode_rs_char(rs, data, ecc);
   \   0000000E   0x4621             MOV      R1,R4
   \   00000010   0x9803             LDR      R0,[SP, #+12]
   \   00000012   0xBC18             POP      {R3,R4}
   \   00000014   0x.... 0x....      B.W      encode_rs_char
     71          }
     72          

   \                                 In section .text, align 2, keep-with-next
     73          static int RSblock_init(RSblock *blocks, int spec[5], unsigned char *data, unsigned char *ecc)
     74          {
   \                     RSblock_init: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x4682             MOV      R10,R0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4614             MOV      R4,R2
   \   0000000C   0x461E             MOV      R6,R3
     75          	int i;
     76          	RSblock *block;
     77          	unsigned char *dp, *ep;
     78          	RS *rs;
     79          	int el, dl;
     80          
     81          	dl = QRspec_rsDataCodes1(spec);
   \   0000000E   0x686F             LDR      R7,[R5, #+4]
     82          	el = QRspec_rsEccCodes1(spec);
   \   00000010   0xF8D5 0x8008      LDR      R8,[R5, #+8]
   \   00000014   0xF1C7 0x00FF      RSB      R0,R7,#+255
   \   00000018   0xEBA0 0x0008      SUB      R0,R0,R8
   \   0000001C   0x9001             STR      R0,[SP, #+4]
   \   0000001E   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   00000022   0x2301             MOVS     R3,#+1
   \   00000024   0x2200             MOVS     R2,#+0
   \   00000026   0xF240 0x111D      MOVW     R1,#+285
   \   0000002A   0x2008             MOVS     R0,#+8
     83          	rs = init_rs(8, 0x11d, 0, 1, el, 255 - dl - el);
   \   0000002C   0x.... 0x....      BL       init_rs
   \   00000030   0x4681             MOV      R9,R0
     84          	if(rs == NULL) return -1;
   \   00000032   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000036   0xD02C             BEQ.N    ??RSblock_init_0
     85          
     86          	block = blocks;
     87          	dp = data;
     88          	ep = ecc;
     89          	for(i=0; i<QRspec_rsBlockNum1(spec); i++) {
   \   00000038   0xF04F 0x0B00      MOV      R11,#+0
   \   0000003C   0xE00E             B.N      ??RSblock_init_1
     90          		RSblock_initBlock(block, dl, dp, el, ep, rs);
   \                     ??RSblock_init_2: (+1)
   \   0000003E   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \   00000042   0x9600             STR      R6,[SP, #+0]
   \   00000044   0x4643             MOV      R3,R8
   \   00000046   0x4622             MOV      R2,R4
   \   00000048   0x4639             MOV      R1,R7
   \   0000004A   0x4650             MOV      R0,R10
   \   0000004C   0x.... 0x....      BL       RSblock_initBlock
     91          		dp += dl;
   \   00000050   0x193C             ADDS     R4,R7,R4
     92          		ep += el;
   \   00000052   0x4446             ADD      R6,R8,R6
     93          		block++;
   \   00000054   0xF10A 0x0A10      ADD      R10,R10,#+16
     94          	}
   \   00000058   0xF10B 0x0B01      ADD      R11,R11,#+1
   \                     ??RSblock_init_1: (+1)
   \   0000005C   0x6828             LDR      R0,[R5, #+0]
   \   0000005E   0x4583             CMP      R11,R0
   \   00000060   0xDBED             BLT.N    ??RSblock_init_2
     95          
     96          	if(QRspec_rsBlockNum2(spec) == 0) return 0;
   \   00000062   0x68E8             LDR      R0,[R5, #+12]
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD02C             BEQ.N    ??RSblock_init_3
     97          
     98          	dl = QRspec_rsDataCodes2(spec);
   \   00000068   0x692F             LDR      R7,[R5, #+16]
     99          	el = QRspec_rsEccCodes2(spec);
   \   0000006A   0xF8D5 0x8008      LDR      R8,[R5, #+8]
    100          	rs = init_rs(8, 0x11d, 0, 1, el, 255 - dl - el);
   \   0000006E   0xF1C7 0x00FF      RSB      R0,R7,#+255
   \   00000072   0xEBA0 0x0008      SUB      R0,R0,R8
   \   00000076   0x9001             STR      R0,[SP, #+4]
   \   00000078   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   0000007C   0x2301             MOVS     R3,#+1
   \   0000007E   0x2200             MOVS     R2,#+0
   \   00000080   0xF240 0x111D      MOVW     R1,#+285
   \   00000084   0x2008             MOVS     R0,#+8
   \   00000086   0x.... 0x....      BL       init_rs
   \   0000008A   0x4681             MOV      R9,R0
    101          	if(rs == NULL) return -1;
   \   0000008C   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000090   0xD102             BNE.N    ??RSblock_init_4
   \                     ??RSblock_init_0: (+1)
   \   00000092   0xF04F 0x30FF      MOV      R0,#-1
   \   00000096   0xE015             B.N      ??RSblock_init_5
    102          	for(i=0; i<QRspec_rsBlockNum2(spec); i++) {
   \                     ??RSblock_init_4: (+1)
   \   00000098   0xF04F 0x0B00      MOV      R11,#+0
   \   0000009C   0xE00E             B.N      ??RSblock_init_6
    103          		RSblock_initBlock(block, dl, dp, el, ep, rs);
   \                     ??RSblock_init_7: (+1)
   \   0000009E   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \   000000A2   0x9600             STR      R6,[SP, #+0]
   \   000000A4   0x4643             MOV      R3,R8
   \   000000A6   0x4622             MOV      R2,R4
   \   000000A8   0x4639             MOV      R1,R7
   \   000000AA   0x4650             MOV      R0,R10
   \   000000AC   0x.... 0x....      BL       RSblock_initBlock
    104          		dp += dl;
   \   000000B0   0x193C             ADDS     R4,R7,R4
    105          		ep += el;
   \   000000B2   0x4446             ADD      R6,R8,R6
    106          		block++;
   \   000000B4   0xF10A 0x0A10      ADD      R10,R10,#+16
    107          	}
   \   000000B8   0xF10B 0x0B01      ADD      R11,R11,#+1
   \                     ??RSblock_init_6: (+1)
   \   000000BC   0x68E8             LDR      R0,[R5, #+12]
   \   000000BE   0x4583             CMP      R11,R0
   \   000000C0   0xDBED             BLT.N    ??RSblock_init_7
    108          
    109          	return 0;
   \                     ??RSblock_init_3: (+1)
   \   000000C2   0x2000             MOVS     R0,#+0
   \                     ??RSblock_init_5: (+1)
   \   000000C4   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    110          }
    111          
    112          static void QRraw_free(QRRawCode *raw);

   \                                 In section .text, align 2, keep-with-next
    113          static QRRawCode *QRraw_new(QRinput *input)
    114          {
   \                     QRraw_new: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x4605             MOV      R5,R0
    115          	QRRawCode *raw;
    116          	int spec[5], ret;
    117          
    118          	raw = (QRRawCode *)malloc(sizeof(QRRawCode));
   \   00000006   0x2024             MOVS     R0,#+36
   \   00000008   0x.... 0x....      BL       malloc
   \   0000000C   0x0004             MOVS     R4,R0
    119          	if(raw == NULL) return NULL;
   \   0000000E   0xD101             BNE.N    ??QRraw_new_0
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE049             B.N      ??QRraw_new_1
    120          
    121          	raw->datacode = QRinput_getByteStream(input);
   \                     ??QRraw_new_0: (+1)
   \   00000014   0x4628             MOV      R0,R5
   \   00000016   0x.... 0x....      BL       QRinput_getByteStream
   \   0000001A   0x60E0             STR      R0,[R4, #+12]
    122          	if(raw->datacode == NULL) {
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD104             BNE.N    ??QRraw_new_2
    123          		free(raw);
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       free
    124          		return NULL;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE03E             B.N      ??QRraw_new_1
    125          	}
    126          
    127          	QRspec_getEccSpec(input->version, input->level, spec);
   \                     ??QRraw_new_2: (+1)
   \   0000002A   0xAA00             ADD      R2,SP,#+0
   \   0000002C   0xF995 0x1004      LDRSB    R1,[R5, #+4]
   \   00000030   0x6828             LDR      R0,[R5, #+0]
   \   00000032   0x.... 0x....      BL       QRspec_getEccSpec
    128          
    129          	raw->version = input->version;
   \   00000036   0x6828             LDR      R0,[R5, #+0]
   \   00000038   0x6020             STR      R0,[R4, #+0]
    130          	raw->b1 = QRspec_rsBlockNum1(spec);
   \   0000003A   0x9800             LDR      R0,[SP, #+0]
   \   0000003C   0x6160             STR      R0,[R4, #+20]
    131          	raw->dataLength = QRspec_rsDataLength(spec);
   \   0000003E   0xAD00             ADD      R5,SP,#+0
   \   00000040   0x9800             LDR      R0,[SP, #+0]
   \   00000042   0x6869             LDR      R1,[R5, #+4]
   \   00000044   0x68EA             LDR      R2,[R5, #+12]
   \   00000046   0x692B             LDR      R3,[R5, #+16]
   \   00000048   0x435A             MULS     R2,R3,R2
   \   0000004A   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   0000004E   0x6060             STR      R0,[R4, #+4]
    132          	raw->eccLength = QRspec_rsEccLength(spec);
   \   00000050   0x9800             LDR      R0,[SP, #+0]
   \   00000052   0x68E9             LDR      R1,[R5, #+12]
   \   00000054   0x1808             ADDS     R0,R1,R0
   \   00000056   0x68A9             LDR      R1,[R5, #+8]
   \   00000058   0x4348             MULS     R0,R1,R0
   \   0000005A   0x60A0             STR      R0,[R4, #+8]
    133          	raw->ecccode = (unsigned char *)malloc(raw->eccLength);
   \   0000005C   0x.... 0x....      BL       malloc
   \   00000060   0x6120             STR      R0,[R4, #+16]
    134          	if(raw->ecccode == NULL) {
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD107             BNE.N    ??QRraw_new_3
    135          		free(raw->datacode);
   \   00000066   0x68E0             LDR      R0,[R4, #+12]
   \   00000068   0x.... 0x....      BL       free
    136          		free(raw);
   \   0000006C   0x4620             MOV      R0,R4
   \   0000006E   0x.... 0x....      BL       free
    137          		return NULL;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0xE018             B.N      ??QRraw_new_1
    138          	}
    139          
    140          	raw->blocks = QRspec_rsBlockNum(spec);
   \                     ??QRraw_new_3: (+1)
   \   00000076   0x9800             LDR      R0,[SP, #+0]
   \   00000078   0x68E9             LDR      R1,[R5, #+12]
   \   0000007A   0x1808             ADDS     R0,R1,R0
   \   0000007C   0x61A0             STR      R0,[R4, #+24]
    141          	raw->rsblock = (RSblock *)calloc(raw->blocks, sizeof(RSblock));
   \   0000007E   0x2110             MOVS     R1,#+16
   \   00000080   0x.... 0x....      BL       calloc
   \   00000084   0x61E0             STR      R0,[R4, #+28]
    142          	if(raw->rsblock == NULL) {
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD006             BEQ.N    ??QRraw_new_4
    143          		QRraw_free(raw);
    144          		return NULL;
    145          	}
    146          	ret = RSblock_init(raw->rsblock, spec, raw->datacode, raw->ecccode);
    147          	if(ret < 0) {
   \   0000008A   0x6923             LDR      R3,[R4, #+16]
   \   0000008C   0x68E2             LDR      R2,[R4, #+12]
   \   0000008E   0xA900             ADD      R1,SP,#+0
   \   00000090   0x.... 0x....      BL       RSblock_init
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD504             BPL.N    ??QRraw_new_5
    148          		QRraw_free(raw);
   \                     ??QRraw_new_4: (+1)
   \   00000098   0x4620             MOV      R0,R4
   \   0000009A   0x.... 0x....      BL       QRraw_free
    149          		return NULL;
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0xE002             B.N      ??QRraw_new_1
    150          	}
    151          
    152          	raw->count = 0;
   \                     ??QRraw_new_5: (+1)
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0x6220             STR      R0,[R4, #+32]
    153          
    154          	return raw;
   \   000000A6   0x4620             MOV      R0,R4
   \                     ??QRraw_new_1: (+1)
   \   000000A8   0xB005             ADD      SP,SP,#+20
   \   000000AA   0xBD30             POP      {R4,R5,PC}       ;; return
    155          }
    156          
    157          /**
    158           * Return a code (byte).
    159           * This function can be called iteratively.
    160           * @param raw raw code.
    161           * @return code
    162           */

   \                                 In section .text, align 2, keep-with-next
    163          static unsigned char QRraw_getCode(QRRawCode *raw)
    164          {
   \                     QRraw_getCode: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    165          	int col, row;
    166          	unsigned char ret;
    167          
    168          	if(raw->count < raw->dataLength) {
   \   00000002   0x6841             LDR      R1,[R0, #+4]
   \   00000004   0x6A02             LDR      R2,[R0, #+32]
   \   00000006   0x428A             CMP      R2,R1
   \   00000008   0xDA13             BGE.N    ??QRraw_getCode_0
    169          		row = raw->count % raw->blocks;
   \   0000000A   0x6981             LDR      R1,[R0, #+24]
   \   0000000C   0xFB92 0xF3F1      SDIV     R3,R2,R1
   \   00000010   0xFB01 0x2113      MLS      R1,R1,R3,R2
    170          		col = raw->count / raw->blocks;
    171          		if(col >= raw->rsblock[0].dataLength) {
   \   00000014   0x69C4             LDR      R4,[R0, #+28]
   \   00000016   0x6825             LDR      R5,[R4, #+0]
   \   00000018   0x42AB             CMP      R3,R5
   \   0000001A   0xDB01             BLT.N    ??QRraw_getCode_1
    172          			row += raw->b1;
   \   0000001C   0x6945             LDR      R5,[R0, #+20]
   \   0000001E   0x1869             ADDS     R1,R5,R1
    173          		}
    174          		ret = raw->rsblock[row].data[col];
   \                     ??QRraw_getCode_1: (+1)
   \   00000020   0xEB04 0x1101      ADD      R1,R4,R1, LSL #+4
   \   00000024   0x6849             LDR      R1,[R1, #+4]
   \   00000026   0x5C59             LDRB     R1,[R3, R1]
    175          	} else if(raw->count < raw->dataLength + raw->eccLength) {
    176          		row = (raw->count - raw->dataLength) % raw->blocks;
    177          		col = (raw->count - raw->dataLength) / raw->blocks;
    178          		ret = raw->rsblock[row].ecc[col];
    179          	} else {
    180          		return 0;
    181          	}
    182          	raw->count++;
   \                     ??QRraw_getCode_2: (+1)
   \   00000028   0x1C52             ADDS     R2,R2,#+1
   \   0000002A   0x6202             STR      R2,[R0, #+32]
    183          	return ret;
   \   0000002C   0x4608             MOV      R0,R1
   \                     ??QRraw_getCode_3: (+1)
   \   0000002E   0xBC30             POP      {R4,R5}
   \   00000030   0x4770             BX       LR               ;; return
   \                     ??QRraw_getCode_0: (+1)
   \   00000032   0x6883             LDR      R3,[R0, #+8]
   \   00000034   0x185B             ADDS     R3,R3,R1
   \   00000036   0x429A             CMP      R2,R3
   \   00000038   0xDA0B             BGE.N    ??QRraw_getCode_4
   \   0000003A   0x1A53             SUBS     R3,R2,R1
   \   0000003C   0x6981             LDR      R1,[R0, #+24]
   \   0000003E   0xFB93 0xF4F1      SDIV     R4,R3,R1
   \   00000042   0xFB01 0x3114      MLS      R1,R1,R4,R3
   \   00000046   0x69C3             LDR      R3,[R0, #+28]
   \   00000048   0xEB03 0x1101      ADD      R1,R3,R1, LSL #+4
   \   0000004C   0x68C9             LDR      R1,[R1, #+12]
   \   0000004E   0x5C61             LDRB     R1,[R4, R1]
   \   00000050   0xE7EA             B.N      ??QRraw_getCode_2
   \                     ??QRraw_getCode_4: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xE7EB             B.N      ??QRraw_getCode_3
    184          }
    185          

   \                                 In section .text, align 2, keep-with-next
    186          static void QRraw_free(QRRawCode *raw)
    187          {
   \                     QRraw_free: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    188          	if(raw != NULL) {
   \   00000004   0xD00D             BEQ.N    ??QRraw_free_0
    189          		free(raw->datacode);
   \   00000006   0x68E0             LDR      R0,[R4, #+12]
   \   00000008   0x.... 0x....      BL       free
    190          		free(raw->ecccode);
   \   0000000C   0x6920             LDR      R0,[R4, #+16]
   \   0000000E   0x.... 0x....      BL       free
    191          		free(raw->rsblock);
   \   00000012   0x69E0             LDR      R0,[R4, #+28]
   \   00000014   0x.... 0x....      BL       free
    192          		free(raw);
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001E   0x.... 0x....      B.W      free
    193          	}
    194          }
   \                     ??QRraw_free_0: (+1)
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    195          
    196          /******************************************************************************
    197           * Raw code for Micro QR Code
    198           *****************************************************************************/
    199          
    200          typedef struct {
    201          	int version;
    202          	int dataLength;
    203          	int eccLength;
    204          	unsigned char *datacode;
    205          	unsigned char *ecccode;
    206          	RSblock *rsblock;
    207          	int oddbits;
    208          	int count;
    209          } MQRRawCode;
    210          
    211          static void MQRraw_free(MQRRawCode *raw);

   \                                 In section .text, align 2, keep-with-next
    212          static MQRRawCode *MQRraw_new(QRinput *input)
    213          {
   \                     MQRraw_new: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x4605             MOV      R5,R0
    214          	MQRRawCode *raw;
    215          	RS *rs;
    216          
    217          	raw = (MQRRawCode *)malloc(sizeof(MQRRawCode));
   \   00000004   0x2020             MOVS     R0,#+32
   \   00000006   0x.... 0x....      BL       malloc
   \   0000000A   0x0004             MOVS     R4,R0
    218          	if(raw == NULL) return NULL;
   \   0000000C   0xD101             BNE.N    ??MQRraw_new_0
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xBD76             POP      {R1,R2,R4-R6,PC}
    219          
    220          	raw->version = input->version;
   \                     ??MQRraw_new_0: (+1)
   \   00000012   0x6828             LDR      R0,[R5, #+0]
   \   00000014   0x6020             STR      R0,[R4, #+0]
    221          	raw->dataLength = MQRspec_getDataLength(input->version, input->level);
   \   00000016   0xF995 0x1004      LDRSB    R1,[R5, #+4]
   \   0000001A   0x6828             LDR      R0,[R5, #+0]
   \   0000001C   0x.... 0x....      BL       MQRspec_getDataLength
   \   00000020   0x6060             STR      R0,[R4, #+4]
    222          	raw->eccLength = MQRspec_getECCLength(input->version, input->level);
   \   00000022   0xF995 0x1004      LDRSB    R1,[R5, #+4]
   \   00000026   0x6828             LDR      R0,[R5, #+0]
   \   00000028   0x.... 0x....      BL       MQRspec_getECCLength
   \   0000002C   0x60A0             STR      R0,[R4, #+8]
    223          	raw->oddbits = raw->dataLength * 8 - MQRspec_getDataLengthBit(input->version, input->level);
   \   0000002E   0x6866             LDR      R6,[R4, #+4]
   \   00000030   0xF995 0x1004      LDRSB    R1,[R5, #+4]
   \   00000034   0x6828             LDR      R0,[R5, #+0]
   \   00000036   0x.... 0x....      BL       MQRspec_getDataLengthBit
   \   0000003A   0xEBC0 0x00C6      RSB      R0,R0,R6, LSL #+3
   \   0000003E   0x61A0             STR      R0,[R4, #+24]
    224          	raw->datacode = QRinput_getByteStream(input);
   \   00000040   0x4628             MOV      R0,R5
   \   00000042   0x.... 0x....      BL       QRinput_getByteStream
   \   00000046   0x60E0             STR      R0,[R4, #+12]
    225          	if(raw->datacode == NULL) {
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD104             BNE.N    ??MQRraw_new_1
    226          		free(raw);
   \   0000004C   0x4620             MOV      R0,R4
   \   0000004E   0x.... 0x....      BL       free
    227          		return NULL;
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xBD76             POP      {R1,R2,R4-R6,PC}
    228          	}
    229          	raw->ecccode = (unsigned char *)malloc(raw->eccLength);
   \                     ??MQRraw_new_1: (+1)
   \   00000056   0x68A0             LDR      R0,[R4, #+8]
   \   00000058   0x.... 0x....      BL       malloc
   \   0000005C   0x6120             STR      R0,[R4, #+16]
    230          	if(raw->ecccode == NULL) {
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD107             BNE.N    ??MQRraw_new_2
    231          		free(raw->datacode);
   \   00000062   0x68E0             LDR      R0,[R4, #+12]
   \   00000064   0x.... 0x....      BL       free
    232          		free(raw);
   \   00000068   0x4620             MOV      R0,R4
   \   0000006A   0x.... 0x....      BL       free
    233          		return NULL;
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0xBD76             POP      {R1,R2,R4-R6,PC}
    234          	}
    235          
    236          	raw->rsblock = (RSblock *)calloc(1, sizeof(RSblock));
   \                     ??MQRraw_new_2: (+1)
   \   00000072   0x2110             MOVS     R1,#+16
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0x.... 0x....      BL       calloc
   \   0000007A   0x6160             STR      R0,[R4, #+20]
    237          	if(raw->rsblock == NULL) {
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD00F             BEQ.N    ??MQRraw_new_3
    238          		MQRraw_free(raw);
    239          		return NULL;
    240          	}
    241          
    242          	rs = init_rs(8, 0x11d, 0, 1, raw->eccLength, 255 - raw->dataLength - raw->eccLength);
   \   00000080   0x68A0             LDR      R0,[R4, #+8]
   \   00000082   0x6861             LDR      R1,[R4, #+4]
   \   00000084   0xF1C1 0x01FF      RSB      R1,R1,#+255
   \   00000088   0x1A09             SUBS     R1,R1,R0
   \   0000008A   0x9101             STR      R1,[SP, #+4]
   \   0000008C   0x9000             STR      R0,[SP, #+0]
   \   0000008E   0x2301             MOVS     R3,#+1
   \   00000090   0x2200             MOVS     R2,#+0
   \   00000092   0xF240 0x111D      MOVW     R1,#+285
   \   00000096   0x2008             MOVS     R0,#+8
   \   00000098   0x.... 0x....      BL       init_rs
    243          	if(rs == NULL) {
   \   0000009C   0x2800             CMP      R0,#+0
   \   0000009E   0xD104             BNE.N    ??MQRraw_new_4
    244          		MQRraw_free(raw);
   \                     ??MQRraw_new_3: (+1)
   \   000000A0   0x4620             MOV      R0,R4
   \   000000A2   0x.... 0x....      BL       MQRraw_free
    245          		return NULL;
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0xBD76             POP      {R1,R2,R4-R6,PC}
    246          	}
    247          
    248          	RSblock_initBlock(raw->rsblock, raw->dataLength, raw->datacode, raw->eccLength, raw->ecccode, rs);
   \                     ??MQRraw_new_4: (+1)
   \   000000AA   0x9001             STR      R0,[SP, #+4]
   \   000000AC   0x6920             LDR      R0,[R4, #+16]
   \   000000AE   0x9000             STR      R0,[SP, #+0]
   \   000000B0   0x68A3             LDR      R3,[R4, #+8]
   \   000000B2   0x68E2             LDR      R2,[R4, #+12]
   \   000000B4   0x6861             LDR      R1,[R4, #+4]
   \   000000B6   0x6960             LDR      R0,[R4, #+20]
   \   000000B8   0x.... 0x....      BL       RSblock_initBlock
    249          
    250          	raw->count = 0;
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x61E0             STR      R0,[R4, #+28]
    251          
    252          	return raw;
   \   000000C0   0x4620             MOV      R0,R4
   \   000000C2   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    253          }
    254          
    255          /**
    256           * Return a code (byte).
    257           * This function can be called iteratively.
    258           * @param raw raw code.
    259           * @return code
    260           */

   \                                 In section .text, align 2, keep-with-next
    261          static unsigned char MQRraw_getCode(MQRRawCode *raw)
    262          {
    263          	unsigned char ret;
    264          
    265          	if(raw->count < raw->dataLength) {
   \                     MQRraw_getCode: (+1)
   \   00000000   0x6841             LDR      R1,[R0, #+4]
   \   00000002   0x69C2             LDR      R2,[R0, #+28]
   \   00000004   0x428A             CMP      R2,R1
   \   00000006   0xDA05             BGE.N    ??MQRraw_getCode_0
    266          		ret = raw->datacode[raw->count];
   \   00000008   0x68C1             LDR      R1,[R0, #+12]
   \   0000000A   0x5C51             LDRB     R1,[R2, R1]
    267          	} else if(raw->count < raw->dataLength + raw->eccLength) {
    268          		ret = raw->ecccode[raw->count - raw->dataLength];
    269          	} else {
    270          		return 0;
    271          	}
    272          	raw->count++;
   \                     ??MQRraw_getCode_1: (+1)
   \   0000000C   0x1C52             ADDS     R2,R2,#+1
   \   0000000E   0x61C2             STR      R2,[R0, #+28]
    273          	return ret;
   \   00000010   0x4608             MOV      R0,R1
   \   00000012   0x4770             BX       LR               ;; return
   \                     ??MQRraw_getCode_0: (+1)
   \   00000014   0x6883             LDR      R3,[R0, #+8]
   \   00000016   0x185B             ADDS     R3,R3,R1
   \   00000018   0x429A             CMP      R2,R3
   \   0000001A   0xDA03             BGE.N    ??MQRraw_getCode_2
   \   0000001C   0x1A51             SUBS     R1,R2,R1
   \   0000001E   0x6903             LDR      R3,[R0, #+16]
   \   00000020   0x5CC9             LDRB     R1,[R1, R3]
   \   00000022   0xE7F3             B.N      ??MQRraw_getCode_1
   \                     ??MQRraw_getCode_2: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x4770             BX       LR
    274          }
    275          

   \                                 In section .text, align 2, keep-with-next
    276          static void MQRraw_free(MQRRawCode *raw)
    277          {
   \                     MQRraw_free: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    278          	if(raw != NULL) {
   \   00000004   0xD00D             BEQ.N    ??MQRraw_free_0
    279          		free(raw->datacode);
   \   00000006   0x68E0             LDR      R0,[R4, #+12]
   \   00000008   0x.... 0x....      BL       free
    280          		free(raw->ecccode);
   \   0000000C   0x6920             LDR      R0,[R4, #+16]
   \   0000000E   0x.... 0x....      BL       free
    281          		free(raw->rsblock);
   \   00000012   0x6960             LDR      R0,[R4, #+20]
   \   00000014   0x.... 0x....      BL       free
    282          		free(raw);
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001E   0x.... 0x....      B.W      free
    283          	}
    284          }
   \                     ??MQRraw_free_0: (+1)
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    285          
    286          
    287          /******************************************************************************
    288           * Frame filling
    289           *****************************************************************************/
    290          
    291          typedef struct {
    292          	int width;
    293          	unsigned char *frame;
    294          	int x, y;
    295          	int dir;
    296          	int bit;
    297          	int mqr;
    298          } FrameFiller;
    299          

   \                                 In section .text, align 2, keep-with-next
    300          static FrameFiller *FrameFiller_new(int width, unsigned char *frame, int mqr)
    301          {
   \                     FrameFiller_new: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    302          	FrameFiller *filler;
    303          
    304          	filler = (FrameFiller *)malloc(sizeof(FrameFiller));
   \   00000008   0x201C             MOVS     R0,#+28
   \   0000000A   0x.... 0x....      BL       malloc
    305          	if(filler == NULL) return NULL;
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD101             BNE.N    ??FrameFiller_new_0
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xBD70             POP      {R4-R6,PC}
    306          	filler->width = width;
   \                     ??FrameFiller_new_0: (+1)
   \   00000016   0x6004             STR      R4,[R0, #+0]
    307          	filler->frame = frame;
   \   00000018   0x6045             STR      R5,[R0, #+4]
    308          	filler->x = width - 1;
   \   0000001A   0x1E61             SUBS     R1,R4,#+1
   \   0000001C   0x6081             STR      R1,[R0, #+8]
    309          	filler->y = width - 1;
   \   0000001E   0x60C1             STR      R1,[R0, #+12]
    310          	filler->dir = -1;
   \   00000020   0xF04F 0x31FF      MOV      R1,#-1
   \   00000024   0x6101             STR      R1,[R0, #+16]
    311          	filler->bit = -1;
   \   00000026   0x6141             STR      R1,[R0, #+20]
    312          	filler->mqr = mqr;
   \   00000028   0x6186             STR      R6,[R0, #+24]
    313          
    314          	return filler;
   \   0000002A   0xBD70             POP      {R4-R6,PC}       ;; return
    315          }
    316          

   \                                 In section .text, align 2, keep-with-next
    317          static unsigned char *FrameFiller_next(FrameFiller *filler)
    318          {
   \                     FrameFiller_next: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    319          	unsigned char *p;
    320          	int x, y, w;
    321          
    322          	if(filler->bit == -1) {
   \                     ??FrameFiller_next_0: (+1)
   \   00000002   0x6944             LDR      R4,[R0, #+20]
   \   00000004   0xF114 0x0F01      CMN      R4,#+1
   \   00000008   0xD109             BNE.N    ??FrameFiller_next_1
    323          		filler->bit = 0;
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x6141             STR      R1,[R0, #+20]
    324          		return filler->frame + filler->y * filler->width + filler->x;
   \   0000000E   0x6881             LDR      R1,[R0, #+8]
   \   00000010   0x68C2             LDR      R2,[R0, #+12]
   \   00000012   0x6803             LDR      R3,[R0, #+0]
   \   00000014   0x6840             LDR      R0,[R0, #+4]
   \   00000016   0xFB03 0x0002      MLA      R0,R3,R2,R0
   \   0000001A   0x1808             ADDS     R0,R1,R0
   \   0000001C   0xE03B             B.N      ??FrameFiller_next_2
    325          	}
    326          
    327          	x = filler->x;
   \                     ??FrameFiller_next_1: (+1)
   \   0000001E   0x6885             LDR      R5,[R0, #+8]
    328          	y = filler->y;
   \   00000020   0x68C3             LDR      R3,[R0, #+12]
    329          	p = filler->frame;
   \   00000022   0x6841             LDR      R1,[R0, #+4]
    330          	w = filler->width;
   \   00000024   0x6802             LDR      R2,[R0, #+0]
    331          
    332          	if(filler->bit == 0) {
   \   00000026   0x2C00             CMP      R4,#+0
   \   00000028   0xD103             BNE.N    ??FrameFiller_next_3
    333          		x--;
   \   0000002A   0x1E6D             SUBS     R5,R5,#+1
    334          		filler->bit++;
   \   0000002C   0x1C64             ADDS     R4,R4,#+1
   \   0000002E   0x6144             STR      R4,[R0, #+20]
   \   00000030   0xE004             B.N      ??FrameFiller_next_4
    335          	} else {
    336          		x++;
   \                     ??FrameFiller_next_3: (+1)
   \   00000032   0x1C6D             ADDS     R5,R5,#+1
    337          		y += filler->dir;
   \   00000034   0x6906             LDR      R6,[R0, #+16]
   \   00000036   0x18F3             ADDS     R3,R6,R3
    338          		filler->bit--;
   \   00000038   0x1E64             SUBS     R4,R4,#+1
   \   0000003A   0x6144             STR      R4,[R0, #+20]
    339          	}
    340          
    341          	if(filler->dir < 0) {
   \                     ??FrameFiller_next_4: (+1)
   \   0000003C   0x6904             LDR      R4,[R0, #+16]
   \   0000003E   0x2C00             CMP      R4,#+0
   \   00000040   0xD50D             BPL.N    ??FrameFiller_next_5
    342          		if(y < 0) {
   \   00000042   0x2B00             CMP      R3,#+0
   \   00000044   0xD519             BPL.N    ??FrameFiller_next_6
    343          			y = 0;
   \   00000046   0x2300             MOVS     R3,#+0
    344          			x -= 2;
   \   00000048   0x1EAD             SUBS     R5,R5,#+2
    345          			filler->dir = 1;
   \   0000004A   0x2401             MOVS     R4,#+1
   \   0000004C   0x6104             STR      R4,[R0, #+16]
    346          			if(!filler->mqr && x == 6) {
   \   0000004E   0x6984             LDR      R4,[R0, #+24]
   \   00000050   0x2C00             CMP      R4,#+0
   \   00000052   0xD112             BNE.N    ??FrameFiller_next_6
   \   00000054   0x2D06             CMP      R5,#+6
   \   00000056   0xD110             BNE.N    ??FrameFiller_next_6
    347          				x--;
   \   00000058   0x2505             MOVS     R5,#+5
    348          				y = 9;
   \   0000005A   0x2309             MOVS     R3,#+9
   \   0000005C   0xE00D             B.N      ??FrameFiller_next_6
    349          			}
    350          		}
    351          	} else {
    352          		if(y == w) {
   \                     ??FrameFiller_next_5: (+1)
   \   0000005E   0x4293             CMP      R3,R2
   \   00000060   0xD10B             BNE.N    ??FrameFiller_next_6
    353          			y = w - 1;
   \   00000062   0x1E53             SUBS     R3,R2,#+1
    354          			x -= 2;
   \   00000064   0x1EAD             SUBS     R5,R5,#+2
    355          			filler->dir = -1;
   \   00000066   0xF04F 0x34FF      MOV      R4,#-1
   \   0000006A   0x6104             STR      R4,[R0, #+16]
    356          			if(!filler->mqr && x == 6) {
   \   0000006C   0x6984             LDR      R4,[R0, #+24]
   \   0000006E   0x2C00             CMP      R4,#+0
   \   00000070   0xD103             BNE.N    ??FrameFiller_next_6
   \   00000072   0x2D06             CMP      R5,#+6
   \   00000074   0xD101             BNE.N    ??FrameFiller_next_6
    357          				x--;
   \   00000076   0x2505             MOVS     R5,#+5
    358          				y -= 8;
   \   00000078   0x3B08             SUBS     R3,R3,#+8
    359          			}
    360          		}
    361          	}
    362          	if(x < 0 || y < 0) return NULL;
   \                     ??FrameFiller_next_6: (+1)
   \   0000007A   0x2D00             CMP      R5,#+0
   \   0000007C   0xD401             BMI.N    ??FrameFiller_next_7
   \   0000007E   0x2B00             CMP      R3,#+0
   \   00000080   0xD501             BPL.N    ??FrameFiller_next_8
   \                     ??FrameFiller_next_7: (+1)
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xE007             B.N      ??FrameFiller_next_2
    363          
    364          	filler->x = x;
   \                     ??FrameFiller_next_8: (+1)
   \   00000086   0x6085             STR      R5,[R0, #+8]
    365          	filler->y = y;
   \   00000088   0x60C3             STR      R3,[R0, #+12]
    366          
    367          	if(p[y * w + x] & 0x80) {
   \   0000008A   0xFB02 0x5203      MLA      R2,R2,R3,R5
   \   0000008E   0x5C53             LDRB     R3,[R2, R1]
   \   00000090   0x061B             LSLS     R3,R3,#+24
   \   00000092   0xD4B6             BMI.N    ??FrameFiller_next_0
    368          		// This tail recursion could be optimized.
    369          		return FrameFiller_next(filler);
    370          	}
    371          	return &p[y * w + x];
   \   00000094   0x1850             ADDS     R0,R2,R1
   \                     ??FrameFiller_next_2: (+1)
   \   00000096   0xBC70             POP      {R4-R6}
   \   00000098   0x4770             BX       LR               ;; return
    372          }
    373          
    374          #ifdef WITH_TESTS
    375          extern unsigned char *FrameFiller_test(int version)
    376          {
    377          	int width;
    378          	unsigned char *frame, *p;
    379          	FrameFiller *filler;
    380          	int i, length;
    381          
    382          	width = QRspec_getWidth(version);
    383          	frame = QRspec_newFrame(version);
    384          	if(frame == NULL) return NULL;
    385          	filler = FrameFiller_new(width, frame, 0);
    386          	if(filler == NULL) {
    387          		free(frame);
    388          		return NULL;
    389          	}
    390          	length = QRspec_getDataLength(version, QR_ECLEVEL_L) * 8
    391          	       + QRspec_getECCLength(version, QR_ECLEVEL_L) * 8
    392          		   + QRspec_getRemainder(version);
    393          	for(i=0; i<length; i++) {
    394          		p = FrameFiller_next(filler);
    395          		if(p == NULL) {
    396          			free(filler);
    397          			free(frame);
    398          			return NULL;
    399          		}
    400          		*p = (unsigned char)(i & 0x7f) | 0x80;
    401          	}
    402          	free(filler);
    403          	return frame;
    404          }
    405          
    406          extern unsigned char *FrameFiller_testMQR(int version)
    407          {
    408          	int width;
    409          	unsigned char *frame, *p;
    410          	FrameFiller *filler;
    411          	int i, length;
    412          
    413          	width = MQRspec_getWidth(version);
    414          	frame = MQRspec_newFrame(version);
    415          	if(frame == NULL) return NULL;
    416          	filler = FrameFiller_new(width, frame, 1);
    417          	if(filler == NULL) {
    418          		free(frame);
    419          		return NULL;
    420          	}
    421          	length = MQRspec_getDataLengthBit(version, QR_ECLEVEL_L)
    422          	       + MQRspec_getECCLength(version, QR_ECLEVEL_L) * 8;
    423          	for(i=0; i<length; i++) {
    424          		p = FrameFiller_next(filler);
    425          		if(p == NULL) {
    426          			fprintf(stderr, "Frame filler run over the frame!\n");
    427          			free(filler);
    428          			return frame;
    429          		}
    430          		*p = (unsigned char)(i & 0x7f) | 0x80;
    431          	}
    432          	free(filler);
    433          	return frame;
    434          }
    435          #endif
    436          
    437          
    438          /******************************************************************************
    439           * QR-code encoding
    440           *****************************************************************************/
    441          

   \                                 In section .text, align 2, keep-with-next
    442          static QRcode *QRcode_new(int version, int width, unsigned char *data)
    443          {
   \                     QRcode_new: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    444          	QRcode *qrcode;
    445          
    446          	qrcode = (QRcode *)malloc(sizeof(QRcode));
   \   00000008   0x200C             MOVS     R0,#+12
   \   0000000A   0x.... 0x....      BL       malloc
    447          	if(qrcode == NULL) return NULL;
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD101             BNE.N    ??QRcode_new_0
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xBD70             POP      {R4-R6,PC}
    448          
    449          	qrcode->version = version;
   \                     ??QRcode_new_0: (+1)
   \   00000016   0x6004             STR      R4,[R0, #+0]
    450          	qrcode->width = width;
   \   00000018   0x6045             STR      R5,[R0, #+4]
    451          	qrcode->data = data;
   \   0000001A   0x6086             STR      R6,[R0, #+8]
    452          
    453          	return qrcode;
   \   0000001C   0xBD70             POP      {R4-R6,PC}       ;; return
    454          }
    455          

   \                                 In section .text, align 2, keep-with-next
    456          void QRcode_free(QRcode *qrcode)
    457          {
   \                     QRcode_free: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    458          	if(qrcode != NULL) {
   \   00000004   0xD007             BEQ.N    ??QRcode_free_0
    459          		free(qrcode->data);
   \   00000006   0x68A0             LDR      R0,[R4, #+8]
   \   00000008   0x.... 0x....      BL       free
    460          		free(qrcode);
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000012   0x.... 0x....      B.W      free
    461          	}
    462          }
   \                     ??QRcode_free_0: (+1)
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
    463          

   \                                 In section .text, align 2, keep-with-next
    464          static QRcode *QRcode_encodeMask(QRinput *input, int mask)
    465          {
   \                     QRcode_encodeMask: (+1)
   \   00000000   0xE92D 0x4FF3      PUSH     {R0,R1,R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
    466          	int width, version;
    467          	QRRawCode *raw;
    468          	unsigned char *frame, *masked, *p, code, bit;
    469          	FrameFiller *filler;
    470          	int i, j;
    471          	QRcode *qrcode = NULL;
   \   00000006   0x2400             MOVS     R4,#+0
    472          	if(input->mqr) {
   \   00000008   0x6900             LDR      R0,[R0, #+16]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD006             BEQ.N    ??QRcode_encodeMask_0
    473          		errno = EINVAL;
   \   0000000E   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000012   0xF04F 0x31FF      MOV      R1,#-1
   \   00000016   0x6001             STR      R1,[R0, #+0]
    474          		return NULL;
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0xE0B4             B.N      ??QRcode_encodeMask_1
    475          	}
    476          	if(input->version < 0 || input->version > QRSPEC_VERSION_MAX) {
   \                     ??QRcode_encodeMask_0: (+1)
   \   0000001C   0x9803             LDR      R0,[SP, #+12]
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x2829             CMP      R0,#+41
   \   00000022   0xD306             BCC.N    ??QRcode_encodeMask_2
    477          		errno = EINVAL;
   \   00000024   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000028   0xF04F 0x31FF      MOV      R1,#-1
   \   0000002C   0x6001             STR      R1,[R0, #+0]
    478          		return NULL;
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0xE0A9             B.N      ??QRcode_encodeMask_1
    479          	}
    480          	if(input->level > QR_ECLEVEL_H) {
   \                     ??QRcode_encodeMask_2: (+1)
   \   00000032   0x9803             LDR      R0,[SP, #+12]
   \   00000034   0xF990 0x0004      LDRSB    R0,[R0, #+4]
   \   00000038   0x2804             CMP      R0,#+4
   \   0000003A   0xDB06             BLT.N    ??QRcode_encodeMask_3
    481          		errno = EINVAL;
   \   0000003C   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000040   0xF04F 0x31FF      MOV      R1,#-1
   \   00000044   0x6001             STR      R1,[R0, #+0]
    482          		return NULL;
   \   00000046   0x4620             MOV      R0,R4
   \   00000048   0xE09D             B.N      ??QRcode_encodeMask_1
    483          	}
    484          	raw = QRraw_new(input);
   \                     ??QRcode_encodeMask_3: (+1)
   \   0000004A   0x9803             LDR      R0,[SP, #+12]
   \   0000004C   0x.... 0x....      BL       QRraw_new
   \   00000050   0x0005             MOVS     R5,R0
    485          	if(raw == NULL) return NULL;
   \   00000052   0xD101             BNE.N    ??QRcode_encodeMask_4
   \   00000054   0x4620             MOV      R0,R4
   \   00000056   0xE096             B.N      ??QRcode_encodeMask_1
    486          	version = raw->version;
   \                     ??QRcode_encodeMask_4: (+1)
   \   00000058   0x6828             LDR      R0,[R5, #+0]
   \   0000005A   0x9001             STR      R0,[SP, #+4]
    487          	width = QRspec_getWidth(version);
   \   0000005C   0x.... 0x....      BL       QRspec_getWidth
   \   00000060   0x9000             STR      R0,[SP, #+0]
    488          printf("QRinput4");
   \   00000062   0x.... 0x....      ADR.W    R0,`?<Constant "QRinput\\274\\306\\313\\3434">`
   \   00000066   0x.... 0x....      BL       printf
    489          	frame = QRspec_newFrame(version);
   \   0000006A   0x9801             LDR      R0,[SP, #+4]
   \   0000006C   0x.... 0x....      BL       QRspec_newFrame
   \   00000070   0x0006             MOVS     R6,R0
    490          	if(frame == NULL) {
   \   00000072   0xD104             BNE.N    ??QRcode_encodeMask_5
    491          		QRraw_free(raw);
   \   00000074   0x4628             MOV      R0,R5
   \   00000076   0x.... 0x....      BL       QRraw_free
    492          		return NULL;
   \   0000007A   0x4620             MOV      R0,R4
   \   0000007C   0xE083             B.N      ??QRcode_encodeMask_1
    493          	}
    494          	filler = FrameFiller_new(width, frame, 0);
   \                     ??QRcode_encodeMask_5: (+1)
   \   0000007E   0x4622             MOV      R2,R4
   \   00000080   0x4631             MOV      R1,R6
   \   00000082   0x9800             LDR      R0,[SP, #+0]
   \   00000084   0x.... 0x....      BL       FrameFiller_new
   \   00000088   0x0007             MOVS     R7,R0
    495          	if(filler == NULL) {
   \   0000008A   0xD107             BNE.N    ??QRcode_encodeMask_6
    496          		QRraw_free(raw);
   \   0000008C   0x4628             MOV      R0,R5
   \   0000008E   0x.... 0x....      BL       QRraw_free
    497          		free(frame);
   \   00000092   0x4630             MOV      R0,R6
   \   00000094   0x.... 0x....      BL       free
    498          		return NULL;
   \   00000098   0x4620             MOV      R0,R4
   \   0000009A   0xE074             B.N      ??QRcode_encodeMask_1
    499          	}
    500          	/* inteleaved data and ecc codes */
    501          	for(i=0; i<raw->dataLength + raw->eccLength; i++) {
   \                     ??QRcode_encodeMask_6: (+1)
   \   0000009C   0x46A0             MOV      R8,R4
   \   0000009E   0xE016             B.N      ??QRcode_encodeMask_7
    502          		code = QRraw_getCode(raw);
    503          		bit = 0x80;
    504          		for(j=0; j<8; j++) {
    505          			p = FrameFiller_next(filler);
   \                     ??QRcode_encodeMask_8: (+1)
   \   000000A0   0x4638             MOV      R0,R7
   \   000000A2   0x.... 0x....      BL       FrameFiller_next
    506          			if(p == NULL)  goto EXIT;
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD063             BEQ.N    ??QRcode_encodeMask_9
    507          			*p = 0x02 | ((bit & code) != 0);
   \   000000AA   0xEA0A 0x0109      AND      R1,R10,R9
   \   000000AE   0x1E49             SUBS     R1,R1,#+1
   \   000000B0   0x4189             SBCS     R1,R1,R1
   \   000000B2   0x43C9             MVNS     R1,R1
   \   000000B4   0x0FC9             LSRS     R1,R1,#+31
   \   000000B6   0xF041 0x0102      ORR      R1,R1,#0x2
   \   000000BA   0x7001             STRB     R1,[R0, #+0]
    508          			bit = bit >> 1;
   \   000000BC   0xEA4F 0x0969      ASR      R9,R9,#+1
    509          		}
   \   000000C0   0xF10B 0x0B01      ADD      R11,R11,#+1
   \                     ??QRcode_encodeMask_10: (+1)
   \   000000C4   0xF1BB 0x0F08      CMP      R11,#+8
   \   000000C8   0xDBEA             BLT.N    ??QRcode_encodeMask_8
   \   000000CA   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??QRcode_encodeMask_7: (+1)
   \   000000CE   0x6868             LDR      R0,[R5, #+4]
   \   000000D0   0x68A9             LDR      R1,[R5, #+8]
   \   000000D2   0x1808             ADDS     R0,R1,R0
   \   000000D4   0x4580             CMP      R8,R0
   \   000000D6   0x4628             MOV      R0,R5
   \   000000D8   0xDA06             BGE.N    ??QRcode_encodeMask_11
   \   000000DA   0x.... 0x....      BL       QRraw_getCode
   \   000000DE   0x4682             MOV      R10,R0
   \   000000E0   0xF04F 0x0980      MOV      R9,#+128
   \   000000E4   0x46A3             MOV      R11,R4
   \   000000E6   0xE7ED             B.N      ??QRcode_encodeMask_10
    510          	}
    511          	QRraw_free(raw);
   \                     ??QRcode_encodeMask_11: (+1)
   \   000000E8   0x.... 0x....      BL       QRraw_free
    512          	raw = NULL;
   \   000000EC   0x4625             MOV      R5,R4
    513          	/* remainder bits */
    514          	j = QRspec_getRemainder(version);
   \   000000EE   0x9801             LDR      R0,[SP, #+4]
   \   000000F0   0x.... 0x....      BL       QRspec_getRemainder
   \   000000F4   0x4683             MOV      R11,R0
    515          	for(i=0; i<j; i++) {
   \   000000F6   0x46A0             MOV      R8,R4
   \   000000F8   0xE008             B.N      ??QRcode_encodeMask_12
    516          		p = FrameFiller_next(filler);
   \                     ??QRcode_encodeMask_13: (+1)
   \   000000FA   0x4638             MOV      R0,R7
   \   000000FC   0x.... 0x....      BL       FrameFiller_next
    517          		if(p == NULL)  goto EXIT;
   \   00000100   0x2800             CMP      R0,#+0
   \   00000102   0xD036             BEQ.N    ??QRcode_encodeMask_9
    518          		*p = 0x02;
   \   00000104   0x2102             MOVS     R1,#+2
   \   00000106   0x7001             STRB     R1,[R0, #+0]
    519          	}
   \   00000108   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??QRcode_encodeMask_12: (+1)
   \   0000010C   0x45D8             CMP      R8,R11
   \   0000010E   0xDBF4             BLT.N    ??QRcode_encodeMask_13
    520          
    521          	/* masking */
    522          	if(mask == -2) { // just for debug purpose
   \   00000110   0x9804             LDR      R0,[SP, #+16]
   \   00000112   0xF110 0x0F02      CMN      R0,#+2
   \   00000116   0xD10C             BNE.N    ??QRcode_encodeMask_14
    523          		masked = (unsigned char *)malloc(width * width);
   \   00000118   0x9800             LDR      R0,[SP, #+0]
   \   0000011A   0x4601             MOV      R1,R0
   \   0000011C   0xFB01 0xF800      MUL      R8,R1,R0
   \   00000120   0x4640             MOV      R0,R8
   \   00000122   0x.... 0x....      BL       malloc
   \   00000126   0x4681             MOV      R9,R0
    524          		memcpy(masked, frame, width * width);
   \   00000128   0x4642             MOV      R2,R8
   \   0000012A   0x4631             MOV      R1,R6
   \   0000012C   0x.... 0x....      BL       memcpy
   \   00000130   0xE012             B.N      ??QRcode_encodeMask_15
    525          	} else if(mask < 0) {
   \                     ??QRcode_encodeMask_14: (+1)
   \   00000132   0x9803             LDR      R0,[SP, #+12]
   \   00000134   0xF990 0x2004      LDRSB    R2,[R0, #+4]
   \   00000138   0x9804             LDR      R0,[SP, #+16]
   \   0000013A   0x2800             CMP      R0,#+0
   \   0000013C   0xD505             BPL.N    ??QRcode_encodeMask_16
    526          		masked = Mask_mask(width, frame, input->level);
   \   0000013E   0x4631             MOV      R1,R6
   \   00000140   0x9800             LDR      R0,[SP, #+0]
   \   00000142   0x.... 0x....      BL       Mask_mask
   \   00000146   0x4681             MOV      R9,R0
   \   00000148   0xE006             B.N      ??QRcode_encodeMask_15
    527          	} else {
    528          		masked = Mask_makeMask(width, frame, mask, input->level);
   \                     ??QRcode_encodeMask_16: (+1)
   \   0000014A   0x4613             MOV      R3,R2
   \   0000014C   0x4602             MOV      R2,R0
   \   0000014E   0x4631             MOV      R1,R6
   \   00000150   0x9800             LDR      R0,[SP, #+0]
   \   00000152   0x.... 0x....      BL       Mask_makeMask
   \   00000156   0x4681             MOV      R9,R0
    529          	}
    530          	if(masked == NULL) {
   \                     ??QRcode_encodeMask_15: (+1)
   \   00000158   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000015C   0xD009             BEQ.N    ??QRcode_encodeMask_9
    531          		goto EXIT;
    532          	}
    533          	qrcode = QRcode_new(version, width, masked);
   \   0000015E   0x464A             MOV      R2,R9
   \   00000160   0x9900             LDR      R1,[SP, #+0]
   \   00000162   0x9801             LDR      R0,[SP, #+4]
   \   00000164   0x.... 0x....      BL       QRcode_new
   \   00000168   0x0004             MOVS     R4,R0
    534          	if(qrcode == NULL) {
   \   0000016A   0xD102             BNE.N    ??QRcode_encodeMask_9
    535          		free(masked);
   \   0000016C   0x4648             MOV      R0,R9
   \   0000016E   0x.... 0x....      BL       free
    536          	}
    537          
    538          EXIT:
    539          	QRraw_free(raw);
   \                     ??QRcode_encodeMask_9: (+1)
   \   00000172   0x4628             MOV      R0,R5
   \   00000174   0x.... 0x....      BL       QRraw_free
    540          	free(filler);
   \   00000178   0x4638             MOV      R0,R7
   \   0000017A   0x.... 0x....      BL       free
    541          	free(frame);
   \   0000017E   0x4630             MOV      R0,R6
   \   00000180   0x.... 0x....      BL       free
    542          	return qrcode;
   \   00000184   0x4620             MOV      R0,R4
   \                     ??QRcode_encodeMask_1: (+1)
   \   00000186   0xB005             ADD      SP,SP,#+20
   \   00000188   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    543          }
    544          

   \                                 In section .text, align 2, keep-with-next
    545          static QRcode *QRcode_encodeMaskMQR(QRinput *input, int mask)
    546          {
   \                     QRcode_encodeMaskMQR: (+1)
   \   00000000   0xE92D 0x4FF3      PUSH     {R0,R1,R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
    547          	int width, version;
    548          	MQRRawCode *raw;
    549          	unsigned char *frame, *masked, *p, code, bit;
    550          	FrameFiller *filler;
    551          	int i, j;
    552          	QRcode *qrcode = NULL;
   \   00000006   0x2400             MOVS     R4,#+0
    553          
    554          	if(!input->mqr) {
   \   00000008   0x6900             LDR      R0,[R0, #+16]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD106             BNE.N    ??QRcode_encodeMaskMQR_0
    555          		errno = EINVAL;
   \   0000000E   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000012   0xF04F 0x31FF      MOV      R1,#-1
   \   00000016   0x6001             STR      R1,[R0, #+0]
    556          		return NULL;
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0xE0AC             B.N      ??QRcode_encodeMaskMQR_1
    557          	}
    558          	if(input->version <= 0 || input->version > MQRSPEC_VERSION_MAX) {
   \                     ??QRcode_encodeMaskMQR_0: (+1)
   \   0000001C   0x9803             LDR      R0,[SP, #+12]
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x1E40             SUBS     R0,R0,#+1
   \   00000022   0x2804             CMP      R0,#+4
   \   00000024   0xD306             BCC.N    ??QRcode_encodeMaskMQR_2
    559          		errno = EINVAL;
   \   00000026   0x.... 0x....      BL       __aeabi_errno_addr
   \   0000002A   0xF04F 0x31FF      MOV      R1,#-1
   \   0000002E   0x6001             STR      R1,[R0, #+0]
    560          		return NULL;
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0xE0A0             B.N      ??QRcode_encodeMaskMQR_1
    561          	}
    562          	if(input->level > QR_ECLEVEL_Q) {
   \                     ??QRcode_encodeMaskMQR_2: (+1)
   \   00000034   0x9803             LDR      R0,[SP, #+12]
   \   00000036   0xF990 0x0004      LDRSB    R0,[R0, #+4]
   \   0000003A   0x2803             CMP      R0,#+3
   \   0000003C   0xDB06             BLT.N    ??QRcode_encodeMaskMQR_3
    563          		errno = EINVAL;
   \   0000003E   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000042   0xF04F 0x31FF      MOV      R1,#-1
   \   00000046   0x6001             STR      R1,[R0, #+0]
    564          		return NULL;
   \   00000048   0x4620             MOV      R0,R4
   \   0000004A   0xE094             B.N      ??QRcode_encodeMaskMQR_1
    565          	}
    566          
    567          	raw = MQRraw_new(input);
   \                     ??QRcode_encodeMaskMQR_3: (+1)
   \   0000004C   0x9803             LDR      R0,[SP, #+12]
   \   0000004E   0x.... 0x....      BL       MQRraw_new
   \   00000052   0x0005             MOVS     R5,R0
    568          	if(raw == NULL) return NULL;
   \   00000054   0xD101             BNE.N    ??QRcode_encodeMaskMQR_4
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0xE08D             B.N      ??QRcode_encodeMaskMQR_1
    569          
    570          	version = raw->version;
   \                     ??QRcode_encodeMaskMQR_4: (+1)
   \   0000005A   0x6828             LDR      R0,[R5, #+0]
   \   0000005C   0x9000             STR      R0,[SP, #+0]
    571          	width = MQRspec_getWidth(version);
   \   0000005E   0x.... 0x....      BL       MQRspec_getWidth
   \   00000062   0x9001             STR      R0,[SP, #+4]
    572          	frame = MQRspec_newFrame(version);
   \   00000064   0x9800             LDR      R0,[SP, #+0]
   \   00000066   0x.... 0x....      BL       MQRspec_newFrame
   \   0000006A   0x0006             MOVS     R6,R0
    573          	if(frame == NULL) {
   \   0000006C   0xD104             BNE.N    ??QRcode_encodeMaskMQR_5
    574          		MQRraw_free(raw);
   \   0000006E   0x4628             MOV      R0,R5
   \   00000070   0x.... 0x....      BL       MQRraw_free
    575          		return NULL;
   \   00000074   0x4620             MOV      R0,R4
   \   00000076   0xE07E             B.N      ??QRcode_encodeMaskMQR_1
    576          	}
    577          	filler = FrameFiller_new(width, frame, 1);
   \                     ??QRcode_encodeMaskMQR_5: (+1)
   \   00000078   0x2201             MOVS     R2,#+1
   \   0000007A   0x4631             MOV      R1,R6
   \   0000007C   0x9801             LDR      R0,[SP, #+4]
   \   0000007E   0x.... 0x....      BL       FrameFiller_new
   \   00000082   0x0007             MOVS     R7,R0
    578          	if(filler == NULL) {
   \   00000084   0xD107             BNE.N    ??QRcode_encodeMaskMQR_6
    579          		MQRraw_free(raw);
   \   00000086   0x4628             MOV      R0,R5
   \   00000088   0x.... 0x....      BL       MQRraw_free
    580          		free(frame);
   \   0000008C   0x4630             MOV      R0,R6
   \   0000008E   0x.... 0x....      BL       free
    581          		return NULL;
   \   00000092   0x4620             MOV      R0,R4
   \   00000094   0xE06F             B.N      ??QRcode_encodeMaskMQR_1
    582          	}
    583          
    584          	/* inteleaved data and ecc codes */
    585          	for(i=0; i<raw->dataLength + raw->eccLength; i++) {
   \                     ??QRcode_encodeMaskMQR_6: (+1)
   \   00000096   0x46A0             MOV      R8,R4
   \   00000098   0xE016             B.N      ??QRcode_encodeMaskMQR_7
    586          		code = MQRraw_getCode(raw);
    587          		if(raw->oddbits && i == raw->dataLength - 1) {
    588          			bit = 1 << (raw->oddbits - 1);
    589          			for(j=0; j<raw->oddbits; j++) {
    590          				p = FrameFiller_next(filler);
    591          				if(p == NULL) goto EXIT;
    592          				*p = 0x02 | ((bit & code) != 0);
    593          				bit = bit >> 1;
    594          			}
    595          		} else {
    596          			bit = 0x80;
    597          			for(j=0; j<8; j++) {
    598          				p = FrameFiller_next(filler);
   \                     ??QRcode_encodeMaskMQR_8: (+1)
   \   0000009A   0x4638             MOV      R0,R7
   \   0000009C   0x.... 0x....      BL       FrameFiller_next
    599          				if(p == NULL) goto EXIT;
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0xD05E             BEQ.N    ??QRcode_encodeMaskMQR_9
    600          				*p = 0x02 | ((bit & code) != 0);
   \   000000A4   0xEA0A 0x0109      AND      R1,R10,R9
   \   000000A8   0x1E49             SUBS     R1,R1,#+1
   \   000000AA   0x4189             SBCS     R1,R1,R1
   \   000000AC   0x43C9             MVNS     R1,R1
   \   000000AE   0x0FC9             LSRS     R1,R1,#+31
   \   000000B0   0xF041 0x0102      ORR      R1,R1,#0x2
   \   000000B4   0x7001             STRB     R1,[R0, #+0]
    601          				bit = bit >> 1;
   \   000000B6   0xEA4F 0x0969      ASR      R9,R9,#+1
    602          			}
   \   000000BA   0xF10B 0x0B01      ADD      R11,R11,#+1
   \                     ??QRcode_encodeMaskMQR_10: (+1)
   \   000000BE   0xF1BB 0x0F08      CMP      R11,#+8
   \   000000C2   0xDBEA             BLT.N    ??QRcode_encodeMaskMQR_8
   \                     ??QRcode_encodeMaskMQR_11: (+1)
   \   000000C4   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??QRcode_encodeMaskMQR_7: (+1)
   \   000000C8   0x6868             LDR      R0,[R5, #+4]
   \   000000CA   0x68A9             LDR      R1,[R5, #+8]
   \   000000CC   0x1808             ADDS     R0,R1,R0
   \   000000CE   0x4580             CMP      R8,R0
   \   000000D0   0x4628             MOV      R0,R5
   \   000000D2   0xDA2A             BGE.N    ??QRcode_encodeMaskMQR_12
   \   000000D4   0x.... 0x....      BL       MQRraw_getCode
   \   000000D8   0x4682             MOV      R10,R0
   \   000000DA   0x69A8             LDR      R0,[R5, #+24]
   \   000000DC   0x2800             CMP      R0,#+0
   \   000000DE   0xD020             BEQ.N    ??QRcode_encodeMaskMQR_13
   \   000000E0   0x6869             LDR      R1,[R5, #+4]
   \   000000E2   0x1E49             SUBS     R1,R1,#+1
   \   000000E4   0x4588             CMP      R8,R1
   \   000000E6   0xD11C             BNE.N    ??QRcode_encodeMaskMQR_13
   \   000000E8   0x2101             MOVS     R1,#+1
   \   000000EA   0x1E40             SUBS     R0,R0,#+1
   \   000000EC   0xFA01 0xF900      LSL      R9,R1,R0
   \   000000F0   0xFA5F 0xF989      UXTB     R9,R9
   \   000000F4   0x46A3             MOV      R11,R4
   \                     ??QRcode_encodeMaskMQR_14: (+1)
   \   000000F6   0x69A8             LDR      R0,[R5, #+24]
   \   000000F8   0x4583             CMP      R11,R0
   \   000000FA   0xDAE3             BGE.N    ??QRcode_encodeMaskMQR_11
   \   000000FC   0x4638             MOV      R0,R7
   \   000000FE   0x.... 0x....      BL       FrameFiller_next
   \   00000102   0x2800             CMP      R0,#+0
   \   00000104   0xD02D             BEQ.N    ??QRcode_encodeMaskMQR_9
   \   00000106   0xEA0A 0x0109      AND      R1,R10,R9
   \   0000010A   0x1E49             SUBS     R1,R1,#+1
   \   0000010C   0x4189             SBCS     R1,R1,R1
   \   0000010E   0x43C9             MVNS     R1,R1
   \   00000110   0x0FC9             LSRS     R1,R1,#+31
   \   00000112   0xF041 0x0102      ORR      R1,R1,#0x2
   \   00000116   0x7001             STRB     R1,[R0, #+0]
   \   00000118   0xEA4F 0x0969      ASR      R9,R9,#+1
   \   0000011C   0xF10B 0x0B01      ADD      R11,R11,#+1
   \   00000120   0xE7E9             B.N      ??QRcode_encodeMaskMQR_14
   \                     ??QRcode_encodeMaskMQR_13: (+1)
   \   00000122   0xF04F 0x0980      MOV      R9,#+128
   \   00000126   0x46A3             MOV      R11,R4
   \   00000128   0xE7C9             B.N      ??QRcode_encodeMaskMQR_10
    603          		}
    604          	}
    605          	MQRraw_free(raw);
   \                     ??QRcode_encodeMaskMQR_12: (+1)
   \   0000012A   0x.... 0x....      BL       MQRraw_free
    606          	raw = NULL;
   \   0000012E   0x4625             MOV      R5,R4
    607          
    608          	/* masking */
    609          	if(mask < 0) {
   \   00000130   0x9803             LDR      R0,[SP, #+12]
   \   00000132   0xF990 0x2004      LDRSB    R2,[R0, #+4]
   \   00000136   0x9804             LDR      R0,[SP, #+16]
   \   00000138   0x2800             CMP      R0,#+0
   \   0000013A   0xD504             BPL.N    ??QRcode_encodeMaskMQR_15
    610          		masked = MMask_mask(version, frame, input->level);
   \   0000013C   0x4631             MOV      R1,R6
   \   0000013E   0x9800             LDR      R0,[SP, #+0]
   \   00000140   0x.... 0x....      BL       MMask_mask
   \   00000144   0xE005             B.N      ??QRcode_encodeMaskMQR_16
    611          	} else {
    612          		masked = MMask_makeMask(version, frame, mask, input->level);
   \                     ??QRcode_encodeMaskMQR_15: (+1)
   \   00000146   0x4613             MOV      R3,R2
   \   00000148   0x4602             MOV      R2,R0
   \   0000014A   0x4631             MOV      R1,R6
   \   0000014C   0x9800             LDR      R0,[SP, #+0]
   \   0000014E   0x.... 0x....      BL       MMask_makeMask
    613          	}
    614          	if(masked == NULL) {
   \                     ??QRcode_encodeMaskMQR_16: (+1)
   \   00000152   0x2800             CMP      R0,#+0
   \   00000154   0xD005             BEQ.N    ??QRcode_encodeMaskMQR_9
    615          		goto EXIT;
    616          	}
    617          
    618          	qrcode = QRcode_new(version, width, masked);
   \   00000156   0x4602             MOV      R2,R0
   \   00000158   0x9901             LDR      R1,[SP, #+4]
   \   0000015A   0x9800             LDR      R0,[SP, #+0]
   \   0000015C   0x.... 0x....      BL       QRcode_new
   \   00000160   0x4604             MOV      R4,R0
    619          
    620          EXIT:
    621          	MQRraw_free(raw);
   \                     ??QRcode_encodeMaskMQR_9: (+1)
   \   00000162   0x4628             MOV      R0,R5
   \   00000164   0x.... 0x....      BL       MQRraw_free
    622          	free(filler);
   \   00000168   0x4638             MOV      R0,R7
   \   0000016A   0x.... 0x....      BL       free
    623          	free(frame);
   \   0000016E   0x4630             MOV      R0,R6
   \   00000170   0x.... 0x....      BL       free
    624          	return qrcode;
   \   00000174   0x4620             MOV      R0,R4
   \                     ??QRcode_encodeMaskMQR_1: (+1)
   \   00000176   0xB005             ADD      SP,SP,#+20
   \   00000178   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    625          }
    626          

   \                                 In section .text, align 2, keep-with-next
    627          QRcode *QRcode_encodeInput(QRinput *input)
    628          {
    629          	if(input->mqr) {
   \                     QRcode_encodeInput: (+1)
   \   00000000   0x6901             LDR      R1,[R0, #+16]
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xF04F 0x31FF      MOV      R1,#-1
   \   00000008   0xD000             BEQ.N    ??QRcode_encodeInput_0
    630          		return QRcode_encodeMaskMQR(input, -1);
   \   0000000A   0x....             B.N      QRcode_encodeMaskMQR
    631          	} else {
    632          		return QRcode_encodeMask(input, -1);
   \                     ??QRcode_encodeInput_0: (+1)
   \   0000000C   0x....             B.N      QRcode_encodeMask
    633          	}
    634          }
    635          //
    636          //string
    637          //version
    638          //level
    639          //hint
    640          //casesensitive

   \                                 In section .text, align 2, keep-with-next
    641          static QRcode *QRcode_encodeStringReal(const char *string, int version, QRecLevel level, int mqr, QRencodeMode hint, int casesensitive)
    642          {
   \                     QRcode_encodeStringReal: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4608             MOV      R0,R1
   \   00000006   0x4611             MOV      R1,R2
    643          	QRinput *input;
    644          	QRcode *code;
    645          	int ret;
    646          
    647          	if(string == NULL) {
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD106             BNE.N    ??QRcode_encodeStringReal_0
    648          		errno = EINVAL;
   \   0000000C   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000010   0xF04F 0x31FF      MOV      R1,#-1
   \   00000014   0x6001             STR      R1,[R0, #+0]
    649          		return NULL;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xBD70             POP      {R4-R6,PC}
    650          	}
   \                     ??QRcode_encodeStringReal_0: (+1)
   \   0000001A   0xF99D 0x5010      LDRSB    R5,[SP, #+16]
    651          	if(hint != QR_MODE_8 && hint != QR_MODE_KANJI) {
   \   0000001E   0x462A             MOV      R2,R5
   \   00000020   0x2A02             CMP      R2,#+2
   \   00000022   0xD008             BEQ.N    ??QRcode_encodeStringReal_1
   \   00000024   0x2A03             CMP      R2,#+3
   \   00000026   0xD006             BEQ.N    ??QRcode_encodeStringReal_1
    652          		errno = EINVAL;
   \   00000028   0x.... 0x....      BL       __aeabi_errno_addr
   \   0000002C   0xF04F 0x31FF      MOV      R1,#-1
   \   00000030   0x6001             STR      R1,[R0, #+0]
    653          		return NULL;//8bit 
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xBD70             POP      {R4-R6,PC}
    654          	}
    655          	if(mqr) {
   \                     ??QRcode_encodeStringReal_1: (+1)
   \   00000036   0x2B00             CMP      R3,#+0
   \   00000038   0xD003             BEQ.N    ??QRcode_encodeStringReal_2
    656          		input = QRinput_newMQR(version, level);//MQR
   \   0000003A   0x.... 0x....      BL       QRinput_newMQR
   \   0000003E   0x4606             MOV      R6,R0
   \   00000040   0xE002             B.N      ??QRcode_encodeStringReal_3
    657          	} else {
    658          		input = QRinput_new2(version, level);
   \                     ??QRcode_encodeStringReal_2: (+1)
   \   00000042   0x.... 0x....      BL       QRinput_new2
   \   00000046   0x4606             MOV      R6,R0
    659          	}
    660          	if(input == NULL) return NULL;
   \                     ??QRcode_encodeStringReal_3: (+1)
   \   00000048   0x2E00             CMP      R6,#+0
   \   0000004A   0xD101             BNE.N    ??QRcode_encodeStringReal_4
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xBD70             POP      {R4-R6,PC}
    661          	ret = Split_splitStringToQRinput(string, input, hint, casesensitive);
    662          	if(ret < 0) {
   \                     ??QRcode_encodeStringReal_4: (+1)
   \   00000050   0x9B05             LDR      R3,[SP, #+20]
   \   00000052   0x462A             MOV      R2,R5
   \   00000054   0x4631             MOV      R1,R6
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0x.... 0x....      BL       Split_splitStringToQRinput
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0x4630             MOV      R0,R6
   \   00000060   0xD503             BPL.N    ??QRcode_encodeStringReal_5
    663          		QRinput_free(input);
   \   00000062   0x.... 0x....      BL       QRinput_free
    664          		return NULL;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0xBD70             POP      {R4-R6,PC}
    665          	}
    666          	code = QRcode_encodeInput(input);
   \                     ??QRcode_encodeStringReal_5: (+1)
   \   0000006A   0x.... 0x....      BL       QRcode_encodeInput
   \   0000006E   0x4604             MOV      R4,R0
    667          	QRinput_free(input);
   \   00000070   0x4630             MOV      R0,R6
   \   00000072   0x.... 0x....      BL       QRinput_free
    668          	return code;
   \   00000076   0x4620             MOV      R0,R4
   \   00000078   0xBD70             POP      {R4-R6,PC}       ;; return
    669          }
    670          

   \                                 In section .text, align 2, keep-with-next
    671          QRcode *QRcode_encodeString(const char *string, int version, QRecLevel level, QRencodeMode hint, int casesensitive)
    672          {
   \                     QRcode_encodeString: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
    673          	return QRcode_encodeStringReal(string, version, level, 0, hint, casesensitive);
   \   00000002   0x9C04             LDR      R4,[SP, #+16]
   \   00000004   0x9401             STR      R4,[SP, #+4]
   \   00000006   0x9300             STR      R3,[SP, #+0]
   \   00000008   0x2300             MOVS     R3,#+0
   \   0000000A   0x.... 0x....      BL       QRcode_encodeStringReal
   \   0000000E   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    674          }
    675          

   \                                 In section .text, align 2, keep-with-next
    676          QRcode *QRcode_encodeStringMQR(const char *string, int version, QRecLevel level, QRencodeMode hint, int casesensitive)
    677          {
   \                     QRcode_encodeStringMQR: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
    678          	return QRcode_encodeStringReal(string, version, level, 1, hint, casesensitive);
   \   00000002   0x9C04             LDR      R4,[SP, #+16]
   \   00000004   0x9401             STR      R4,[SP, #+4]
   \   00000006   0x9300             STR      R3,[SP, #+0]
   \   00000008   0x2301             MOVS     R3,#+1
   \   0000000A   0x.... 0x....      BL       QRcode_encodeStringReal
   \   0000000E   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    679          }
    680          

   \                                 In section .text, align 2, keep-with-next
    681          static QRcode *QRcode_encodeDataReal(const unsigned char *data, int length, int version, QRecLevel level, int mqr)
    682          {
   \                     QRcode_encodeDataReal: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4610             MOV      R0,R2
   \   00000008   0x4619             MOV      R1,R3
    683          	QRinput *input;
    684          	QRcode *code;
    685          	int ret;
    686          
    687          	if(data == NULL || length == 0) {
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD001             BEQ.N    ??QRcode_encodeDataReal_0
   \   0000000E   0x2D00             CMP      R5,#+0
   \   00000010   0xD106             BNE.N    ??QRcode_encodeDataReal_1
    688          		errno = EINVAL;
   \                     ??QRcode_encodeDataReal_0: (+1)
   \   00000012   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000016   0xF04F 0x31FF      MOV      R1,#-1
   \   0000001A   0x6001             STR      R1,[R0, #+0]
    689          		return NULL;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xBD70             POP      {R4-R6,PC}
    690          	}
    691          
    692          	if(mqr) {
   \                     ??QRcode_encodeDataReal_1: (+1)
   \   00000020   0x9A04             LDR      R2,[SP, #+16]
   \   00000022   0x2A00             CMP      R2,#+0
   \   00000024   0xD003             BEQ.N    ??QRcode_encodeDataReal_2
    693          		input = QRinput_newMQR(version, level);
   \   00000026   0x.... 0x....      BL       QRinput_newMQR
   \   0000002A   0x4606             MOV      R6,R0
   \   0000002C   0xE002             B.N      ??QRcode_encodeDataReal_3
    694          	} else {
    695          		input = QRinput_new2(version, level);
   \                     ??QRcode_encodeDataReal_2: (+1)
   \   0000002E   0x.... 0x....      BL       QRinput_new2
   \   00000032   0x4606             MOV      R6,R0
    696          	}
    697          	if(input == NULL) return NULL;
   \                     ??QRcode_encodeDataReal_3: (+1)
   \   00000034   0x2E00             CMP      R6,#+0
   \   00000036   0xD101             BNE.N    ??QRcode_encodeDataReal_4
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xBD70             POP      {R4-R6,PC}
    698          
    699          	ret = QRinput_append(input, QR_MODE_8, length, data);
    700          	if(ret < 0) {
   \                     ??QRcode_encodeDataReal_4: (+1)
   \   0000003C   0x4623             MOV      R3,R4
   \   0000003E   0x462A             MOV      R2,R5
   \   00000040   0x2102             MOVS     R1,#+2
   \   00000042   0x4630             MOV      R0,R6
   \   00000044   0x.... 0x....      BL       QRinput_append
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0x4630             MOV      R0,R6
   \   0000004C   0xD503             BPL.N    ??QRcode_encodeDataReal_5
    701          		QRinput_free(input);
   \   0000004E   0x.... 0x....      BL       QRinput_free
    702          		return NULL;
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xBD70             POP      {R4-R6,PC}
    703          	}
    704          	code = QRcode_encodeInput(input);
   \                     ??QRcode_encodeDataReal_5: (+1)
   \   00000056   0x.... 0x....      BL       QRcode_encodeInput
   \   0000005A   0x4604             MOV      R4,R0
    705          	QRinput_free(input);
   \   0000005C   0x4630             MOV      R0,R6
   \   0000005E   0x.... 0x....      BL       QRinput_free
    706          
    707          	return code;
   \   00000062   0x4620             MOV      R0,R4
   \   00000064   0xBD70             POP      {R4-R6,PC}       ;; return
    708          }
    709          

   \                                 In section .text, align 2, keep-with-next
    710          QRcode *QRcode_encodeData(int size, const unsigned char *data, int version, QRecLevel level)
    711          {
   \                     QRcode_encodeData: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x460C             MOV      R4,R1
    712          	return QRcode_encodeDataReal(data, size, version, level, 0);
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x9100             STR      R1,[SP, #+0]
   \   0000000A   0x4601             MOV      R1,R0
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       QRcode_encodeDataReal
   \   00000012   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    713          }
    714          

   \                                 In section .text, align 2, keep-with-next
    715          QRcode *QRcode_encodeString8bit(const char *string, int version, QRecLevel level)
    716          {
   \                     QRcode_encodeString8bit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
    717          	if(string == NULL) {
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD106             BNE.N    ??QRcode_encodeString8bit_0
    718          		errno = EINVAL;
   \   0000000E   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000012   0xF04F 0x31FF      MOV      R1,#-1
   \   00000016   0x6001             STR      R1,[R0, #+0]
    719          		return NULL;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xBD76             POP      {R1,R2,R4-R6,PC}
    720          	}
    721          	return QRcode_encodeDataReal((unsigned char *)string, strlen(string), version, level, 0);
   \                     ??QRcode_encodeString8bit_0: (+1)
   \   0000001C   0x.... 0x....      BL       strlen
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x9100             STR      R1,[SP, #+0]
   \   00000024   0x4633             MOV      R3,R6
   \   00000026   0x462A             MOV      R2,R5
   \   00000028   0x4601             MOV      R1,R0
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       QRcode_encodeDataReal
   \   00000030   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    722          }
    723          

   \                                 In section .text, align 2, keep-with-next
    724          QRcode *QRcode_encodeDataMQR(int size, const unsigned char *data, int version, QRecLevel level)
    725          {
   \                     QRcode_encodeDataMQR: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x460C             MOV      R4,R1
    726          	return QRcode_encodeDataReal(data, size, version, level, 1);
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x9100             STR      R1,[SP, #+0]
   \   0000000A   0x4601             MOV      R1,R0
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       QRcode_encodeDataReal
   \   00000012   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    727          }
    728          

   \                                 In section .text, align 2, keep-with-next
    729          QRcode *QRcode_encodeString8bitMQR(const char *string, int version, QRecLevel level)
    730          {
   \                     QRcode_encodeString8bitMQR: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
    731          	if(string == NULL) {
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD106             BNE.N    ??QRcode_encodeString8bitMQR_0
    732          		errno = EINVAL;
   \   0000000E   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000012   0xF04F 0x31FF      MOV      R1,#-1
   \   00000016   0x6001             STR      R1,[R0, #+0]
    733          		return NULL;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xBD76             POP      {R1,R2,R4-R6,PC}
    734          	}
    735          	return QRcode_encodeDataReal((unsigned char *)string, strlen(string), version, level, 1);
   \                     ??QRcode_encodeString8bitMQR_0: (+1)
   \   0000001C   0x.... 0x....      BL       strlen
   \   00000020   0x2101             MOVS     R1,#+1
   \   00000022   0x9100             STR      R1,[SP, #+0]
   \   00000024   0x4633             MOV      R3,R6
   \   00000026   0x462A             MOV      R2,R5
   \   00000028   0x4601             MOV      R1,R0
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       QRcode_encodeDataReal
   \   00000030   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    736          }
    737          
    738          
    739          /******************************************************************************
    740           * Structured QR-code encoding
    741           *****************************************************************************/
    742          

   \                                 In section .text, align 2, keep-with-next
    743          static QRcode_List *QRcode_List_newEntry(void)
    744          {
   \                     QRcode_List_newEntry: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    745          	QRcode_List *entry;
    746          
    747          	entry = (QRcode_List *)malloc(sizeof(QRcode_List));
   \   00000002   0x2008             MOVS     R0,#+8
   \   00000004   0x.... 0x....      BL       malloc
    748          	if(entry == NULL) return NULL;
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD101             BNE.N    ??QRcode_List_newEntry_0
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xBD02             POP      {R1,PC}
    749          
    750          	entry->next = NULL;
   \                     ??QRcode_List_newEntry_0: (+1)
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6041             STR      R1,[R0, #+4]
    751          	entry->code = NULL;
   \   00000014   0x6001             STR      R1,[R0, #+0]
    752          
    753          	return entry;
   \   00000016   0xBD02             POP      {R1,PC}          ;; return
    754          }
    755          

   \                                 In section .text, align 2, keep-with-next
    756          static void QRcode_List_freeEntry(QRcode_List *entry)
    757          {
   \                     QRcode_List_freeEntry: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    758          	if(entry != NULL) {
   \   00000004   0xD007             BEQ.N    ??QRcode_List_freeEntry_0
    759          		QRcode_free(entry->code);
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       QRcode_free
    760          		free(entry);
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000012   0x.... 0x....      B.W      free
    761          	}
    762          }
   \                     ??QRcode_List_freeEntry_0: (+1)
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
    763          

   \                                 In section .text, align 2, keep-with-next
    764          void QRcode_List_free(QRcode_List *qrlist)
    765          {
   \                     QRcode_List_free: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    766          	QRcode_List *list = qrlist, *next;
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xE003             B.N      ??QRcode_List_free_0
    767          
    768          	while(list != NULL) {
    769          		next = list->next;
   \                     ??QRcode_List_free_1: (+1)
   \   00000006   0x6844             LDR      R4,[R0, #+4]
    770          		QRcode_List_freeEntry(list);
   \   00000008   0x.... 0x....      BL       QRcode_List_freeEntry
    771          		list = next;
   \   0000000C   0x0020             MOVS     R0,R4
    772          	}
   \                     ??QRcode_List_free_0: (+1)
   \   0000000E   0xD1FA             BNE.N    ??QRcode_List_free_1
    773          }
   \   00000010   0xBD10             POP      {R4,PC}          ;; return
    774          

   \                                 In section .text, align 2, keep-with-next
    775          int QRcode_List_size(QRcode_List *qrlist)
    776          {
    777          	QRcode_List *list = qrlist;
    778          	int size = 0;
   \                     QRcode_List_size: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xE001             B.N      ??QRcode_List_size_0
    779          
    780          	while(list != NULL) {
    781          		size++;
   \                     ??QRcode_List_size_1: (+1)
   \   00000004   0x1C49             ADDS     R1,R1,#+1
    782          		list = list->next;
   \   00000006   0x6840             LDR      R0,[R0, #+4]
    783          	}
   \                     ??QRcode_List_size_0: (+1)
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD1FB             BNE.N    ??QRcode_List_size_1
    784          
    785          	return size;
   \   0000000C   0x4608             MOV      R0,R1
   \   0000000E   0x4770             BX       LR               ;; return
    786          }
    787          
    788          #if 0
    789          static unsigned char QRcode_parity(const char *str, int size)
    790          {
    791          	unsigned char parity = 0;
    792          	int i;
    793          
    794          	for(i=0; i<size; i++) {
    795          		parity ^= str[i];
    796          	}
    797          
    798          	return parity;
    799          }
    800          #endif
    801          

   \                                 In section .text, align 2, keep-with-next
    802          QRcode_List *QRcode_encodeInputStructured(QRinput_Struct *s)
    803          {
   \                     QRcode_encodeInputStructured: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    804          	QRcode_List *head = NULL;
   \   00000002   0x2400             MOVS     R4,#+0
    805          	QRcode_List *tail = NULL;
   \   00000004   0x4625             MOV      R5,R4
    806          	QRcode_List *entry;
    807          	QRinput_InputList *list = s->head;
   \   00000006   0x6886             LDR      R6,[R0, #+8]
   \   00000008   0xE00C             B.N      ??QRcode_encodeInputStructured_0
    808          
    809          	while(list != NULL) {
    810          		if(head == NULL) {
    811          			entry = QRcode_List_newEntry();
    812          			if(entry == NULL) goto ABORT;
    813          			head = entry;
    814          			tail = head;
    815          		} else {
    816          			entry = QRcode_List_newEntry();
   \                     ??QRcode_encodeInputStructured_1: (+1)
   \   0000000A   0x.... 0x....      BL       QRcode_List_newEntry
   \   0000000E   0x0001             MOVS     R1,R0
    817          			if(entry == NULL) goto ABORT;
   \   00000010   0xD015             BEQ.N    ??QRcode_encodeInputStructured_2
    818          			tail->next = entry;
   \   00000012   0x6069             STR      R1,[R5, #+4]
    819          			tail = tail->next;
   \   00000014   0x4605             MOV      R5,R0
    820          		}
    821          		tail->code = QRcode_encodeInput(list->input);
   \                     ??QRcode_encodeInputStructured_3: (+1)
   \   00000016   0x6830             LDR      R0,[R6, #+0]
   \   00000018   0x.... 0x....      BL       QRcode_encodeInput
   \   0000001C   0x6028             STR      R0,[R5, #+0]
    822          		if(tail->code == NULL) {
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD00D             BEQ.N    ??QRcode_encodeInputStructured_2
    823          			goto ABORT;
    824          		}
    825          		list = list->next;
   \   00000022   0x6876             LDR      R6,[R6, #+4]
   \                     ??QRcode_encodeInputStructured_0: (+1)
   \   00000024   0x2E00             CMP      R6,#+0
   \   00000026   0xD008             BEQ.N    ??QRcode_encodeInputStructured_4
   \   00000028   0x2C00             CMP      R4,#+0
   \   0000002A   0xD1EE             BNE.N    ??QRcode_encodeInputStructured_1
   \   0000002C   0x.... 0x....      BL       QRcode_List_newEntry
   \   00000030   0x0001             MOVS     R1,R0
   \   00000032   0xD004             BEQ.N    ??QRcode_encodeInputStructured_2
   \   00000034   0x460C             MOV      R4,R1
   \   00000036   0x4625             MOV      R5,R4
   \   00000038   0xE7ED             B.N      ??QRcode_encodeInputStructured_3
    826          	}
    827          
    828          	return head;
   \                     ??QRcode_encodeInputStructured_4: (+1)
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0xBD70             POP      {R4-R6,PC}
    829          ABORT:
    830          	QRcode_List_free(head);
   \                     ??QRcode_encodeInputStructured_2: (+1)
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0x.... 0x....      BL       QRcode_List_free
    831          	return NULL;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xBD70             POP      {R4-R6,PC}       ;; return
    832          }
    833          

   \                                 In section .text, align 2, keep-with-next
    834          static QRcode_List *QRcode_encodeInputToStructured(QRinput *input)
    835          {
   \                     QRcode_encodeInputToStructured: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    836          	QRinput_Struct *s;
    837          	QRcode_List *codes;
    838          
    839          	s = QRinput_splitQRinputToStruct(input);
   \   00000002   0x.... 0x....      BL       QRinput_splitQRinputToStruct
   \   00000006   0x0004             MOVS     R4,R0
    840          	if(s == NULL) return NULL;
   \   00000008   0xD101             BNE.N    ??QRcode_encodeInputToStructured_0
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xBD32             POP      {R1,R4,R5,PC}
    841          
    842          	codes = QRcode_encodeInputStructured(s);
   \                     ??QRcode_encodeInputToStructured_0: (+1)
   \   0000000E   0x.... 0x....      BL       QRcode_encodeInputStructured
   \   00000012   0x4605             MOV      R5,R0
    843          	QRinput_Struct_free(s);
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       QRinput_Struct_free
    844          
    845          	return codes;
   \   0000001A   0x4628             MOV      R0,R5
   \   0000001C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    846          }
    847          

   \                                 In section .text, align 2, keep-with-next
    848          static QRcode_List *QRcode_encodeDataStructuredReal(
    849          	int size, const unsigned char *data,
    850          	int version, QRecLevel level,
    851          	int eightbit, QRencodeMode hint, int casesensitive)
    852          {
   \                     QRcode_encodeDataStructuredReal: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4610             MOV      R0,R2
   \   0000000A   0x4619             MOV      R1,R3
    853          	QRinput *input;
    854          	QRcode_List *codes;
    855          	int ret;
    856          
    857          	if(version <= 0) {
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xDA06             BGE.N    ??QRcode_encodeDataStructuredReal_0
    858          		errno = EINVAL;
   \   00000010   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000014   0xF04F 0x31FF      MOV      R1,#-1
   \   00000018   0x6001             STR      R1,[R0, #+0]
    859          		return NULL;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE034             B.N      ??QRcode_encodeDataStructuredReal_1
    860          	}
   \                     ??QRcode_encodeDataStructuredReal_0: (+1)
   \   0000001E   0x9E06             LDR      R6,[SP, #+24]
   \   00000020   0xF99D 0x701C      LDRSB    R7,[SP, #+28]
    861          	if(!eightbit && (hint != QR_MODE_8 && hint != QR_MODE_KANJI)) {
   \   00000024   0x2E00             CMP      R6,#+0
   \   00000026   0xD10B             BNE.N    ??QRcode_encodeDataStructuredReal_2
   \   00000028   0x463A             MOV      R2,R7
   \   0000002A   0x2A02             CMP      R2,#+2
   \   0000002C   0xD008             BEQ.N    ??QRcode_encodeDataStructuredReal_2
   \   0000002E   0x2A03             CMP      R2,#+3
   \   00000030   0xD006             BEQ.N    ??QRcode_encodeDataStructuredReal_2
    862          		errno = EINVAL;
   \   00000032   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000036   0xF04F 0x31FF      MOV      R1,#-1
   \   0000003A   0x6001             STR      R1,[R0, #+0]
    863          		return NULL;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xE023             B.N      ??QRcode_encodeDataStructuredReal_1
    864          	}
    865          
    866          	input = QRinput_new2(version, level);
   \                     ??QRcode_encodeDataStructuredReal_2: (+1)
   \   00000040   0x.... 0x....      BL       QRinput_new2
   \   00000044   0x4680             MOV      R8,R0
    867          	if(input == NULL) return NULL;
   \   00000046   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000004A   0xD101             BNE.N    ??QRcode_encodeDataStructuredReal_3
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xE01B             B.N      ??QRcode_encodeDataStructuredReal_1
    868          
    869          	if(eightbit) {
   \                     ??QRcode_encodeDataStructuredReal_3: (+1)
   \   00000050   0x2E00             CMP      R6,#+0
   \   00000052   0xD005             BEQ.N    ??QRcode_encodeDataStructuredReal_4
    870          		ret = QRinput_append(input, QR_MODE_8, size, data);
   \   00000054   0x462B             MOV      R3,R5
   \   00000056   0x4622             MOV      R2,R4
   \   00000058   0x2102             MOVS     R1,#+2
   \   0000005A   0x.... 0x....      BL       QRinput_append
   \   0000005E   0xE005             B.N      ??QRcode_encodeDataStructuredReal_5
    871          	} else {
    872          		ret = Split_splitStringToQRinput((char *)data, input, hint, casesensitive);
   \                     ??QRcode_encodeDataStructuredReal_4: (+1)
   \   00000060   0x9B08             LDR      R3,[SP, #+32]
   \   00000062   0x463A             MOV      R2,R7
   \   00000064   0x4641             MOV      R1,R8
   \   00000066   0x4628             MOV      R0,R5
   \   00000068   0x.... 0x....      BL       Split_splitStringToQRinput
    873          	}
    874          	if(ret < 0) {
   \                     ??QRcode_encodeDataStructuredReal_5: (+1)
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0x4640             MOV      R0,R8
   \   00000070   0xD503             BPL.N    ??QRcode_encodeDataStructuredReal_6
    875          		QRinput_free(input);
   \   00000072   0x.... 0x....      BL       QRinput_free
    876          		return NULL;
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xE006             B.N      ??QRcode_encodeDataStructuredReal_1
    877          	}
    878          	codes = QRcode_encodeInputToStructured(input);
   \                     ??QRcode_encodeDataStructuredReal_6: (+1)
   \   0000007A   0x.... 0x....      BL       QRcode_encodeInputToStructured
   \   0000007E   0x4604             MOV      R4,R0
    879          	QRinput_free(input);
   \   00000080   0x4640             MOV      R0,R8
   \   00000082   0x.... 0x....      BL       QRinput_free
    880          
    881          	return codes;
   \   00000086   0x4620             MOV      R0,R4
   \                     ??QRcode_encodeDataStructuredReal_1: (+1)
   \   00000088   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    882          }
    883          

   \                                 In section .text, align 2, keep-with-next
    884          QRcode_List *QRcode_encodeDataStructured(int size, const unsigned char *data, int version, QRecLevel level) {
   \                     QRcode_encodeDataStructured: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
    885          	return QRcode_encodeDataStructuredReal(size, data, version, level, 1, QR_MODE_NUL, 0);
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0x9402             STR      R4,[SP, #+8]
   \   00000008   0xF04F 0x34FF      MOV      R4,#-1
   \   0000000C   0x9401             STR      R4,[SP, #+4]
   \   0000000E   0x2401             MOVS     R4,#+1
   \   00000010   0x9400             STR      R4,[SP, #+0]
   \   00000012   0x.... 0x....      BL       QRcode_encodeDataStructuredReal
   \   00000016   0xB004             ADD      SP,SP,#+16
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
    886          }
    887          

   \                                 In section .text, align 2, keep-with-next
    888          QRcode_List *QRcode_encodeString8bitStructured(const char *string, int version, QRecLevel level) {
   \                     QRcode_encodeString8bitStructured: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    889          	if(string == NULL) {
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD106             BNE.N    ??QRcode_encodeString8bitStructured_0
    890          		errno = EINVAL;
   \   0000000C   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000010   0xF04F 0x31FF      MOV      R1,#-1
   \   00000014   0x6001             STR      R1,[R0, #+0]
    891          		return NULL;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xBD70             POP      {R4-R6,PC}
    892          	}
    893          	return QRcode_encodeDataStructured(strlen(string), (unsigned char *)string, version, level);
   \                     ??QRcode_encodeString8bitStructured_0: (+1)
   \   0000001A   0x.... 0x....      BL       strlen
   \   0000001E   0x4633             MOV      R3,R6
   \   00000020   0x462A             MOV      R2,R5
   \   00000022   0x4621             MOV      R1,R4
   \   00000024   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000028   0x....             B.N      QRcode_encodeDataStructured
    894          }
    895          

   \                                 In section .text, align 2, keep-with-next
    896          QRcode_List *QRcode_encodeStringStructured(const char *string, int version, QRecLevel level, QRencodeMode hint, int casesensitive)
    897          {
   \                     QRcode_encodeStringStructured: (+1)
   \   00000000   0xB5FE             PUSH     {R1-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0x461F             MOV      R7,R3
    898          	if(string == NULL) {
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD106             BNE.N    ??QRcode_encodeStringStructured_0
    899          		errno = EINVAL;
   \   0000000E   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000012   0xF04F 0x31FF      MOV      R1,#-1
   \   00000016   0x6001             STR      R1,[R0, #+0]
    900          		return NULL;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xBDFE             POP      {R1-R7,PC}
    901          	}
    902          	return QRcode_encodeDataStructuredReal(strlen(string), (unsigned char *)string, version, level, 0, hint, casesensitive);
   \                     ??QRcode_encodeStringStructured_0: (+1)
   \   0000001C   0x.... 0x....      BL       strlen
   \   00000020   0x9908             LDR      R1,[SP, #+32]
   \   00000022   0x9102             STR      R1,[SP, #+8]
   \   00000024   0x9701             STR      R7,[SP, #+4]
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0x9100             STR      R1,[SP, #+0]
   \   0000002A   0x4633             MOV      R3,R6
   \   0000002C   0x462A             MOV      R2,R5
   \   0000002E   0x4621             MOV      R1,R4
   \   00000030   0x.... 0x....      BL       QRcode_encodeDataStructuredReal
   \   00000034   0xBDFE             POP      {R1-R7,PC}       ;; return
    903          }
    904          
    905          /******************************************************************************
    906           * System utilities
    907           *****************************************************************************/
    908          /*
    909          void QRcode_APIVersion(int *major_version, int *minor_version, int *micro_version)
    910          {
    911          	if(major_version != NULL) {
    912          		*major_version = MAJOR_VERSION;
    913          	}
    914          	if(minor_version != NULL) {
    915          		*minor_version = MINOR_VERSION;
    916          	}
    917          	if(micro_version != NULL) {
    918          		*micro_version = MICRO_VERSION;
    919          	}
    920          }
    921          
    922          char *QRcode_APIVersionString(void)
    923          {
    924          	return VERSION;
    925          }
    926          */

   \                                 In section .text, align 2, keep-with-next
    927          void QRcode_clearCache(void)
    928          {
   \                     QRcode_clearCache: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    929          	QRspec_clearCache();
   \   00000002   0x.... 0x....      BL       QRspec_clearCache
    930          	MQRspec_clearCache();
   \   00000006   0x.... 0x....      BL       MQRspec_clearCache
    931          	free_rs_cache();
   \   0000000A   0xE8BD 0x4001      POP      {R0,LR}
   \   0000000E   0x.... 0x....      B.W      free_rs_cache
    932          }

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "QRinput\\274\\306\\313\\3434">`:
   \   00000000   0x51 0x52          DC8 "QRinput\274\306\313\3434"
   \              0x69 0x6E    
   \              0x70 0x75    
   \              0x74 0xBC    
   \              0xC6 0xCB    
   \              0xE3 0x34    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   FrameFiller_new
        16   -> malloc
      12   FrameFiller_next
       8   MQRraw_free
         0   -> free
         8   -> free
       0   MQRraw_getCode
      24   MQRraw_new
        24   -> MQRraw_free
        24   -> MQRspec_getDataLength
        24   -> MQRspec_getDataLengthBit
        24   -> MQRspec_getECCLength
        24   -> QRinput_getByteStream
        24   -> RSblock_initBlock
        24   -> calloc
        24   -> free
        24   -> init_rs
        24   -> malloc
       8   QRcode_List_free
         8   -> QRcode_List_freeEntry
       8   QRcode_List_freeEntry
         8   -> QRcode_free
         0   -> free
       8   QRcode_List_newEntry
         8   -> malloc
       0   QRcode_List_size
       8   QRcode_clearCache
         8   -> MQRspec_clearCache
         8   -> QRspec_clearCache
         0   -> free_rs_cache
      16   QRcode_encodeData
        16   -> QRcode_encodeDataReal
      16   QRcode_encodeDataMQR
        16   -> QRcode_encodeDataReal
      16   QRcode_encodeDataReal
        16   -> QRcode_encodeInput
        16   -> QRinput_append
        16   -> QRinput_free
        16   -> QRinput_new2
        16   -> QRinput_newMQR
        16   -> __aeabi_errno_addr
      24   QRcode_encodeDataStructured
        24   -> QRcode_encodeDataStructuredReal
      24   QRcode_encodeDataStructuredReal
        24   -> QRcode_encodeInputToStructured
        24   -> QRinput_append
        24   -> QRinput_free
        24   -> QRinput_new2
        24   -> Split_splitStringToQRinput
        24   -> __aeabi_errno_addr
       0   QRcode_encodeInput
         0   -> QRcode_encodeMask
         0   -> QRcode_encodeMaskMQR
      16   QRcode_encodeInputStructured
        16   -> QRcode_List_free
        16   -> QRcode_List_newEntry
        16   -> QRcode_encodeInput
      16   QRcode_encodeInputToStructured
        16   -> QRcode_encodeInputStructured
        16   -> QRinput_Struct_free
        16   -> QRinput_splitQRinputToStruct
      56   QRcode_encodeMask
        56   -> FrameFiller_new
        56   -> FrameFiller_next
        56   -> Mask_makeMask
        56   -> Mask_mask
        56   -> QRcode_new
        56   -> QRraw_free
        56   -> QRraw_getCode
        56   -> QRraw_new
        56   -> QRspec_getRemainder
        56   -> QRspec_getWidth
        56   -> QRspec_newFrame
        56   -> __aeabi_errno_addr
        56   -> free
        56   -> malloc
        56   -> memcpy
        56   -> printf
      56   QRcode_encodeMaskMQR
        56   -> FrameFiller_new
        56   -> FrameFiller_next
        56   -> MMask_makeMask
        56   -> MMask_mask
        56   -> MQRraw_free
        56   -> MQRraw_getCode
        56   -> MQRraw_new
        56   -> MQRspec_getWidth
        56   -> MQRspec_newFrame
        56   -> QRcode_new
        56   -> __aeabi_errno_addr
        56   -> free
      16   QRcode_encodeString
        16   -> QRcode_encodeStringReal
      24   QRcode_encodeString8bit
        24   -> QRcode_encodeDataReal
        24   -> __aeabi_errno_addr
        24   -> strlen
      24   QRcode_encodeString8bitMQR
        24   -> QRcode_encodeDataReal
        24   -> __aeabi_errno_addr
        24   -> strlen
      16   QRcode_encodeString8bitStructured
         0   -> QRcode_encodeDataStructured
        16   -> __aeabi_errno_addr
        16   -> strlen
      16   QRcode_encodeStringMQR
        16   -> QRcode_encodeStringReal
      16   QRcode_encodeStringReal
        16   -> QRcode_encodeInput
        16   -> QRinput_free
        16   -> QRinput_new2
        16   -> QRinput_newMQR
        16   -> Split_splitStringToQRinput
        16   -> __aeabi_errno_addr
      32   QRcode_encodeStringStructured
        32   -> QRcode_encodeDataStructuredReal
        32   -> __aeabi_errno_addr
        32   -> strlen
       8   QRcode_free
         0   -> free
         8   -> free
      16   QRcode_new
        16   -> malloc
       8   QRraw_free
         0   -> free
         8   -> free
       8   QRraw_getCode
      32   QRraw_new
        32   -> QRinput_getByteStream
        32   -> QRraw_free
        32   -> QRspec_getEccSpec
        32   -> RSblock_init
        32   -> calloc
        32   -> free
        32   -> malloc
      48   RSblock_init
        48   -> RSblock_initBlock
        48   -> init_rs
       8   RSblock_initBlock
         0   -> encode_rs_char


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      16  ?<Constant "QRinput\274\306\313\3434">
      44  FrameFiller_new
     154  FrameFiller_next
      36  MQRraw_free
      40  MQRraw_getCode
     196  MQRraw_new
      18  QRcode_List_free
      24  QRcode_List_freeEntry
      24  QRcode_List_newEntry
      16  QRcode_List_size
      18  QRcode_clearCache
      20  QRcode_encodeData
      20  QRcode_encodeDataMQR
     102  QRcode_encodeDataReal
      26  QRcode_encodeDataStructured
     140  QRcode_encodeDataStructuredReal
      14  QRcode_encodeInput
      72  QRcode_encodeInputStructured
      30  QRcode_encodeInputToStructured
     396  QRcode_encodeMask
     380  QRcode_encodeMaskMQR
      16  QRcode_encodeString
      50  QRcode_encodeString8bit
      50  QRcode_encodeString8bitMQR
      42  QRcode_encodeString8bitStructured
      16  QRcode_encodeStringMQR
     122  QRcode_encodeStringReal
      54  QRcode_encodeStringStructured
      24  QRcode_free
      30  QRcode_new
      36  QRraw_free
      86  QRraw_getCode
     172  QRraw_new
     200  RSblock_init
      24  RSblock_initBlock

 
 2 708 bytes in section .text
 
 2 708 bytes of CODE memory

Errors: none
Warnings: none
