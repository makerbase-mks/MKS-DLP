###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        16/Jul/2019  17:00:04
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\User\ui\QRENCODE\mqrspec.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\User\ui\QRENCODE\mqrspec.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Ucgui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\mqrspec.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\mqrspec.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\User\ui\QRENCODE\mqrspec.c
      1          /*
      2           * qrencode - QR Code encoder
      3           *
      4           * Micor QR Code specification in convenient format. 
      5           * Copyright (C) 2006-2011 Kentaro Fukuchi <kentaro@fukuchi.org>
      6           *
      7           * The following data / specifications are taken from
      8           * "Two dimensional symbol -- QR-code -- Basic Specification" (JIS X0510:2004)
      9           *  or
     10           * "Automatic identification and data capture techniques -- 
     11           *  QR Code 2005 bar code symbology specification" (ISO/IEC 18004:2006)
     12           *
     13           * This library is free software; you can redistribute it and/or
     14           * modify it under the terms of the GNU Lesser General Public
     15           * License as published by the Free Software Foundation; either
     16           * version 2.1 of the License, or any later version.
     17           *
     18           * This library is distributed in the hope that it will be useful,
     19           * but WITHOUT ANY WARRANTY; without even the implied warranty of
     20           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
     21           * Lesser General Public License for more details.
     22           *
     23           * You should have received a copy of the GNU Lesser General Public
     24           * License along with this library; if not, write to the Free Software
     25           * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
     26           */
     27          
     28          #if HAVE_CONFIG_H
     29          # include "config.h"
     30          #endif
     31          #include <stdio.h>
     32          #include <stdlib.h>
     33          #include <string.h>
     34          #include <errno.h>
     35          #ifdef HAVE_LIBPTHREAD
     36          #include <pthread.h>
     37          #endif
     38          
     39          #include "mqrspec.h"
     40          
     41          /******************************************************************************
     42           * Version and capacity
     43           *****************************************************************************/
     44          
     45          typedef struct {
     46          	int width; //< Edge length of the symbol符号的边缘长度
     47          	int ec[4];  //< Number of ECC code (bytes)ECC码数（字节）
     48          } MQRspec_Capacity;
     49          
     50          /**
     51           * Table of the capacity of symbols
     52           * See Table 1 (pp.106) and Table 8 (pp.113) of Appendix 1, JIS X0510:2004.
     53           */

   \                                 In section .text, align 4, keep-with-next
     54          static const MQRspec_Capacity mqrspecCapacity[MQRSPEC_VERSION_MAX + 1] = {
   \                     mqrspecCapacity:
   \   00000000   0x00000000         DC32 0, 0, 0, 0, 0, 11, 2, 0, 0, 0, 13, 5, 6, 0, 0, 15, 6, 8, 0, 0, 17
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x0000000B   
   \              0x00000002   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x0000000D   
   \              0x00000005   
   \              0x00000006   
   \              0x00000000   
   \              0x00000000   
   \              0x0000000F   
   \              0x00000006   
   \              0x00000008   
   \              0x00000000   
   \              0x00000000   
   \              0x00000011   
   \   00000054   0x00000008         DC32 8, 10, 14, 0
   \              0x0000000A   
   \              0x0000000E   
   \              0x00000000   
     55          	{  0, {0,  0,  0, 0}},
     56          	{ 11, {2,  0,  0, 0}},
     57          	{ 13, {5,  6,  0, 0}},
     58          	{ 15, {6,  8,  0, 0}},
     59          	{ 17, {8, 10, 14, 0}}
     60          };
     61          //获取数据位长度

   \                                 In section .text, align 2, keep-with-next
     62          int MQRspec_getDataLengthBit(int version, QRecLevel level)
     63          {
     64          	int w;
     65          	int ecc;
     66          
     67          	w = mqrspecCapacity[version].width - 1;//符号的边缘长度
   \                     MQRspec_getDataLengthBit: (+1)
   \   00000000   0xEB00 0x0280      ADD      R2,R0,R0, LSL #+2
   \   00000004   0x0090             LSLS     R0,R2,#+2
   \   00000006   0x.... 0x....      ADR.W    R2,mqrspecCapacity
   \   0000000A   0x5883             LDR      R3,[R0, R2]
   \   0000000C   0x1E5B             SUBS     R3,R3,#+1
     68          	ecc = mqrspecCapacity[version].ec[level];//ECC长度
   \   0000000E   0x1880             ADDS     R0,R0,R2
   \   00000010   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \   00000014   0x6840             LDR      R0,[R0, #+4]
     69          	if(ecc == 0) return 0;
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD101             BNE.N    ??MQRspec_getDataLengthBit_0
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x4770             BX       LR
     70          	return w * w - 64 - ecc * 8;
   \                     ??MQRspec_getDataLengthBit_0: (+1)
   \   0000001E   0xFB03 0xF103      MUL      R1,R3,R3
   \   00000022   0x3940             SUBS     R1,R1,#+64
   \   00000024   0xEBA1 0x00C0      SUB      R0,R1,R0, LSL #+3
   \   00000028   0x4770             BX       LR               ;; return
     71          }
     72          //获取数据长度

   \                                 In section .text, align 2, keep-with-next
     73          int MQRspec_getDataLength(int version, QRecLevel level)
     74          {
   \                     MQRspec_getDataLength: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     75          	return (MQRspec_getDataLengthBit(version, level) + 4) / 8;
   \   00000002   0x.... 0x....      BL       MQRspec_getDataLengthBit
   \   00000006   0x1D00             ADDS     R0,R0,#+4
   \   00000008   0x1081             ASRS     R1,R0,#+2
   \   0000000A   0xEB00 0x7051      ADD      R0,R0,R1, LSR #+29
   \   0000000E   0x10C0             ASRS     R0,R0,#+3
   \   00000010   0xBD02             POP      {R1,PC}          ;; return
     76          }
     77          //获取ECC长度

   \                                 In section .text, align 2, keep-with-next
     78          int MQRspec_getECCLength(int version, QRecLevel level)
     79          {
     80          	return mqrspecCapacity[version].ec[level];
   \                     MQRspec_getECCLength: (+1)
   \   00000000   0xEB00 0x0280      ADD      R2,R0,R0, LSL #+2
   \   00000004   0x.... 0x....      ADR.W    R0,mqrspecCapacity
   \   00000008   0xEB00 0x0082      ADD      R0,R0,R2, LSL #+2
   \   0000000C   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \   00000010   0x6840             LDR      R0,[R0, #+4]
   \   00000012   0x4770             BX       LR               ;; return
     81          }
     82          //获取长度

   \                                 In section .text, align 2, keep-with-next
     83          int MQRspec_getWidth(int version)
     84          {
     85          	return mqrspecCapacity[version].width;
   \                     MQRspec_getWidth: (+1)
   \   00000000   0xEB00 0x0180      ADD      R1,R0,R0, LSL #+2
   \   00000004   0x0088             LSLS     R0,R1,#+2
   \   00000006   0x.... 0x....      ADR.W    R1,mqrspecCapacity
   \   0000000A   0x5840             LDR      R0,[R0, R1]
   \   0000000C   0x4770             BX       LR               ;; return
     86          }
     87          
     88          /******************************************************************************
     89           * Length indicator
     90           *****************************************************************************/
     91          
     92          /**
     93           * See Table 3 (pp.107) of Appendix 1, JIS X0510:2004.
     94           */

   \                                 In section .text, align 4, keep-with-next
     95          static const int lengthTableBits[4][4] = {
   \                     lengthTableBits:
   \   00000000   0x00000003         DC32 3, 4, 5, 6, 0, 3, 4, 5, 0, 0, 4, 5, 0, 0, 3, 4
   \              0x00000004   
   \              0x00000005   
   \              0x00000006   
   \              0x00000000   
   \              0x00000003   
   \              0x00000004   
   \              0x00000005   
   \              0x00000000   
   \              0x00000000   
   \              0x00000004   
   \              0x00000005   
   \              0x00000000   
   \              0x00000000   
   \              0x00000003   
   \              0x00000004   
     96          	{ 3, 4, 5, 6},
     97          	{ 0, 3, 4, 5},
     98          	{ 0, 0, 4, 5},
     99          	{ 0, 0, 3, 4}
    100          };
    101          

   \                                 In section .text, align 2, keep-with-next
    102          int MQRspec_lengthIndicator(QRencodeMode mode, int version)
    103          {
    104          	return lengthTableBits[mode][version - 1];
   \                     MQRspec_lengthIndicator: (+1)
   \   00000000   0x.... 0x....      ADR.W    R2,lengthTableBits
   \   00000004   0xEB02 0x1000      ADD      R0,R2,R0, LSL #+4
   \   00000008   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \   0000000C   0xF850 0x0C04      LDR      R0,[R0, #-4]
   \   00000010   0x4770             BX       LR               ;; return
    105          }
    106          

   \                                 In section .text, align 2, keep-with-next
    107          int MQRspec_maximumWords(QRencodeMode mode, int version)
    108          {
    109          	int bits;
    110          	int words;
    111          
    112          	bits = lengthTableBits[mode][version - 1];
    113          	words = (1 << bits) - 1;
   \                     MQRspec_maximumWords: (+1)
   \   00000000   0x2201             MOVS     R2,#+1
   \   00000002   0x.... 0x....      ADR.W    R3,lengthTableBits
   \   00000006   0xEB03 0x1300      ADD      R3,R3,R0, LSL #+4
   \   0000000A   0xEB03 0x0181      ADD      R1,R3,R1, LSL #+2
   \   0000000E   0xF851 0x1C04      LDR      R1,[R1, #-4]
   \   00000012   0xFA02 0xF101      LSL      R1,R2,R1
   \   00000016   0x1E49             SUBS     R1,R1,#+1
    114          	if(mode == QR_MODE_KANJI) {
   \   00000018   0x2803             CMP      R0,#+3
   \   0000001A   0xD100             BNE.N    ??MQRspec_maximumWords_0
    115          		words *= 2; // the number of bytes is required
   \   0000001C   0x0049             LSLS     R1,R1,#+1
    116          	}
    117          
    118          	return words;
   \                     ??MQRspec_maximumWords_0: (+1)
   \   0000001E   0x4608             MOV      R0,R1
   \   00000020   0x4770             BX       LR               ;; return
    119          }
    120          
    121          /******************************************************************************
    122           * Format information
    123           *****************************************************************************/
    124          
    125          /* See calcFormatInfo in tests/test_mqrspec.c */

   \                                 In section .text, align 4, keep-with-next
    126          static const unsigned int formatInfo[4][8] = {
   \                     formatInfo:
   \   00000000   0x00004445         DC32 17477, 21934, 26515, 30328, 1758, 5941, 9480, 13539, 16754, 20633
   \              0x000055AE   
   \              0x00006793   
   \              0x00007678   
   \              0x000006DE   
   \              0x00001735   
   \              0x00002508   
   \              0x000034E3   
   \              0x00004172   
   \              0x00005099   
   \   00000028   0x000062A4         DC32 25252, 29519, 1001, 4610, 8255, 12756, 20011, 24512, 28157, 31766
   \              0x0000734F   
   \              0x000003E9   
   \              0x00001202   
   \              0x0000203F   
   \              0x000031D4   
   \              0x00004E2B   
   \              0x00005FC0   
   \              0x00006DFD   
   \              0x00007C16   
   \   00000050   0x00000CB0         DC32 3248, 7515, 12134, 16013, 19228, 23287, 26826, 31009, 2439, 6252
   \              0x00001D5B   
   \              0x00002F66   
   \              0x00003E8D   
   \              0x00004B1C   
   \              0x00005AF7   
   \              0x000068CA   
   \              0x00007921   
   \              0x00000987   
   \              0x0000186C   
   \   00000078   0x00002A51         DC32 10833, 15290
   \              0x00003BBA   
    127          	{0x4445, 0x55ae, 0x6793, 0x7678, 0x06de, 0x1735, 0x2508, 0x34e3},
    128          	{0x4172, 0x5099, 0x62a4, 0x734f, 0x03e9, 0x1202, 0x203f, 0x31d4},
    129          	{0x4e2b, 0x5fc0, 0x6dfd, 0x7c16, 0x0cb0, 0x1d5b, 0x2f66, 0x3e8d},
    130          	{0x4b1c, 0x5af7, 0x68ca, 0x7921, 0x0987, 0x186c, 0x2a51, 0x3bba}
    131          };
    132          
    133          /* See Table 10 of Appendix 1. (pp.115) */

   \                                 In section .text, align 4, keep-with-next
    134          static const int typeTable[MQRSPEC_VERSION_MAX + 1][3] = {
   \                     typeTable:
   \   00000000   0xFFFFFFFF         DC32 -1, -1, -1, 0, -1, -1, 1, 2, -1, 3, 4, -1, 5, 6, 7
   \              0xFFFFFFFF   
   \              0xFFFFFFFF   
   \              0x00000000   
   \              0xFFFFFFFF   
   \              0xFFFFFFFF   
   \              0x00000001   
   \              0x00000002   
   \              0xFFFFFFFF   
   \              0x00000003   
   \              0x00000004   
   \              0xFFFFFFFF   
   \              0x00000005   
   \              0x00000006   
   \              0x00000007   
    135          	{-1, -1, -1},
    136          	{ 0, -1, -1},
    137          	{ 1,  2, -1},
    138          	{ 3,  4, -1},
    139          	{ 5,  6,  7}
    140          };
    141          

   \                                 In section .text, align 2, keep-with-next
    142          unsigned int MQRspec_getFormatInfo(int mask, int version, QRecLevel level)
    143          {
    144          	int type;
    145          
    146          	if(mask < 0 || mask > 3) return 0;
   \                     MQRspec_getFormatInfo: (+1)
   \   00000000   0x2804             CMP      R0,#+4
   \   00000002   0xD301             BCC.N    ??MQRspec_getFormatInfo_0
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x4770             BX       LR
    147          	if(version <= 0 || version > MQRSPEC_VERSION_MAX) return 0;
   \                     ??MQRspec_getFormatInfo_0: (+1)
   \   00000008   0x1E4B             SUBS     R3,R1,#+1
   \   0000000A   0x2B04             CMP      R3,#+4
   \   0000000C   0xD301             BCC.N    ??MQRspec_getFormatInfo_1
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x4770             BX       LR
    148          	if(level == QR_ECLEVEL_H) return 0;
   \                     ??MQRspec_getFormatInfo_1: (+1)
   \   00000012   0x2A03             CMP      R2,#+3
   \   00000014   0xD101             BNE.N    ??MQRspec_getFormatInfo_2
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x4770             BX       LR
    149          	type = typeTable[version][level];
   \                     ??MQRspec_getFormatInfo_2: (+1)
   \   0000001A   0xEB01 0x0341      ADD      R3,R1,R1, LSL #+1
   \   0000001E   0x.... 0x....      ADR.W    R1,typeTable
   \   00000022   0xEB01 0x0183      ADD      R1,R1,R3, LSL #+2
   \   00000026   0xF851 0x1022      LDR      R1,[R1, R2, LSL #+2]
    150          	if(type < 0) return 0;
   \   0000002A   0x2900             CMP      R1,#+0
   \   0000002C   0xD501             BPL.N    ??MQRspec_getFormatInfo_3
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x4770             BX       LR
    151          
    152          	return formatInfo[mask][type];
   \                     ??MQRspec_getFormatInfo_3: (+1)
   \   00000032   0x.... 0x....      ADR.W    R2,formatInfo
   \   00000036   0xEB02 0x1040      ADD      R0,R2,R0, LSL #+5
   \   0000003A   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   0000003E   0x4770             BX       LR               ;; return
    153          }
    154          
    155          /******************************************************************************
    156           * Frame
    157           *****************************************************************************/
    158          
    159          /**
    160           * Cache of initial frames.
    161           */
    162          /* C99 says that static storage shall be initialized to a null pointer
    163           * by compiler. */

   \                                 In section .bss, align 4
    164          static unsigned char *frames[MQRSPEC_VERSION_MAX + 1];
   \                     frames:
   \   00000000                      DS8 20
    165          #ifdef HAVE_LIBPTHREAD
    166          static pthread_mutex_t frames_mutex = PTHREAD_MUTEX_INITIALIZER;
    167          #endif
    168          
    169          /**
    170           * Put a finder pattern.
    171           * @param frame
    172           * @param width
    173           * @param ox,oy upper-left coordinate of the pattern
    174           */

   \                                 In section .text, align 2, keep-with-next
    175          static void putFinderPattern(unsigned char *frame, int width, int ox, int oy)
    176          {
   \                     putFinderPattern: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    177          	static const unsigned char finder[] = {
    178          		0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1,
    179          		0xc1, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc1,
    180          		0xc1, 0xc0, 0xc1, 0xc1, 0xc1, 0xc0, 0xc1,
    181          		0xc1, 0xc0, 0xc1, 0xc1, 0xc1, 0xc0, 0xc1,
    182          		0xc1, 0xc0, 0xc1, 0xc1, 0xc1, 0xc0, 0xc1,
    183          		0xc1, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc1,
    184          		0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1,
    185          	};
    186          	int x, y;
    187          	const unsigned char *s;
    188          
    189          	frame += oy * width + ox;
   \   00000002   0xFB01 0x2203      MLA      R2,R1,R3,R2
   \   00000006   0x1810             ADDS     R0,R2,R0
    190          	s = finder;
   \   00000008   0x.... 0x....      ADR.W    R2,??finder
    191          	for(y=0; y<7; y++) {
   \   0000000C   0x2300             MOVS     R3,#+0
   \   0000000E   0xE008             B.N      ??putFinderPattern_0
    192          		for(x=0; x<7; x++) {
    193          			frame[x] = s[x];
   \                     ??putFinderPattern_1: (+1)
   \   00000010   0x5CA5             LDRB     R5,[R4, R2]
   \   00000012   0x5425             STRB     R5,[R4, R0]
    194          		}
   \   00000014   0x1C64             ADDS     R4,R4,#+1
   \                     ??putFinderPattern_2: (+1)
   \   00000016   0x2C07             CMP      R4,#+7
   \   00000018   0xDBFA             BLT.N    ??putFinderPattern_1
    195          		frame += width;
   \   0000001A   0x1808             ADDS     R0,R1,R0
    196          		s += 7;
   \   0000001C   0xF202 0x0207      ADDW     R2,R2,#+7
   \   00000020   0x1C5B             ADDS     R3,R3,#+1
   \                     ??putFinderPattern_0: (+1)
   \   00000022   0x2B07             CMP      R3,#+7
   \   00000024   0xDA01             BGE.N    ??putFinderPattern_3
   \   00000026   0x2400             MOVS     R4,#+0
   \   00000028   0xE7F5             B.N      ??putFinderPattern_2
    197          	}
    198          }
   \                     ??putFinderPattern_3: (+1)
   \   0000002A   0xBC30             POP      {R4,R5}
   \   0000002C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??finder:
   \   00000000   0xC1 0xC1          DC8 193, 193, 193, 193, 193, 193, 193, 193, 192, 192, 192, 192, 192
   \              0xC1 0xC1    
   \              0xC1 0xC1    
   \              0xC1 0xC1    
   \              0xC0 0xC0    
   \              0xC0 0xC0    
   \              0xC0         
   \   0000000D   0xC1 0xC1          DC8 193, 193, 192, 193, 193, 193, 192, 193, 193, 192, 193, 193, 193
   \              0xC0 0xC1    
   \              0xC1 0xC1    
   \              0xC0 0xC1    
   \              0xC1 0xC0    
   \              0xC1 0xC1    
   \              0xC1         
   \   0000001A   0xC0 0xC1          DC8 192, 193, 193, 192, 193, 193, 193, 192, 193, 193, 192, 192, 192
   \              0xC1 0xC0    
   \              0xC1 0xC1    
   \              0xC1 0xC0    
   \              0xC1 0xC1    
   \              0xC0 0xC0    
   \              0xC0         
   \   00000027   0xC0 0xC0          DC8 192, 192, 193, 193, 193, 193, 193, 193, 193, 193, 0, 0, 0
   \              0xC1 0xC1    
   \              0xC1 0xC1    
   \              0xC1 0xC1    
   \              0xC1 0xC1    
   \              0x00 0x00    
   \              0x00         
    199          

   \                                 In section .text, align 2, keep-with-next
    200          static unsigned char *MQRspec_createFrame(int version)
    201          {
   \                     MQRspec_createFrame: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    202          	unsigned char *frame, *p, *q;
    203          	int width;
    204          	int x, y;
    205          
    206          	width = mqrspecCapacity[version].width;
   \   00000002   0xEB00 0x0180      ADD      R1,R0,R0, LSL #+2
   \   00000006   0x0088             LSLS     R0,R1,#+2
   \   00000008   0x.... 0x....      ADR.W    R1,mqrspecCapacity
   \   0000000C   0x5844             LDR      R4,[R0, R1]
    207          	frame = (unsigned char *)malloc(width * width);
   \   0000000E   0xFB04 0xF604      MUL      R6,R4,R4
   \   00000012   0x4630             MOV      R0,R6
   \   00000014   0x.... 0x....      BL       malloc
   \   00000018   0x0005             MOVS     R5,R0
    208          	if(frame == NULL) return NULL;
   \   0000001A   0xD101             BNE.N    ??MQRspec_createFrame_0
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xBD70             POP      {R4-R6,PC}
    209          
    210          	memset(frame, 0, width * width);
   \                     ??MQRspec_createFrame_0: (+1)
   \   00000020   0x4632             MOV      R2,R6
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x.... 0x....      BL       memset
    211          	/* Finder pattern */
    212          	putFinderPattern(frame, width, 0, 0);
   \   00000028   0x2300             MOVS     R3,#+0
   \   0000002A   0x461A             MOV      R2,R3
   \   0000002C   0x4621             MOV      R1,R4
   \   0000002E   0x4628             MOV      R0,R5
   \   00000030   0x.... 0x....      BL       putFinderPattern
    213          	/* Separator */
    214          	p = frame;
   \   00000034   0x4628             MOV      R0,R5
    215          	for(y=0; y<7; y++) {
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x22C0             MOVS     R2,#+192
   \   0000003A   0xE002             B.N      ??MQRspec_createFrame_1
    216          		p[7] = 0xc0;
   \                     ??MQRspec_createFrame_2: (+1)
   \   0000003C   0x71C2             STRB     R2,[R0, #+7]
    217          		p += width;
   \   0000003E   0x1820             ADDS     R0,R4,R0
    218          	}
   \   00000040   0x1C49             ADDS     R1,R1,#+1
   \                     ??MQRspec_createFrame_1: (+1)
   \   00000042   0x2907             CMP      R1,#+7
   \   00000044   0xDBFA             BLT.N    ??MQRspec_createFrame_2
    219          	memset(frame + width * 7, 0xc0, 8);
   \   00000046   0x2208             MOVS     R2,#+8
   \   00000048   0x21C0             MOVS     R1,#+192
   \   0000004A   0xEBC4 0x00C4      RSB      R0,R4,R4, LSL #+3
   \   0000004E   0x1940             ADDS     R0,R0,R5
   \   00000050   0x.... 0x....      BL       memset
    220          	/* Mask format information area */
    221          	memset(frame + width * 8 + 1, 0x84, 8);
   \   00000054   0xEB05 0x06C4      ADD      R6,R5,R4, LSL #+3
   \   00000058   0x2208             MOVS     R2,#+8
   \   0000005A   0x2184             MOVS     R1,#+132
   \   0000005C   0x1C70             ADDS     R0,R6,#+1
   \   0000005E   0x.... 0x....      BL       memset
    222          	p = frame + width + 8;
   \   00000062   0x1960             ADDS     R0,R4,R5
   \   00000064   0x3008             ADDS     R0,R0,#+8
    223          	for(y=0; y<7; y++) {
   \   00000066   0x2100             MOVS     R1,#+0
   \   00000068   0x2284             MOVS     R2,#+132
   \   0000006A   0xE002             B.N      ??MQRspec_createFrame_3
    224          		*p = 0x84;
   \                     ??MQRspec_createFrame_4: (+1)
   \   0000006C   0x7002             STRB     R2,[R0, #+0]
    225          		p += width;
   \   0000006E   0x1820             ADDS     R0,R4,R0
    226          	}
   \   00000070   0x1C49             ADDS     R1,R1,#+1
   \                     ??MQRspec_createFrame_3: (+1)
   \   00000072   0x2907             CMP      R1,#+7
   \   00000074   0xDBFA             BLT.N    ??MQRspec_createFrame_4
    227          	/* Timing pattern */
    228          	p = frame + 8;
   \   00000076   0xF105 0x0008      ADD      R0,R5,#+8
    229          	q = frame + width * 8;
    230          	for(x=1; x<width-7; x++) {
   \   0000007A   0x2101             MOVS     R1,#+1
   \   0000007C   0xE008             B.N      ??MQRspec_createFrame_5
    231          		*p =  0x90 | (x & 1);
   \                     ??MQRspec_createFrame_6: (+1)
   \   0000007E   0xF001 0x0201      AND      R2,R1,#0x1
   \   00000082   0xF042 0x0290      ORR      R2,R2,#0x90
   \   00000086   0xF800 0x2B01      STRB     R2,[R0], #+1
    232          		*q =  0x90 | (x & 1);
   \   0000008A   0x7032             STRB     R2,[R6, #+0]
    233          		p++;
    234          		q += width;
   \   0000008C   0x19A6             ADDS     R6,R4,R6
    235          	}
   \   0000008E   0x1C49             ADDS     R1,R1,#+1
   \                     ??MQRspec_createFrame_5: (+1)
   \   00000090   0x1FE2             SUBS     R2,R4,#+7
   \   00000092   0x4291             CMP      R1,R2
   \   00000094   0xDBF3             BLT.N    ??MQRspec_createFrame_6
    236          
    237          	return frame;
   \   00000096   0x4628             MOV      R0,R5
   \   00000098   0xBD70             POP      {R4-R6,PC}       ;; return
    238          }
    239          

   \                                 In section .text, align 2, keep-with-next
    240          unsigned char *MQRspec_newFrame(int version)
    241          {
   \                     MQRspec_newFrame: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    242          	unsigned char *frame;
    243          	int width;
    244          
    245          	if(version < 1 || version > MQRSPEC_VERSION_MAX) return NULL;
   \   00000004   0x1E60             SUBS     R0,R4,#+1
   \   00000006   0x2804             CMP      R0,#+4
   \   00000008   0xD301             BCC.N    ??MQRspec_newFrame_0
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xBDF2             POP      {R1,R4-R7,PC}
    246          
    247          #ifdef HAVE_LIBPTHREAD
    248          	pthread_mutex_lock(&frames_mutex);
    249          #endif
    250          	if(frames[version] == NULL) {
   \                     ??MQRspec_newFrame_0: (+1)
   \   0000000E   0x....             LDR.N    R5,??DataTable6
   \   00000010   0xF855 0x0024      LDR      R0,[R5, R4, LSL #+2]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD104             BNE.N    ??MQRspec_newFrame_1
    251          		frames[version] = MQRspec_createFrame(version);
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       MQRspec_createFrame
   \   0000001E   0xF845 0x0024      STR      R0,[R5, R4, LSL #+2]
    252          	}
    253          #ifdef HAVE_LIBPTHREAD
    254          	pthread_mutex_unlock(&frames_mutex);
    255          #endif
    256          	if(frames[version] == NULL) return NULL;
   \                     ??MQRspec_newFrame_1: (+1)
   \   00000022   0xF855 0x0024      LDR      R0,[R5, R4, LSL #+2]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD101             BNE.N    ??MQRspec_newFrame_2
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xBDF2             POP      {R1,R4-R7,PC}
    257          
    258          	width = mqrspecCapacity[version].width;
   \                     ??MQRspec_newFrame_2: (+1)
   \   0000002E   0xEB04 0x0084      ADD      R0,R4,R4, LSL #+2
   \   00000032   0x0080             LSLS     R0,R0,#+2
   \   00000034   0x.... 0x....      ADR.W    R1,mqrspecCapacity
   \   00000038   0x5840             LDR      R0,[R0, R1]
    259          	frame = (unsigned char *)malloc(width * width);
   \   0000003A   0xFB00 0xF600      MUL      R6,R0,R0
   \   0000003E   0x4630             MOV      R0,R6
   \   00000040   0x.... 0x....      BL       malloc
   \   00000044   0x0007             MOVS     R7,R0
    260          	if(frame == NULL) return NULL;
   \   00000046   0xD101             BNE.N    ??MQRspec_newFrame_3
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xBDF2             POP      {R1,R4-R7,PC}
    261          	memcpy(frame, frames[version], width * width);
   \                     ??MQRspec_newFrame_3: (+1)
   \   0000004C   0x4632             MOV      R2,R6
   \   0000004E   0xF855 0x1024      LDR      R1,[R5, R4, LSL #+2]
   \   00000052   0x.... 0x....      BL       memcpy
    262          
    263          	return frame;
   \   00000056   0x4638             MOV      R0,R7
   \   00000058   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    264          }
    265          

   \                                 In section .text, align 2, keep-with-next
    266          void MQRspec_clearCache(void)
    267          {
   \                     MQRspec_clearCache: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    268          	int i;
    269          
    270          #ifdef HAVE_LIBPTHREAD
    271          	pthread_mutex_lock(&frames_mutex);
    272          #endif
    273          	for(i=1; i<=MQRSPEC_VERSION_MAX; i++) {
   \   00000002   0x2401             MOVS     R4,#+1
   \   00000004   0x....             LDR.N    R5,??DataTable6
   \   00000006   0xE007             B.N      ??MQRspec_clearCache_0
    274          		free(frames[i]);
   \                     ??MQRspec_clearCache_1: (+1)
   \   00000008   0xF855 0x0024      LDR      R0,[R5, R4, LSL #+2]
   \   0000000C   0x.... 0x....      BL       free
    275          		frames[i] = NULL;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xF845 0x0024      STR      R0,[R5, R4, LSL #+2]
    276          	}
   \   00000016   0x1C64             ADDS     R4,R4,#+1
   \                     ??MQRspec_clearCache_0: (+1)
   \   00000018   0x2C05             CMP      R4,#+5
   \   0000001A   0xDBF5             BLT.N    ??MQRspec_clearCache_1
    277          #ifdef HAVE_LIBPTHREAD
    278          	pthread_mutex_unlock(&frames_mutex);
    279          #endif
    280          }
   \   0000001C   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     frames

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   MQRspec_clearCache
        16   -> free
      16   MQRspec_createFrame
        16   -> malloc
        16   -> memset
        16   -> putFinderPattern
       8   MQRspec_getDataLength
         8   -> MQRspec_getDataLengthBit
       0   MQRspec_getDataLengthBit
       0   MQRspec_getECCLength
       0   MQRspec_getFormatInfo
       0   MQRspec_getWidth
       0   MQRspec_lengthIndicator
       0   MQRspec_maximumWords
      24   MQRspec_newFrame
        24   -> MQRspec_createFrame
        24   -> malloc
        24   -> memcpy
       8   putFinderPattern


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
      30  MQRspec_clearCache
     154  MQRspec_createFrame
      18  MQRspec_getDataLength
      42  MQRspec_getDataLengthBit
      20  MQRspec_getECCLength
      64  MQRspec_getFormatInfo
      14  MQRspec_getWidth
      18  MQRspec_lengthIndicator
      34  MQRspec_maximumWords
      90  MQRspec_newFrame
      52  finder
     128  formatInfo
      20  frames
      64  lengthTableBits
     100  mqrspecCapacity
      46  putFinderPattern
      60  typeTable

 
  20 bytes in section .bss
 938 bytes in section .text
 
 938 bytes of CODE memory
  20 bytes of DATA memory

Errors: none
Warnings: none
