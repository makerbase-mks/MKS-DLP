###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  10:58:22
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Core\GUICirc.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Core\GUICirc.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\GUICirc.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\GUICirc.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Core\GUICirc.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              µC/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : GUICirc.C
     16          Purpose     : Circle and ellipse drawing functions
     17          ----------------------------------------------------------------------
     18          Version-Date---Author-Explanation
     19          ----------------------------------------------------------------------
     20          1.00.02 011115 JE     a) GL_FillEllipse, GL_FillCircle, GL_DrawCircle changed
     21          1.00.01 011113 JE     a) GL_DrawEllipse changed
     22          1.00.00 991206 RS     First release
     23          ----------------------------------------------------------------------
     24          Known problems or limitations with current version
     25          ----------------------------------------------------------------------
     26          None.
     27          ----------------------------------------------------------------------
     28          Open issues
     29          ----------------------------------------------------------------------
     30          None
     31          ---------------------------END-OF-HEADER------------------------------
     32          */
     33          
     34          #include <stddef.h>           /* needed for definition of NULL */
     35          #include "GUI_Private.h"
     36          
     37          /*********************************************************************
     38          *
     39          *       Static code
     40          *
     41          **********************************************************************
     42          */
     43          /*********************************************************************
     44          *
     45          *       Draw8Point
     46          */

   \                                 In section .text, align 2, keep-with-next
     47          static void Draw8Point(int x0,int y0, int xoff, int yoff) {
   \                     Draw8Point: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4693             MOV      R11,R2
   \   0000000A   0x461E             MOV      R6,R3
     48            LCD_HL_DrawPixel(x0+xoff,y0+yoff);
   \   0000000C   0xEB0B 0x0704      ADD      R7,R11,R4
   \   00000010   0xEB06 0x0905      ADD      R9,R6,R5
   \   00000014   0x4649             MOV      R1,R9
   \   00000016   0x4638             MOV      R0,R7
   \   00000018   0x.... 0x....      BL       LCD_DrawPixel
     49            LCD_HL_DrawPixel(x0-xoff,y0+yoff);
   \   0000001C   0xEBA4 0x080B      SUB      R8,R4,R11
   \   00000020   0x4649             MOV      R1,R9
   \   00000022   0x4640             MOV      R0,R8
   \   00000024   0x.... 0x....      BL       LCD_DrawPixel
     50            LCD_HL_DrawPixel(x0+yoff,y0+xoff);
   \   00000028   0xEB06 0x0904      ADD      R9,R6,R4
   \   0000002C   0xEB0B 0x0A05      ADD      R10,R11,R5
   \   00000030   0x4651             MOV      R1,R10
   \   00000032   0x4648             MOV      R0,R9
   \   00000034   0x.... 0x....      BL       LCD_DrawPixel
     51            LCD_HL_DrawPixel(x0+yoff,y0-xoff);
   \   00000038   0xEBA5 0x0B0B      SUB      R11,R5,R11
   \   0000003C   0x4659             MOV      R1,R11
   \   0000003E   0x4648             MOV      R0,R9
   \   00000040   0x.... 0x....      BL       LCD_DrawPixel
     52            if (yoff) {
   \   00000044   0x2E00             CMP      R6,#+0
   \   00000046   0xD013             BEQ.N    ??Draw8Point_0
     53              LCD_HL_DrawPixel(x0+xoff,y0-yoff);
   \   00000048   0x1BAD             SUBS     R5,R5,R6
   \   0000004A   0x4629             MOV      R1,R5
   \   0000004C   0x4638             MOV      R0,R7
   \   0000004E   0x.... 0x....      BL       LCD_DrawPixel
     54              LCD_HL_DrawPixel(x0-xoff,y0-yoff);
   \   00000052   0x4629             MOV      R1,R5
   \   00000054   0x4640             MOV      R0,R8
   \   00000056   0x.... 0x....      BL       LCD_DrawPixel
     55              LCD_HL_DrawPixel(x0-yoff,y0+xoff);
   \   0000005A   0x1BA4             SUBS     R4,R4,R6
   \   0000005C   0x4651             MOV      R1,R10
   \   0000005E   0x4620             MOV      R0,R4
   \   00000060   0x.... 0x....      BL       LCD_DrawPixel
     56              LCD_HL_DrawPixel(x0-yoff,y0-xoff);
   \   00000064   0x4659             MOV      R1,R11
   \   00000066   0x4620             MOV      R0,R4
   \   00000068   0xE8BD 0x4FF4      POP      {R2,R4-R11,LR}
   \   0000006C   0x.... 0x....      B.W      LCD_DrawPixel
     57            }
     58          }
   \                     ??Draw8Point_0: (+1)
   \   00000070   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
     59          
     60          /*********************************************************************
     61          *
     62          *       Public code, circle
     63          *
     64          **********************************************************************
     65          */
     66          /*********************************************************************
     67          *
     68          *       GL_DrawCircle
     69          */

   \                                 In section .text, align 2, keep-with-next
     70          void GL_DrawCircle(int x0, int y0, int r) {
   \                     GL_DrawCircle: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
     71            I32 i;
     72            int imax = ((I32)((I32)r*707))/1000+1;
   \   0000000A   0xF240 0x20C3      MOVW     R0,#+707
   \   0000000E   0x4370             MULS     R0,R0,R6
   \   00000010   0xF44F 0x717A      MOV      R1,#+1000
   \   00000014   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000018   0x1C47             ADDS     R7,R0,#+1
     73            I32 sqmax = (I32)r*(I32)r+(I32)r/2;
   \   0000001A   0xEB06 0x70D6      ADD      R0,R6,R6, LSR #+31
   \   0000001E   0x1040             ASRS     R0,R0,#+1
   \   00000020   0xFB06 0x0806      MLA      R8,R6,R6,R0
     74            I32 y=r;
     75            Draw8Point(x0,y0,r,0);
   \   00000024   0x2300             MOVS     R3,#+0
   \   00000026   0x4629             MOV      R1,R5
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       Draw8Point
     76            for (i=1; i<= imax; i++) {
   \   0000002E   0xF04F 0x0901      MOV      R9,#+1
   \   00000032   0xE014             B.N      ??GL_DrawCircle_0
     77              if ((i*i+y*y) >sqmax) {
   \                     ??GL_DrawCircle_1: (+1)
   \   00000034   0xFB06 0xF006      MUL      R0,R6,R6
   \   00000038   0xFB09 0x0009      MLA      R0,R9,R9,R0
   \   0000003C   0x4580             CMP      R8,R0
   \   0000003E   0xDA06             BGE.N    ??GL_DrawCircle_2
     78                Draw8Point(x0,y0,i,y);
   \   00000040   0x4633             MOV      R3,R6
   \   00000042   0x464A             MOV      R2,R9
   \   00000044   0x4629             MOV      R1,R5
   \   00000046   0x4620             MOV      R0,R4
   \   00000048   0x.... 0x....      BL       Draw8Point
     79                y--;
   \   0000004C   0x1E76             SUBS     R6,R6,#+1
     80              }
     81              Draw8Point(x0,y0,i,y);
   \                     ??GL_DrawCircle_2: (+1)
   \   0000004E   0x4633             MOV      R3,R6
   \   00000050   0x464A             MOV      R2,R9
   \   00000052   0x4629             MOV      R1,R5
   \   00000054   0x4620             MOV      R0,R4
   \   00000056   0x.... 0x....      BL       Draw8Point
     82            }
   \   0000005A   0xF109 0x0901      ADD      R9,R9,#+1
   \                     ??GL_DrawCircle_0: (+1)
   \   0000005E   0x454F             CMP      R7,R9
   \   00000060   0xDAE8             BGE.N    ??GL_DrawCircle_1
     83          }
   \   00000062   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
     84          
     85          /*********************************************************************
     86          *
     87          *       GUI_DrawCircle
     88          */

   \                                 In section .text, align 2, keep-with-next
     89          void GUI_DrawCircle(int x0, int y0, int r) {
   \                     GUI_DrawCircle: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x4614             MOV      R4,R2
     90            #if (GUI_WINSUPPORT)
     91              GUI_RECT Rect;
     92            #endif
     93            GUI_LOCK();
     94            #if (GUI_WINSUPPORT)
     95              WM_ADDORG(x0,y0);
   \   00000004   0x....             LDR.N    R2,??DataTable3
   \   00000006   0x6C13             LDR      R3,[R2, #+64]
   \   00000008   0x181D             ADDS     R5,R3,R0
   \   0000000A   0x6C50             LDR      R0,[R2, #+68]
   \   0000000C   0x1846             ADDS     R6,R0,R1
     96              Rect.x0 = x0-r;
   \   0000000E   0x1B28             SUBS     R0,R5,R4
   \   00000010   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     97              Rect.x1 = x0+r;
   \   00000014   0x1960             ADDS     R0,R4,R5
   \   00000016   0xF8AD 0x0004      STRH     R0,[SP, #+4]
     98              Rect.y0 = y0-r;
   \   0000001A   0x1B30             SUBS     R0,R6,R4
   \   0000001C   0xF8AD 0x0002      STRH     R0,[SP, #+2]
     99              Rect.y1 = y0+r;
   \   00000020   0x19A0             ADDS     R0,R4,R6
   \   00000022   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    100              WM_ITERATE_START(&Rect); {
   \   00000026   0xA800             ADD      R0,SP,#+0
   \   00000028   0x.... 0x....      BL       WM__InitIVRSearch
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD008             BEQ.N    ??GUI_DrawCircle_0
    101            #endif
    102              GL_DrawCircle( x0, y0, r);
   \                     ??GUI_DrawCircle_1: (+1)
   \   00000030   0x4622             MOV      R2,R4
   \   00000032   0x4631             MOV      R1,R6
   \   00000034   0x4628             MOV      R0,R5
   \   00000036   0x.... 0x....      BL       GL_DrawCircle
    103            #if (GUI_WINSUPPORT)
    104              } WM_ITERATE_END();
   \   0000003A   0x.... 0x....      BL       WM__GetNextIVR
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD1F6             BNE.N    ??GUI_DrawCircle_1
    105            #endif
    106            GUI_UNLOCK();
    107          }
   \                     ??GUI_DrawCircle_0: (+1)
   \   00000042   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    108          
    109          /*********************************************************************
    110          *
    111          *       GL_FillCircle
    112          */

   \                                 In section .text, align 2, keep-with-next
    113          void GL_FillCircle(int x0, int y0, int r) {
   \                     GL_FillCircle: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4691             MOV      R9,R2
    114            I32 i;
    115            int imax = ((I32)((I32)r*707))/1000+1;
   \   0000000A   0xF240 0x20C3      MOVW     R0,#+707
   \   0000000E   0xFB00 0xF009      MUL      R0,R0,R9
   \   00000012   0xF44F 0x717A      MOV      R1,#+1000
   \   00000016   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000001A   0x1C46             ADDS     R6,R0,#+1
    116            I32 sqmax = (I32)r*(I32)r+(I32)r/2;
   \   0000001C   0xEB09 0x70D9      ADD      R0,R9,R9, LSR #+31
   \   00000020   0x1040             ASRS     R0,R0,#+1
   \   00000022   0xFB09 0x0709      MLA      R7,R9,R9,R0
    117            I32 x=r;
    118            LCD_HL_DrawHLine(x0-r,y0,x0+r);
   \   00000026   0xEB09 0x0204      ADD      R2,R9,R4
   \   0000002A   0x4629             MOV      R1,R5
   \   0000002C   0xEBA4 0x0009      SUB      R0,R4,R9
   \   00000030   0x.... 0x....      BL       LCD_DrawHLine
    119            for (i=1; i<= imax; i++) {
   \   00000034   0xF04F 0x0801      MOV      R8,#+1
   \   00000038   0xE02F             B.N      ??GL_FillCircle_0
    120              if ((i*i+x*x) >sqmax) {
   \                     ??GL_FillCircle_1: (+1)
   \   0000003A   0xFB09 0xF009      MUL      R0,R9,R9
   \   0000003E   0xFB08 0x0008      MLA      R0,R8,R8,R0
   \   00000042   0x4287             CMP      R7,R0
   \   00000044   0xDA17             BGE.N    ??GL_FillCircle_2
    121                /* draw lines from outside */
    122                if (x>imax) {
   \   00000046   0x454E             CMP      R6,R9
   \   00000048   0xDA13             BGE.N    ??GL_FillCircle_3
    123                  LCD_HL_DrawHLine (x0-i+1,y0+x, x0+i-1);
   \   0000004A   0xEBA4 0x0008      SUB      R0,R4,R8
   \   0000004E   0xF100 0x0A01      ADD      R10,R0,#+1
   \   00000052   0xEB08 0x0004      ADD      R0,R8,R4
   \   00000056   0xF1A0 0x0B01      SUB      R11,R0,#+1
   \   0000005A   0x465A             MOV      R2,R11
   \   0000005C   0xEB09 0x0105      ADD      R1,R9,R5
   \   00000060   0x4650             MOV      R0,R10
   \   00000062   0x.... 0x....      BL       LCD_DrawHLine
    124                  LCD_HL_DrawHLine (x0-i+1,y0-x, x0+i-1);
   \   00000066   0x465A             MOV      R2,R11
   \   00000068   0xEBA5 0x0109      SUB      R1,R5,R9
   \   0000006C   0x4650             MOV      R0,R10
   \   0000006E   0x.... 0x....      BL       LCD_DrawHLine
    125                }
    126                x--;
   \                     ??GL_FillCircle_3: (+1)
   \   00000072   0xF1A9 0x0901      SUB      R9,R9,#+1
    127              }
    128              /* draw lines from inside (center) */
    129              LCD_HL_DrawHLine(x0-x,y0+i, x0+x);
   \                     ??GL_FillCircle_2: (+1)
   \   00000076   0xEBA4 0x0A09      SUB      R10,R4,R9
   \   0000007A   0xEB09 0x0B04      ADD      R11,R9,R4
   \   0000007E   0x465A             MOV      R2,R11
   \   00000080   0xEB08 0x0105      ADD      R1,R8,R5
   \   00000084   0x4650             MOV      R0,R10
   \   00000086   0x.... 0x....      BL       LCD_DrawHLine
    130              LCD_HL_DrawHLine(x0-x,y0-i, x0+x);
   \   0000008A   0x465A             MOV      R2,R11
   \   0000008C   0xEBA5 0x0108      SUB      R1,R5,R8
   \   00000090   0x4650             MOV      R0,R10
   \   00000092   0x.... 0x....      BL       LCD_DrawHLine
    131            }
   \   00000096   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??GL_FillCircle_0: (+1)
   \   0000009A   0x4546             CMP      R6,R8
   \   0000009C   0xDACD             BGE.N    ??GL_FillCircle_1
    132          }
   \   0000009E   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
    133          
    134          /*********************************************************************
    135          *
    136          *       GUI_FillCircle
    137          */

   \                                 In section .text, align 2, keep-with-next
    138          void GUI_FillCircle(int x0, int y0, int r) {
   \                     GUI_FillCircle: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4614             MOV      R4,R2
    139            GUI_LOCK();
    140            #if (GUI_WINSUPPORT)
    141              WM_ADDORG(x0,y0);
   \   00000004   0x....             LDR.N    R2,??DataTable3
   \   00000006   0x6C13             LDR      R3,[R2, #+64]
   \   00000008   0x181D             ADDS     R5,R3,R0
   \   0000000A   0x6C50             LDR      R0,[R2, #+68]
   \   0000000C   0x1846             ADDS     R6,R0,R1
    142              WM_ITERATE_START(NULL); {
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x.... 0x....      BL       WM__InitIVRSearch
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD008             BEQ.N    ??GUI_FillCircle_0
    143            #endif
    144            GL_FillCircle(x0,y0,r);
   \                     ??GUI_FillCircle_1: (+1)
   \   00000018   0x4622             MOV      R2,R4
   \   0000001A   0x4631             MOV      R1,R6
   \   0000001C   0x4628             MOV      R0,R5
   \   0000001E   0x.... 0x....      BL       GL_FillCircle
    145            #if (GUI_WINSUPPORT)
    146              } WM_ITERATE_END();
   \   00000022   0x.... 0x....      BL       WM__GetNextIVR
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD1F6             BNE.N    ??GUI_FillCircle_1
    147            #endif
    148            GUI_UNLOCK();
    149          }
   \                     ??GUI_FillCircle_0: (+1)
   \   0000002A   0xBD70             POP      {R4-R6,PC}       ;; return
    150          
    151          /*********************************************************************
    152          *
    153          *       Public code, ellipse
    154          *
    155          * The most efficient way to calculate the ellipse positions is using
    156          * the knowledge that the ellipse is just circle which has compressed
    157          * (or stretched) in one direction. For a circle, the following
    158          * equation holds true for all points located on the border of it:
    159          *
    160          *               x^2 + y(x)^2 = r^2 = const
    161          *
    162          * Therefor, for an ellipse we can make use of the following equation:
    163          *
    164          *               (ry*x)^2 + (rx*y(x))^2 = (ry*rx)^2 = const
    165          *
    166          **********************************************************************
    167          */
    168          /*********************************************************************
    169          *
    170          *       GL_FillEllipse
    171          */

   \                                 In section .text, align 2, keep-with-next
    172          void GL_FillEllipse(int x0, int y0, int rx, int ry) {
   \                     GL_FillEllipse: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x461F             MOV      R7,R3
    173            I32 OutConst, Sum, SumY;
    174            int x,y;
    175            U32 _rx = rx;
    176            U32 _ry = ry;
    177            OutConst = _rx*_rx*_ry*_ry  /* Constant as explaint above */
    178                      +(_rx*_rx*_ry>>1); /* To compensate for rounding */
   \   0000000C   0xFB06 0xF006      MUL      R0,R6,R6
   \   00000010   0x4378             MULS     R0,R7,R0
   \   00000012   0x0841             LSRS     R1,R0,#+1
   \   00000014   0xFB07 0x1000      MLA      R0,R7,R0,R1
   \   00000018   0x9000             STR      R0,[SP, #+0]
    179            x = rx;
   \   0000001A   0x46B0             MOV      R8,R6
    180            for (y=0; y<=ry; y++) {
   \   0000001C   0xF04F 0x0900      MOV      R9,#+0
   \   00000020   0xE017             B.N      ??GL_FillEllipse_0
    181              SumY =((I32)(rx*rx))*((I32)(y*y)); /* Does not change in loop */
    182              while (Sum = SumY + ((I32)(ry*ry))*((I32)(x*x)),
    183                     (x>0) && (Sum>OutConst))
   \                     ??GL_FillEllipse_1: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \                     ??GL_FillEllipse_2: (+1)
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD11D             BNE.N    ??GL_FillEllipse_3
    184              {
    185                x--;
    186              }
    187              LCD_HL_DrawHLine(x0-x, y0+y, x0+x);
   \   00000028   0xEBA4 0x0A08      SUB      R10,R4,R8
   \   0000002C   0xEB08 0x0B04      ADD      R11,R8,R4
   \   00000030   0x465A             MOV      R2,R11
   \   00000032   0xEB09 0x0105      ADD      R1,R9,R5
   \   00000036   0x4650             MOV      R0,R10
   \   00000038   0x.... 0x....      BL       LCD_DrawHLine
    188              if (y)
   \   0000003C   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000040   0xD005             BEQ.N    ??GL_FillEllipse_4
    189                LCD_HL_DrawHLine(x0-x, y0-y, x0+x);
   \   00000042   0x465A             MOV      R2,R11
   \   00000044   0xEBA5 0x0109      SUB      R1,R5,R9
   \   00000048   0x4650             MOV      R0,R10
   \   0000004A   0x.... 0x....      BL       LCD_DrawHLine
   \                     ??GL_FillEllipse_4: (+1)
   \   0000004E   0xF109 0x0901      ADD      R9,R9,#+1
   \                     ??GL_FillEllipse_0: (+1)
   \   00000052   0x454F             CMP      R7,R9
   \   00000054   0xDB16             BLT.N    ??GL_FillEllipse_5
   \   00000056   0xFB06 0xF006      MUL      R0,R6,R6
   \   0000005A   0xFB09 0xF000      MUL      R0,R9,R0
   \   0000005E   0xFB09 0xF100      MUL      R1,R9,R0
   \   00000062   0xE001             B.N      ??GL_FillEllipse_6
   \                     ??GL_FillEllipse_3: (+1)
   \   00000064   0xF1A8 0x0801      SUB      R8,R8,#+1
   \                     ??GL_FillEllipse_6: (+1)
   \   00000068   0xF1B8 0x0F01      CMP      R8,#+1
   \   0000006C   0xDBD9             BLT.N    ??GL_FillEllipse_1
   \   0000006E   0x9800             LDR      R0,[SP, #+0]
   \   00000070   0xFB07 0xF207      MUL      R2,R7,R7
   \   00000074   0xFB08 0xF202      MUL      R2,R8,R2
   \   00000078   0xFB08 0x1202      MLA      R2,R8,R2,R1
   \   0000007C   0x4290             CMP      R0,R2
   \   0000007E   0xDAD0             BGE.N    ??GL_FillEllipse_1
   \   00000080   0x2001             MOVS     R0,#+1
   \   00000082   0xE7CF             B.N      ??GL_FillEllipse_2
    190            }
    191          }
   \                     ??GL_FillEllipse_5: (+1)
   \   00000084   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
    192          
    193          /*********************************************************************
    194          *
    195          *       GUI_FillEllipse
    196          */

   \                                 In section .text, align 2, keep-with-next
    197          void GUI_FillEllipse(int x0, int y0, int rx, int ry) {
   \                     GUI_FillEllipse: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x4614             MOV      R4,R2
   \   00000006   0x461D             MOV      R5,R3
    198            #if (GUI_WINSUPPORT)
    199              GUI_RECT r;
    200            #endif
    201            GUI_LOCK();
    202            #if (GUI_WINSUPPORT)
    203              WM_ADDORG(x0,y0);
   \   00000008   0x....             LDR.N    R2,??DataTable3
   \   0000000A   0x6C13             LDR      R3,[R2, #+64]
   \   0000000C   0x181E             ADDS     R6,R3,R0
   \   0000000E   0x6C50             LDR      R0,[R2, #+68]
   \   00000010   0x1847             ADDS     R7,R0,R1
    204              /* Calc rectangle in order to avoid unnecessary drawing ops. */
    205              r.x0 = x0-rx; r.x1 = x0+rx; r.y0 = y0-ry; r.y1 = y0+ry;
   \   00000012   0x1B30             SUBS     R0,R6,R4
   \   00000014   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   00000018   0x19A0             ADDS     R0,R4,R6
   \   0000001A   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   \   0000001E   0x1B78             SUBS     R0,R7,R5
   \   00000020   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   \   00000024   0x19E8             ADDS     R0,R5,R7
   \   00000026   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    206              WM_ITERATE_START(&r); {
   \   0000002A   0xA800             ADD      R0,SP,#+0
   \   0000002C   0x.... 0x....      BL       WM__InitIVRSearch
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD009             BEQ.N    ??GUI_FillEllipse_0
    207            #endif
    208            GL_FillEllipse (x0,y0, rx, ry);
   \                     ??GUI_FillEllipse_1: (+1)
   \   00000034   0x462B             MOV      R3,R5
   \   00000036   0x4622             MOV      R2,R4
   \   00000038   0x4639             MOV      R1,R7
   \   0000003A   0x4630             MOV      R0,R6
   \   0000003C   0x.... 0x....      BL       GL_FillEllipse
    209            #if (GUI_WINSUPPORT)
    210              } WM_ITERATE_END();
   \   00000040   0x.... 0x....      BL       WM__GetNextIVR
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD1F5             BNE.N    ??GUI_FillEllipse_1
    211            #endif
    212            GUI_UNLOCK();
    213          }
   \                     ??GUI_FillEllipse_0: (+1)
   \   00000048   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
    214          
    215          /*********************************************************************
    216          *
    217          *       GL_DrawEllipse
    218          */

   \                                 In section .text, align 2, keep-with-next
    219          void GL_DrawEllipse(int x0, int y0, int rx, int ry) {
   \                     GL_DrawEllipse: (+1)
   \   00000000   0xE92D 0x4FF6      PUSH     {R1,R2,R4-R11,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x461D             MOV      R5,R3
    220            I32 OutConst, Sum, SumY;
    221            int x,y;
    222            int xOld;
    223            U32 _rx = rx;
   \   0000000A   0x4610             MOV      R0,R2
    224            U32 _ry = ry;
    225            OutConst = _rx*_rx*_ry*_ry  /* Constant as explaint above */
    226                      +(_rx*_rx*_ry>>1); /* To compensate for rounding */
   \   0000000C   0x4340             MULS     R0,R0,R0
   \   0000000E   0x4368             MULS     R0,R5,R0
   \   00000010   0x0841             LSRS     R1,R0,#+1
   \   00000012   0xFB05 0x1000      MLA      R0,R5,R0,R1
   \   00000016   0x9003             STR      R0,[SP, #+12]
    227            xOld = x = rx;
   \   00000018   0x4616             MOV      R6,R2
   \   0000001A   0x9600             STR      R6,[SP, #+0]
    228            for (y=0; y<=ry; y++) {
   \   0000001C   0x2700             MOVS     R7,#+0
   \   0000001E   0xE034             B.N      ??GL_DrawEllipse_0
    229              if (y==ry) {
    230                x=0;
    231              } else {
    232                SumY =((I32)(rx*rx))*((I32)(y*y)); /* Does not change in loop */
    233                while (Sum = SumY + ((I32)(ry*ry))*((I32)(x*x)),
    234                       (x>0) && (Sum>OutConst)) x--;
   \                     ??GL_DrawEllipse_1: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \                     ??GL_DrawEllipse_2: (+1)
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD13E             BNE.N    ??GL_DrawEllipse_3
    235              }
    236              /* Since we draw lines, we can not draw on the first
    237                  iteration
    238              */
    239              if (y) {
   \                     ??GL_DrawEllipse_4: (+1)
   \   00000026   0x2F00             CMP      R7,#+0
   \   00000028   0xD02D             BEQ.N    ??GL_DrawEllipse_5
    240                GL_DrawLine1(x0-xOld,y0-y+1,x0-x,y0-y);
   \   0000002A   0x9805             LDR      R0,[SP, #+20]
   \   0000002C   0xEBA0 0x0807      SUB      R8,R0,R7
   \   00000030   0xF108 0x0001      ADD      R0,R8,#+1
   \   00000034   0x9002             STR      R0,[SP, #+8]
   \   00000036   0x9800             LDR      R0,[SP, #+0]
   \   00000038   0xEBA4 0x0900      SUB      R9,R4,R0
   \   0000003C   0xEBA4 0x0A06      SUB      R10,R4,R6
   \   00000040   0x4643             MOV      R3,R8
   \   00000042   0x4652             MOV      R2,R10
   \   00000044   0x9902             LDR      R1,[SP, #+8]
   \   00000046   0x4648             MOV      R0,R9
   \   00000048   0x.... 0x....      BL       GL_DrawLine1
    241                GL_DrawLine1(x0-xOld,y0+y-1,x0-x,y0+y);
   \   0000004C   0x9805             LDR      R0,[SP, #+20]
   \   0000004E   0xEB07 0x0B00      ADD      R11,R7,R0
   \   00000052   0xF1AB 0x0001      SUB      R0,R11,#+1
   \   00000056   0x9001             STR      R0,[SP, #+4]
   \   00000058   0x465B             MOV      R3,R11
   \   0000005A   0x4652             MOV      R2,R10
   \   0000005C   0x4601             MOV      R1,R0
   \   0000005E   0x4648             MOV      R0,R9
   \   00000060   0x.... 0x....      BL       GL_DrawLine1
    242                GL_DrawLine1(x0+xOld,y0-y+1,x0+x,y0-y);
   \   00000064   0x9800             LDR      R0,[SP, #+0]
   \   00000066   0xEB00 0x0904      ADD      R9,R0,R4
   \   0000006A   0xEB06 0x0A04      ADD      R10,R6,R4
   \   0000006E   0x4643             MOV      R3,R8
   \   00000070   0x4652             MOV      R2,R10
   \   00000072   0x9902             LDR      R1,[SP, #+8]
   \   00000074   0x4648             MOV      R0,R9
   \   00000076   0x.... 0x....      BL       GL_DrawLine1
    243                GL_DrawLine1(x0+xOld,y0+y-1,x0+x,y0+y);
   \   0000007A   0x465B             MOV      R3,R11
   \   0000007C   0x4652             MOV      R2,R10
   \   0000007E   0x9901             LDR      R1,[SP, #+4]
   \   00000080   0x4648             MOV      R0,R9
   \   00000082   0x.... 0x....      BL       GL_DrawLine1
    244              }
    245              xOld = x;
   \                     ??GL_DrawEllipse_5: (+1)
   \   00000086   0x9600             STR      R6,[SP, #+0]
   \   00000088   0x1C7F             ADDS     R7,R7,#+1
   \                     ??GL_DrawEllipse_0: (+1)
   \   0000008A   0x42BD             CMP      R5,R7
   \   0000008C   0xDB17             BLT.N    ??GL_DrawEllipse_6
   \   0000008E   0x42AF             CMP      R7,R5
   \   00000090   0xD101             BNE.N    ??GL_DrawEllipse_7
   \   00000092   0x2600             MOVS     R6,#+0
   \   00000094   0xE7C7             B.N      ??GL_DrawEllipse_4
   \                     ??GL_DrawEllipse_7: (+1)
   \   00000096   0x9806             LDR      R0,[SP, #+24]
   \   00000098   0x4601             MOV      R1,R0
   \   0000009A   0x4348             MULS     R0,R1,R0
   \   0000009C   0x4378             MULS     R0,R7,R0
   \   0000009E   0xFB07 0xF100      MUL      R1,R7,R0
   \   000000A2   0xE000             B.N      ??GL_DrawEllipse_8
   \                     ??GL_DrawEllipse_3: (+1)
   \   000000A4   0x1E76             SUBS     R6,R6,#+1
   \                     ??GL_DrawEllipse_8: (+1)
   \   000000A6   0x2E01             CMP      R6,#+1
   \   000000A8   0xDBBA             BLT.N    ??GL_DrawEllipse_1
   \   000000AA   0x9803             LDR      R0,[SP, #+12]
   \   000000AC   0xFB05 0xF205      MUL      R2,R5,R5
   \   000000B0   0x4372             MULS     R2,R6,R2
   \   000000B2   0xFB06 0x1202      MLA      R2,R6,R2,R1
   \   000000B6   0x4290             CMP      R0,R2
   \   000000B8   0xDAB2             BGE.N    ??GL_DrawEllipse_1
   \   000000BA   0x2001             MOVS     R0,#+1
   \   000000BC   0xE7B1             B.N      ??GL_DrawEllipse_2
    246            }
    247          }
   \                     ??GL_DrawEllipse_6: (+1)
   \   000000BE   0xB007             ADD      SP,SP,#+28
   \   000000C0   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    248          
    249          /*********************************************************************
    250          *
    251          *       GUI_DrawEllipse
    252          */

   \                                 In section .text, align 2, keep-with-next
    253          void GUI_DrawEllipse(int x0, int y0, int rx, int ry) {
   \                     GUI_DrawEllipse: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x4614             MOV      R4,R2
   \   00000006   0x461D             MOV      R5,R3
    254            #if (GUI_WINSUPPORT)
    255              GUI_RECT r;
    256            #endif
    257            GUI_LOCK();
    258            #if (GUI_WINSUPPORT)
    259              WM_ADDORG(x0,y0);
   \   00000008   0x....             LDR.N    R2,??DataTable3
   \   0000000A   0x6C13             LDR      R3,[R2, #+64]
   \   0000000C   0x181E             ADDS     R6,R3,R0
   \   0000000E   0x6C50             LDR      R0,[R2, #+68]
   \   00000010   0x1847             ADDS     R7,R0,R1
    260            /* Calc rectangle in order to avoid unnecessary drawing ops. */
    261              r.x0 = x0-rx; r.x1 = x0+rx; r.y0 = y0-ry; r.y1 = y0+ry;
   \   00000012   0x1B30             SUBS     R0,R6,R4
   \   00000014   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   00000018   0x19A0             ADDS     R0,R4,R6
   \   0000001A   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   \   0000001E   0x1B78             SUBS     R0,R7,R5
   \   00000020   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   \   00000024   0x19E8             ADDS     R0,R5,R7
   \   00000026   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    262              WM_ITERATE_START(&r); {
   \   0000002A   0xA800             ADD      R0,SP,#+0
   \   0000002C   0x.... 0x....      BL       WM__InitIVRSearch
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD009             BEQ.N    ??GUI_DrawEllipse_0
    263            #endif
    264            GL_DrawEllipse(x0, y0, rx, ry);
   \                     ??GUI_DrawEllipse_1: (+1)
   \   00000034   0x462B             MOV      R3,R5
   \   00000036   0x4622             MOV      R2,R4
   \   00000038   0x4639             MOV      R1,R7
   \   0000003A   0x4630             MOV      R0,R6
   \   0000003C   0x.... 0x....      BL       GL_DrawEllipse
    265            #if (GUI_WINSUPPORT)
    266              } WM_ITERATE_END();
   \   00000040   0x.... 0x....      BL       WM__GetNextIVR
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD1F5             BNE.N    ??GUI_DrawEllipse_1
    267            #endif
    268            GUI_UNLOCK();
    269          }
   \                     ??GUI_DrawEllipse_0: (+1)
   \   00000048   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     GUI_Context
    270          
    271          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   Draw8Point
         0   -> LCD_DrawPixel
        40   -> LCD_DrawPixel
      32   GL_DrawCircle
        32   -> Draw8Point
      64   GL_DrawEllipse
        64   -> GL_DrawLine1
      40   GL_FillCircle
        40   -> LCD_DrawHLine
      40   GL_FillEllipse
        40   -> LCD_DrawHLine
      24   GUI_DrawCircle
        24   -> GL_DrawCircle
        24   -> WM__GetNextIVR
        24   -> WM__InitIVRSearch
      32   GUI_DrawEllipse
        32   -> GL_DrawEllipse
        32   -> WM__GetNextIVR
        32   -> WM__InitIVRSearch
      16   GUI_FillCircle
        16   -> GL_FillCircle
        16   -> WM__GetNextIVR
        16   -> WM__InitIVRSearch
      32   GUI_FillEllipse
        32   -> GL_FillEllipse
        32   -> WM__GetNextIVR
        32   -> WM__InitIVRSearch


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
     116  Draw8Point
     102  GL_DrawCircle
     196  GL_DrawEllipse
     162  GL_FillCircle
     136  GL_FillEllipse
      68  GUI_DrawCircle
      74  GUI_DrawEllipse
      44  GUI_FillCircle
      74  GUI_FillEllipse

 
 976 bytes in section .text
 
 976 bytes of CODE memory

Errors: none
Warnings: none
