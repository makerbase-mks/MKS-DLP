###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  10:57:48
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Widget\EDIT.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Widget\EDIT.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\EDIT.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\EDIT.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Widget\EDIT.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              µC/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : EDIT.c
     16          Purpose     : Implementation of edit widget
     17          ---------------------------END-OF-HEADER------------------------------
     18          */
     19          
     20          #include <stdlib.h>
     21          #include <string.h>
     22          
     23          #define EDIT_C       /* Required to generate intermodule data */
     24          
     25          #include "EDIT.h"
     26          #include "GUIDebug.h"
     27          #include "GUI_Protected.h"
     28          #include "EDIT_Private.h"
     29          
     30          #if GUI_WINSUPPORT
     31          
     32          /*********************************************************************
     33          *
     34          *       Private config defaults
     35          *
     36          **********************************************************************
     37          */
     38          
     39          /* Define default fonts */
     40          #ifndef EDIT_FONT_DEFAULT
     41            #define EDIT_FONT_DEFAULT &GUI_Font13_1
     42          #endif
     43          
     44          #ifndef EDIT_ALIGN_DEFAULT
     45            #define EDIT_ALIGN_DEFAULT GUI_TA_LEFT | GUI_TA_VCENTER
     46          #endif
     47          
     48          /* Define colors */
     49          #ifndef EDIT_BKCOLOR0_DEFAULT
     50            #define EDIT_BKCOLOR0_DEFAULT 0xC0C0C0
     51          #endif
     52          
     53          #ifndef EDIT_BKCOLOR1_DEFAULT
     54            #define EDIT_BKCOLOR1_DEFAULT GUI_WHITE
     55          #endif
     56          
     57          #ifndef EDIT_TEXTCOLOR0_DEFAULT
     58            #define EDIT_TEXTCOLOR0_DEFAULT GUI_BLACK
     59          #endif
     60          
     61          #ifndef EDIT_TEXTCOLOR1_DEFAULT
     62            #define EDIT_TEXTCOLOR1_DEFAULT GUI_BLACK
     63          #endif
     64          
     65          #ifndef EDIT_BORDER_DEFAULT
     66            #define EDIT_BORDER_DEFAULT 1
     67          #endif
     68          
     69          #ifndef EDIT_XOFF
     70            #define EDIT_XOFF 1
     71          #endif
     72          
     73          /*********************************************************************
     74          *
     75          *       Static data
     76          *
     77          **********************************************************************
     78          */

   \                                 In section .data, align 4
     79          EDIT_PROPS EDIT__DefaultProps = {
   \                     EDIT__DefaultProps:
   \   00000000   0x0000000C         DC32 12, 1, GUI_Font13_1, 0, 0, 12632256, 16777215
   \              0x00000001   
   \              0x........   
   \              0x00000000   
   \              0x00000000   
   \              0x00C0C0C0   
   \              0x00FFFFFF   
     80            EDIT_ALIGN_DEFAULT,
     81            EDIT_BORDER_DEFAULT,
     82            EDIT_FONT_DEFAULT,
     83            EDIT_TEXTCOLOR0_DEFAULT,
     84            EDIT_TEXTCOLOR1_DEFAULT,
     85            EDIT_BKCOLOR0_DEFAULT,
     86            EDIT_BKCOLOR1_DEFAULT
     87          };
     88          
     89          /*********************************************************************
     90          *
     91          *       Macros for internal use
     92          *
     93          **********************************************************************
     94          */
     95          
     96          #if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
     97            #define OBJECT_ID 0x4569   /* Magic nubmer, should be unique if possible */
     98            #define INIT_ID(p)   p->DebugId = OBJECT_ID
     99            #define DEINIT_ID(p) p->DebugId = 0
    100          #else
    101            #define INIT_ID(p)
    102            #define DEINIT_ID(p)
    103          #endif
    104          
    105          /*********************************************************************
    106          *
    107          *       Static routines
    108          *
    109          **********************************************************************
    110          */
    111          /*********************************************************************
    112          *
    113          *       EDIT_h2p
    114          */
    115          #if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
    116          EDIT_Obj* EDIT_h2p(EDIT_Handle h) {
    117            EDIT_Obj* p = (EDIT_Obj*)GUI_ALLOC_h2p(h);
    118            if (p) {
    119          	  //houhh 20061022...
    120              if (p->DebugId != OBJECT_ID) {
    121                GUI_DEBUG_ERROROUT("EDIT.C: Wrong handle type or Object not init'ed");
    122                return 0;
    123              }
    124            }
    125            return p;
    126          }
    127          #endif
    128          
    129          ///////////houhh 20061018...

   \                                 In section .bss, align 2
    130          static GUI_TIMER_HANDLE Timer1 = 0;	//houhh 20061018...
   \                     Timer1:
   \   00000000                      DS8 2
    131          static void _Paint(EDIT_Obj* pObj, EDIT_Handle hObj) ;
    132          

   \                                 In section .text, align 2, keep-with-next
    133          void ShowCurrsor(GUI_TIMER_MESSAGE* TimeMsg)
    134          {
   \                     ShowCurrsor: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    135          	EDIT_Handle hObj = (EDIT_Handle) TimeMsg->Context;
   \   00000002   0x6844             LDR      R4,[R0, #+4]
    136          	EDIT_Obj*   pObj = (EDIT_Obj*) GUI_ALLOC_h2p(hObj);
   \   00000004   0x4620             MOV      R0,R4
   \   00000006   0xB200             SXTH     R0,R0
   \   00000008   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000000C   0x4605             MOV      R5,R0
    137          
    138              WM_Obj* pWin = WM_H2P(hObj);
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0xB200             SXTH     R0,R0
   \   00000012   0x.... 0x....      BL       GUI_ALLOC_h2p
    139          	GUI_DEBUG_LOG("EDIT: _Callback(WM_PAINT)\n");
    140              WM_SelectWindow(hObj);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0xB200             SXTH     R0,R0
   \   0000001A   0x.... 0x....      BL       WM_SelectWindow
    141          	_Paint(pObj, hObj);
   \   0000001E   0x4621             MOV      R1,R4
   \   00000020   0xB209             SXTH     R1,R1
   \   00000022   0x4628             MOV      R0,R5
   \   00000024   0x.... 0x....      BL       _Paint
    142          	pObj->CurrsorShow++;
   \   00000028   0x6F28             LDR      R0,[R5, #+112]
   \   0000002A   0x1C40             ADDS     R0,R0,#+1
   \   0000002C   0x6728             STR      R0,[R5, #+112]
    143          	GUI_TIMER_Restart(Timer1);
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable3
   \   00000032   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000036   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000003A   0x.... 0x....      B.W      GUI_TIMER_Restart
    144          
    145          }
    146          ///////
    147          
    148          /*********************************************************************
    149          *
    150          *       _Paint
    151          */

   \                                 In section .text, align 2, keep-with-next
    152          static void _Paint(EDIT_Obj* pObj, EDIT_Handle hObj) {
   \                     _Paint: (+1)
   \   00000000   0xE92D 0x4FF2      PUSH     {R1,R4-R11,LR}
   \   00000004   0xB08A             SUB      SP,SP,#+40
   \   00000006   0x4605             MOV      R5,R0
    153            GUI_RECT rFillRect, rInside, r, rText, rInvert;
    154            const char GUI_UNI_PTR * pText = NULL;
   \   00000008   0x2600             MOVS     R6,#+0
    155            int IsEnabled, CursorWidth;
    156            IsEnabled = WM__IsEnabled(hObj);
   \   0000000A   0x4608             MOV      R0,R1
   \   0000000C   0x.... 0x....      BL       WM__IsEnabled
    157            /* Set colors and font */
    158            LCD_SetBkColor(pObj->Props.aBkColor[IsEnabled]);
   \   00000010   0xEB05 0x0080      ADD      R0,R5,R0, LSL #+2
   \   00000014   0x6E80             LDR      R0,[R0, #+104]
   \   00000016   0x.... 0x....      BL       LCD_SetBkColor
    159            LCD_SetColor(pObj->Props.aTextColor[0]);
   \   0000001A   0xF105 0x0740      ADD      R7,R5,#+64
   \   0000001E   0x6A38             LDR      R0,[R7, #+32]
   \   00000020   0x.... 0x....      BL       LCD_SetColor
    160            GUI_SetFont(pObj->Props.pFont);
   \   00000024   0x69F8             LDR      R0,[R7, #+28]
   \   00000026   0x.... 0x....      BL       GUI_SetFont
    161            /* Calculate size */
    162            WM__GetClientRectWin(&pObj->Widget.Win, &r);
   \   0000002A   0xA908             ADD      R1,SP,#+32
   \   0000002C   0x4628             MOV      R0,R5
   \   0000002E   0x.... 0x....      BL       WM__GetClientRectWin
    163            WIDGET__GetInsideRect(&pObj->Widget, &rFillRect);
   \   00000032   0xA905             ADD      R1,SP,#+20
   \   00000034   0x4628             MOV      R0,R5
   \   00000036   0x.... 0x....      BL       WIDGET__GetInsideRect
   \   0000003A   0xF105 0x0026      ADD      R0,R5,#+38
   \   0000003E   0xF9B0 0x0002      LDRSH    R0,[R0, #+2]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD002             BEQ.N    ??_Paint_0
    164            if (pObj->hpText) {
    165              pText = (const char*) GUI_ALLOC_h2p(pObj->hpText);
   \   00000046   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000004A   0x4606             MOV      R6,R0
    166            }
    167            rInside = rFillRect;
   \                     ??_Paint_0: (+1)
   \   0000004C   0xE9DD 0x0105      LDRD     R0,R1,[SP, #+20]
   \   00000050   0xE9CD 0x0101      STRD     R0,R1,[SP, #+4]
    168            rInside.x0 += pObj->Props.Border + EDIT_XOFF;
   \   00000054   0xF8BD 0x0004      LDRH     R0,[SP, #+4]
   \   00000058   0x69B9             LDR      R1,[R7, #+24]
   \   0000005A   0x1C49             ADDS     R1,R1,#+1
   \   0000005C   0x1808             ADDS     R0,R1,R0
   \   0000005E   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    169            rInside.x1 -= pObj->Props.Border + EDIT_XOFF;
   \   00000062   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   00000066   0x69B9             LDR      R1,[R7, #+24]
   \   00000068   0x1A40             SUBS     R0,R0,R1
   \   0000006A   0x1E40             SUBS     R0,R0,#+1
   \   0000006C   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    170            GUI__CalcTextRect(pText, &rInside, &rText, pObj->Props.Align);
   \   00000070   0x697B             LDR      R3,[R7, #+20]
   \   00000072   0xAA03             ADD      R2,SP,#+12
   \   00000074   0xA901             ADD      R1,SP,#+4
   \   00000076   0x4630             MOV      R0,R6
   \   00000078   0x.... 0x....      BL       GUI__CalcTextRect
    171            /* Calculate position and size of cursor */
    172            if (pObj->Widget.State & WIDGET_STATE_FOCUS) {
   \   0000007C   0xF895 0x0026      LDRB     R0,[R5, #+38]
   \   00000080   0x07C0             LSLS     R0,R0,#+31
   \   00000082   0xD54F             BPL.N    ??_Paint_1
    173              const char GUI_UNI_PTR * p = pText;
   \   00000084   0x9607             STR      R6,[SP, #+28]
    174              CursorWidth = ((pObj->XSizeCursor > 0) ? (pObj->XSizeCursor) : (1));
   \   00000086   0x7A7C             LDRB     R4,[R7, #+9]
   \   00000088   0x2C00             CMP      R4,#+0
   \   0000008A   0xD100             BNE.N    ??_Paint_2
   \   0000008C   0x2401             MOVS     R4,#+1
    175              if (pText) {
   \                     ??_Paint_2: (+1)
   \   0000008E   0x2E00             CMP      R6,#+0
   \   00000090   0xD048             BEQ.N    ??_Paint_1
    176                U16 Char;
    177                int i;
    178          	//  pObj->SelSize = 3;	//houhh 20061023...
    179                if ((pObj->EditMode != GUI_EDIT_MODE_INSERT) || (pObj->SelSize)) {
   \   00000092   0x7A38             LDRB     R0,[R7, #+8]
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD102             BNE.N    ??_Paint_3
   \   00000098   0x6878             LDR      R0,[R7, #+4]
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD02A             BEQ.N    ??_Paint_4
    180                  int NumChars, CursorOffset;
    181                  NumChars = GUI__GetNumChars(pText);
   \                     ??_Paint_3: (+1)
   \   0000009E   0x4630             MOV      R0,R6
   \   000000A0   0x.... 0x....      BL       GUI__GetNumChars
    182                  if (pObj->CursorPos < NumChars) {
   \   000000A4   0xF8D5 0x8040      LDR      R8,[R5, #+64]
   \   000000A8   0x4580             CMP      R8,R0
   \   000000AA   0xDA23             BGE.N    ??_Paint_4
    183                    if (pObj->SelSize) {
   \   000000AC   0x6878             LDR      R0,[R7, #+4]
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD016             BEQ.N    ??_Paint_5
    184                      CursorWidth = 0;
   \   000000B2   0x2400             MOVS     R4,#+0
    185                      for (i = pObj->CursorPos; i < (int)(pObj->CursorPos + pObj->SelSize); i++) {
   \   000000B4   0xE00B             B.N      ??_Paint_6
    186                        CursorOffset = GUI_UC__NumChars2NumBytes(pText, i);
   \                     ??_Paint_7: (+1)
   \   000000B6   0x4641             MOV      R1,R8
   \   000000B8   0x4630             MOV      R0,R6
   \   000000BA   0x.... 0x....      BL       GUI_UC__NumChars2NumBytes
    187                        Char         = GUI_UC_GetCharCode      (pText + CursorOffset);
   \   000000BE   0x1980             ADDS     R0,R0,R6
   \   000000C0   0x.... 0x....      BL       GUI_UC_GetCharCode
    188                        CursorWidth += GUI_GetCharDistX        (Char);
   \   000000C4   0x.... 0x....      BL       GUI_GetCharDistX
   \   000000C8   0x1904             ADDS     R4,R0,R4
    189                      }
   \   000000CA   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??_Paint_6: (+1)
   \   000000CE   0x6C28             LDR      R0,[R5, #+64]
   \   000000D0   0x6879             LDR      R1,[R7, #+4]
   \   000000D2   0x1808             ADDS     R0,R1,R0
   \   000000D4   0x4580             CMP      R8,R0
   \   000000D6   0xDBEE             BLT.N    ??_Paint_7
    190                      if (!CursorWidth) {
   \   000000D8   0x2C00             CMP      R4,#+0
   \   000000DA   0xD10B             BNE.N    ??_Paint_4
    191                        CursorWidth = 1;
   \   000000DC   0x2401             MOVS     R4,#+1
   \   000000DE   0xE009             B.N      ??_Paint_4
    192                      }
    193                    } else {
    194                      CursorOffset = GUI_UC__NumChars2NumBytes(pText, pObj->CursorPos);
   \                     ??_Paint_5: (+1)
   \   000000E0   0x4641             MOV      R1,R8
   \   000000E2   0x4630             MOV      R0,R6
   \   000000E4   0x.... 0x....      BL       GUI_UC__NumChars2NumBytes
    195                      Char = GUI_UC_GetCharCode(pText + CursorOffset);
   \   000000E8   0x1980             ADDS     R0,R0,R6
   \   000000EA   0x.... 0x....      BL       GUI_UC_GetCharCode
    196                      CursorWidth = GUI_GetCharDistX(Char);
   \   000000EE   0x.... 0x....      BL       GUI_GetCharDistX
   \   000000F2   0x4604             MOV      R4,R0
    197                    }
    198                  }
    199                }
    200                rInvert = rText;
   \                     ??_Paint_4: (+1)
   \   000000F4   0xF9BD 0x800C      LDRSH    R8,[SP, #+12]
   \   000000F8   0xF8BD 0x000E      LDRH     R0,[SP, #+14]
   \   000000FC   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   00000100   0xF8BD 0x0012      LDRH     R0,[SP, #+18]
   \   00000104   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    201                for (i = 0; i != pObj->CursorPos; i++) {
   \   00000108   0xF04F 0x0900      MOV      R9,#+0
   \   0000010C   0xE007             B.N      ??_Paint_8
    202                  Char = GUI_UC__GetCharCodeInc(&p);
   \                     ??_Paint_9: (+1)
   \   0000010E   0xA807             ADD      R0,SP,#+28
   \   00000110   0x.... 0x....      BL       GUI_UC__GetCharCodeInc
    203                  rInvert.x0 += GUI_GetCharDistX(Char);
   \   00000114   0x.... 0x....      BL       GUI_GetCharDistX
   \   00000118   0x4480             ADD      R8,R0,R8
    204                }
   \   0000011A   0xF109 0x0901      ADD      R9,R9,#+1
   \                     ??_Paint_8: (+1)
   \   0000011E   0x6C28             LDR      R0,[R5, #+64]
   \   00000120   0x4581             CMP      R9,R0
   \   00000122   0xD1F4             BNE.N    ??_Paint_9
    205              }
    206            }
    207            /* WM loop */
    208            WM_ITERATE_START(NULL) {
   \                     ??_Paint_1: (+1)
   \   00000124   0x2000             MOVS     R0,#+0
   \   00000126   0x.... 0x....      BL       WM__InitIVRSearch
   \   0000012A   0x2800             CMP      R0,#+0
   \   0000012C   0xD056             BEQ.N    ??_Paint_10
    209              /* Set clipping rectangle */
    210              WM_SetUserClipRect(&rFillRect);
   \                     ??_Paint_11: (+1)
   \   0000012E   0xA805             ADD      R0,SP,#+20
   \   00000130   0x.... 0x....      BL       WM_SetUserClipRect
    211              /* Display text */
    212              WIDGET__FillStringInRect(pText, &rFillRect, &rInside, &rText);
   \   00000134   0xAB03             ADD      R3,SP,#+12
   \   00000136   0xAA01             ADD      R2,SP,#+4
   \   00000138   0xA905             ADD      R1,SP,#+20
   \   0000013A   0x4630             MOV      R0,R6
   \   0000013C   0x.... 0x....      BL       WIDGET__FillStringInRect
    213              /* Display cursor if needed */
    214              if (pObj->Widget.State & WIDGET_STATE_FOCUS) {
   \   00000140   0xF895 0x0026      LDRB     R0,[R5, #+38]
   \   00000144   0x07C0             LSLS     R0,R0,#+31
   \   00000146   0xD53F             BPL.N    ??_Paint_12
    215          		///////////////houhh 20061020...
    216          		//  static GUI_TIMER_HANDLE Timer1 = NULL;	//houhh 20061018...
    217          		if(!Timer1){
   \   00000148   0x.... 0x....      LDR.W    R9,??DataTable3
   \   0000014C   0xF9B9 0x0000      LDRSH    R0,[R9, #+0]
   \   00000150   0x2800             CMP      R0,#+0
   \   00000152   0xD113             BNE.N    ??_Paint_13
    218          			  Timer1 = GUI_TIMER_Create((GUI_TIMER_CALLBACK*)ShowCurrsor, 1000*2, 0, 0);	//houhh 20061018...
   \   00000154   0x2300             MOVS     R3,#+0
   \   00000156   0x461A             MOV      R2,R3
   \   00000158   0xF44F 0x61FA      MOV      R1,#+2000
   \   0000015C   0x.... 0x....      LDR.W    R0,??DataTable3_1
   \   00000160   0x.... 0x....      BL       GUI_TIMER_Create
   \   00000164   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    219          			  GUI_TIMER_SetTime(Timer1, 1000*2);
   \   00000168   0xF44F 0x61FA      MOV      R1,#+2000
   \   0000016C   0x.... 0x....      BL       GUI_TIMER_SetTime
    220          			  GUI_TIMER_SetPeriod(Timer1, 500);
   \   00000170   0xF44F 0x71FA      MOV      R1,#+500
   \   00000174   0xF9B9 0x0000      LDRSH    R0,[R9, #+0]
   \   00000178   0x.... 0x....      BL       GUI_TIMER_SetPeriod
    221          		  }
    222          		if(Timer1) GUI_TIMER_Context(Timer1, hObj);
   \                     ??_Paint_13: (+1)
   \   0000017C   0xF9B9 0x0000      LDRSH    R0,[R9, #+0]
   \   00000180   0x2800             CMP      R0,#+0
   \   00000182   0xD003             BEQ.N    ??_Paint_14
   \   00000184   0xF9BD 0x1028      LDRSH    R1,[SP, #+40]
   \   00000188   0x.... 0x....      BL       GUI_TIMER_Context
    223          		if(pObj->CurrsorShow%2) //houhh 20061022...
   \                     ??_Paint_14: (+1)
   \   0000018C   0x6B38             LDR      R0,[R7, #+48]
   \   0000018E   0xFA0F 0xF888      SXTH     R8,R8
   \   00000192   0x46C1             MOV      R9,R8
   \   00000194   0xEB04 0x0109      ADD      R1,R4,R9
   \   00000198   0xF1A1 0x0A01      SUB      R10,R1,#+1
   \   0000019C   0xF9BD 0xB002      LDRSH    R11,[SP, #+2]
   \   000001A0   0xEB00 0x71D0      ADD      R1,R0,R0, LSR #+31
   \   000001A4   0x1049             ASRS     R1,R1,#+1
   \   000001A6   0xEBB0 0x0041      SUBS     R0,R0,R1, LSL #+1
   \   000001AA   0xD006             BEQ.N    ??_Paint_15
    224          		  GUI_InvertRect(rInvert.x0, rInvert.y0, rInvert.x0 + CursorWidth - 1, rInvert.y1);
   \   000001AC   0x465B             MOV      R3,R11
   \   000001AE   0x4652             MOV      R2,R10
   \   000001B0   0xF9BD 0x1000      LDRSH    R1,[SP, #+0]
   \   000001B4   0x4648             MOV      R0,R9
   \   000001B6   0x.... 0x....      BL       GUI_InvertRect
    225          		/////////////
    226          		GUI_InvertRect(rInvert.x0, rInvert.y0, rInvert.x0 + CursorWidth - 1, rInvert.y1);
   \                     ??_Paint_15: (+1)
   \   000001BA   0x465B             MOV      R3,R11
   \   000001BC   0x4652             MOV      R2,R10
   \   000001BE   0xF9BD 0x1000      LDRSH    R1,[SP, #+0]
   \   000001C2   0x4648             MOV      R0,R9
   \   000001C4   0x.... 0x....      BL       GUI_InvertRect
    227              }
    228              WM_SetUserClipRect(NULL);
   \                     ??_Paint_12: (+1)
   \   000001C8   0x2000             MOVS     R0,#+0
   \   000001CA   0x.... 0x....      BL       WM_SetUserClipRect
    229              /* Draw the 3D effect (if configured) */
    230              WIDGET__EFFECT_DrawDown(&pObj->Widget);
   \   000001CE   0x4628             MOV      R0,R5
   \   000001D0   0x.... 0x....      BL       WIDGET__EFFECT_DrawDown
    231            } WM_ITERATE_END();
   \   000001D4   0x.... 0x....      BL       WM__GetNextIVR
   \   000001D8   0x2800             CMP      R0,#+0
   \   000001DA   0xD1A8             BNE.N    ??_Paint_11
    232          }
   \                     ??_Paint_10: (+1)
   \   000001DC   0xB00B             ADD      SP,SP,#+44
   \   000001DE   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    233          
    234          /*********************************************************************
    235          *
    236          *       _Delete
    237          */

   \                                 In section .text, align 2, keep-with-next
    238          static void _Delete(EDIT_Obj* pObj) {
    239            GUI_ALLOC_FreePtr(&pObj->hpText);
   \                     _Delete: (+1)
   \   00000000   0x3028             ADDS     R0,R0,#+40
   \   00000002   0x.... 0x....      B.W      GUI_ALLOC_FreePtr
    240          }
    241          
    242          /*********************************************************************
    243          *
    244          *       EDIT_SetCursorAtPixel
    245          */

   \                                 In section .text, align 2, keep-with-next
    246          void EDIT_SetCursorAtPixel(EDIT_Handle hObj, int xPos) {
   \                     EDIT_SetCursorAtPixel: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
    247            if (hObj) {
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD060             BEQ.N    ??EDIT_SetCursorAtPixel_0
    248              EDIT_Obj* pObj;
    249              WM_LOCK();
    250              pObj = EDIT_H2P(hObj);
   \   0000000E   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000012   0x4606             MOV      R6,R0
    251              if (pObj->hpText) {    
   \   00000014   0xF9B6 0x0028      LDRSH    R0,[R6, #+40]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD059             BEQ.N    ??EDIT_SetCursorAtPixel_0
    252                const GUI_FONT GUI_UNI_PTR *pOldFont;
    253                int xSize, TextWidth, NumChars;
    254                const char GUI_UNI_PTR * pText;
    255                pText = (char*) GUI_ALLOC_h2p(pObj->hpText);
   \   0000001C   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000020   0x9000             STR      R0,[SP, #+0]
    256                pOldFont = GUI_SetFont(pObj->Props.pFont);
   \   00000022   0x6DF0             LDR      R0,[R6, #+92]
   \   00000024   0x.... 0x....      BL       GUI_SetFont
   \   00000028   0x4607             MOV      R7,R0
    257                xSize = WM_GetWindowSizeX(hObj);
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       WM_GetWindowSizeX
   \   00000030   0x4680             MOV      R8,R0
    258                TextWidth = GUI_GetStringDistX(pText);
   \   00000032   0x9800             LDR      R0,[SP, #+0]
   \   00000034   0x.... 0x....      BL       GUI_GetStringDistX
   \   00000038   0x4681             MOV      R9,R0
    259                switch (pObj->Props.Align & GUI_TA_HORIZONTAL) {
   \   0000003A   0xF896 0x0054      LDRB     R0,[R6, #+84]
   \   0000003E   0xF000 0x0013      AND      R0,R0,#0x13
   \   00000042   0x2801             CMP      R0,#+1
   \   00000044   0xD009             BEQ.N    ??EDIT_SetCursorAtPixel_1
   \   00000046   0x2802             CMP      R0,#+2
   \   00000048   0xD10E             BNE.N    ??EDIT_SetCursorAtPixel_2
    260                case GUI_TA_HCENTER:
    261                  xPos -= (xSize - TextWidth + 1) / 2;
   \   0000004A   0xEBA8 0x0009      SUB      R0,R8,R9
   \   0000004E   0x1C40             ADDS     R0,R0,#+1
   \   00000050   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   00000054   0xEBA5 0x0560      SUB      R5,R5,R0, ASR #+1
    262                  break;
   \   00000058   0xE00C             B.N      ??EDIT_SetCursorAtPixel_3
    263                case GUI_TA_RIGHT:
    264                  xPos -= xSize - TextWidth - (pObj->Props.Border + EDIT_XOFF);
   \                     ??EDIT_SetCursorAtPixel_1: (+1)
   \   0000005A   0xEBA5 0x0008      SUB      R0,R5,R8
   \   0000005E   0x4448             ADD      R0,R9,R0
   \   00000060   0x6DB1             LDR      R1,[R6, #+88]
   \   00000062   0x1808             ADDS     R0,R1,R0
   \   00000064   0x1C45             ADDS     R5,R0,#+1
    265                  break;
   \   00000066   0xE005             B.N      ??EDIT_SetCursorAtPixel_3
    266                default:
    267                  xPos -= (pObj->Props.Border + EDIT_XOFF) + pObj->Widget.pEffect->EffectSize;
   \                     ??EDIT_SetCursorAtPixel_2: (+1)
   \   00000068   0x6DB0             LDR      R0,[R6, #+88]
   \   0000006A   0x1A28             SUBS     R0,R5,R0
   \   0000006C   0x6A31             LDR      R1,[R6, #+32]
   \   0000006E   0x6949             LDR      R1,[R1, #+20]
   \   00000070   0x1A40             SUBS     R0,R0,R1
   \   00000072   0x1E45             SUBS     R5,R0,#+1
    268                }
    269                NumChars = GUI__GetNumChars(pText);
   \                     ??EDIT_SetCursorAtPixel_3: (+1)
   \   00000074   0x9800             LDR      R0,[SP, #+0]
   \   00000076   0x.... 0x....      BL       GUI__GetNumChars
   \   0000007A   0x4680             MOV      R8,R0
    270                if (xPos < 0) {
   \   0000007C   0x2D00             CMP      R5,#+0
   \   0000007E   0xD504             BPL.N    ??EDIT_SetCursorAtPixel_4
    271                  EDIT__SetCursorPos(pObj, 0);
   \   00000080   0x2100             MOVS     R1,#+0
   \   00000082   0x4630             MOV      R0,R6
   \   00000084   0x.... 0x....      BL       EDIT__SetCursorPos
   \   00000088   0xE01C             B.N      ??EDIT_SetCursorAtPixel_5
    272                } else if (xPos > TextWidth) {
   \                     ??EDIT_SetCursorAtPixel_4: (+1)
   \   0000008A   0x45A9             CMP      R9,R5
   \   0000008C   0xDA04             BGE.N    ??EDIT_SetCursorAtPixel_6
    273                  EDIT__SetCursorPos(pObj, NumChars);
   \   0000008E   0x4641             MOV      R1,R8
   \   00000090   0x4630             MOV      R0,R6
   \   00000092   0x.... 0x....      BL       EDIT__SetCursorPos
   \   00000096   0xE015             B.N      ??EDIT_SetCursorAtPixel_5
    274                } else {
    275                  int i, x, xLenChar;
    276                  U16 Char;
    277                  for (i = 0, x = 0; (i < NumChars) && (x < xPos); i++) {
   \                     ??EDIT_SetCursorAtPixel_6: (+1)
   \   00000098   0xF04F 0x0900      MOV      R9,#+0
   \   0000009C   0x46CA             MOV      R10,R9
   \   0000009E   0xE001             B.N      ??EDIT_SetCursorAtPixel_7
    278                    Char     = GUI_UC__GetCharCodeInc(&pText);
    279                    xLenChar = GUI_GetCharDistX(Char);
    280                    if (xPos < (x + xLenChar))
    281                      break;
    282                    x += xLenChar;
   \                     ??EDIT_SetCursorAtPixel_8: (+1)
   \   000000A0   0xF109 0x0901      ADD      R9,R9,#+1
   \                     ??EDIT_SetCursorAtPixel_7: (+1)
   \   000000A4   0x45C1             CMP      R9,R8
   \   000000A6   0xDA09             BGE.N    ??EDIT_SetCursorAtPixel_9
   \   000000A8   0x45AA             CMP      R10,R5
   \   000000AA   0xDA07             BGE.N    ??EDIT_SetCursorAtPixel_9
   \   000000AC   0xA800             ADD      R0,SP,#+0
   \   000000AE   0x.... 0x....      BL       GUI_UC__GetCharCodeInc
   \   000000B2   0x.... 0x....      BL       GUI_GetCharDistX
   \   000000B6   0x4482             ADD      R10,R0,R10
   \   000000B8   0x4555             CMP      R5,R10
   \   000000BA   0xDAF1             BGE.N    ??EDIT_SetCursorAtPixel_8
    283                  }
    284                  EDIT__SetCursorPos(pObj, i);
   \                     ??EDIT_SetCursorAtPixel_9: (+1)
   \   000000BC   0x4649             MOV      R1,R9
   \   000000BE   0x4630             MOV      R0,R6
   \   000000C0   0x.... 0x....      BL       EDIT__SetCursorPos
    285                }
    286                GUI_SetFont(pOldFont);
   \                     ??EDIT_SetCursorAtPixel_5: (+1)
   \   000000C4   0x4638             MOV      R0,R7
   \   000000C6   0x.... 0x....      BL       GUI_SetFont
    287                EDIT_Invalidate(hObj);
   \   000000CA   0x4620             MOV      R0,R4
   \   000000CC   0x.... 0x....      BL       WM_InvalidateWindow
    288              }
    289              WM_UNLOCK();
    290            }
    291          }
   \                     ??EDIT_SetCursorAtPixel_0: (+1)
   \   000000D0   0xE8BD 0x87F3      POP      {R0,R1,R4-R10,PC}  ;; return
    292          
    293          /*********************************************************************
    294          *
    295          *       _IncrementBuffer
    296          *
    297          * Increments the buffer size by AddBytes.
    298          */

   \                                 In section .text, align 2, keep-with-next
    299          static int _IncrementBuffer(EDIT_Obj* pObj, unsigned AddBytes) {
   \                     _IncrementBuffer: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    300            WM_HMEM hNew;
    301            int NewSize;
    302            NewSize = pObj->BufferSize + AddBytes;
   \   00000004   0x8DA0             LDRH     R0,[R4, #+44]
   \   00000006   0xFA11 0xF580      UXTAH    R5,R1,R0
    303            hNew    = GUI_ALLOC_Realloc(pObj->hpText, NewSize);
   \   0000000A   0x4629             MOV      R1,R5
   \   0000000C   0xF9B4 0x0028      LDRSH    R0,[R4, #+40]
   \   00000010   0x.... 0x....      BL       GUI_ALLOC_Realloc
   \   00000014   0x0006             MOVS     R6,R0
    304            if (hNew) {
   \   00000016   0xD00C             BEQ.N    ??_IncrementBuffer_0
    305              if (!(pObj->hpText)) {
   \   00000018   0xF9B4 0x0028      LDRSH    R0,[R4, #+40]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD104             BNE.N    ??_IncrementBuffer_1
    306                char* pText;
    307                pText  = (char*) GUI_ALLOC_h2p(hNew);
   \   00000020   0x4630             MOV      R0,R6
   \   00000022   0x.... 0x....      BL       GUI_ALLOC_h2p
    308                *pText = 0;
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0x7001             STRB     R1,[R0, #+0]
    309              }
    310              pObj->BufferSize = NewSize;
   \                     ??_IncrementBuffer_1: (+1)
   \   0000002A   0x85A5             STRH     R5,[R4, #+44]
    311              pObj->hpText     = hNew;
   \   0000002C   0x8526             STRH     R6,[R4, #+40]
    312              return 1;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xBD70             POP      {R4-R6,PC}
    313            }
    314            return 0;
   \                     ??_IncrementBuffer_0: (+1)
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xBD70             POP      {R4-R6,PC}       ;; return
    315          }
    316          
    317          /*********************************************************************
    318          *
    319          *       _IsSpaceInBuffer
    320          *
    321          * Checks the available space in the buffer. If there is not enough
    322          * space left this function attempts to get more.
    323          *
    324          * Returns:
    325          *  1 = requested space is available
    326          *  0 = failed to get enough space
    327          */

   \                                 In section .text, align 2, keep-with-next
    328          static int _IsSpaceInBuffer(EDIT_Obj* pObj, int BytesNeeded) {
   \                     _IsSpaceInBuffer: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    329            int NumBytes = 0;
   \   00000006   0x2100             MOVS     R1,#+0
    330            if (pObj->hpText) {
   \   00000008   0xF9B4 0x0028      LDRSH    R0,[R4, #+40]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD004             BEQ.N    ??_IsSpaceInBuffer_0
    331              NumBytes = strlen((char*)GUI_ALLOC_h2p(pObj->hpText));
   \   00000010   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000014   0x.... 0x....      BL       strlen
   \   00000018   0x4601             MOV      R1,R0
    332            }
    333            BytesNeeded = (BytesNeeded + NumBytes + 1) - pObj->BufferSize;
   \                     ??_IsSpaceInBuffer_0: (+1)
   \   0000001A   0x1948             ADDS     R0,R1,R5
   \   0000001C   0x1C40             ADDS     R0,R0,#+1
   \   0000001E   0x8DA1             LDRH     R1,[R4, #+44]
   \   00000020   0x1A40             SUBS     R0,R0,R1
    334            if (BytesNeeded > 0) {
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xDB08             BLT.N    ??_IsSpaceInBuffer_1
    335              if (!_IncrementBuffer(pObj, BytesNeeded + EDIT_REALLOC_SIZE)) {
   \   00000026   0xF100 0x0110      ADD      R1,R0,#+16
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       _IncrementBuffer
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD101             BNE.N    ??_IsSpaceInBuffer_1
    336                return 0;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xBD32             POP      {R1,R4,R5,PC}
    337              }
    338            }
    339            return 1;
   \                     ??_IsSpaceInBuffer_1: (+1)
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    340          }
    341          
    342          /*********************************************************************
    343          *
    344          *       _IsCharsAvailable
    345          *
    346          * Checks weither the maximum number of characters is reached or not.
    347          *
    348          * Returns:
    349          *  1 = requested number of chars is available
    350          *  0 = maximum number of chars have reached
    351          */

   \                                 In section .text, align 2, keep-with-next
    352          static int _IsCharsAvailable(EDIT_Obj* pObj, int CharsNeeded) {
   \                     _IsCharsAvailable: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    353            if ((CharsNeeded > 0) && (pObj->MaxLen > 0)) {
   \   00000006   0x2D01             CMP      R5,#+1
   \   00000008   0xDB14             BLT.N    ??_IsCharsAvailable_0
   \   0000000A   0xF9B4 0x002A      LDRSH    R0,[R4, #+42]
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xDB10             BLT.N    ??_IsCharsAvailable_0
    354              int NumChars = 0;
   \   00000012   0x2100             MOVS     R1,#+0
    355              if (pObj->hpText) {
   \   00000014   0xF9B4 0x0028      LDRSH    R0,[R4, #+40]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD004             BEQ.N    ??_IsCharsAvailable_1
    356                NumChars = GUI__GetNumChars((char*)GUI_ALLOC_h2p(pObj->hpText));
   \   0000001C   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000020   0x.... 0x....      BL       GUI__GetNumChars
   \   00000024   0x4601             MOV      R1,R0
    357              }
    358              if ((CharsNeeded + NumChars) > pObj->MaxLen) {
   \                     ??_IsCharsAvailable_1: (+1)
   \   00000026   0xF9B4 0x002A      LDRSH    R0,[R4, #+42]
   \   0000002A   0x1949             ADDS     R1,R1,R5
   \   0000002C   0x4288             CMP      R0,R1
   \   0000002E   0xDA01             BGE.N    ??_IsCharsAvailable_0
    359                return 0;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xBD32             POP      {R1,R4,R5,PC}
    360              }
    361            }
    362            return 1;
   \                     ??_IsCharsAvailable_0: (+1)
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    363          }
    364          
    365          /*********************************************************************
    366          *
    367          *       _DeleteChar
    368          *
    369          * Deletes a character at the current cursor position and moves
    370          * all bytes after the cursor position.
    371          */

   \                                 In section .text, align 2, keep-with-next
    372          static void _DeleteChar(EDIT_Handle hObj, EDIT_Obj* pObj) {
   \                     _DeleteChar: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    373            if (pObj->hpText) {
   \   00000006   0xF9B5 0x0028      LDRSH    R0,[R5, #+40]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD019             BEQ.N    ??_DeleteChar_0
    374              unsigned CursorOffset;
    375              char* pText;
    376              pText = (char*) GUI_ALLOC_h2p(pObj->hpText);
   \   0000000E   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000012   0x4606             MOV      R6,R0
    377              CursorOffset = GUI_UC__NumChars2NumBytes(pText, pObj->CursorPos);
   \   00000014   0x6C29             LDR      R1,[R5, #+64]
   \   00000016   0x.... 0x....      BL       GUI_UC__NumChars2NumBytes
   \   0000001A   0x4605             MOV      R5,R0
    378              if (CursorOffset < strlen(pText)) {
   \   0000001C   0x4630             MOV      R0,R6
   \   0000001E   0x.... 0x....      BL       strlen
   \   00000022   0x4285             CMP      R5,R0
   \   00000024   0xD20D             BCS.N    ??_DeleteChar_0
    379                int NumBytes;
    380                pText += CursorOffset;
   \   00000026   0x19AE             ADDS     R6,R5,R6
    381                NumBytes = GUI_UC_GetCharSize(pText);
   \   00000028   0x4630             MOV      R0,R6
   \   0000002A   0x.... 0x....      BL       GUI_UC_GetCharSize
    382                strcpy(pText, pText + NumBytes);
   \   0000002E   0x1981             ADDS     R1,R0,R6
   \   00000030   0x4630             MOV      R0,R6
   \   00000032   0x.... 0x....      BL       strcpy
    383                WM_NotifyParent(hObj, WM_NOTIFICATION_VALUE_CHANGED);
   \   00000036   0x2105             MOVS     R1,#+5
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000003E   0x.... 0x....      B.W      WM_NotifyParent
    384              }
    385            }
    386          }
   \                     ??_DeleteChar_0: (+1)
   \   00000042   0xBD70             POP      {R4-R6,PC}       ;; return
    387          
    388          /*********************************************************************
    389          *
    390          *       _InsertChar
    391          *
    392          * Create space at the current cursor position and inserts a character.
    393          */

   \                                 In section .text, align 2, keep-with-next
    394          static int _InsertChar(EDIT_Handle hObj, EDIT_Obj* pObj, U16 Char) {
   \                     _InsertChar: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
    395            if (_IsCharsAvailable(pObj, 1)) {
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x4628             MOV      R0,R5
   \   0000000E   0x.... 0x....      BL       _IsCharsAvailable
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD025             BEQ.N    ??_InsertChar_0
    396              int BytesNeeded;
    397              BytesNeeded = GUI_UC__CalcSizeOfChar(Char);
   \   00000016   0x4630             MOV      R0,R6
   \   00000018   0x.... 0x....      BL       GUI_UC__CalcSizeOfChar
   \   0000001C   0x4607             MOV      R7,R0
    398              if (_IsSpaceInBuffer(pObj, BytesNeeded)) {
   \   0000001E   0x4639             MOV      R1,R7
   \   00000020   0x4628             MOV      R0,R5
   \   00000022   0x.... 0x....      BL       _IsSpaceInBuffer
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD01B             BEQ.N    ??_InsertChar_0
    399                int CursorOffset;
    400                char* pText;
    401                pText = (char*) GUI_ALLOC_h2p(pObj->hpText);
   \   0000002A   0xF9B5 0x0028      LDRSH    R0,[R5, #+40]
   \   0000002E   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000032   0x4680             MOV      R8,R0
    402                CursorOffset = GUI_UC__NumChars2NumBytes(pText, pObj->CursorPos);
    403                pText += CursorOffset;
   \   00000034   0x6C29             LDR      R1,[R5, #+64]
   \   00000036   0x.... 0x....      BL       GUI_UC__NumChars2NumBytes
   \   0000003A   0xEB00 0x0508      ADD      R5,R0,R8
    404                memmove(pText + BytesNeeded, pText, strlen(pText) + 1);
   \   0000003E   0x4628             MOV      R0,R5
   \   00000040   0x.... 0x....      BL       strlen
   \   00000044   0x1C42             ADDS     R2,R0,#+1
   \   00000046   0x4629             MOV      R1,R5
   \   00000048   0x1978             ADDS     R0,R7,R5
   \   0000004A   0x.... 0x....      BL       memmove
    405                GUI_UC_Encode(pText, Char);
   \   0000004E   0x4631             MOV      R1,R6
   \   00000050   0x4628             MOV      R0,R5
   \   00000052   0x.... 0x....      BL       GUI_UC_Encode
    406                WM_NotifyParent(hObj, WM_NOTIFICATION_VALUE_CHANGED);
   \   00000056   0x2105             MOVS     R1,#+5
   \   00000058   0x4620             MOV      R0,R4
   \   0000005A   0x.... 0x....      BL       WM_NotifyParent
    407                return 1;
   \   0000005E   0x2001             MOVS     R0,#+1
   \   00000060   0xE000             B.N      ??_InsertChar_1
    408              }
    409            }
    410            return 0;
   \                     ??_InsertChar_0: (+1)
   \   00000062   0x2000             MOVS     R0,#+0
   \                     ??_InsertChar_1: (+1)
   \   00000064   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    411          }
    412          
    413          /*********************************************************************
    414          *
    415          *       EDIT__GetCurrentChar
    416          */

   \                                 In section .text, align 2, keep-with-next
    417          U16 EDIT__GetCurrentChar(EDIT_Obj* pObj) {
   \                     EDIT__GetCurrentChar: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    418            U16 Char = 0;
   \   00000004   0x2000             MOVS     R0,#+0
    419            if (pObj->hpText) {
   \   00000006   0xF9B4 0x1028      LDRSH    R1,[R4, #+40]
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD00B             BEQ.N    ??EDIT__GetCurrentChar_0
    420              const char* pText;
    421              pText  = (const char*) GUI_ALLOC_h2p(pObj->hpText);
   \   0000000E   0x4608             MOV      R0,R1
   \   00000010   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000014   0x4605             MOV      R5,R0
    422              pText += GUI_UC__NumChars2NumBytes(pText, pObj->CursorPos);
   \   00000016   0x6C21             LDR      R1,[R4, #+64]
   \   00000018   0x.... 0x....      BL       GUI_UC__NumChars2NumBytes
   \   0000001C   0x1940             ADDS     R0,R0,R5
    423              Char   = GUI_UC_GetCharCode(pText);
   \   0000001E   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000022   0x.... 0x....      B.W      GUI_UC_GetCharCode
    424            }
    425            return Char;
   \                     ??EDIT__GetCurrentChar_0: (+1)
   \   00000026   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    426          }
    427          
    428          /*********************************************************************
    429          *
    430          *       EDIT__SetCursorPos
    431          *
    432          * Sets a new cursor position.
    433          */

   \                                 In section .text, align 2, keep-with-next
    434          void EDIT__SetCursorPos(EDIT_Obj* pObj, int CursorPos) {
   \                     EDIT__SetCursorPos: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460C             MOV      R4,R1
    435            if (pObj->hpText) {
   \   00000006   0xF9B5 0x0028      LDRSH    R0,[R5, #+40]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD01D             BEQ.N    ??EDIT__SetCursorPos_0
    436              char* pText;
    437              int NumChars, Offset;
    438              pText    = (char*) GUI_ALLOC_h2p(pObj->hpText);
   \   0000000E   0x.... 0x....      BL       GUI_ALLOC_h2p
    439              NumChars = GUI__GetNumChars(pText);
   \   00000012   0x.... 0x....      BL       GUI__GetNumChars
    440              Offset   = (pObj->EditMode == GUI_EDIT_MODE_INSERT) ? 0 : 1;
   \   00000016   0xF895 0x2048      LDRB     R2,[R5, #+72]
   \   0000001A   0x1E51             SUBS     R1,R2,#+1
   \   0000001C   0x4189             SBCS     R1,R1,R1
   \   0000001E   0x43C9             MVNS     R1,R1
    441              if (CursorPos < 0) {
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD500             BPL.N    ??EDIT__SetCursorPos_1
    442                CursorPos = 0;
   \   00000024   0x2400             MOVS     R4,#+0
    443              }
    444              if (CursorPos > NumChars) {
   \                     ??EDIT__SetCursorPos_1: (+1)
   \   00000026   0x42A0             CMP      R0,R4
   \   00000028   0xDC00             BGT.N    ??EDIT__SetCursorPos_2
   \   0000002A   0x4604             MOV      R4,R0
    445                CursorPos = NumChars;
    446              }
    447              if (CursorPos > (pObj->MaxLen - Offset)) {
   \                     ??EDIT__SetCursorPos_2: (+1)
   \   0000002C   0xF105 0x0028      ADD      R0,R5,#+40
   \   00000030   0xF9B0 0x2002      LDRSH    R2,[R0, #+2]
   \   00000034   0xEBB2 0x71D1      SUBS     R1,R2,R1, LSR #+31
   \   00000038   0x42A1             CMP      R1,R4
   \   0000003A   0xDA00             BGE.N    ??EDIT__SetCursorPos_3
    448                CursorPos = pObj->MaxLen - Offset;
   \   0000003C   0x460C             MOV      R4,R1
    449              }
    450              if (pObj->CursorPos != CursorPos) {
   \                     ??EDIT__SetCursorPos_3: (+1)
   \   0000003E   0x6981             LDR      R1,[R0, #+24]
   \   00000040   0x42A1             CMP      R1,R4
   \   00000042   0xD000             BEQ.N    ??EDIT__SetCursorPos_4
    451                pObj->CursorPos = CursorPos;
   \   00000044   0x6184             STR      R4,[R0, #+24]
    452              }
    453              pObj->SelSize = 0;
   \                     ??EDIT__SetCursorPos_4: (+1)
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0x61C1             STR      R1,[R0, #+28]
    454            }
    455          }
   \                     ??EDIT__SetCursorPos_0: (+1)
   \   0000004A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    456          
    457          /*********************************************************************
    458          *
    459          *       _OnTouch
    460          */

   \                                 In section .text, align 2, keep-with-next
    461          static void _OnTouch(EDIT_Handle hObj, EDIT_Obj* pObj, WM_MESSAGE*pMsg) {
   \                     _OnTouch: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
    462            const GUI_PID_STATE* pState = (const GUI_PID_STATE*)pMsg->Data.p;
   \   00000004   0x6891             LDR      R1,[R2, #+8]
    463            GUI_USE_PARA(pObj);
    464            if (pMsg->Data.p) {  /* Something happened in our area (pressed or released) */
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD008             BEQ.N    ??_OnTouch_0
    465          	  static int StartPress = 0;	//houhh 20061023...
                 	             ^
Warning[Pe550]: variable "StartPress" was set but never used
    466              if (pState->Pressed) {
   \   0000000A   0x7A0A             LDRB     R2,[R1, #+8]
   \   0000000C   0x2A00             CMP      R2,#+0
   \   0000000E   0xD005             BEQ.N    ??_OnTouch_0
    467                GUI_DEBUG_LOG1("EDIT__Callback(WM_TOUCH, Pressed, Handle %d)\n",1);
    468                EDIT_SetCursorAtPixel(hObj, pState->x);
   \   00000010   0x6809             LDR      R1,[R1, #+0]
   \   00000012   0x.... 0x....      BL       EDIT_SetCursorAtPixel
    469          	  StartPress = pObj->CursorPos;	//houhh 20061023...
   \   00000016   0x6C20             LDR      R0,[R4, #+64]
   \   00000018   0x....             LDR.N    R1,??DataTable3_2
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    470              } else {
    471                GUI_DEBUG_LOG1("EDIT__Callback(WM_TOUCH, Released, Handle %d)\n",1);
    472              }
    473            } else {
    474              GUI_DEBUG_LOG1("_EDIT_Callback(WM_TOUCH, Moved out, Handle %d)\n",1);
    475            }
    476          }
   \                     ??_OnTouch_0: (+1)
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .bss, align 4
   \                     ??StartPress:
   \   00000000                      DS8 4
    477          
    478          /*********************************************************************
    479          *
    480          *       EDIT__Callback
    481          */

   \                                 In section .text, align 2, keep-with-next
    482          static void EDIT__Callback (WM_MESSAGE * pMsg) {
   \                     EDIT__Callback: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    483            int IsEnabled;
    484            EDIT_Handle hObj = (EDIT_Handle) pMsg->hWin;
   \   00000004   0xF9B4 0x5004      LDRSH    R5,[R4, #+4]
    485            EDIT_Obj*   pObj = (EDIT_Obj*) GUI_ALLOC_h2p(hObj);
   \   00000008   0x4628             MOV      R0,R5
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000000E   0x4606             MOV      R6,R0
    486            IsEnabled = WM__IsEnabled(hObj);
   \   00000010   0x4628             MOV      R0,R5
   \   00000012   0x.... 0x....      BL       WM__IsEnabled
   \   00000016   0x4607             MOV      R7,R0
    487            /* Let widget handle the standard messages */
    488            if (WIDGET_HandleActive(hObj, pMsg) == 0) {
   \   00000018   0x4621             MOV      R1,R4
   \   0000001A   0x4628             MOV      R0,R5
   \   0000001C   0x.... 0x....      BL       WIDGET_HandleActive
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD013             BEQ.N    ??EDIT__Callback_0
    489              return;
    490            }
    491            switch (pMsg->MsgId) {
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x280B             CMP      R0,#+11
   \   00000028   0xD016             BEQ.N    ??EDIT__Callback_1
   \   0000002A   0x280C             CMP      R0,#+12
   \   0000002C   0xD004             BEQ.N    ??EDIT__Callback_2
   \   0000002E   0x280E             CMP      R0,#+14
   \   00000030   0xD016             BEQ.N    ??EDIT__Callback_3
   \   00000032   0x280F             CMP      R0,#+15
   \   00000034   0xD00B             BEQ.N    ??EDIT__Callback_4
   \   00000036   0xE004             B.N      ??EDIT__Callback_5
    492            case WM_TOUCH:
    493              _OnTouch(hObj, pObj, pMsg);
   \                     ??EDIT__Callback_2: (+1)
   \   00000038   0x4622             MOV      R2,R4
   \   0000003A   0x4631             MOV      R1,R6
   \   0000003C   0x4628             MOV      R0,R5
   \   0000003E   0x.... 0x....      BL       _OnTouch
    494              break;
    495            case WM_PAINT:
    496              GUI_DEBUG_LOG("EDIT: _Callback(WM_PAINT)\n");
    497              _Paint(pObj, hObj);
    498              return;
    499            case WM_DELETE:
    500              GUI_DEBUG_LOG("EDIT: _Callback(WM_DELETE)\n");
    501              _Delete(pObj);
    502              break;       /* No return here ... WM_DefaultProc needs to be called */
    503            case WM_KEY:
    504              if (IsEnabled) {
    505                if ( ((const WM_KEY_INFO*)(pMsg->Data.p))->PressedCnt >0) {
    506                  int Key = ((const WM_KEY_INFO*)(pMsg->Data.p))->Key;
    507                  switch (Key) {
    508                    case GUI_KEY_TAB:
    509                      break;                    /* Send to parent by not doing anything */
    510                    default:
    511                      EDIT_AddKey(hObj, Key);
    512                      return;
    513                  }
    514                }
    515              }
    516              break;
    517            }
    518            WM_DefaultProc(pMsg);
   \                     ??EDIT__Callback_5: (+1)
   \   00000042   0x4620             MOV      R0,R4
   \   00000044   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   00000048   0x.... 0x....      B.W      WM_DefaultProc
   \                     ??EDIT__Callback_0: (+1)
   \   0000004C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   \                     ??EDIT__Callback_4: (+1)
   \   0000004E   0x4629             MOV      R1,R5
   \   00000050   0x4630             MOV      R0,R6
   \   00000052   0xE8BD 0x40F4      POP      {R2,R4-R7,LR}
   \   00000056   0x....             B.N      _Paint
   \                     ??EDIT__Callback_1: (+1)
   \   00000058   0x4630             MOV      R0,R6
   \   0000005A   0x.... 0x....      BL       _Delete
   \   0000005E   0xE7F0             B.N      ??EDIT__Callback_5
   \                     ??EDIT__Callback_3: (+1)
   \   00000060   0x2F00             CMP      R7,#+0
   \   00000062   0xD0EE             BEQ.N    ??EDIT__Callback_5
   \   00000064   0x68A0             LDR      R0,[R4, #+8]
   \   00000066   0x6841             LDR      R1,[R0, #+4]
   \   00000068   0x2901             CMP      R1,#+1
   \   0000006A   0xDBEA             BLT.N    ??EDIT__Callback_5
   \   0000006C   0x6801             LDR      R1,[R0, #+0]
   \   0000006E   0x2909             CMP      R1,#+9
   \   00000070   0xD0E7             BEQ.N    ??EDIT__Callback_5
   \   00000072   0x4628             MOV      R0,R5
   \   00000074   0xE8BD 0x40F4      POP      {R2,R4-R7,LR}
   \   00000078   0x....             B.N      EDIT_AddKey
    519          }
    520          
    521          /*********************************************************************
    522          *
    523          *       Exported routines:  Create
    524          *
    525          **********************************************************************
    526          */
    527          /*********************************************************************
    528          *
    529          *       EDIT_CreateEx
    530          */

   \                                 In section .text, align 2, keep-with-next
    531          EDIT_Handle EDIT_CreateEx(int x0, int y0, int xsize, int ysize, WM_HWIN hParent, int WinFlags, int ExFlags,
    532                                    int Id, int MaxLen)
    533          {
   \                     EDIT_CreateEx: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    534            EDIT_Handle hObj;
    535            GUI_USE_PARA(ExFlags);
    536            /* Alloc memory for obj */
    537            WinFlags |= WM_CF_LATE_CLIP;    /* Always use late clipping since widget is optimized for it. */
    538            hObj = WM_CreateWindowAsChild(x0, y0, xsize, ysize, hParent, WM_CF_SHOW | WinFlags, EDIT__Callback,
    539                                          sizeof(EDIT_Obj) - sizeof(WM_Obj));
   \   00000004   0x2454             MOVS     R4,#+84
   \   00000006   0x9403             STR      R4,[SP, #+12]
   \   00000008   0x....             LDR.N    R4,??DataTable3_3
   \   0000000A   0x9402             STR      R4,[SP, #+8]
   \   0000000C   0x9C09             LDR      R4,[SP, #+36]
   \   0000000E   0xF444 0x5480      ORR      R4,R4,#0x1000
   \   00000012   0xF044 0x0402      ORR      R4,R4,#0x2
   \   00000016   0xB2A4             UXTH     R4,R4
   \   00000018   0x9401             STR      R4,[SP, #+4]
   \   0000001A   0xF9BD 0x4020      LDRSH    R4,[SP, #+32]
   \   0000001E   0x9400             STR      R4,[SP, #+0]
   \   00000020   0x.... 0x....      BL       WM_CreateWindowAsChild
   \   00000024   0x0004             MOVS     R4,R0
    540            if (hObj) {
   \   00000026   0xD025             BEQ.N    ??EDIT_CreateEx_0
    541              EDIT_Obj* pObj;
    542              WM_LOCK();
    543              pObj = (EDIT_Obj*)GUI_ALLOC_h2p(hObj);
   \   00000028   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000002C   0x4605             MOV      R5,R0
    544              /* init widget specific variables */
    545              WIDGET__Init(&pObj->Widget, Id, WIDGET_STATE_FOCUSSABLE);
   \   0000002E   0x2210             MOVS     R2,#+16
   \   00000030   0x990B             LDR      R1,[SP, #+44]
   \   00000032   0x.... 0x....      BL       WIDGET__Init
    546              /* init member variables */
    547              INIT_ID(pObj);
    548              pObj->Props         = EDIT__DefaultProps;
   \   00000036   0xF105 0x0054      ADD      R0,R5,#+84
   \   0000003A   0x....             LDR.N    R1,??DataTable3_4
   \   0000003C   0x221C             MOVS     R2,#+28
   \   0000003E   0x.... 0x....      BL       __aeabi_memcpy4
    549              pObj->XSizeCursor   = 1;
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0xF885 0x0049      STRB     R0,[R5, #+73]
   \   00000048   0x980C             LDR      R0,[SP, #+48]
    550              pObj->MaxLen        = (MaxLen == 0) ? 8 : MaxLen;
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD100             BNE.N    ??EDIT_CreateEx_1
   \   0000004E   0x2008             MOVS     R0,#+8
   \                     ??EDIT_CreateEx_1: (+1)
   \   00000050   0xF105 0x0128      ADD      R1,R5,#+40
   \   00000054   0x8048             STRH     R0,[R1, #+2]
    551              pObj->BufferSize    = 0;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x8088             STRH     R0,[R1, #+4]
    552              pObj->hpText        = 0;
   \   0000005A   0x8528             STRH     R0,[R5, #+40]
    553              if (_IncrementBuffer(pObj, pObj->MaxLen + 1) == 0) {
   \   0000005C   0xF9B1 0x0002      LDRSH    R0,[R1, #+2]
   \   00000060   0x1C41             ADDS     R1,R0,#+1
   \   00000062   0x4628             MOV      R0,R5
   \   00000064   0x.... 0x....      BL       _IncrementBuffer
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD103             BNE.N    ??EDIT_CreateEx_0
    554                GUI_DEBUG_ERROROUT("EDIT_Create failed to alloc buffer");
    555                EDIT_Delete(hObj);
   \   0000006C   0x4620             MOV      R0,R4
   \   0000006E   0x.... 0x....      BL       WM_DeleteWindow
    556                hObj = 0;
   \   00000072   0x2400             MOVS     R4,#+0
    557              }
    558              WM_UNLOCK();
    559            }
    560            return hObj;
   \                     ??EDIT_CreateEx_0: (+1)
   \   00000074   0x4620             MOV      R0,R4
   \   00000076   0xB005             ADD      SP,SP,#+20
   \   00000078   0xBD30             POP      {R4,R5,PC}       ;; return
    561          }
    562          
    563          /*********************************************************************
    564          *
    565          *       Exported routines:  Various methods
    566          *
    567          **********************************************************************
    568          */
    569          /*********************************************************************
    570          *
    571          *       EDIT_AddKey
    572          */

   \                                 In section .text, align 2, keep-with-next
    573          void EDIT_AddKey(EDIT_Handle hObj, int Key) {
   \                     EDIT_AddKey: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460E             MOV      R6,R1
    574            if (hObj) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xF000 0x80A0      BEQ.W    ??EDIT_AddKey_0
    575              EDIT_Obj* pObj;
    576              WM_LOCK();
    577              pObj = EDIT_H2P(hObj);
   \   0000000C   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000010   0x0005             MOVS     R5,R0
    578              if (pObj) {
   \   00000012   0xF000 0x809B      BEQ.W    ??EDIT_AddKey_0
   \   00000016   0xF105 0x0048      ADD      R0,R5,#+72
   \   0000001A   0x6842             LDR      R2,[R0, #+4]
   \   0000001C   0x0010             MOVS     R0,R2
   \   0000001E   0xD003             BEQ.N    ??EDIT_AddKey_1
    579                if (pObj->pfAddKeyEx) {
    580                  pObj->pfAddKeyEx(hObj, Key);
   \   00000020   0x4631             MOV      R1,R6
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x4790             BLX      R2
   \   00000026   0xE08C             B.N      ??EDIT_AddKey_2
    581                } else {
    582                  switch (Key) {
   \                     ??EDIT_AddKey_1: (+1)
   \   00000028   0x4630             MOV      R0,R6
   \   0000002A   0x2808             CMP      R0,#+8
   \   0000002C   0xD04D             BEQ.N    ??EDIT_AddKey_3
   \   0000002E   0x280D             CMP      R0,#+13
   \   00000030   0xF000 0x8087      BEQ.W    ??EDIT_AddKey_2
   \   00000034   0x2810             CMP      R0,#+16
   \   00000036   0xD040             BEQ.N    ??EDIT_AddKey_4
   \   00000038   0x2811             CMP      R0,#+17
   \   0000003A   0xD00A             BEQ.N    ??EDIT_AddKey_5
   \   0000003C   0x2812             CMP      R0,#+18
   \   0000003E   0xD079             BEQ.N    ??EDIT_AddKey_6
   \   00000040   0x2813             CMP      R0,#+19
   \   00000042   0xD020             BEQ.N    ??EDIT_AddKey_7
   \   00000044   0x281B             CMP      R0,#+27
   \   00000046   0xD07C             BEQ.N    ??EDIT_AddKey_2
   \   00000048   0x281D             CMP      R0,#+29
   \   0000004A   0xD04F             BEQ.N    ??EDIT_AddKey_8
   \   0000004C   0x281E             CMP      R0,#+30
   \   0000004E   0xD048             BEQ.N    ??EDIT_AddKey_9
   \   00000050   0xE05E             B.N      ??EDIT_AddKey_10
    583                  case GUI_KEY_UP:
    584                    if (pObj->hpText) {
   \                     ??EDIT_AddKey_5: (+1)
   \   00000052   0xF9B5 0x0028      LDRSH    R0,[R5, #+40]
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD073             BEQ.N    ??EDIT_AddKey_2
    585                      char* pText;
    586                      U16 Char;
    587                      pText  = (char*) GUI_ALLOC_h2p(pObj->hpText);
   \   0000005A   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000005E   0x4606             MOV      R6,R0
    588                      pText += GUI_UC__NumChars2NumBytes(pText, pObj->CursorPos);
   \   00000060   0xF105 0x0028      ADD      R0,R5,#+40
   \   00000064   0x6981             LDR      R1,[R0, #+24]
   \   00000066   0x4630             MOV      R0,R6
   \   00000068   0x.... 0x....      BL       GUI_UC__NumChars2NumBytes
   \   0000006C   0x1985             ADDS     R5,R0,R6
    589                      Char   = GUI_UC_GetCharCode(pText);
   \   0000006E   0x4628             MOV      R0,R5
   \   00000070   0x.... 0x....      BL       GUI_UC_GetCharCode
    590                      if (Char < 0x7f) {  
   \   00000074   0x287F             CMP      R0,#+127
   \   00000076   0xDA64             BGE.N    ??EDIT_AddKey_2
    591                        *pText = Char + 1;
   \   00000078   0x1C40             ADDS     R0,R0,#+1
   \   0000007A   0x7028             STRB     R0,[R5, #+0]
    592                        WM_NotifyParent(hObj, WM_NOTIFICATION_VALUE_CHANGED);
   \   0000007C   0x2105             MOVS     R1,#+5
   \   0000007E   0x4620             MOV      R0,R4
   \   00000080   0x.... 0x....      BL       WM_NotifyParent
   \   00000084   0xE05D             B.N      ??EDIT_AddKey_2
    593                      }
    594                    }
    595                    break;
    596                  case GUI_KEY_DOWN:
    597                    if (pObj->hpText) {
   \                     ??EDIT_AddKey_7: (+1)
   \   00000086   0xF9B5 0x0028      LDRSH    R0,[R5, #+40]
   \   0000008A   0x2800             CMP      R0,#+0
   \   0000008C   0xD059             BEQ.N    ??EDIT_AddKey_2
    598                      char* pText;
    599                      U16 Char;
    600                      pText  = (char*) GUI_ALLOC_h2p(pObj->hpText);
   \   0000008E   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000092   0x4606             MOV      R6,R0
    601                      pText += GUI_UC__NumChars2NumBytes(pText, pObj->CursorPos);
   \   00000094   0xF105 0x0028      ADD      R0,R5,#+40
   \   00000098   0x6981             LDR      R1,[R0, #+24]
   \   0000009A   0x4630             MOV      R0,R6
   \   0000009C   0x.... 0x....      BL       GUI_UC__NumChars2NumBytes
   \   000000A0   0x1985             ADDS     R5,R0,R6
    602                      Char   = GUI_UC_GetCharCode(pText);
   \   000000A2   0x4628             MOV      R0,R5
   \   000000A4   0x.... 0x....      BL       GUI_UC_GetCharCode
    603                      if (Char > 0x20) {  
   \   000000A8   0x2821             CMP      R0,#+33
   \   000000AA   0xDB4A             BLT.N    ??EDIT_AddKey_2
    604                        *pText = Char - 1;
   \   000000AC   0x1E40             SUBS     R0,R0,#+1
   \   000000AE   0x7028             STRB     R0,[R5, #+0]
    605                        WM_NotifyParent(hObj, WM_NOTIFICATION_VALUE_CHANGED);
   \   000000B0   0x2105             MOVS     R1,#+5
   \   000000B2   0x4620             MOV      R0,R4
   \   000000B4   0x.... 0x....      BL       WM_NotifyParent
   \   000000B8   0xE043             B.N      ??EDIT_AddKey_2
    606                      }
    607                    }
    608                    break;
    609                  case GUI_KEY_RIGHT:
    610                    EDIT__SetCursorPos(pObj, pObj->CursorPos + 1);
    611                    break;
    612                  case GUI_KEY_LEFT:
    613                    EDIT__SetCursorPos(pObj, pObj->CursorPos - 1);
   \                     ??EDIT_AddKey_4: (+1)
   \   000000BA   0xF105 0x0028      ADD      R0,R5,#+40
   \   000000BE   0x6980             LDR      R0,[R0, #+24]
   \   000000C0   0x1E41             SUBS     R1,R0,#+1
   \   000000C2   0x4628             MOV      R0,R5
   \   000000C4   0x.... 0x....      BL       EDIT__SetCursorPos
    614                    break;
   \   000000C8   0xE03B             B.N      ??EDIT_AddKey_2
    615                  case GUI_KEY_BACKSPACE:
    616                    EDIT__SetCursorPos(pObj, pObj->CursorPos - 1);
   \                     ??EDIT_AddKey_3: (+1)
   \   000000CA   0xF105 0x0028      ADD      R0,R5,#+40
   \   000000CE   0x6980             LDR      R0,[R0, #+24]
   \   000000D0   0x1E41             SUBS     R1,R0,#+1
   \   000000D2   0x4628             MOV      R0,R5
   \   000000D4   0x.... 0x....      BL       EDIT__SetCursorPos
    617                    _DeleteChar(hObj, pObj);
   \   000000D8   0x4629             MOV      R1,R5
   \   000000DA   0x4620             MOV      R0,R4
   \   000000DC   0x.... 0x....      BL       _DeleteChar
    618                    break;
   \   000000E0   0xE02F             B.N      ??EDIT_AddKey_2
    619                  case GUI_KEY_DELETE:
    620                    _DeleteChar(hObj, pObj);
   \                     ??EDIT_AddKey_9: (+1)
   \   000000E2   0x4629             MOV      R1,R5
   \   000000E4   0x4620             MOV      R0,R4
   \   000000E6   0x.... 0x....      BL       _DeleteChar
    621                    break;
   \   000000EA   0xE02A             B.N      ??EDIT_AddKey_2
    622                  case GUI_KEY_INSERT:
    623                    if (pObj->EditMode == GUI_EDIT_MODE_OVERWRITE) {
   \                     ??EDIT_AddKey_8: (+1)
   \   000000EC   0xF895 0x0048      LDRB     R0,[R5, #+72]
   \   000000F0   0x2801             CMP      R0,#+1
   \   000000F2   0xD103             BNE.N    ??EDIT_AddKey_11
    624                      pObj->EditMode = GUI_EDIT_MODE_INSERT;
   \   000000F4   0x2000             MOVS     R0,#+0
   \   000000F6   0xF885 0x0048      STRB     R0,[R5, #+72]
   \   000000FA   0xE022             B.N      ??EDIT_AddKey_2
    625                    } else {
    626                      pObj->EditMode = GUI_EDIT_MODE_OVERWRITE;
   \                     ??EDIT_AddKey_11: (+1)
   \   000000FC   0x2001             MOVS     R0,#+1
   \   000000FE   0xF885 0x0048      STRB     R0,[R5, #+72]
    627                      EDIT__SetCursorPos(pObj, pObj->CursorPos);
   \   00000102   0xF105 0x0028      ADD      R0,R5,#+40
   \   00000106   0x6981             LDR      R1,[R0, #+24]
   \   00000108   0x4628             MOV      R0,R5
   \   0000010A   0x.... 0x....      BL       EDIT__SetCursorPos
   \   0000010E   0xE018             B.N      ??EDIT_AddKey_2
    628                    }
    629                    break;
    630                  case GUI_KEY_ENTER:
    631                  case GUI_KEY_ESCAPE:
    632                    break;
    633                  default:
    634                    if (Key >= 0x20) {
   \                     ??EDIT_AddKey_10: (+1)
   \   00000110   0x2E20             CMP      R6,#+32
   \   00000112   0xDB16             BLT.N    ??EDIT_AddKey_2
    635                      if (pObj->EditMode != GUI_EDIT_MODE_INSERT) {
   \   00000114   0xF895 0x0048      LDRB     R0,[R5, #+72]
   \   00000118   0x2800             CMP      R0,#+0
   \   0000011A   0xD003             BEQ.N    ??EDIT_AddKey_12
    636                        _DeleteChar(hObj, pObj);
   \   0000011C   0x4629             MOV      R1,R5
   \   0000011E   0x4620             MOV      R0,R4
   \   00000120   0x.... 0x....      BL       _DeleteChar
    637                      }
    638                      if (_InsertChar(hObj, pObj, Key)) {
   \                     ??EDIT_AddKey_12: (+1)
   \   00000124   0x4632             MOV      R2,R6
   \   00000126   0xB292             UXTH     R2,R2
   \   00000128   0x4629             MOV      R1,R5
   \   0000012A   0x4620             MOV      R0,R4
   \   0000012C   0x.... 0x....      BL       _InsertChar
   \   00000130   0x2800             CMP      R0,#+0
   \   00000132   0xD006             BEQ.N    ??EDIT_AddKey_2
    639                        EDIT__SetCursorPos(pObj, pObj->CursorPos + 1);
   \                     ??EDIT_AddKey_6: (+1)
   \   00000134   0xF105 0x0028      ADD      R0,R5,#+40
   \   00000138   0x6980             LDR      R0,[R0, #+24]
   \   0000013A   0x1C41             ADDS     R1,R0,#+1
   \   0000013C   0x4628             MOV      R0,R5
   \   0000013E   0x.... 0x....      BL       EDIT__SetCursorPos
    640                      }
    641                    }
    642                  }
    643                }
    644                EDIT_Invalidate(hObj);
   \                     ??EDIT_AddKey_2: (+1)
   \   00000142   0x4620             MOV      R0,R4
   \   00000144   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000148   0x.... 0x....      B.W      WM_InvalidateWindow
    645              }
    646              WM_UNLOCK();
    647            }
    648          }
   \                     ??EDIT_AddKey_0: (+1)
   \   0000014C   0xBD70             POP      {R4-R6,PC}       ;; return
    649          
    650          /*********************************************************************
    651          *
    652          *       EDIT_SetFont
    653          */

   \                                 In section .text, align 2, keep-with-next
    654          void EDIT_SetFont(EDIT_Handle hObj, const GUI_FONT GUI_UNI_PTR * pfont) {
   \                     EDIT_SetFont: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    655            EDIT_Obj* pObj;
    656            if (hObj == 0)
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD009             BEQ.N    ??EDIT_SetFont_0
    657              return;
    658            WM_LOCK();
    659            pObj = EDIT_H2P(hObj);
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
    660            if (pObj) {
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD005             BEQ.N    ??EDIT_SetFont_0
    661              pObj->Props.pFont = pfont;
   \   00000012   0x65C5             STR      R5,[R0, #+92]
    662              EDIT_Invalidate(hObj);
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000001A   0x.... 0x....      B.W      WM_InvalidateWindow
    663            }
    664            WM_UNLOCK();
    665          }
   \                     ??EDIT_SetFont_0: (+1)
   \   0000001E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    666          
    667          /*********************************************************************
    668          *
    669          *       EDIT_SetBkColor
    670          */

   \                                 In section .text, align 2, keep-with-next
    671          void EDIT_SetBkColor(EDIT_Handle hObj, unsigned int Index, GUI_COLOR color) {
   \                     EDIT_SetBkColor: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    672            EDIT_Obj* pObj;
    673            if (hObj == 0)
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD00D             BEQ.N    ??EDIT_SetBkColor_0
    674              return;
    675            WM_LOCK();
    676            pObj = EDIT_H2P(hObj);
   \   0000000C   0x.... 0x....      BL       GUI_ALLOC_h2p
    677            if (pObj) {
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD009             BEQ.N    ??EDIT_SetBkColor_0
    678              if (Index < GUI_COUNTOF(pObj->Props.aBkColor)) {
   \   00000014   0x2D02             CMP      R5,#+2
   \   00000016   0xD207             BCS.N    ??EDIT_SetBkColor_0
    679                pObj->Props.aBkColor[Index] = color;
   \   00000018   0xEB00 0x0085      ADD      R0,R0,R5, LSL #+2
   \   0000001C   0x6686             STR      R6,[R0, #+104]
    680                EDIT_Invalidate(hObj);
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000024   0x.... 0x....      B.W      WM_InvalidateWindow
    681              }
    682            }
    683            WM_UNLOCK();
    684          }
   \                     ??EDIT_SetBkColor_0: (+1)
   \   00000028   0xBD70             POP      {R4-R6,PC}       ;; return
    685          
    686          /*********************************************************************
    687          *
    688          *       EDIT_SetTextColor
    689          */

   \                                 In section .text, align 2, keep-with-next
    690          void EDIT_SetTextColor(EDIT_Handle hObj, unsigned int Index, GUI_COLOR color) {
   \                     EDIT_SetTextColor: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    691            EDIT_Obj* pObj;
    692            if (hObj == 0)
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD00D             BEQ.N    ??EDIT_SetTextColor_0
    693              return;
    694            WM_LOCK();
    695            pObj = EDIT_H2P(hObj);
   \   0000000C   0x.... 0x....      BL       GUI_ALLOC_h2p
    696            if (pObj) {
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD009             BEQ.N    ??EDIT_SetTextColor_0
    697              if (Index < GUI_COUNTOF(pObj->Props.aTextColor)) {
   \   00000014   0x2D02             CMP      R5,#+2
   \   00000016   0xD207             BCS.N    ??EDIT_SetTextColor_0
    698                pObj->Props.aTextColor[Index] = color;
   \   00000018   0xEB00 0x0085      ADD      R0,R0,R5, LSL #+2
   \   0000001C   0x6606             STR      R6,[R0, #+96]
    699                EDIT_Invalidate(hObj);
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000024   0x.... 0x....      B.W      WM_InvalidateWindow
    700              }
    701            }
    702            WM_UNLOCK();
    703          }
   \                     ??EDIT_SetTextColor_0: (+1)
   \   00000028   0xBD70             POP      {R4-R6,PC}       ;; return
    704          
    705          /*********************************************************************
    706          *
    707          *       EDIT_SetText
    708          */

   \                                 In section .text, align 2, keep-with-next
    709          void EDIT_SetText(EDIT_Handle hObj, const char* s) {
   \                     EDIT_SetText: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    710            if (hObj) {
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD04A             BEQ.N    ??EDIT_SetText_0
    711              EDIT_Obj* pObj;
    712              WM_LOCK();
    713              pObj = EDIT_H2P(hObj);
   \   0000000C   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000010   0x4606             MOV      R6,R0
    714              if (s) {
   \   00000012   0x2D00             CMP      R5,#+0
   \   00000014   0xD038             BEQ.N    ??EDIT_SetText_1
    715                int NumBytesNew, NumBytesOld = 0;
   \   00000016   0xF04F 0x0800      MOV      R8,#+0
    716                int NumCharsNew;
    717                if (pObj->hpText) {
   \   0000001A   0xF9B6 0x0028      LDRSH    R0,[R6, #+40]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD005             BEQ.N    ??EDIT_SetText_2
    718                  char* pText;
    719                  pText       = (char*) GUI_ALLOC_h2p(pObj->hpText);
   \   00000022   0x.... 0x....      BL       GUI_ALLOC_h2p
    720                  NumBytesOld = strlen(pText) + 1;
   \   00000026   0x.... 0x....      BL       strlen
   \   0000002A   0xF100 0x0801      ADD      R8,R0,#+1
    721                }
    722                NumCharsNew = GUI__GetNumChars(s);
   \                     ??EDIT_SetText_2: (+1)
   \   0000002E   0x4628             MOV      R0,R5
   \   00000030   0x.... 0x....      BL       GUI__GetNumChars
   \   00000034   0x4601             MOV      R1,R0
    723                if (NumCharsNew > pObj->MaxLen) {
   \   00000036   0xF106 0x0728      ADD      R7,R6,#+40
   \   0000003A   0xF9B7 0x0002      LDRSH    R0,[R7, #+2]
   \   0000003E   0x4288             CMP      R0,R1
   \   00000040   0xDA00             BGE.N    ??EDIT_SetText_3
    724                  NumCharsNew = pObj->MaxLen;
   \   00000042   0x4601             MOV      R1,R0
    725                }
    726                NumBytesNew = GUI_UC__NumChars2NumBytes(s, NumCharsNew) + 1;
   \                     ??EDIT_SetText_3: (+1)
   \   00000044   0x4628             MOV      R0,R5
   \   00000046   0x.... 0x....      BL       GUI_UC__NumChars2NumBytes
   \   0000004A   0xF100 0x0901      ADD      R9,R0,#+1
    727                if (_IsSpaceInBuffer(pObj, NumBytesNew - NumBytesOld)) {
   \   0000004E   0xEBA9 0x0108      SUB      R1,R9,R8
   \   00000052   0x4630             MOV      R0,R6
   \   00000054   0x.... 0x....      BL       _IsSpaceInBuffer
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD01D             BEQ.N    ??EDIT_SetText_4
    728                  char* pText;
    729                  pText = (char*) GUI_ALLOC_h2p(pObj->hpText);
   \   0000005C   0xF9B6 0x0028      LDRSH    R0,[R6, #+40]
   \   00000060   0x.... 0x....      BL       GUI_ALLOC_h2p
    730                  memcpy(pText, s, NumBytesNew);
   \   00000064   0x464A             MOV      R2,R9
   \   00000066   0x4629             MOV      R1,R5
   \   00000068   0x.... 0x....      BL       memcpy
    731                  pObj->CursorPos = NumBytesNew - 1;
   \   0000006C   0xF1A9 0x0001      SUB      R0,R9,#+1
   \   00000070   0x61B8             STR      R0,[R7, #+24]
    732                  if (pObj->CursorPos == pObj->MaxLen) {
   \   00000072   0xF9B7 0x1002      LDRSH    R1,[R7, #+2]
   \   00000076   0x4288             CMP      R0,R1
   \   00000078   0xD10E             BNE.N    ??EDIT_SetText_4
    733                    if (pObj->EditMode == GUI_EDIT_MODE_OVERWRITE) {
   \   0000007A   0xF896 0x1048      LDRB     R1,[R6, #+72]
   \   0000007E   0x2901             CMP      R1,#+1
   \   00000080   0xD10A             BNE.N    ??EDIT_SetText_4
    734                      pObj->CursorPos--;
   \   00000082   0x1E40             SUBS     R0,R0,#+1
   \   00000084   0x61B8             STR      R0,[R7, #+24]
   \   00000086   0xE007             B.N      ??EDIT_SetText_4
    735                    }
    736                  }
    737                }
    738              } else {
    739                GUI_ALLOC_FreePtr(&pObj->hpText);
   \                     ??EDIT_SetText_1: (+1)
   \   00000088   0xF106 0x0728      ADD      R7,R6,#+40
   \   0000008C   0x4638             MOV      R0,R7
   \   0000008E   0x.... 0x....      BL       GUI_ALLOC_FreePtr
    740                pObj->BufferSize = 0;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x80B8             STRH     R0,[R7, #+4]
    741                pObj->CursorPos  = 0;
   \   00000096   0x61B8             STR      R0,[R7, #+24]
    742              }
    743              EDIT_Invalidate(hObj);
   \                     ??EDIT_SetText_4: (+1)
   \   00000098   0x4620             MOV      R0,R4
   \   0000009A   0xE8BD 0x43F2      POP      {R1,R4-R9,LR}
   \   0000009E   0x.... 0x....      B.W      WM_InvalidateWindow
    744              WM_UNLOCK();
    745            }
    746          }
   \                     ??EDIT_SetText_0: (+1)
   \   000000A2   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    747          
    748          /*********************************************************************
    749          *
    750          *       EDIT_GetText
    751          */

   \                                 In section .text, align 2, keep-with-next
    752          void EDIT_GetText(EDIT_Handle hObj, char* sDest, int MaxLen) {
   \                     EDIT_GetText: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x4615             MOV      R5,R2
    753            if (sDest) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD01D             BEQ.N    ??EDIT_GetText_0
    754              *sDest = 0;
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x7021             STRB     R1,[R4, #+0]
    755              if (hObj) {
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD019             BEQ.N    ??EDIT_GetText_0
    756                EDIT_Obj* pObj;
    757                WM_LOCK();
    758                pObj = EDIT_H2P(hObj);
   \   00000012   0x.... 0x....      BL       GUI_ALLOC_h2p
    759                if (pObj->hpText) {
   \   00000016   0xF9B0 0x0028      LDRSH    R0,[R0, #+40]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD013             BEQ.N    ??EDIT_GetText_0
    760                  char* pText;
    761                  int NumChars, NumBytes;
    762                  pText = (char*) GUI_ALLOC_h2p(pObj->hpText);
   \   0000001E   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000022   0x4606             MOV      R6,R0
    763                  NumChars = GUI__GetNumChars(pText);
   \   00000024   0x.... 0x....      BL       GUI__GetNumChars
    764                  if (NumChars > MaxLen) {
   \   00000028   0x4285             CMP      R5,R0
   \   0000002A   0xDD00             BLE.N    ??EDIT_GetText_1
   \   0000002C   0x4605             MOV      R5,R0
    765                    NumChars = MaxLen;
    766                  }
    767                  NumBytes = GUI_UC__NumChars2NumBytes(pText, NumChars);
   \                     ??EDIT_GetText_1: (+1)
   \   0000002E   0x4629             MOV      R1,R5
   \   00000030   0x4630             MOV      R0,R6
   \   00000032   0x.... 0x....      BL       GUI_UC__NumChars2NumBytes
   \   00000036   0x4605             MOV      R5,R0
    768                  memcpy(sDest, pText, NumBytes);
   \   00000038   0x462A             MOV      R2,R5
   \   0000003A   0x4631             MOV      R1,R6
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0x.... 0x....      BL       memcpy
    769                  *(sDest + NumBytes) = 0;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x5528             STRB     R0,[R5, R4]
    770                }
    771                WM_UNLOCK();
    772              }
    773            }
    774          }
   \                     ??EDIT_GetText_0: (+1)
   \   00000046   0xBD70             POP      {R4-R6,PC}       ;; return
    775          
    776          /*********************************************************************
    777          *
    778          *       EDIT_GetValue
    779          */

   \                                 In section .text, align 2, keep-with-next
    780          I32  EDIT_GetValue(EDIT_Handle hObj) {
   \                     EDIT_GetValue: (+1)
   \   00000000   0x4601             MOV      R1,R0
    781            EDIT_Obj* pObj;
    782            I32 r = 0;
   \   00000002   0x2000             MOVS     R0,#+0
    783            if (hObj) {
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD100             BNE.N    ??EDIT_GetValue_0
   \   00000008   0x4770             BX       LR
    784              WM_LOCK();
    785              pObj = EDIT_H2P(hObj);
   \                     ??EDIT_GetValue_0: (+1)
   \   0000000A   0xB580             PUSH     {R7,LR}
   \   0000000C   0x4608             MOV      R0,R1
   \   0000000E   0x.... 0x....      BL       GUI_ALLOC_h2p
    786              r = pObj->CurrentValue;
   \   00000012   0x6BC0             LDR      R0,[R0, #+60]
    787              WM_UNLOCK();
    788            }
    789            return r;
   \   00000014   0xBD02             POP      {R1,PC}          ;; return
    790          }
    791          
    792          /*********************************************************************
    793          *
    794          *       EDIT_SetValue
    795          */

   \                                 In section .text, align 2, keep-with-next
    796          void EDIT_SetValue(EDIT_Handle hObj, I32 Value) {
   \                     EDIT_SetValue: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    797            EDIT_Obj* pObj;
    798            if (hObj) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD01C             BEQ.N    ??EDIT_SetValue_0
    799              WM_LOCK();
    800              pObj = EDIT_H2P(hObj);
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
    801              /* Put in min/max range */
    802              if (Value < pObj->Min) {
   \   0000000E   0x6B01             LDR      R1,[R0, #+48]
   \   00000010   0x428D             CMP      R5,R1
   \   00000012   0xDA00             BGE.N    ??EDIT_SetValue_1
   \   00000014   0x460D             MOV      R5,R1
   \                     ??EDIT_SetValue_1: (+1)
   \   00000016   0x4629             MOV      R1,R5
    803                Value = pObj->Min;
    804              }
    805              if (Value > pObj->Max) {
   \   00000018   0x6B45             LDR      R5,[R0, #+52]
   \   0000001A   0x428D             CMP      R5,R1
   \   0000001C   0xDD00             BLE.N    ??EDIT_SetValue_2
   \   0000001E   0x460D             MOV      R5,R1
    806                Value = pObj->Max;
    807              }
    808              if (pObj->CurrentValue != (U32)Value) {
   \                     ??EDIT_SetValue_2: (+1)
   \   00000020   0x6BC1             LDR      R1,[R0, #+60]
   \   00000022   0x42A9             CMP      R1,R5
   \   00000024   0xD00E             BEQ.N    ??EDIT_SetValue_0
    809                pObj->CurrentValue = Value;
   \   00000026   0x63C5             STR      R5,[R0, #+60]
    810                if (pObj->pfUpdateBuffer) {
   \   00000028   0x6D01             LDR      R1,[R0, #+80]
   \   0000002A   0x0008             MOVS     R0,R1
   \   0000002C   0xD001             BEQ.N    ??EDIT_SetValue_3
    811                  pObj->pfUpdateBuffer(hObj);
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x4788             BLX      R1
    812                }
    813                WM_InvalidateWindow(hObj);
   \                     ??EDIT_SetValue_3: (+1)
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x.... 0x....      BL       WM_InvalidateWindow
    814                WM_NotifyParent(hObj, WM_NOTIFICATION_VALUE_CHANGED);
   \   00000038   0x2105             MOVS     R1,#+5
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000040   0x.... 0x....      B.W      WM_NotifyParent
    815              }
    816              WM_UNLOCK();
    817            }
    818          }
   \                     ??EDIT_SetValue_0: (+1)
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    819          
    820          /*********************************************************************
    821          *
    822          *       EDIT_SetMaxLen
    823          */

   \                                 In section .text, align 2, keep-with-next
    824          void EDIT_SetMaxLen(EDIT_Handle  hObj, int MaxLen) {
   \                     EDIT_SetMaxLen: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    825            if (hObj) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD025             BEQ.N    ??EDIT_SetMaxLen_0
    826              EDIT_Obj* pObj;
    827              WM_LOCK();
    828              pObj = EDIT_H2P(hObj);
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000000E   0x4606             MOV      R6,R0
    829              if (MaxLen != pObj->MaxLen) {
   \   00000010   0xF9B6 0x002A      LDRSH    R0,[R6, #+42]
   \   00000014   0x4285             CMP      R5,R0
   \   00000016   0xD01E             BEQ.N    ??EDIT_SetMaxLen_0
    830                if (MaxLen < pObj->MaxLen) {
   \   00000018   0x4285             CMP      R5,R0
   \   0000001A   0xDA10             BGE.N    ??EDIT_SetMaxLen_1
    831                  if (pObj->hpText) {
   \   0000001C   0xF9B6 0x0028      LDRSH    R0,[R6, #+40]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD00C             BEQ.N    ??EDIT_SetMaxLen_1
    832                    char* pText;
    833                    int   NumChars;
    834                    pText    = (char*) GUI_ALLOC_h2p(pObj->hpText);
   \   00000024   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000028   0x4607             MOV      R7,R0
    835                    NumChars = GUI__GetNumChars(pText);
    836                    if (NumChars > MaxLen) {
   \   0000002A   0x.... 0x....      BL       GUI__GetNumChars
   \   0000002E   0x4285             CMP      R5,R0
   \   00000030   0xDA05             BGE.N    ??EDIT_SetMaxLen_1
    837                      int NumBytes;
    838                      NumBytes = GUI_UC__NumChars2NumBytes(pText, MaxLen);
    839                      *(pText + NumBytes) = 0;
   \   00000032   0x4629             MOV      R1,R5
   \   00000034   0x4638             MOV      R0,R7
   \   00000036   0x.... 0x....      BL       GUI_UC__NumChars2NumBytes
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0x55C1             STRB     R1,[R0, R7]
    840                    }
    841                  }
    842                }
    843                _IncrementBuffer(pObj, MaxLen - pObj->BufferSize + 1);
   \                     ??EDIT_SetMaxLen_1: (+1)
   \   0000003E   0x8DB0             LDRH     R0,[R6, #+44]
   \   00000040   0x1A28             SUBS     R0,R5,R0
   \   00000042   0x1C41             ADDS     R1,R0,#+1
   \   00000044   0x4630             MOV      R0,R6
   \   00000046   0x.... 0x....      BL       _IncrementBuffer
    844                pObj->MaxLen = MaxLen;
   \   0000004A   0x8575             STRH     R5,[R6, #+42]
    845                EDIT_Invalidate(hObj);
   \   0000004C   0x4620             MOV      R0,R4
   \   0000004E   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   00000052   0x.... 0x....      B.W      WM_InvalidateWindow
    846              }
    847              WM_UNLOCK();
    848            }
    849          }
   \                     ??EDIT_SetMaxLen_0: (+1)
   \   00000056   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    850          
    851          /*********************************************************************
    852          *
    853          *       EDIT_SetTextAlign
    854          */

   \                                 In section .text, align 2, keep-with-next
    855          void EDIT_SetTextAlign(EDIT_Handle hObj, int Align) {
   \                     EDIT_SetTextAlign: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    856            EDIT_Obj* pObj;
    857            if (hObj == 0)
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD009             BEQ.N    ??EDIT_SetTextAlign_0
    858              return;
    859            WM_LOCK();
    860            pObj = EDIT_H2P(hObj);
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
    861            if (pObj) {
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD005             BEQ.N    ??EDIT_SetTextAlign_0
    862              pObj->Props.Align = Align;
   \   00000012   0x6545             STR      R5,[R0, #+84]
    863              EDIT_Invalidate(hObj);
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000001A   0x.... 0x....      B.W      WM_InvalidateWindow
    864            }
    865            WM_UNLOCK();
    866          }
   \                     ??EDIT_SetTextAlign_0: (+1)
   \   0000001E   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     Timer1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     ShowCurrsor

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x........         DC32     ??StartPress

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x........         DC32     EDIT__Callback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x........         DC32     EDIT__DefaultProps
    867          
    868          #else  /* avoid empty object files */
    869          
    870          void Edit_C(void) {}
    871          
    872          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   EDIT_AddKey
        16   -- Indirect call
        16   -> EDIT__SetCursorPos
        16   -> GUI_ALLOC_h2p
        16   -> GUI_UC_GetCharCode
        16   -> GUI_UC__NumChars2NumBytes
         0   -> WM_InvalidateWindow
        16   -> WM_NotifyParent
        16   -> _DeleteChar
        16   -> _InsertChar
      32   EDIT_CreateEx
        32   -> GUI_ALLOC_h2p
        32   -> WIDGET__Init
        32   -> WM_CreateWindowAsChild
        32   -> WM_DeleteWindow
        32   -> _IncrementBuffer
        32   -> __aeabi_memcpy4
      16   EDIT_GetText
        16   -> GUI_ALLOC_h2p
        16   -> GUI_UC__NumChars2NumBytes
        16   -> GUI__GetNumChars
        16   -> memcpy
       8   EDIT_GetValue
         8   -> GUI_ALLOC_h2p
      16   EDIT_SetBkColor
        16   -> GUI_ALLOC_h2p
         0   -> WM_InvalidateWindow
      40   EDIT_SetCursorAtPixel
        40   -> EDIT__SetCursorPos
        40   -> GUI_ALLOC_h2p
        40   -> GUI_GetCharDistX
        40   -> GUI_GetStringDistX
        40   -> GUI_SetFont
        40   -> GUI_UC__GetCharCodeInc
        40   -> GUI__GetNumChars
        40   -> WM_GetWindowSizeX
        40   -> WM_InvalidateWindow
      16   EDIT_SetFont
        16   -> GUI_ALLOC_h2p
         0   -> WM_InvalidateWindow
      24   EDIT_SetMaxLen
        24   -> GUI_ALLOC_h2p
        24   -> GUI_UC__NumChars2NumBytes
        24   -> GUI__GetNumChars
         0   -> WM_InvalidateWindow
        24   -> _IncrementBuffer
      32   EDIT_SetText
        32   -> GUI_ALLOC_FreePtr
        32   -> GUI_ALLOC_h2p
        32   -> GUI_UC__NumChars2NumBytes
        32   -> GUI__GetNumChars
         0   -> WM_InvalidateWindow
        32   -> _IsSpaceInBuffer
        32   -> memcpy
        32   -> strlen
      16   EDIT_SetTextAlign
        16   -> GUI_ALLOC_h2p
         0   -> WM_InvalidateWindow
      16   EDIT_SetTextColor
        16   -> GUI_ALLOC_h2p
         0   -> WM_InvalidateWindow
      16   EDIT_SetValue
        16   -- Indirect call
        16   -> GUI_ALLOC_h2p
        16   -> WM_InvalidateWindow
         0   -> WM_NotifyParent
      24   EDIT__Callback
         0   -> EDIT_AddKey
        24   -> GUI_ALLOC_h2p
        24   -> WIDGET_HandleActive
         0   -> WM_DefaultProc
        24   -> WM__IsEnabled
        24   -> _Delete
        24   -> _OnTouch
         0   -> _Paint
      16   EDIT__GetCurrentChar
        16   -> GUI_ALLOC_h2p
         0   -> GUI_UC_GetCharCode
        16   -> GUI_UC__NumChars2NumBytes
      16   EDIT__SetCursorPos
        16   -> GUI_ALLOC_h2p
        16   -> GUI__GetNumChars
      16   ShowCurrsor
        16   -> GUI_ALLOC_h2p
         0   -> GUI_TIMER_Restart
        16   -> WM_SelectWindow
        16   -> _Paint
       0   _Delete
         0   -> GUI_ALLOC_FreePtr
      16   _DeleteChar
        16   -> GUI_ALLOC_h2p
        16   -> GUI_UC_GetCharSize
        16   -> GUI_UC__NumChars2NumBytes
         0   -> WM_NotifyParent
        16   -> strcpy
        16   -> strlen
      16   _IncrementBuffer
        16   -> GUI_ALLOC_Realloc
        16   -> GUI_ALLOC_h2p
      24   _InsertChar
        24   -> GUI_ALLOC_h2p
        24   -> GUI_UC_Encode
        24   -> GUI_UC__CalcSizeOfChar
        24   -> GUI_UC__NumChars2NumBytes
        24   -> WM_NotifyParent
        24   -> _IsCharsAvailable
        24   -> _IsSpaceInBuffer
        24   -> memmove
        24   -> strlen
      16   _IsCharsAvailable
        16   -> GUI_ALLOC_h2p
        16   -> GUI__GetNumChars
      16   _IsSpaceInBuffer
        16   -> GUI_ALLOC_h2p
        16   -> _IncrementBuffer
        16   -> strlen
       8   _OnTouch
         8   -> EDIT_SetCursorAtPixel
      80   _Paint
        80   -> GUI_ALLOC_h2p
        80   -> GUI_GetCharDistX
        80   -> GUI_InvertRect
        80   -> GUI_SetFont
        80   -> GUI_TIMER_Context
        80   -> GUI_TIMER_Create
        80   -> GUI_TIMER_SetPeriod
        80   -> GUI_TIMER_SetTime
        80   -> GUI_UC_GetCharCode
        80   -> GUI_UC__GetCharCodeInc
        80   -> GUI_UC__NumChars2NumBytes
        80   -> GUI__CalcTextRect
        80   -> GUI__GetNumChars
        80   -> LCD_SetBkColor
        80   -> LCD_SetColor
        80   -> WIDGET__EFFECT_DrawDown
        80   -> WIDGET__FillStringInRect
        80   -> WIDGET__GetInsideRect
        80   -> WM_SetUserClipRect
        80   -> WM__GetClientRectWin
        80   -> WM__GetNextIVR
        80   -> WM__InitIVRSearch
        80   -> WM__IsEnabled


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
     334  EDIT_AddKey
     122  EDIT_CreateEx
      72  EDIT_GetText
      22  EDIT_GetValue
      42  EDIT_SetBkColor
     212  EDIT_SetCursorAtPixel
      32  EDIT_SetFont
      88  EDIT_SetMaxLen
     166  EDIT_SetText
      32  EDIT_SetTextAlign
      42  EDIT_SetTextColor
      70  EDIT_SetValue
     122  EDIT__Callback
      28  EDIT__DefaultProps
      40  EDIT__GetCurrentChar
      76  EDIT__SetCursorPos
      62  ShowCurrsor
       4  StartPress
       2  Timer1
       6  _Delete
      68  _DeleteChar
      54  _IncrementBuffer
     104  _InsertChar
      56  _IsCharsAvailable
      60  _IsSpaceInBuffer
      30  _OnTouch
     482  _Paint

 
     6 bytes in section .bss
    28 bytes in section .data
 2 414 bytes in section .text
 
 2 414 bytes of CODE memory
    34 bytes of DATA memory

Errors: none
Warnings: 1
