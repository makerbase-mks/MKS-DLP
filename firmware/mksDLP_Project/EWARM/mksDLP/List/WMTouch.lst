###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  10:59:37
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\WM\WMTouch.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\WM\WMTouch.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\WMTouch.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\WMTouch.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\WM\WMTouch.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              µC/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : WMTouch.c
     16          Purpose     : Windows manager, touch support
     17          ----------------------------------------------------------------------
     18          */
     19          
     20          #include <stddef.h>           /* needed for definition of NULL */
     21          #include "WM_Intern.h"
     22          #include "GUIDebug.h"
     23          
     24          #if (GUI_WINSUPPORT)
     25          
     26          /*********************************************************************
     27          *
     28          *          Public data
     29          *
     30          **********************************************************************
     31          */
     32          

   \                                 In section .bss, align 4
     33          WM_CRITICAL_HANDLE  WM__CHWinModal;
   \                     WM__CHWinModal:
   \   00000000                      DS8 8

   \                                 In section .bss, align 4
     34          WM_CRITICAL_HANDLE  WM__CHWinLast;
   \                     WM__CHWinLast:
   \   00000000                      DS8 8
     35          
     36          /*********************************************************************
     37          *
     38          *          Modul internal routines
     39          *
     40          **********************************************************************
     41          */
     42          /*********************************************************************
     43          *
     44          *       WM__IsInModalArea
     45          */

   \                                 In section .text, align 2, keep-with-next
     46          int WM__IsInModalArea(WM_HWIN hWin) {
   \                     WM__IsInModalArea: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
     47            if ((WM__CHWinModal.hWin == 0) || WM__IsAncestor(hWin, WM__CHWinModal.hWin) || (hWin == WM__CHWinModal.hWin)) {
   \   00000004   0x....             LDR.N    R5,??DataTable2
   \   00000006   0xF9B5 0x0004      LDRSH    R0,[R5, #+4]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD00A             BEQ.N    ??WM__IsInModalArea_0
   \   0000000E   0xF9B5 0x1004      LDRSH    R1,[R5, #+4]
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       WM__IsAncestor
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD103             BNE.N    ??WM__IsInModalArea_0
   \   0000001C   0xF9B5 0x0004      LDRSH    R0,[R5, #+4]
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD101             BNE.N    ??WM__IsInModalArea_1
     48              return 1;
   \                     ??WM__IsInModalArea_0: (+1)
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xBD32             POP      {R1,R4,R5,PC}
     49            }
     50            return 0;
   \                     ??WM__IsInModalArea_1: (+1)
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     51          }
     52          
     53          /*********************************************************************
     54          *
     55          *       WM__SendPIDMessage
     56          *
     57          * Purpose:
     58          *   Sends a PID -type message to the affected window.
     59          *   All ancestors are notified of this by sending a WM_TOUCH_CHILD
     60          *   message.
     61          *
     62          */

   \                                 In section .text, align 2, keep-with-next
     63          void WM__SendPIDMessage(WM_HWIN hWin, WM_MESSAGE* pMsg) {
   \                     WM__SendPIDMessage: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
     64            WM_MESSAGE Msg;
     65            /* Send message to the affected window */
     66            Msg = *pMsg;                 /* Save message as it may be modified in callback (as return value) */
   \   00000006   0xA800             ADD      R0,SP,#+0
   \   00000008   0xCD0E             LDM      R5!,{R1-R3}
   \   0000000A   0xC00E             STM      R0!,{R1-R3}
   \   0000000C   0x3D0C             SUBS     R5,R5,#+12
     67            WM__SendMessageIfEnabled(hWin, &Msg);
   \   0000000E   0xA900             ADD      R1,SP,#+0
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       WM__SendMessageIfEnabled
     68            /* Send notification to all ancestors.
     69               We need to check if the window which has received the last message still exists,
     70               since it may have deleted itself and its parent as result of the message.
     71            */
     72            Msg.hWinSrc = hWin;
   \   00000016   0xF8AD 0x4006      STRH     R4,[SP, #+6]
     73            Msg.MsgId   = WM_TOUCH_CHILD;
   \   0000001A   0x200D             MOVS     R0,#+13
   \   0000001C   0x9000             STR      R0,[SP, #+0]
   \   0000001E   0xE008             B.N      ??WM__SendPIDMessage_0
     74            while (WM_IsWindow(hWin)) {
     75              hWin = WM_GetParent(hWin);
   \                     ??WM__SendPIDMessage_1: (+1)
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       WM_GetParent
   \   00000026   0x0004             MOVS     R4,R0
     76              if (hWin) {
   \   00000028   0xD003             BEQ.N    ??WM__SendPIDMessage_0
     77                Msg.Data.p  = pMsg;            /* Needs to be set for each window, as callback is allowed to modify it */
   \   0000002A   0x9502             STR      R5,[SP, #+8]
     78                WM__SendMessageIfEnabled(hWin, &Msg);    /* Send message to the ancestors */
   \   0000002C   0xA900             ADD      R1,SP,#+0
   \   0000002E   0x.... 0x....      BL       WM__SendMessageIfEnabled
     79              }
     80            }
   \                     ??WM__SendPIDMessage_0: (+1)
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x.... 0x....      BL       WM_IsWindow
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD1F1             BNE.N    ??WM__SendPIDMessage_1
     81          }
   \   0000003C   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
     82          
     83          /*********************************************************************
     84          *
     85          *       WM__SendTouchMessage
     86          */

   \                                 In section .text, align 2, keep-with-next
     87          void WM__SendTouchMessage(WM_HWIN hWin, WM_MESSAGE* pMsg) {
   \                     WM__SendTouchMessage: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
     88            GUI_PID_STATE* pState;
     89            pState     = (GUI_PID_STATE*)pMsg->Data.p;
   \   00000006   0x68AE             LDR      R6,[R5, #+8]
     90            if (pState) {
   \   00000008   0x2E00             CMP      R6,#+0
   \   0000000A   0xD00B             BEQ.N    ??WM__SendTouchMessage_0
     91              WM_Obj* pWin;
     92              pWin       = WM_H2P(hWin);
   \   0000000C   0x.... 0x....      BL       GUI_ALLOC_h2p
     93              pState->x -= pWin->Rect.x0;
   \   00000010   0x6831             LDR      R1,[R6, #+0]
   \   00000012   0xF9B0 0x2000      LDRSH    R2,[R0, #+0]
   \   00000016   0x1A89             SUBS     R1,R1,R2
   \   00000018   0x6031             STR      R1,[R6, #+0]
     94              pState->y -= pWin->Rect.y0;
   \   0000001A   0x6871             LDR      R1,[R6, #+4]
   \   0000001C   0xF9B0 0x0002      LDRSH    R0,[R0, #+2]
   \   00000020   0x1A08             SUBS     R0,R1,R0
   \   00000022   0x6070             STR      R0,[R6, #+4]
     95            }
     96            WM__SendPIDMessage(hWin, pMsg);
   \                     ??WM__SendTouchMessage_0: (+1)
   \   00000024   0x4629             MOV      R1,R5
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000002C   0x....             B.N      WM__SendPIDMessage
     97          }
     98          
     99          /*********************************************************************
    100          *
    101          *          Static code
    102          *
    103          **********************************************************************
    104          */
    105          /*********************************************************************
    106          *
    107          *       _Screen2Win
    108          */

   \                                 In section .text, align 2, keep-with-next
    109          static WM_HWIN _Screen2Win(GUI_PID_STATE* pState) {
   \                     _Screen2Win: (+1)
   \   00000000   0x4602             MOV      R2,R0
    110            if (WM__hCapture == 0) {
   \   00000002   0x....             LDR.N    R0,??DataTable2_1
   \   00000004   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD103             BNE.N    ??_Screen2Win_0
    111              return WM_Screen2hWin(pState->x, pState->y);
   \   0000000C   0x6851             LDR      R1,[R2, #+4]
   \   0000000E   0x6810             LDR      R0,[R2, #+0]
   \   00000010   0x.... 0x....      B.W      WM_Screen2hWin
    112            } 
    113            return WM__hCapture;
   \                     ??_Screen2Win_0: (+1)
   \   00000014   0x4770             BX       LR               ;; return
    114          }
    115          
    116          /*********************************************************************
    117          *
    118          *       Public code
    119          *
    120          **********************************************************************
    121          */
    122          /*********************************************************************
    123          *
    124          *       WM_HandlePID       
    125          *
    126          * Polls the touch screen. If something has changed,
    127          * sends a message to the concerned window.
    128          *
    129          * Return value:
    130          *   0 if nothing has been done
    131          *   1 if touch message has been sent
    132          */

   \                                 In section .text, align 2, keep-with-next
    133          int WM_HandlePID(void) {
   \                     WM_HandlePID: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB08F             SUB      SP,SP,#+60
    134            int r = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    135            WM_MESSAGE Msg;
    136            WM_CRITICAL_HANDLE CHWin;
    137            GUI_PID_STATE State, StateNew;
    138            GUI_PID_GetState(&StateNew);
   \   00000006   0xA802             ADD      R0,SP,#+8
   \   00000008   0x.... 0x....      BL       GUI_PID_GetState
    139            WM_LOCK();
    140            WM__AddCriticalHandle(&CHWin);
   \   0000000C   0xA800             ADD      R0,SP,#+0
   \   0000000E   0x.... 0x....      BL       WM__AddCriticalHandle
    141            if ((WM_PID__StateLast.x != StateNew.x) || (WM_PID__StateLast.y != StateNew.y) || (WM_PID__StateLast.Pressed != StateNew.Pressed)) {
   \   00000012   0x9903             LDR      R1,[SP, #+12]
   \   00000014   0x....             LDR.N    R4,??DataTable2_2
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x9A02             LDR      R2,[SP, #+8]
   \   0000001A   0x4290             CMP      R0,R2
   \   0000001C   0xD108             BNE.N    ??WM_HandlePID_0
   \   0000001E   0x6860             LDR      R0,[R4, #+4]
   \   00000020   0x4288             CMP      R0,R1
   \   00000022   0xD105             BNE.N    ??WM_HandlePID_0
   \   00000024   0x7A20             LDRB     R0,[R4, #+8]
   \   00000026   0xF89D 0x2010      LDRB     R2,[SP, #+16]
   \   0000002A   0x4290             CMP      R0,R2
   \   0000002C   0xF000 0x8082      BEQ.W    ??WM_HandlePID_1
    142              #if GUI_SUPPORT_CURSOR
    143                GUI_CURSOR_SetPosition(StateNew.x, StateNew.y);
   \                     ??WM_HandlePID_0: (+1)
   \   00000030   0x9802             LDR      R0,[SP, #+8]
   \   00000032   0x.... 0x....      BL       GUI_CURSOR_SetPosition
    144              #endif
    145              CHWin.hWin = _Screen2Win(&StateNew);
   \   00000036   0xA802             ADD      R0,SP,#+8
   \   00000038   0x.... 0x....      BL       _Screen2Win
   \   0000003C   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    146              if (WM__IsInModalArea(CHWin.hWin)) {
   \   00000040   0xF9BD 0x0004      LDRSH    R0,[SP, #+4]
   \   00000044   0x.... 0x....      BL       WM__IsInModalArea
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD070             BEQ.N    ??WM_HandlePID_2
    147                /*
    148                 * Send WM_PID_STATE_CHANGED message if state has changed (just pressed or just released)
    149                 */
    150                if ((WM_PID__StateLast.Pressed != StateNew.Pressed) && CHWin.hWin) {
   \   0000004C   0x7A20             LDRB     R0,[R4, #+8]
   \   0000004E   0xF89D 0x1010      LDRB     R1,[SP, #+16]
   \   00000052   0x4288             CMP      R0,R1
   \   00000054   0xD021             BEQ.N    ??WM_HandlePID_3
   \   00000056   0xF9BD 0x0004      LDRSH    R0,[SP, #+4]
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD01D             BEQ.N    ??WM_HandlePID_3
    151                  WM_PID_STATE_CHANGED_INFO Info;
    152                  WM_Obj* pWin;
    153                  pWin = WM_H2P(CHWin.hWin);
   \   0000005E   0xF9BD 0x0004      LDRSH    R0,[SP, #+4]
   \   00000062   0x.... 0x....      BL       GUI_ALLOC_h2p
    154                  Info.State     = StateNew.Pressed;
   \   00000066   0xF89D 0x1010      LDRB     R1,[SP, #+16]
   \   0000006A   0xF88D 0x1034      STRB     R1,[SP, #+52]
    155                  Info.StatePrev = WM_PID__StateLast.Pressed;
   \   0000006E   0x7A21             LDRB     R1,[R4, #+8]
   \   00000070   0xF88D 0x1035      STRB     R1,[SP, #+53]
    156                  Info.x         = StateNew.x - pWin->Rect.x0;
   \   00000074   0x9902             LDR      R1,[SP, #+8]
   \   00000076   0xF9B0 0x2000      LDRSH    R2,[R0, #+0]
   \   0000007A   0x1A89             SUBS     R1,R1,R2
   \   0000007C   0x910B             STR      R1,[SP, #+44]
    157                  Info.y         = StateNew.y - pWin->Rect.y0;
   \   0000007E   0x9903             LDR      R1,[SP, #+12]
   \   00000080   0xF9B0 0x0002      LDRSH    R0,[R0, #+2]
   \   00000084   0x1A08             SUBS     R0,R1,R0
   \   00000086   0x900C             STR      R0,[SP, #+48]
    158                  Msg.Data.p = &Info;
   \   00000088   0xA80B             ADD      R0,SP,#+44
   \   0000008A   0x9007             STR      R0,[SP, #+28]
    159                  Msg.MsgId  = WM_PID_STATE_CHANGED;
   \   0000008C   0x2011             MOVS     R0,#+17
   \   0000008E   0x9005             STR      R0,[SP, #+20]
    160                  WM__SendMessageIfEnabled(CHWin.hWin, &Msg);
   \   00000090   0xA905             ADD      R1,SP,#+20
   \   00000092   0xF9BD 0x0004      LDRSH    R0,[SP, #+4]
   \   00000096   0x.... 0x....      BL       WM__SendMessageIfEnabled
    161                }
    162                /*
    163                 * Send WM_TOUCH message(s)
    164                 * Note that we may have to send 2 touch messages.
    165                 */
    166                if (WM_PID__StateLast.Pressed | StateNew.Pressed) {    /* Only if pressed or just released */
   \                     ??WM_HandlePID_3: (+1)
   \   0000009A   0x7A20             LDRB     R0,[R4, #+8]
   \   0000009C   0xF89D 0x1010      LDRB     R1,[SP, #+16]
   \   000000A0   0x4308             ORRS     R0,R1,R0
   \   000000A2   0xD044             BEQ.N    ??WM_HandlePID_2
    167                  Msg.MsgId = WM_TOUCH;
   \   000000A4   0x200C             MOVS     R0,#+12
   \   000000A6   0x9005             STR      R0,[SP, #+20]
    168                  r = 1;
   \   000000A8   0x2501             MOVS     R5,#+1
    169                  /*
    170                   * Tell window if it is no longer pressed
    171                   * This happens for 2 possible reasons:
    172                   * a) PID is released
    173                   * b) PID is moved out
    174                   */
    175                  if (WM__CHWinLast.hWin != CHWin.hWin) {
                         ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \   000000AA   0x....             LDR.N    R6,??DataTable2_3
   \   000000AC   0xF9B6 0x0004      LDRSH    R0,[R6, #+4]
   \   000000B0   0xF9BD 0x1004      LDRSH    R1,[SP, #+4]
   \   000000B4   0x4288             CMP      R0,R1
   \   000000B6   0xD01A             BEQ.N    ??WM_HandlePID_4
    176                    if (WM__CHWinLast.hWin != 0) {
   \   000000B8   0xF9B6 0x0004      LDRSH    R0,[R6, #+4]
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD016             BEQ.N    ??WM_HandlePID_4
    177                      if (StateNew.Pressed) {
   \   000000C0   0xF89D 0x0010      LDRB     R0,[SP, #+16]
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD002             BEQ.N    ??WM_HandlePID_5
    178                        /* Moved out -> no longer in this window
    179                         * Send a NULL pointer as data
    180                         */
    181                        Msg.Data.p = NULL;
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0x9007             STR      R0,[SP, #+28]
   \   000000CC   0xE008             B.N      ??WM_HandlePID_6
    182                      } else {
    183                        /* Last window needs to know that it has been "Released"
    184                         * Send last coordinates 
    185                         */
    186                        State.x       = WM_PID__StateLast.x;
   \                     ??WM_HandlePID_5: (+1)
   \   000000CE   0x6820             LDR      R0,[R4, #+0]
   \   000000D0   0x9008             STR      R0,[SP, #+32]
    187                        State.y       = WM_PID__StateLast.y;
   \   000000D2   0x6860             LDR      R0,[R4, #+4]
   \   000000D4   0x9009             STR      R0,[SP, #+36]
    188                        State.Pressed = 0;
   \   000000D6   0x2000             MOVS     R0,#+0
   \   000000D8   0xF88D 0x0028      STRB     R0,[SP, #+40]
    189                        Msg.Data.p = (void*)&State;
   \   000000DC   0xA808             ADD      R0,SP,#+32
   \   000000DE   0x9007             STR      R0,[SP, #+28]
    190                      }
    191                      GUI_DEBUG_LOG1 ("\nSending WM_Touch to LastWindow %d (out of area)", WM__CHWinLast.hWin);
    192                      WM__SendTouchMessage(WM__CHWinLast.hWin, &Msg);
   \                     ??WM_HandlePID_6: (+1)
   \   000000E0   0xA905             ADD      R1,SP,#+20
   \   000000E2   0xF9B6 0x0004      LDRSH    R0,[R6, #+4]
   \   000000E6   0x.... 0x....      BL       WM__SendTouchMessage
    193                      WM__CHWinLast.hWin = 0;
   \   000000EA   0x2000             MOVS     R0,#+0
   \   000000EC   0x80B0             STRH     R0,[R6, #+4]
    194                    }
    195                  }
    196                  /* Sending WM_Touch to current window */
    197                  if (CHWin.hWin) {
   \                     ??WM_HandlePID_4: (+1)
   \   000000EE   0xF9BD 0x0004      LDRSH    R0,[SP, #+4]
   \   000000F2   0x2800             CMP      R0,#+0
   \   000000F4   0xD01B             BEQ.N    ??WM_HandlePID_2
    198                    /* convert screen into window coordinates */
    199                    State = StateNew;
   \   000000F6   0xA808             ADD      R0,SP,#+32
   \   000000F8   0xA902             ADD      R1,SP,#+8
   \   000000FA   0xC98C             LDM      R1!,{R2,R3,R7}
   \   000000FC   0xC08C             STM      R0!,{R2,R3,R7}
    200                    /* Remember window */
    201                    if (State.Pressed) {
   \   000000FE   0xF89D 0x0028      LDRB     R0,[SP, #+40]
   \   00000102   0x2800             CMP      R0,#+0
   \   00000104   0xD003             BEQ.N    ??WM_HandlePID_7
    202                      WM__CHWinLast.hWin = CHWin.hWin;
   \   00000106   0xF8BD 0x0004      LDRH     R0,[SP, #+4]
   \   0000010A   0x80B0             STRH     R0,[R6, #+4]
   \   0000010C   0xE008             B.N      ??WM_HandlePID_8
    203                    } else {
    204                      /* Handle automatic capture release */
    205                      if (WM__CaptureReleaseAuto) {
   \                     ??WM_HandlePID_7: (+1)
   \   0000010E   0x....             LDR.N    R0,??DataTable2_4
   \   00000110   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000114   0x2800             CMP      R0,#+0
   \   00000116   0xD001             BEQ.N    ??WM_HandlePID_9
    206                        WM_ReleaseCapture();
   \   00000118   0x.... 0x....      BL       WM_ReleaseCapture
    207                      }
    208                      WM__CHWinLast.hWin = 0;
   \                     ??WM_HandlePID_9: (+1)
   \   0000011C   0x2000             MOVS     R0,#+0
   \   0000011E   0x80B0             STRH     R0,[R6, #+4]
    209                    }
    210                    Msg.Data.p = (void*)&State;
   \                     ??WM_HandlePID_8: (+1)
   \   00000120   0xA808             ADD      R0,SP,#+32
   \   00000122   0x9007             STR      R0,[SP, #+28]
    211                    WM__SendTouchMessage(CHWin.hWin, &Msg);
   \   00000124   0xA905             ADD      R1,SP,#+20
   \   00000126   0xF9BD 0x0004      LDRSH    R0,[SP, #+4]
   \   0000012A   0x.... 0x....      BL       WM__SendTouchMessage
    212                  }
    213                }
    214                /*
    215                 * Send WM_MOUSEOVER message
    216                 */
    217                #if GUI_SUPPORT_MOUSE
    218                else {
    219                  /* Send WM_MOUSEOVER Message */
    220                  if (CHWin.hWin) {
    221                    /* Do not send messages to disabled windows */
    222                    if (WM__IsEnabled(CHWin.hWin)) {
    223                      State      = StateNew;
    224                      Msg.MsgId  = WM_MOUSEOVER;
    225                      Msg.Data.p = (void*)&State;
    226                      WM__SendTouchMessage(CHWin.hWin, &Msg);
    227                    }
    228                  }
    229                }
    230                #endif
    231              }
    232              /* Store the new state */
    233              WM_PID__StateLast = StateNew;
   \                     ??WM_HandlePID_2: (+1)
   \   0000012E   0xA802             ADD      R0,SP,#+8
   \   00000130   0xC80E             LDM      R0!,{R1-R3}
   \   00000132   0xC40E             STM      R4!,{R1-R3}
    234            }
    235            WM__RemoveCriticalHandle(&CHWin);
   \                     ??WM_HandlePID_1: (+1)
   \   00000134   0xA800             ADD      R0,SP,#+0
   \   00000136   0x.... 0x....      BL       WM__RemoveCriticalHandle
    236            WM_UNLOCK();
    237            return r;
   \   0000013A   0x4628             MOV      R0,R5
   \   0000013C   0xB00F             ADD      SP,SP,#+60
   \   0000013E   0xBDF0             POP      {R4-R7,PC}       ;; return
    238          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     WM__CHWinModal

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x........         DC32     WM__hCapture

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x........         DC32     WM_PID__StateLast

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x........         DC32     WM__CHWinLast

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x........         DC32     WM__CaptureReleaseAuto
    239          
    240          #else
    241            void WM_Touch_c(void) {} /* avoid empty object files */
    242          #endif  /* (GUI_WINSUPPORT & GUI_SUPPORT_TOUCH) */
    243          
    244          /*************************** End of file ****************************/
    245          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      80   WM_HandlePID
        80   -> GUI_ALLOC_h2p
        80   -> GUI_CURSOR_SetPosition
        80   -> GUI_PID_GetState
        80   -> WM_ReleaseCapture
        80   -> WM__AddCriticalHandle
        80   -> WM__IsInModalArea
        80   -> WM__RemoveCriticalHandle
        80   -> WM__SendMessageIfEnabled
        80   -> WM__SendTouchMessage
        80   -> _Screen2Win
      16   WM__IsInModalArea
        16   -> WM__IsAncestor
      24   WM__SendPIDMessage
        24   -> WM_GetParent
        24   -> WM_IsWindow
        24   -> WM__SendMessageIfEnabled
      16   WM__SendTouchMessage
        16   -> GUI_ALLOC_h2p
         0   -> WM__SendPIDMessage
       0   _Screen2Win
         0   -> WM_Screen2hWin


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
     320  WM_HandlePID
       8  WM__CHWinLast
       8  WM__CHWinModal
      44  WM__IsInModalArea
      62  WM__SendPIDMessage
      46  WM__SendTouchMessage
      22  _Screen2Win

 
  16 bytes in section .bss
 514 bytes in section .text
 
 514 bytes of CODE memory
  16 bytes of DATA memory

Errors: none
Warnings: 1
