###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  10:58:20
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Core\GUI_UC_EncodeUTF8.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Core\GUI_UC_EncodeUTF8.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\GUI_UC_EncodeUTF8.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\GUI_UC_EncodeUTF8.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Core\GUI_UC_EncodeUTF8.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              µC/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : GUI_UC_EncodeUTF8.c
     16          Purpose     : Encoding routines
     17          ---------------------------END-OF-HEADER------------------------------
     18          */
     19          
     20          #include "GUI_Protected.h"
     21          
     22          /*********************************************************************
     23          *
     24          *       Static code
     25          *
     26          **********************************************************************
     27          */
     28          /*********************************************************************
     29          *
     30          *       _GetCharCode
     31          *
     32          * Purpose:
     33          *   Return the UNICODE character code of the current character.
     34          */

   \                                 In section .text, align 2, keep-with-next
     35          static U16 _GetCharCode(const char GUI_UNI_PTR * s) {
     36            U16 r;
     37            U8 Char = *(const U8*)s;
   \                     _GetCharCode: (+1)
   \   00000000   0x7801             LDRB     R1,[R0, #+0]
     38            if ((Char & 0x80) == 0) {                /* Single byte (ASCII)  */
   \   00000002   0x460A             MOV      R2,R1
   \   00000004   0x0612             LSLS     R2,R2,#+24
   \   00000006   0xD51F             BPL.N    ??_GetCharCode_0
     39              r = Char;
     40            } else if ((Char & 0xe0) == 0xc0) {      /* Double byte sequence */
   \   00000008   0xF001 0x02E0      AND      R2,R1,#0xE0
   \   0000000C   0x2AC0             CMP      R2,#+192
   \   0000000E   0xD107             BNE.N    ??_GetCharCode_1
     41              r = (Char & 0x1f) << 6;
     42              Char = *(++s);
     43              Char &= 0x3f;
     44              r |= Char;
   \   00000010   0xF001 0x011F      AND      R1,R1,#0x1F
   \   00000014   0x7840             LDRB     R0,[R0, #+1]
   \   00000016   0xF000 0x003F      AND      R0,R0,#0x3F
   \   0000001A   0xEA40 0x1181      ORR      R1,R0,R1, LSL #+6
   \   0000001E   0xE013             B.N      ??_GetCharCode_0
     45            } else if ((Char & 0xf0) == 0xe0) {      /* 3 byte sequence      */
   \                     ??_GetCharCode_1: (+1)
   \   00000020   0xF001 0x02F0      AND      R2,R1,#0xF0
   \   00000024   0x2AE0             CMP      R2,#+224
   \   00000026   0xD10E             BNE.N    ??_GetCharCode_2
     46              r = (Char & 0x0f) << 12;
   \   00000028   0x030A             LSLS     R2,R1,#+12
     47              Char = *(++s);
   \   0000002A   0xF910 0x1F01      LDRSB    R1,[R0, #+1]!
   \   0000002E   0xB2C9             UXTB     R1,R1
     48              Char &= 0x3f;
     49              r |= (Char << 6);
     50              Char = *(++s);
     51              Char &= 0x3f;
     52              r |= Char;
   \   00000030   0xF001 0x013F      AND      R1,R1,#0x3F
   \   00000034   0xF810 0x3F01      LDRB     R3,[R0, #+1]!
   \   00000038   0xF003 0x003F      AND      R0,R3,#0x3F
   \   0000003C   0xEA40 0x1081      ORR      R0,R0,R1, LSL #+6
   \   00000040   0xEA40 0x0102      ORR      R1,R0,R2
   \   00000044   0xE000             B.N      ??_GetCharCode_0
     53            } else {
     54              GUI_DEBUG_ERROROUT("Illegal character during UTF-8 decoding!");
     55              r = 1;       /* Illegal character. To avoid endless loops in upper layers, we return 1 rather than 0. */
   \                     ??_GetCharCode_2: (+1)
   \   00000046   0x2101             MOVS     R1,#+1
     56            }
     57            return r;
   \                     ??_GetCharCode_0: (+1)
   \   00000048   0x4608             MOV      R0,R1
   \   0000004A   0xB280             UXTH     R0,R0
   \   0000004C   0x4770             BX       LR               ;; return
     58          }
     59          
     60          /*********************************************************************
     61          *
     62          *       _GetCharSize
     63          *
     64          * Purpose:
     65          *   Return the number of bytes of the current character.
     66          */

   \                                 In section .text, align 2, keep-with-next
     67          static int _GetCharSize(const char GUI_UNI_PTR * s) {
     68            U8 Char = *s;
   \                     _GetCharSize: (+1)
   \   00000000   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000004   0xB2C0             UXTB     R0,R0
     69            if ((Char & 0x80) == 0) {
   \   00000006   0x4601             MOV      R1,R0
   \   00000008   0x0609             LSLS     R1,R1,#+24
   \   0000000A   0xD401             BMI.N    ??_GetCharSize_0
     70              return 1;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x4770             BX       LR
     71            } else if ((Char & 0xe0) == 0xc0) {
   \                     ??_GetCharSize_0: (+1)
   \   00000010   0xF000 0x01E0      AND      R1,R0,#0xE0
   \   00000014   0x29C0             CMP      R1,#+192
   \   00000016   0xD101             BNE.N    ??_GetCharSize_1
     72              return 2;
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0x4770             BX       LR
     73            } else if ((Char & 0xf0) == 0xe0) {
   \                     ??_GetCharSize_1: (+1)
   \   0000001C   0xF000 0x00F0      AND      R0,R0,#0xF0
   \   00000020   0x28E0             CMP      R0,#+224
   \   00000022   0xD101             BNE.N    ??_GetCharSize_2
     74              return 3;
   \   00000024   0x2003             MOVS     R0,#+3
   \   00000026   0x4770             BX       LR
     75            }
     76            GUI_DEBUG_ERROROUT("Illegal character during UTF-8 decoding!");
     77            return 1;       /* Illegal character. To avoid endless loops in upper layers, we return 1 rather than 0. */
   \                     ??_GetCharSize_2: (+1)
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x4770             BX       LR               ;; return
     78          }
     79          
     80          /*********************************************************************
     81          *
     82          *       _CalcSizeOfChar
     83          *
     84          * Purpose:
     85          *   Return the number of bytes needed for the given character.
     86          */

   \                                 In section .text, align 2, keep-with-next
     87          static int _CalcSizeOfChar(U16 Char) {
     88            int r;
     89            if (Char & 0xF800) {                /* Single byte (ASCII)  */
   \                     _CalcSizeOfChar: (+1)
   \   00000000   0xF44F 0x4178      MOV      R1,#+63488
   \   00000004   0x4208             TST      R0,R1
   \   00000006   0xD001             BEQ.N    ??_CalcSizeOfChar_0
     90              r = 3;
   \   00000008   0x2003             MOVS     R0,#+3
   \   0000000A   0x4770             BX       LR
     91            } else if (Char & 0xFF80) {         /* Double byte sequence */
   \                     ??_CalcSizeOfChar_0: (+1)
   \   0000000C   0xF64F 0x7180      MOVW     R1,#+65408
   \   00000010   0x4208             TST      R0,R1
   \   00000012   0xD001             BEQ.N    ??_CalcSizeOfChar_1
     92              r = 2;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0x4770             BX       LR
     93            } else {                            /* 3 byte sequence      */
     94              r = 1;
   \                     ??_CalcSizeOfChar_1: (+1)
   \   00000018   0x2001             MOVS     R0,#+1
     95            }
     96            return r;
   \   0000001A   0x4770             BX       LR               ;; return
     97          }
     98          
     99          /*********************************************************************
    100          *
    101          *       _Encode
    102          *
    103          * Purpose:
    104          *   Encode character into 1/2/3 bytes.
    105          */

   \                                 In section .text, align 2, keep-with-next
    106          static int _Encode(char *s, U16 Char) {
   \                     _Encode: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    107            int r;
    108            r = _CalcSizeOfChar(Char);
   \   00000006   0x4628             MOV      R0,R5
   \   00000008   0x.... 0x....      BL       _CalcSizeOfChar
    109            switch (r) {
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD004             BEQ.N    ??_Encode_0
   \   00000010   0xD321             BCC.N    ??_Encode_1
   \   00000012   0x2803             CMP      R0,#+3
   \   00000014   0xD00E             BEQ.N    ??_Encode_2
   \   00000016   0xD302             BCC.N    ??_Encode_3
   \   00000018   0xBD32             POP      {R1,R4,R5,PC}
    110            case 1:
    111              *s = (char)Char;
   \                     ??_Encode_0: (+1)
   \   0000001A   0x7025             STRB     R5,[R4, #+0]
    112              break;
   \   0000001C   0xBD32             POP      {R1,R4,R5,PC}
    113            case 2:
    114              *s++ = 0xC0 | (Char >> 6);
   \                     ??_Encode_3: (+1)
   \   0000001E   0x09A9             LSRS     R1,R5,#+6
   \   00000020   0xF061 0x013F      ORN      R1,R1,#+63
   \   00000024   0x7021             STRB     R1,[R4, #+0]
    115              *s   = 0x80 | (Char & 0x3F);
   \   00000026   0xF005 0x013F      AND      R1,R5,#0x3F
   \   0000002A   0xF061 0x017F      ORN      R1,R1,#+127
   \   0000002E   0xF804 0x1F01      STRB     R1,[R4, #+1]!
    116              break;
   \   00000032   0xBD32             POP      {R1,R4,R5,PC}
    117            case 3:
    118              *s++ = 0xE0 | (Char >> 12);
   \                     ??_Encode_2: (+1)
   \   00000034   0x0B29             LSRS     R1,R5,#+12
   \   00000036   0xF061 0x011F      ORN      R1,R1,#+31
   \   0000003A   0x7021             STRB     R1,[R4, #+0]
    119              *s++ = 0x80 | ((Char >> 6) & 0x3F);
   \   0000003C   0x09A9             LSRS     R1,R5,#+6
   \   0000003E   0xF001 0x013F      AND      R1,R1,#0x3F
   \   00000042   0xF061 0x017F      ORN      R1,R1,#+127
   \   00000046   0xF804 0x1F01      STRB     R1,[R4, #+1]!
    120              *s   = 0x80 | (Char & 0x3F);
   \   0000004A   0xF005 0x013F      AND      R1,R5,#0x3F
   \   0000004E   0xF061 0x017F      ORN      R1,R1,#+127
   \   00000052   0xF804 0x1F01      STRB     R1,[R4, #+1]!
    121              break;
    122            }
    123            return r;
   \                     ??_Encode_1: (+1)
   \   00000056   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    124          }
    125          
    126          /*********************************************************************
    127          *
    128          *       _API_Table
    129          */

   \                                 In section .text, align 4, keep-with-next
    130          static const GUI_UC_ENC_APILIST _API_Table = {
   \                     _API_Table:
   \   00000000   0x........         DC32 _GetCharCode, _GetCharSize, _CalcSizeOfChar, _Encode
   \              0x........   
   \              0x........   
   \              0x........   
    131            _GetCharCode,     /*  return character code as U16 (Unicode) */
    132            _GetCharSize,     /*  return size of character: 1/2/3        */
    133            _CalcSizeOfChar,  /*  return size of character: 1/2/3        */
    134            _Encode           /*  Encode character into 1/2/3 bytes      */
    135          };
    136          
    137          /*********************************************************************
    138          *
    139          *       Exported code
    140          *
    141          **********************************************************************
    142          */
    143          /*********************************************************************
    144          *
    145          *       GUI_UC_SetEncodeUTF8
    146          */

   \                                 In section .text, align 2, keep-with-next
    147          void GUI_UC_SetEncodeUTF8(void) {
    148            GUI_LOCK();
    149            GUI_Context.pUC_API = &_API_Table;
   \                     GUI_UC_SetEncodeUTF8: (+1)
   \   00000000   0x.... 0x....      ADR.W    R0,_API_Table
   \   00000004   0x....             LDR.N    R1,??DataTable1
   \   00000006   0x61C8             STR      R0,[R1, #+28]
    150            GUI_UNLOCK();
    151          }
   \   00000008   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     GUI_Context
    152          
    153          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   GUI_UC_SetEncodeUTF8
       0   _CalcSizeOfChar
      16   _Encode
        16   -> _CalcSizeOfChar
       0   _GetCharCode
       0   _GetCharSize


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
      10  GUI_UC_SetEncodeUTF8
      16  _API_Table
      28  _CalcSizeOfChar
      88  _Encode
      78  _GetCharCode
      44  _GetCharSize

 
 268 bytes in section .text
 
 268 bytes of CODE memory

Errors: none
Warnings: none
