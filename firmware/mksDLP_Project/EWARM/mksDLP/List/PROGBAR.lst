###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  10:59:20
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Widget\PROGBAR.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Widget\PROGBAR.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\PROGBAR.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\PROGBAR.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Widget\PROGBAR.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              µC/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : ProgBar.c
     16          Purpose     : Implementation of progress bar
     17          ---------------------------END-OF-HEADER------------------------------
     18          */
     19          
     20          #include <stdlib.h>
     21          #include <string.h>
     22          #include "GUI_Protected.h"
     23          #include "PROGBAR.h"
     24          #include "WIDGET.h"
     25          
     26          #if GUI_WINSUPPORT
     27          
     28          /*********************************************************************
     29          *
     30          *       Private config defaults
     31          *
     32          **********************************************************************
     33          */
     34          
     35          #ifndef PROGBAR_DEFAULT_FONT
     36            #define PROGBAR_DEFAULT_FONT GUI_DEFAULT_FONT
     37          #endif
     38          
     39          #ifndef PROGBAR_DEFAULT_BARCOLOR0
     40            #define PROGBAR_DEFAULT_BARCOLOR0 0x555555
     41          #endif
     42          
     43          #ifndef PROGBAR_DEFAULT_BARCOLOR1
     44            #define PROGBAR_DEFAULT_BARCOLOR1 0xAAAAAA
     45          #endif
     46          
     47          #ifndef PROGBAR_DEFAULT_TEXTCOLOR0
     48            #define PROGBAR_DEFAULT_TEXTCOLOR0 0xFFFFFF
     49          #endif
     50          
     51          #ifndef PROGBAR_DEFAULT_TEXTCOLOR1
     52            #define PROGBAR_DEFAULT_TEXTCOLOR1 0x000000
     53          #endif
     54          
     55          /*********************************************************************
     56          *
     57          *       Object definition
     58          *
     59          **********************************************************************
     60          */
     61          
     62          typedef struct {
     63            WIDGET Widget;
     64            int v;
     65            const GUI_FONT GUI_UNI_PTR * pFont;
     66            GUI_COLOR BarColor[2];
     67            GUI_COLOR TextColor[2];
     68            WM_HMEM hpText;
     69            I16 XOff, YOff;
     70            I16 TextAlign;
     71            int Min, Max;
     72          /*  I16 Options; */
     73            #if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
     74              int DebugId;
     75            #endif  
     76          } PROGBAR_Obj;
     77          
     78          /*********************************************************************
     79          *
     80          *       Macros for internal use
     81          *
     82          **********************************************************************
     83          */
     84          
     85          #define Invalidate(h) WM_InvalidateWindow(h)
     86          
     87          #if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
     88            #define OBJECT_ID 0x4569   /* Magic nubmer, should be unique if possible */
     89            #define INIT_ID(p)   p->DebugId = OBJECT_ID
     90            #define DEINIT_ID(p) p->DebugId = OBJECT_ID+1
     91          #else
     92            #define INIT_ID(p)
     93            #define DEINIT_ID(p)
     94          #endif
     95          
     96          /*********************************************************************
     97          *
     98          *       Static routines
     99          *
    100          **********************************************************************
    101          */
    102          
    103          #if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
    104            PROGBAR_Obj* PROGBAR_h2p(PROGBAR_Handle h) {
    105              PROGBAR_Obj* p = (PROGBAR_Obj*)GUI_ALLOC_h2p(h);
    106              if (p) {
    107                if (p->DebugId != OBJECT_ID) {
    108                  GUI_DEBUG_ERROROUT("PROGBAR.C: Wrong handle type or Object not init'ed");
    109                  return 0;
    110                }
    111              }
    112              return p;
    113            }
    114            #define PROGBAR_H2P(h) PROGBAR_h2p(h)
    115          #else
    116            #define PROGBAR_H2P(h) (PROGBAR_Obj*) GUI_ALLOC_h2p(h)
    117          #endif
    118          
    119          /*********************************************************************
    120          *
    121          *       _FreeText
    122          */

   \                                 In section .text, align 2, keep-with-next
    123          static void _FreeText(PROGBAR_Handle hObj) {
   \                     _FreeText: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    124            PROGBAR_Obj* pObj = PROGBAR_H2P(hObj);
   \   00000002   0x.... 0x....      BL       GUI_ALLOC_h2p
    125            GUI_ALLOC_FreePtr(&pObj->hpText);
   \   00000006   0x3040             ADDS     R0,R0,#+64
   \   00000008   0xE8BD 0x4002      POP      {R1,LR}
   \   0000000C   0x.... 0x....      B.W      GUI_ALLOC_FreePtr
    126          }
    127          
    128          /*********************************************************************
    129          *
    130          *       _Value2X
    131          */

   \                                 In section .text, align 2, keep-with-next
    132          static int _Value2X(const PROGBAR_Obj* pObj, int v) {
   \                     _Value2X: (+1)
   \   00000000   0xB410             PUSH     {R4}
    133            int EffectSize = pObj->Widget.pEffect->EffectSize;
   \   00000002   0x6A02             LDR      R2,[R0, #+32]
   \   00000004   0x6952             LDR      R2,[R2, #+20]
    134            int xSize = pObj->Widget.Win.Rect.x1 - pObj->Widget.Win.Rect.x0 + 1;
   \   00000006   0xF9B0 0x3004      LDRSH    R3,[R0, #+4]
   \   0000000A   0xF9B0 0x4000      LDRSH    R4,[R0, #+0]
   \   0000000E   0x1B1B             SUBS     R3,R3,R4
   \   00000010   0x1C5B             ADDS     R3,R3,#+1
    135            int Min   = pObj->Min;
   \   00000012   0x6C84             LDR      R4,[R0, #+72]
    136            int Max   = pObj->Max;
   \   00000014   0x6CC0             LDR      R0,[R0, #+76]
    137            if (v < Min) {
   \   00000016   0x42A1             CMP      R1,R4
   \   00000018   0xDA00             BGE.N    ??_Value2X_0
   \   0000001A   0x4621             MOV      R1,R4
    138          	  v = Min;
    139            }
    140            if (v > Max) {
   \                     ??_Value2X_0: (+1)
   \   0000001C   0x4288             CMP      R0,R1
   \   0000001E   0xDC00             BGT.N    ??_Value2X_1
   \   00000020   0x4601             MOV      R1,R0
    141          	  v = Max;
    142            }
    143            return EffectSize + ((xSize - 2 * EffectSize) * (I32)(v - Min)) / (Max - Min);
   \                     ??_Value2X_1: (+1)
   \   00000022   0xEBA3 0x0342      SUB      R3,R3,R2, LSL #+1
   \   00000026   0x1B09             SUBS     R1,R1,R4
   \   00000028   0x4359             MULS     R1,R1,R3
   \   0000002A   0x1B00             SUBS     R0,R0,R4
   \   0000002C   0xFB91 0xF0F0      SDIV     R0,R1,R0
   \   00000030   0x1880             ADDS     R0,R0,R2
   \   00000032   0xBC10             POP      {R4}
   \   00000034   0x4770             BX       LR               ;; return
    144          }
    145          
    146          /*********************************************************************
    147          *
    148          *       _DrawPart
    149          */

   \                                 In section .text, align 2, keep-with-next
    150          static void _DrawPart(const PROGBAR_Obj* pObj, int Index,
    151          										  int xText, int yText, const char* pText) {
   \                     _DrawPart: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4614             MOV      R4,R2
   \   00000004   0x461D             MOV      R5,R3
    152            LCD_SetBkColor(pObj->BarColor[Index]);
   \   00000006   0xEB00 0x0681      ADD      R6,R0,R1, LSL #+2
   \   0000000A   0x6B30             LDR      R0,[R6, #+48]
   \   0000000C   0x.... 0x....      BL       LCD_SetBkColor
    153            LCD_SetColor(pObj->TextColor[Index]);
   \   00000010   0x6BB0             LDR      R0,[R6, #+56]
   \   00000012   0x.... 0x....      BL       LCD_SetColor
    154            GUI_Clear();
   \   00000016   0x.... 0x....      BL       GUI_Clear
    155            GUI_GotoXY(xText, yText);
   \   0000001A   0x4629             MOV      R1,R5
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       GUI_GotoXY
    156            GUI_DispString(pText);
   \   00000022   0x9804             LDR      R0,[SP, #+16]
   \   00000024   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000028   0x.... 0x....      B.W      GUI_DispString
    157          }
    158          
    159          /*********************************************************************
    160          *
    161          *       _GetText
    162          */

   \                                 In section .text, align 2, keep-with-next
    163          static const char* _GetText(const PROGBAR_Obj* pObj, char* pBuffer) {
   \                     _GetText: (+1)
   \   00000000   0xB532             PUSH     {R1,R4,R5,LR}
    164            char* pText;
    165            if (pObj->hpText) {
   \   00000002   0xF9B0 0x1040      LDRSH    R1,[R0, #+64]
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD004             BEQ.N    ??_GetText_0
    166              pText = (char*) GUI_ALLOC_h2p(pObj->hpText);
   \   0000000A   0x4608             MOV      R0,R1
   \   0000000C   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000010   0x4604             MOV      R4,R0
   \   00000012   0xE012             B.N      ??_GetText_1
    167            } else {
    168              pText = pBuffer;
   \                     ??_GetText_0: (+1)
   \   00000014   0x9C00             LDR      R4,[SP, #+0]
    169              GUI_AddDecMin((100 * (I32)(pObj->v - pObj->Min)) / (pObj->Max - pObj->Min), &pBuffer);
   \   00000016   0x6C82             LDR      R2,[R0, #+72]
   \   00000018   0xA900             ADD      R1,SP,#+0
   \   0000001A   0x6A83             LDR      R3,[R0, #+40]
   \   0000001C   0x1A9B             SUBS     R3,R3,R2
   \   0000001E   0x2564             MOVS     R5,#+100
   \   00000020   0x436B             MULS     R3,R5,R3
   \   00000022   0x6CC0             LDR      R0,[R0, #+76]
   \   00000024   0x1A80             SUBS     R0,R0,R2
   \   00000026   0xFB93 0xF0F0      SDIV     R0,R3,R0
   \   0000002A   0x.... 0x....      BL       GUI_AddDecMin
    170              *pBuffer++ = '%';
   \   0000002E   0x2025             MOVS     R0,#+37
   \   00000030   0x9900             LDR      R1,[SP, #+0]
   \   00000032   0x7008             STRB     R0,[R1, #+0]
    171          		*pBuffer   = 0;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x9900             LDR      R1,[SP, #+0]
   \   00000038   0x7048             STRB     R0,[R1, #+1]
    172          	}
    173            return (const char*)pText;
   \                     ??_GetText_1: (+1)
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    174          }
    175          
    176          /*********************************************************************
    177          *
    178          *       _GetTextRect
    179          */

   \                                 In section .text, align 2, keep-with-next
    180          static void _GetTextRect(const PROGBAR_Obj* pObj, GUI_RECT* pRect, const char* pText) {
   \                     _GetTextRect: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4610             MOV      R0,R2
    181            int xSize      = pObj->Widget.Win.Rect.x1 - pObj->Widget.Win.Rect.x0 + 1;
   \   0000000A   0xF9B4 0x1004      LDRSH    R1,[R4, #+4]
   \   0000000E   0xF9B4 0x2000      LDRSH    R2,[R4, #+0]
   \   00000012   0x1A89             SUBS     R1,R1,R2
   \   00000014   0x1C4F             ADDS     R7,R1,#+1
    182            int ySize      = pObj->Widget.Win.Rect.y1 - pObj->Widget.Win.Rect.y0 + 1;
   \   00000016   0xF9B4 0x1006      LDRSH    R1,[R4, #+6]
   \   0000001A   0xF9B4 0x2002      LDRSH    R2,[R4, #+2]
   \   0000001E   0x1A89             SUBS     R1,R1,R2
   \   00000020   0xF101 0x0801      ADD      R8,R1,#+1
    183            int TextWidth  = GUI_GetStringDistX(pText);
   \   00000024   0x.... 0x....      BL       GUI_GetStringDistX
   \   00000028   0x4606             MOV      R6,R0
    184            int TextHeight = GUI_GetFontSizeY();
   \   0000002A   0x.... 0x....      BL       GUI_GetFontSizeY
    185            int EffectSize = pObj->Widget.pEffect->EffectSize;
   \   0000002E   0x6A21             LDR      R1,[R4, #+32]
   \   00000030   0x6949             LDR      R1,[R1, #+20]
    186            switch (pObj->TextAlign & GUI_TA_HORIZONTAL) {
   \   00000032   0xF894 0x2046      LDRB     R2,[R4, #+70]
   \   00000036   0xF002 0x0213      AND      R2,R2,#0x13
   \   0000003A   0x2A01             CMP      R2,#+1
   \   0000003C   0xD007             BEQ.N    ??_GetTextRect_0
   \   0000003E   0x2A02             CMP      R2,#+2
   \   00000040   0xD10A             BNE.N    ??_GetTextRect_1
    187            case GUI_TA_CENTER:
    188              pRect->x0 = (xSize - TextWidth) / 2;
   \   00000042   0x1BB9             SUBS     R1,R7,R6
   \   00000044   0xEB01 0x71D1      ADD      R1,R1,R1, LSR #+31
   \   00000048   0x1049             ASRS     R1,R1,#+1
   \   0000004A   0x8029             STRH     R1,[R5, #+0]
    189          		break;
   \   0000004C   0xE005             B.N      ??_GetTextRect_2
    190            case GUI_TA_RIGHT:
    191              pRect->x0 = xSize - TextWidth - 1 - EffectSize;
   \                     ??_GetTextRect_0: (+1)
   \   0000004E   0x1BBA             SUBS     R2,R7,R6
   \   00000050   0x1E52             SUBS     R2,R2,#+1
   \   00000052   0x1A51             SUBS     R1,R2,R1
   \   00000054   0x8029             STRH     R1,[R5, #+0]
    192          		break;
   \   00000056   0xE000             B.N      ??_GetTextRect_2
    193            default:
    194              pRect->x0 = EffectSize;
   \                     ??_GetTextRect_1: (+1)
   \   00000058   0x8029             STRH     R1,[R5, #+0]
    195          	}
    196            pRect->y0  = (ySize - TextHeight) / 2;
   \                     ??_GetTextRect_2: (+1)
   \   0000005A   0xEBA8 0x0100      SUB      R1,R8,R0
   \   0000005E   0xEB01 0x71D1      ADD      R1,R1,R1, LSR #+31
   \   00000062   0x1049             ASRS     R1,R1,#+1
   \   00000064   0x8069             STRH     R1,[R5, #+2]
    197            pRect->x0 += pObj->XOff;
   \   00000066   0x8829             LDRH     R1,[R5, #+0]
   \   00000068   0xF8B4 0x2042      LDRH     R2,[R4, #+66]
   \   0000006C   0x1851             ADDS     R1,R2,R1
   \   0000006E   0x8029             STRH     R1,[R5, #+0]
    198            pRect->y0 += pObj->YOff;
   \   00000070   0x8869             LDRH     R1,[R5, #+2]
   \   00000072   0xF8B4 0x2044      LDRH     R2,[R4, #+68]
   \   00000076   0x1851             ADDS     R1,R2,R1
   \   00000078   0x8069             STRH     R1,[R5, #+2]
    199            pRect->x1  = pRect->x0 + TextWidth  - 1;
   \   0000007A   0x8829             LDRH     R1,[R5, #+0]
   \   0000007C   0x1871             ADDS     R1,R6,R1
   \   0000007E   0x1E49             SUBS     R1,R1,#+1
   \   00000080   0x80A9             STRH     R1,[R5, #+4]
    200            pRect->y1  = pRect->y0 + TextHeight - 1;
   \   00000082   0x8869             LDRH     R1,[R5, #+2]
   \   00000084   0x1840             ADDS     R0,R0,R1
   \   00000086   0x1E40             SUBS     R0,R0,#+1
   \   00000088   0x80E8             STRH     R0,[R5, #+6]
    201          }
   \   0000008A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    202          
    203          /*********************************************************************
    204          *
    205          *       _Paint
    206          */

   \                                 In section .text, align 2, keep-with-next
    207          static void _Paint(PROGBAR_Handle hObj) {
   \                     _Paint: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
    208            PROGBAR_Obj* pObj;
    209            GUI_RECT r, rInside, rClient, rText;
    210            const char* pText;
    211            char ac[5];
    212            int tm, xPos;
    213            pObj = PROGBAR_H2P(hObj);
   \   00000004   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000008   0x4604             MOV      R4,R0
    214            WM_GetClientRect(&rClient);
   \   0000000A   0xA805             ADD      R0,SP,#+20
   \   0000000C   0x.... 0x....      BL       WM_GetClientRect
    215            GUI__ReduceRect(&rInside, &rClient, pObj->Widget.pEffect->EffectSize);
   \   00000010   0x6A20             LDR      R0,[R4, #+32]
   \   00000012   0x6942             LDR      R2,[R0, #+20]
   \   00000014   0xA905             ADD      R1,SP,#+20
   \   00000016   0xA807             ADD      R0,SP,#+28
   \   00000018   0x.... 0x....      BL       GUI__ReduceRect
    216            xPos  = _Value2X(pObj, pObj->v);
   \   0000001C   0x6AA1             LDR      R1,[R4, #+40]
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       _Value2X
   \   00000024   0x4605             MOV      R5,R0
    217            pText = _GetText(pObj, ac);
   \   00000026   0xA909             ADD      R1,SP,#+36
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       _GetText
   \   0000002E   0x4606             MOV      R6,R0
    218            GUI_SetFont(pObj->pFont);
   \   00000030   0x6AE0             LDR      R0,[R4, #+44]
   \   00000032   0x.... 0x....      BL       GUI_SetFont
    219            _GetTextRect(pObj, &rText, pText);
   \   00000036   0x4632             MOV      R2,R6
   \   00000038   0xA903             ADD      R1,SP,#+12
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x.... 0x....      BL       _GetTextRect
    220            tm = GUI_SetTextMode(GUI_TM_TRANS);
   \   00000040   0x2002             MOVS     R0,#+2
   \   00000042   0x.... 0x....      BL       GUI_SetTextMode
   \   00000046   0x4607             MOV      R7,R0
    221            /* Draw left bar */
    222            r    = rInside;
   \   00000048   0xE9DD 0x0107      LDRD     R0,R1,[SP, #+28]
   \   0000004C   0xE9CD 0x0101      STRD     R0,R1,[SP, #+4]
    223            r.x1 = xPos - 1;
   \   00000050   0x4628             MOV      R0,R5
   \   00000052   0x1E40             SUBS     R0,R0,#+1
   \   00000054   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    224            WM_SetUserClipArea(&r);
   \   00000058   0xA801             ADD      R0,SP,#+4
   \   0000005A   0x.... 0x....      BL       WM_SetUserClipRect
    225            _DrawPart(pObj, 0, rText.x0, rText.y0, pText);
   \   0000005E   0x9600             STR      R6,[SP, #+0]
   \   00000060   0xF9BD 0x300E      LDRSH    R3,[SP, #+14]
   \   00000064   0xF9BD 0x200C      LDRSH    R2,[SP, #+12]
   \   00000068   0x2100             MOVS     R1,#+0
   \   0000006A   0x4620             MOV      R0,R4
   \   0000006C   0x.... 0x....      BL       _DrawPart
    226            /* Draw right bar */
    227            r    = rInside;
   \   00000070   0xE9DD 0x0107      LDRD     R0,R1,[SP, #+28]
   \   00000074   0xE9CD 0x0101      STRD     R0,R1,[SP, #+4]
    228            r.x0 = xPos;
   \   00000078   0xF8AD 0x5004      STRH     R5,[SP, #+4]
    229            WM_SetUserClipArea(&r);
   \   0000007C   0xA801             ADD      R0,SP,#+4
   \   0000007E   0x.... 0x....      BL       WM_SetUserClipRect
    230            _DrawPart(pObj, 1, rText.x0, rText.y0, pText);
   \   00000082   0x9600             STR      R6,[SP, #+0]
   \   00000084   0xF9BD 0x300E      LDRSH    R3,[SP, #+14]
   \   00000088   0xF9BD 0x200C      LDRSH    R2,[SP, #+12]
   \   0000008C   0x2101             MOVS     R1,#+1
   \   0000008E   0x4620             MOV      R0,R4
   \   00000090   0x.... 0x....      BL       _DrawPart
    231            WM_SetUserClipArea(NULL);
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0x.... 0x....      BL       WM_SetUserClipRect
    232            GUI_SetTextMode(tm);
   \   0000009A   0x4638             MOV      R0,R7
   \   0000009C   0x.... 0x....      BL       GUI_SetTextMode
    233            WIDGET__EFFECT_DrawDownRect(&pObj->Widget, &rClient);
   \   000000A0   0xA905             ADD      R1,SP,#+20
   \   000000A2   0x4620             MOV      R0,R4
   \   000000A4   0x.... 0x....      BL       WIDGET__EFFECT_DrawDownRect
    234          }
   \   000000A8   0xB00B             ADD      SP,SP,#+44
   \   000000AA   0xBDF0             POP      {R4-R7,PC}       ;; return
    235          
    236          /*********************************************************************
    237          *
    238          *       _Delete
    239          */

   \                                 In section .text, align 2, keep-with-next
    240          static void _Delete(PROGBAR_Handle hObj) {
    241            _FreeText(hObj);
   \                     _Delete: (+1)
   \   00000000   0x....             B.N      _FreeText
    242            DEINIT_ID(PROGBAR_H2P(hObj));
    243          }
    244          
    245          /*********************************************************************
    246          *
    247          *       _Callback
    248          */

   \                                 In section .text, align 2, keep-with-next
    249          static void _PROGBAR_Callback(WM_MESSAGE*pMsg) {
   \                     _PROGBAR_Callback: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    250            PROGBAR_Handle hObj = (PROGBAR_Handle)pMsg->hWin;
   \   00000004   0xF9B4 0x5004      LDRSH    R5,[R4, #+4]
    251            /* Let widget handle the standard messages */
    252            if (WIDGET_HandleActive(hObj, pMsg) == 0) {
   \   00000008   0x4621             MOV      R1,R4
   \   0000000A   0x4628             MOV      R0,R5
   \   0000000C   0x.... 0x....      BL       WIDGET_HandleActive
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD010             BEQ.N    ??_PROGBAR_Callback_0
    253              return;
    254            }
    255            switch (pMsg->MsgId) {
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x280B             CMP      R0,#+11
   \   00000018   0xD005             BEQ.N    ??_PROGBAR_Callback_1
   \   0000001A   0x280F             CMP      R0,#+15
   \   0000001C   0xD106             BNE.N    ??_PROGBAR_Callback_2
    256            case WM_PAINT:
    257              _Paint(hObj);
   \   0000001E   0x4628             MOV      R0,R5
   \   00000020   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000024   0x....             B.N      _Paint
    258              return;
    259            case WM_DELETE:
    260              _Delete(hObj);
   \                     ??_PROGBAR_Callback_1: (+1)
   \   00000026   0x4628             MOV      R0,R5
   \   00000028   0x.... 0x....      BL       _Delete
    261              break;
    262            }
    263            WM_DefaultProc(pMsg);
   \                     ??_PROGBAR_Callback_2: (+1)
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000032   0x.... 0x....      B.W      WM_DefaultProc
   \                     ??_PROGBAR_Callback_0: (+1)
   \   00000036   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    264          }
    265          
    266          /*********************************************************************
    267          *
    268          *       Exported routines:  Create
    269          *
    270          **********************************************************************
    271          */
    272          /*********************************************************************
    273          *
    274          *       PROGBAR_CreateEx
    275          */

   \                                 In section .text, align 2, keep-with-next
    276          PROGBAR_Handle PROGBAR_CreateEx(int x0, int y0, int xsize, int ysize, WM_HWIN hParent,
    277                                          int WinFlags, int ExFlags, int Id)
    278          {
   \                     PROGBAR_CreateEx: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    279            PROGBAR_Handle hObj;
    280            GUI_USE_PARA(ExFlags);
    281            hObj = WM_CreateWindowAsChild(x0, y0, xsize, ysize, hParent, WinFlags, _PROGBAR_Callback,
    282                                          sizeof(PROGBAR_Obj) - sizeof(WM_Obj));
   \   00000004   0x2430             MOVS     R4,#+48
   \   00000006   0x9403             STR      R4,[SP, #+12]
   \   00000008   0x....             LDR.N    R4,??DataTable0
   \   0000000A   0x9402             STR      R4,[SP, #+8]
   \   0000000C   0x9C09             LDR      R4,[SP, #+36]
   \   0000000E   0xB2A4             UXTH     R4,R4
   \   00000010   0x9401             STR      R4,[SP, #+4]
   \   00000012   0xF9BD 0x4020      LDRSH    R4,[SP, #+32]
   \   00000016   0x9400             STR      R4,[SP, #+0]
   \   00000018   0x.... 0x....      BL       WM_CreateWindowAsChild
   \   0000001C   0x0004             MOVS     R4,R0
    283            if (hObj) {
   \   0000001E   0xD01D             BEQ.N    ??PROGBAR_CreateEx_0
    284              PROGBAR_Obj* pObj;
    285              WM_LOCK();
    286              pObj = (PROGBAR_Obj*) GUI_ALLOC_h2p(hObj);
   \   00000020   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000024   0x4605             MOV      R5,R0
    287              /* init widget specific variables */
    288              WIDGET__Init(&pObj->Widget, Id, 0);
   \   00000026   0x2200             MOVS     R2,#+0
   \   00000028   0x990B             LDR      R1,[SP, #+44]
   \   0000002A   0x.... 0x....      BL       WIDGET__Init
    289              WIDGET_SetEffect(hObj, &WIDGET_Effect_None); /* Standard effect for progbar: None */
   \   0000002E   0x....             LDR.N    R1,??DataTable0_1
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       WIDGET_SetEffect
    290              INIT_ID(pObj);
    291              /* init member variables */
    292              pObj->pFont        = GUI_DEFAULT_FONT;
   \   00000036   0x....             LDR.N    R0,??DataTable0_2
   \   00000038   0x62E8             STR      R0,[R5, #+44]
    293              pObj->BarColor[0]  = PROGBAR_DEFAULT_BARCOLOR0;
   \   0000003A   0xF105 0x002C      ADD      R0,R5,#+44
   \   0000003E   0x....             LDR.N    R1,??DataTable0_3  ;; 0x555555
   \   00000040   0x6041             STR      R1,[R0, #+4]
    294              pObj->BarColor[1]  = PROGBAR_DEFAULT_BARCOLOR1;
   \   00000042   0x....             LDR.N    R1,??DataTable0_4  ;; 0xaaaaaa
   \   00000044   0x6081             STR      R1,[R0, #+8]
    295              pObj->TextColor[0] = PROGBAR_DEFAULT_TEXTCOLOR0;
   \   00000046   0xF06F 0x417F      MVN      R1,#-16777216
   \   0000004A   0x60C1             STR      R1,[R0, #+12]
    296              pObj->TextColor[1] = PROGBAR_DEFAULT_TEXTCOLOR1;
   \   0000004C   0x2100             MOVS     R1,#+0
   \   0000004E   0x6101             STR      R1,[R0, #+16]
    297              pObj->TextAlign    = GUI_TA_CENTER;
   \   00000050   0x2102             MOVS     R1,#+2
   \   00000052   0x8341             STRH     R1,[R0, #+26]
    298              pObj->Max          = 100;
   \   00000054   0x2164             MOVS     R1,#+100
   \   00000056   0x6201             STR      R1,[R0, #+32]
    299              pObj->Min          = 0;
   \   00000058   0x2100             MOVS     R1,#+0
   \   0000005A   0x61C1             STR      R1,[R0, #+28]
    300              WM_UNLOCK();
    301            }
    302            return hObj;
   \                     ??PROGBAR_CreateEx_0: (+1)
   \   0000005C   0x4620             MOV      R0,R4
   \   0000005E   0xB005             ADD      SP,SP,#+20
   \   00000060   0xBD30             POP      {R4,R5,PC}       ;; return
    303          }
    304          
    305          /*********************************************************************
    306          *
    307          *       Exported routines:  Various methods
    308          *
    309          **********************************************************************
    310          */
    311          /*********************************************************************
    312          *
    313          *       PROGBAR_SetValue
    314          */

   \                                 In section .text, align 2, keep-with-next
    315          void PROGBAR_SetValue(PROGBAR_Handle hObj, int v) {
   \                     PROGBAR_SetValue: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460E             MOV      R6,R1
    316            if (hObj) {
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD05D             BEQ.N    ??PROGBAR_SetValue_0
    317              PROGBAR_Obj* pObj;
    318              WM_LOCK();
    319              pObj= PROGBAR_H2P(hObj);
   \   0000000C   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000010   0x4605             MOV      R5,R0
    320              /* Put v into legal range */
    321              if (v < pObj->Min) {
   \   00000012   0x6CA8             LDR      R0,[R5, #+72]
   \   00000014   0x4286             CMP      R6,R0
   \   00000016   0xDA00             BGE.N    ??PROGBAR_SetValue_1
   \   00000018   0x4606             MOV      R6,R0
   \                     ??PROGBAR_SetValue_1: (+1)
   \   0000001A   0x4630             MOV      R0,R6
    322          	    v = pObj->Min;
    323              }
    324              if (v > pObj->Max) {
   \   0000001C   0x6CEE             LDR      R6,[R5, #+76]
   \   0000001E   0x4286             CMP      R6,R0
   \   00000020   0xDD00             BLE.N    ??PROGBAR_SetValue_2
   \   00000022   0x4606             MOV      R6,R0
    325          	    v = pObj->Max;
    326              }
    327              if (pObj->v != v) {
   \                     ??PROGBAR_SetValue_2: (+1)
   \   00000024   0x6AA9             LDR      R1,[R5, #+40]
   \   00000026   0x42B1             CMP      R1,R6
   \   00000028   0xD04E             BEQ.N    ??PROGBAR_SetValue_0
    328                GUI_RECT r;
    329                /* Get x values */
    330                if (v < pObj->v) {
   \   0000002A   0x428E             CMP      R6,R1
   \   0000002C   0xDA0C             BGE.N    ??PROGBAR_SetValue_3
    331                  r.x0 = _Value2X(pObj, v);
   \   0000002E   0x4631             MOV      R1,R6
   \   00000030   0x4628             MOV      R0,R5
   \   00000032   0x.... 0x....      BL       _Value2X
   \   00000036   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    332                  r.x1 = _Value2X(pObj, pObj->v);
   \   0000003A   0x6AA9             LDR      R1,[R5, #+40]
   \   0000003C   0x4628             MOV      R0,R5
   \   0000003E   0x.... 0x....      BL       _Value2X
   \   00000042   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   \   00000046   0xE00A             B.N      ??PROGBAR_SetValue_4
    333                } else {
    334                  r.x0 = _Value2X(pObj, pObj->v);
   \                     ??PROGBAR_SetValue_3: (+1)
   \   00000048   0x4628             MOV      R0,R5
   \   0000004A   0x.... 0x....      BL       _Value2X
   \   0000004E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    335                  r.x1 = _Value2X(pObj, v);
   \   00000052   0x4631             MOV      R1,R6
   \   00000054   0x4628             MOV      R0,R5
   \   00000056   0x.... 0x....      BL       _Value2X
   \   0000005A   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    336                }
    337          		  r.y0    = 0;
   \                     ??PROGBAR_SetValue_4: (+1)
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    338          		  r.y1    = 4095;
   \   00000064   0xF640 0x70FF      MOVW     R0,#+4095
   \   00000068   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    339                if (pObj->hpText == 0) {
   \   0000006C   0xF9B5 0x0040      LDRSH    R0,[R5, #+64]
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD124             BNE.N    ??PROGBAR_SetValue_5
    340                  const GUI_FONT GUI_UNI_PTR * pOldFont;
    341                  char acBuffer[5];
    342                  GUI_RECT rText;
    343                  pOldFont = GUI_SetFont(pObj->pFont);
   \   00000074   0x6AE8             LDR      R0,[R5, #+44]
   \   00000076   0x.... 0x....      BL       GUI_SetFont
   \   0000007A   0x4607             MOV      R7,R0
    344                  _GetTextRect(pObj, &rText, _GetText(pObj, acBuffer));
   \   0000007C   0xA904             ADD      R1,SP,#+16
   \   0000007E   0x4628             MOV      R0,R5
   \   00000080   0x.... 0x....      BL       _GetText
   \   00000084   0x4602             MOV      R2,R0
   \   00000086   0xA902             ADD      R1,SP,#+8
   \   00000088   0x4628             MOV      R0,R5
   \   0000008A   0x.... 0x....      BL       _GetTextRect
    345                  GUI_MergeRect(&r, &r, &rText);
   \   0000008E   0xAA02             ADD      R2,SP,#+8
   \   00000090   0xA900             ADD      R1,SP,#+0
   \   00000092   0xA800             ADD      R0,SP,#+0
   \   00000094   0x.... 0x....      BL       GUI_MergeRect
    346                  pObj->v = v;
   \   00000098   0x62AE             STR      R6,[R5, #+40]
    347                  _GetTextRect(pObj, &rText, _GetText(pObj, acBuffer));
   \   0000009A   0xA904             ADD      R1,SP,#+16
   \   0000009C   0x4628             MOV      R0,R5
   \   0000009E   0x.... 0x....      BL       _GetText
   \   000000A2   0x4602             MOV      R2,R0
   \   000000A4   0xA902             ADD      R1,SP,#+8
   \   000000A6   0x4628             MOV      R0,R5
   \   000000A8   0x.... 0x....      BL       _GetTextRect
    348                  GUI_MergeRect(&r, &r, &rText);
   \   000000AC   0xAA02             ADD      R2,SP,#+8
   \   000000AE   0xA900             ADD      R1,SP,#+0
   \   000000B0   0xA800             ADD      R0,SP,#+0
   \   000000B2   0x.... 0x....      BL       GUI_MergeRect
    349                  GUI_SetFont(pOldFont);
   \   000000B6   0x4638             MOV      R0,R7
   \   000000B8   0x.... 0x....      BL       GUI_SetFont
   \   000000BC   0xE000             B.N      ??PROGBAR_SetValue_6
    350                } else {
    351                  pObj->v = v;
   \                     ??PROGBAR_SetValue_5: (+1)
   \   000000BE   0x62AE             STR      R6,[R5, #+40]
    352                }
    353                WM_InvalidateRect(hObj, &r);
   \                     ??PROGBAR_SetValue_6: (+1)
   \   000000C0   0xA900             ADD      R1,SP,#+0
   \   000000C2   0x4620             MOV      R0,R4
   \   000000C4   0x.... 0x....      BL       WM_InvalidateRect
    354              }
    355              WM_UNLOCK();
    356            }
    357          }
   \                     ??PROGBAR_SetValue_0: (+1)
   \   000000C8   0xB007             ADD      SP,SP,#+28
   \   000000CA   0xBDF0             POP      {R4-R7,PC}       ;; return
    358          
    359          /*********************************************************************
    360          *
    361          *       PROGBAR_SetFont
    362          */

   \                                 In section .text, align 2, keep-with-next
    363          void PROGBAR_SetFont(PROGBAR_Handle hObj, const GUI_FONT GUI_UNI_PTR * pfont) {
   \                     PROGBAR_SetFont: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    364            PROGBAR_Obj* pObj;
    365            if (hObj) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??PROGBAR_SetFont_0
    366              WM_LOCK();
    367              pObj = PROGBAR_H2P(hObj);
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
    368              pObj->pFont = pfont;
   \   0000000E   0x62C5             STR      R5,[R0, #+44]
    369              WM_InvalidateWindow(hObj);
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000016   0x.... 0x....      B.W      WM_InvalidateWindow
    370              WM_UNLOCK();
    371            }
    372          }
   \                     ??PROGBAR_SetFont_0: (+1)
   \   0000001A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    373          
    374          /*********************************************************************
    375          *
    376          *       PROGBAR_SetBarColor
    377          */

   \                                 In section .text, align 2, keep-with-next
    378          void PROGBAR_SetBarColor(PROGBAR_Handle hObj, unsigned int Index, GUI_COLOR color) {
   \                     PROGBAR_SetBarColor: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    379            PROGBAR_Obj* pObj;
    380            if (hObj) {
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD00B             BEQ.N    ??PROGBAR_SetBarColor_0
    381              WM_LOCK();
    382              pObj = PROGBAR_H2P(hObj);
   \   0000000C   0x.... 0x....      BL       GUI_ALLOC_h2p
    383              if (Index < GUI_COUNTOF(pObj->BarColor)) {
   \   00000010   0x2D02             CMP      R5,#+2
   \   00000012   0xD207             BCS.N    ??PROGBAR_SetBarColor_0
    384                pObj->BarColor[Index] = color;
   \   00000014   0xEB00 0x0085      ADD      R0,R0,R5, LSL #+2
   \   00000018   0x6306             STR      R6,[R0, #+48]
    385                WM_InvalidateWindow(hObj);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000020   0x.... 0x....      B.W      WM_InvalidateWindow
    386              }
    387              WM_UNLOCK();
    388            }
    389          }
   \                     ??PROGBAR_SetBarColor_0: (+1)
   \   00000024   0xBD70             POP      {R4-R6,PC}       ;; return
    390          
    391          /*********************************************************************
    392          *
    393          *       PROGBAR_SetTextColor
    394          */

   \                                 In section .text, align 2, keep-with-next
    395          void PROGBAR_SetTextColor(PROGBAR_Handle hObj, unsigned int Index, GUI_COLOR color) {
   \                     PROGBAR_SetTextColor: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    396            PROGBAR_Obj* pObj;
    397            if (hObj) {
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD00B             BEQ.N    ??PROGBAR_SetTextColor_0
    398              WM_LOCK();
    399              pObj = PROGBAR_H2P(hObj);
   \   0000000C   0x.... 0x....      BL       GUI_ALLOC_h2p
    400              if (Index < GUI_COUNTOF(pObj->TextColor)) {
   \   00000010   0x2D02             CMP      R5,#+2
   \   00000012   0xD207             BCS.N    ??PROGBAR_SetTextColor_0
    401                pObj->TextColor[Index] = color;
   \   00000014   0xEB00 0x0085      ADD      R0,R0,R5, LSL #+2
   \   00000018   0x6386             STR      R6,[R0, #+56]
    402                WM_InvalidateWindow(hObj);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000020   0x.... 0x....      B.W      WM_InvalidateWindow
    403              }
    404              WM_UNLOCK();
    405            }
    406          }
   \                     ??PROGBAR_SetTextColor_0: (+1)
   \   00000024   0xBD70             POP      {R4-R6,PC}       ;; return
    407          
    408          /*********************************************************************
    409          *
    410          *       PROGBAR_SetText
    411          */

   \                                 In section .text, align 2, keep-with-next
    412          void PROGBAR_SetText(PROGBAR_Handle hObj, const char* s) {
   \                     PROGBAR_SetText: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    413            if (hObj) {
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD02B             BEQ.N    ??PROGBAR_SetText_0
    414              PROGBAR_Obj* pObj;
    415              const GUI_FONT GUI_UNI_PTR * pOldFont;
    416              GUI_RECT r1;
    417              char acBuffer[5];
    418              WM_LOCK();
    419              pObj = PROGBAR_H2P(hObj);
   \   0000000C   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000010   0x4606             MOV      R6,R0
    420              pOldFont = GUI_SetFont(pObj->pFont);
   \   00000012   0x6AF0             LDR      R0,[R6, #+44]
   \   00000014   0x.... 0x....      BL       GUI_SetFont
   \   00000018   0x4607             MOV      R7,R0
    421              _GetTextRect(pObj, &r1, _GetText(pObj, acBuffer));
   \   0000001A   0xA904             ADD      R1,SP,#+16
   \   0000001C   0x4630             MOV      R0,R6
   \   0000001E   0x.... 0x....      BL       _GetText
   \   00000022   0x4602             MOV      R2,R0
   \   00000024   0xA900             ADD      R1,SP,#+0
   \   00000026   0x4630             MOV      R0,R6
   \   00000028   0x.... 0x....      BL       _GetTextRect
    422              if (GUI__SetText(&pObj->hpText, s)) {
   \   0000002C   0x4629             MOV      R1,R5
   \   0000002E   0xF106 0x0040      ADD      R0,R6,#+64
   \   00000032   0x.... 0x....      BL       GUI__SetText
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD011             BEQ.N    ??PROGBAR_SetText_1
    423                GUI_RECT r2;
    424                _GetTextRect(pObj, &r2, _GetText(pObj, acBuffer));
   \   0000003A   0xA904             ADD      R1,SP,#+16
   \   0000003C   0x4630             MOV      R0,R6
   \   0000003E   0x.... 0x....      BL       _GetText
   \   00000042   0x4602             MOV      R2,R0
   \   00000044   0xA902             ADD      R1,SP,#+8
   \   00000046   0x4630             MOV      R0,R6
   \   00000048   0x.... 0x....      BL       _GetTextRect
    425                GUI_MergeRect(&r1, &r1, &r2);
   \   0000004C   0xAA02             ADD      R2,SP,#+8
   \   0000004E   0xA900             ADD      R1,SP,#+0
   \   00000050   0xA800             ADD      R0,SP,#+0
   \   00000052   0x.... 0x....      BL       GUI_MergeRect
    426                WM_InvalidateRect(hObj, &r1);
   \   00000056   0xA900             ADD      R1,SP,#+0
   \   00000058   0x4620             MOV      R0,R4
   \   0000005A   0x.... 0x....      BL       WM_InvalidateRect
    427              }
    428              GUI_SetFont(pOldFont);
   \                     ??PROGBAR_SetText_1: (+1)
   \   0000005E   0x4638             MOV      R0,R7
   \   00000060   0x.... 0x....      BL       GUI_SetFont
    429              WM_UNLOCK();
    430            }
    431          }
   \                     ??PROGBAR_SetText_0: (+1)
   \   00000064   0xB007             ADD      SP,SP,#+28
   \   00000066   0xBDF0             POP      {R4-R7,PC}       ;; return
    432          
    433          /*********************************************************************
    434          *
    435          *       PROGBAR_SetTextAlign
    436          */

   \                                 In section .text, align 2, keep-with-next
    437          void PROGBAR_SetTextAlign(PROGBAR_Handle hObj, int Align) {
   \                     PROGBAR_SetTextAlign: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    438            PROGBAR_Obj* pObj;
    439            if (hObj) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD008             BEQ.N    ??PROGBAR_SetTextAlign_0
    440              WM_LOCK();
    441              pObj = PROGBAR_H2P(hObj);
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
    442              pObj->TextAlign = Align;
   \   0000000E   0xF8A0 0x5046      STRH     R5,[R0, #+70]
    443              WM_InvalidateWindow(hObj);
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000018   0x.... 0x....      B.W      WM_InvalidateWindow
    444              WM_UNLOCK();
    445            }
    446          }
   \                     ??PROGBAR_SetTextAlign_0: (+1)
   \   0000001C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    447          
    448          /*********************************************************************
    449          *
    450          *       PROGBAR_SetTextPos
    451          */

   \                                 In section .text, align 2, keep-with-next
    452          void PROGBAR_SetTextPos(PROGBAR_Handle hObj, int XOff, int YOff) {
   \                     PROGBAR_SetTextPos: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    453            PROGBAR_Obj* pObj;
    454            if (hObj) {
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD00A             BEQ.N    ??PROGBAR_SetTextPos_0
    455              WM_LOCK();
    456              pObj = PROGBAR_H2P(hObj);
   \   0000000C   0x.... 0x....      BL       GUI_ALLOC_h2p
    457              pObj->XOff = XOff;
   \   00000010   0xF8A0 0x5042      STRH     R5,[R0, #+66]
    458              pObj->YOff = YOff;
   \   00000014   0xF8A0 0x6044      STRH     R6,[R0, #+68]
    459              WM_InvalidateWindow(hObj);
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000001E   0x.... 0x....      B.W      WM_InvalidateWindow
    460              WM_UNLOCK();
    461            }
    462          }
   \                     ??PROGBAR_SetTextPos_0: (+1)
   \   00000022   0xBD70             POP      {R4-R6,PC}       ;; return
    463          
    464          /*********************************************************************
    465          *
    466          *       PROGBAR_SetMinMax
    467          */

   \                                 In section .text, align 2, keep-with-next
    468          void PROGBAR_SetMinMax(PROGBAR_Handle hObj, int Min, int Max) {
   \                     PROGBAR_SetMinMax: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    469            PROGBAR_Obj* pObj;
    470            if (hObj) {
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD010             BEQ.N    ??PROGBAR_SetMinMax_0
    471              WM_LOCK();
    472              pObj = PROGBAR_H2P(hObj);
   \   0000000C   0x.... 0x....      BL       GUI_ALLOC_h2p
    473              if (Max > Min) {
   \   00000010   0x42B5             CMP      R5,R6
   \   00000012   0xDA0C             BGE.N    ??PROGBAR_SetMinMax_0
    474                if ((Max != pObj->Max) || (Min != pObj->Min)) {
   \   00000014   0x6CC1             LDR      R1,[R0, #+76]
   \   00000016   0x428E             CMP      R6,R1
   \   00000018   0xD102             BNE.N    ??PROGBAR_SetMinMax_1
   \   0000001A   0x6C81             LDR      R1,[R0, #+72]
   \   0000001C   0x428D             CMP      R5,R1
   \   0000001E   0xD006             BEQ.N    ??PROGBAR_SetMinMax_0
    475                  pObj->Min = Min;
   \                     ??PROGBAR_SetMinMax_1: (+1)
   \   00000020   0x6485             STR      R5,[R0, #+72]
    476                  pObj->Max = Max;
   \   00000022   0x64C6             STR      R6,[R0, #+76]
    477                  WM_InvalidateWindow(hObj);
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000002A   0x.... 0x....      B.W      WM_InvalidateWindow
    478                }
    479              }
    480              WM_UNLOCK();
    481            }
    482          }
   \                     ??PROGBAR_SetMinMax_0: (+1)
   \   0000002E   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0x........         DC32     _PROGBAR_Callback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \   00000000   0x........         DC32     WIDGET_Effect_None

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_2:
   \   00000000   0x........         DC32     GUI_Font6x8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_3:
   \   00000000   0x00555555         DC32     0x555555

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_4:
   \   00000000   0x00AAAAAA         DC32     0xaaaaaa
    483          
    484          #else
    485          
    486          void WIDGET_Progbar(void) {} /* avoid empty object files */
    487          
    488          #endif /* GUI_WINSUPPORT */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   PROGBAR_CreateEx
        32   -> GUI_ALLOC_h2p
        32   -> WIDGET_SetEffect
        32   -> WIDGET__Init
        32   -> WM_CreateWindowAsChild
      16   PROGBAR_SetBarColor
        16   -> GUI_ALLOC_h2p
         0   -> WM_InvalidateWindow
      16   PROGBAR_SetFont
        16   -> GUI_ALLOC_h2p
         0   -> WM_InvalidateWindow
      16   PROGBAR_SetMinMax
        16   -> GUI_ALLOC_h2p
         0   -> WM_InvalidateWindow
      48   PROGBAR_SetText
        48   -> GUI_ALLOC_h2p
        48   -> GUI_MergeRect
        48   -> GUI_SetFont
        48   -> GUI__SetText
        48   -> WM_InvalidateRect
        48   -> _GetText
        48   -> _GetTextRect
      16   PROGBAR_SetTextAlign
        16   -> GUI_ALLOC_h2p
         0   -> WM_InvalidateWindow
      16   PROGBAR_SetTextColor
        16   -> GUI_ALLOC_h2p
         0   -> WM_InvalidateWindow
      16   PROGBAR_SetTextPos
        16   -> GUI_ALLOC_h2p
         0   -> WM_InvalidateWindow
      48   PROGBAR_SetValue
        48   -> GUI_ALLOC_h2p
        48   -> GUI_MergeRect
        48   -> GUI_SetFont
        48   -> WM_InvalidateRect
        48   -> _GetText
        48   -> _GetTextRect
        48   -> _Value2X
       0   _Delete
         0   -> _FreeText
      16   _DrawPart
        16   -> GUI_Clear
         0   -> GUI_DispString
        16   -> GUI_GotoXY
        16   -> LCD_SetBkColor
        16   -> LCD_SetColor
       8   _FreeText
         0   -> GUI_ALLOC_FreePtr
         8   -> GUI_ALLOC_h2p
      16   _GetText
        16   -> GUI_ALLOC_h2p
        16   -> GUI_AddDecMin
      24   _GetTextRect
        24   -> GUI_GetFontSizeY
        24   -> GUI_GetStringDistX
      16   _PROGBAR_Callback
        16   -> WIDGET_HandleActive
         0   -> WM_DefaultProc
        16   -> _Delete
         0   -> _Paint
      64   _Paint
        64   -> GUI_ALLOC_h2p
        64   -> GUI_SetFont
        64   -> GUI_SetTextMode
        64   -> GUI__ReduceRect
        64   -> WIDGET__EFFECT_DrawDownRect
        64   -> WM_GetClientRect
        64   -> WM_SetUserClipRect
        64   -> _DrawPart
        64   -> _GetText
        64   -> _GetTextRect
        64   -> _Value2X
       4   _Value2X


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
       4  ??DataTable0_2
       4  ??DataTable0_3
       4  ??DataTable0_4
      98  PROGBAR_CreateEx
      38  PROGBAR_SetBarColor
      28  PROGBAR_SetFont
      48  PROGBAR_SetMinMax
     104  PROGBAR_SetText
      30  PROGBAR_SetTextAlign
      38  PROGBAR_SetTextColor
      36  PROGBAR_SetTextPos
     204  PROGBAR_SetValue
       2  _Delete
      44  _DrawPart
      16  _FreeText
      62  _GetText
     142  _GetTextRect
      56  _PROGBAR_Callback
     172  _Paint
      54  _Value2X

 
 1 192 bytes in section .text
 
 1 192 bytes of CODE memory

Errors: none
Warnings: none
