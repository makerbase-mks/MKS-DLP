///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM       18/Jul/2019  11:56:54
// Copyright 1999-2014 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\Marlin_main.cpp
//    Command line =  
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\Marlin_main.cpp
//        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
//        MKS_DLP_BOARD -D TFT35 -lC
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
//        --diag_suppress Pa050 -o
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
//        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
//        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
//        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
//        7.0\arm\INC\c\DLib_Config_Full.h" -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
//        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
//        -Om --eec++ -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
//        7.0\arm\CMSIS\Include\"
//    List file    =  
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\Marlin_main.s
//
///////////////////////////////////////////////////////////////////////////////

        RTMODEL "__CPP_Language", "EC++"
        RTMODEL "__SystemLibrary", "DLib"
        RTMODEL "__dlib_file_descriptor", "1"
        RTMODEL "__dlib_full_locale_support", "1"
        RTMODEL "__iar_require _Printf", "floats,int_specials"
        AAPCS BASE,INTERWORK,VFP
        PRESERVE8
        REQUIRE8

        #define SHT_PROGBITS 0x1
        #define SHT_INIT_ARRAY 0xe

        EXTERN AT24CXX_Read
        EXTERN AT24CXX_Write
        EXTERN BMP_PIC_X
        EXTERN BMP_PIC_Y
        EXTERN GUI_Exec
        EXTERN GUI_RefreshPage
        EXTERN GUI_TOUCH_Exec
        EXTERN HAL_Delay
        EXTERN HAL_GPIO_ReadPin
        EXTERN HAL_GPIO_WritePin
        EXTERN HAL_GetTick
        EXTERN HAL_SPI_Transmit_DMA
        EXTERN SPI1_ReadWriteByte
        EXTERN Serial6
        EXTERN _Z10safe_delaym
        EXTERN _Z14mksBeeperAlarmv
        EXTERN _Z17serial_echopair_PPKcS0_
        EXTERN _Z17serial_echopair_PPKcd
        EXTERN _Z17serial_echopair_PPKcf
        EXTERN _Z17serial_echopair_PPKci
        EXTERN _ZN10CardReader10removeFileEPc
        EXTERN _ZN10CardReader11openLogFileEPc
        EXTERN _ZN10CardReader11stopSDPrintEv
        EXTERN _ZN10CardReader12checkFilesysEh
        EXTERN _ZN10CardReader12pauseSDPrintEv
        EXTERN _ZN10CardReader13write_commandEPc
        EXTERN _ZN10CardReader14startFileprintEv
        EXTERN _ZN10CardReader19printingHasFinishedEv
        EXTERN _ZN10CardReader2lsEv
        EXTERN _ZN10CardReader7releaseEv
        EXTERN _ZN10CardReader8getsdposEv
        EXTERN _ZN10CardReader8openFileEPcbb
        EXTERN _ZN10CardReader9closefileEb
        EXTERN _ZN10CardReader9getStatusEv
        EXTERN _ZN10CardReaderC1Ev
        EXTERN _ZN10USARTClass4readEv
        EXTERN _ZN10USARTClass5flushEv
        EXTERN _ZN10USARTClass5writeEh
        EXTERN _ZN10USARTClass9availableEv
        EXTERN _ZN11GCodeParser10string_argE
        EXTERN _ZN11GCodeParser11command_ptrE
        EXTERN _ZN11GCodeParser14command_letterE
        EXTERN _ZN11GCodeParser18volumetric_enabledE
        EXTERN _ZN11GCodeParser21unknown_command_errorEv
        EXTERN _ZN11GCodeParser5paramE
        EXTERN _ZN11GCodeParser5parseEPc
        EXTERN _ZN11GCodeParser7codenumE
        EXTERN _ZN11GCodeParser8codebitsE
        EXTERN _ZN11GCodeParser9value_ptrE
        EXTERN _ZN11Temperature12PID_autotuneEfaab
        EXTERN _ZN11Temperature13manage_heaterEv
        EXTERN _ZN11Temperature18target_temperatureE
        EXTERN _ZN11Temperature19current_temperatureE
        EXTERN _ZN11Temperature19disable_all_heatersEv
        EXTERN _ZN11Temperature21start_watching_heaterEh
        EXTERN _ZN11Temperature2KdE
        EXTERN _ZN11Temperature2KiE
        EXTERN _ZN11Temperature2KpE
        EXTERN _ZN11Temperature4initEv
        EXTERN _ZN14MarlinSettings4loadEv
        EXTERN _ZN14MarlinSettings4saveEv
        EXTERN _ZN14MarlinSettings5resetEv
        EXTERN _ZN14MarlinSettings6reportEb
        EXTERN _ZN5Print5printEPKc
        EXTERN _ZN5Print5printEdi
        EXTERN _ZN5Print5printEhi
        EXTERN _ZN5Print5printEii
        EXTERN _ZN5Print5printEji
        EXTERN _ZN5Print5printEli
        EXTERN _ZN7Planner12accelerationE
        EXTERN _ZN7Planner13filament_sizeE
        EXTERN _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h
        EXTERN _ZN7Planner15flow_percentageE
        EXTERN _ZN7Planner15set_position_mmE8AxisEnumRKf
        EXTERN _ZN7Planner16_set_position_mmERKfS1_S1_S1_
        EXTERN _ZN7Planner17axis_steps_per_mmE
        EXTERN _ZN7Planner17block_buffer_headE
        EXTERN _ZN7Planner17block_buffer_tailE
        EXTERN _ZN7Planner17max_feedrate_mm_sE
        EXTERN _ZN7Planner17min_feedrate_mm_sE
        EXTERN _ZN7Planner18autotemp_M104_M109Ev
        EXTERN _ZN7Planner19check_axes_activityEv
        EXTERN _ZN7Planner19min_segment_time_usE
        EXTERN _ZN7Planner19refresh_positioningEv
        EXTERN _ZN7Planner19travel_accelerationE
        EXTERN _ZN7Planner20retract_accelerationE
        EXTERN _ZN7Planner21volumetric_multiplierE
        EXTERN _ZN7Planner24min_travel_feedrate_mm_sE
        EXTERN _ZN7Planner24reset_acceleration_ratesEv
        EXTERN _ZN7Planner26max_acceleration_mm_per_s2E
        EXTERN _ZN7Planner29max_acceleration_steps_per_s2E
        EXTERN _ZN7Planner32calculate_volumetric_multipliersEv
        EXTERN _ZN7Planner8e_factorE
        EXTERN _ZN7Planner8max_jerkE
        EXTERN _ZN7SSD28284initEv
        EXTERN _ZN7SSD28288sleep_inEv
        EXTERN _ZN7SSD28289sleep_outEv
        EXTERN _ZN7SSD2828C1Ev
        EXTERN _ZN7Stepper10quick_stopEv
        EXTERN _ZN7Stepper11synchronizeEv
        EXTERN _ZN7Stepper16report_positionsEv
        EXTERN _ZN7Stepper18finish_and_disableEv
        EXTERN _ZN7Stepper20get_axis_position_mmE8AxisEnum
        EXTERN _ZN7Stepper23cleaning_buffer_counterE
        EXTERN _ZN7Stepper4initEv
        EXTERN _ZN8Endstops12report_stateEv
        EXTERN _ZN8Endstops16enabled_globallyE
        EXTERN _ZN8Endstops16endstop_hit_bitsE
        EXTERN _ZN8Endstops4M119Ev
        EXTERN _ZN8Endstops7enabledE
        EXTERN _ZN9Stopwatch4stopEv
        EXTERN _ZN9Stopwatch5pauseEv
        EXTERN _ZN9Stopwatch5startEv
        EXTERN _ZN9Stopwatch8durationEv
        EXTERN _ZN9StopwatchC1Ev
        EXTERN __aeabi_d2f
        EXTERN __aeabi_d2uiz
        EXTERN __aeabi_dadd
        EXTERN __aeabi_ddiv
        EXTERN __aeabi_dmul
        EXTERN __aeabi_dsub
        EXTERN __aeabi_f2d
        EXTERN __aeabi_i2d
        EXTERN __aeabi_memcpy
        EXTERN __aeabi_memcpy4
        EXTERN __aeabi_ui2d
        EXTERN __iar_Strchr
        EXTERN __iar_Strrchr
        EXTERN __iar_Strstr
        EXTERN atan2f
        EXTERN atof
        EXTERN bmp_layer_buf
        EXTERN clear_cur_ui
        EXTERN cosf
        EXTERN curFileName
        EXTERN default_preview_flg
        EXTERN disp_pre_gcode
        EXTERN disp_state
        EXTERN display_print_statue
        EXTERN draw_dialog
        EXTERN draw_printing
        EXTERN draw_ready_print
        EXTERN draw_status_clear
        EXTERN echomagic
        EXTERN epr_read_data
        EXTERN epr_write_data
        EXTERN errormagic
        EXTERN exposure_msg_display
        EXTERN f_lseek
        EXTERN f_read
        EXTERN flash_preview_begin
        EXTERN floorf
        EXTERN from_flash_pic
        EXTERN gArrayGpioPin
        EXTERN gArrayGpioPort
        EXTERN gCfgItems
        EXTERN getTick
        EXTERN getTickDiff
        EXTERN hdma_spi1_tx
        EXTERN hspi1
        EXTERN layer_pic_clean
        EXTERN layer_pic_display
        EXTERN leveling_first_time
        EXTERN logo_tick1
        EXTERN logo_tick2
        EXTERN memcpy
        EXTERN memset
        EXTERN mipi_te_cnt
        EXTERN mksCfg
        EXTERN parser
        EXTERN pause_resum
        EXTERN preview_gcode_prehandle
        EXTERN print_time
        EXTERN reset_file_info
        EXTERN reset_print_time
        EXTERN setProBarRate
        EXTERN sinf
        EXTERN sprintf
        EXTERN sqrt
        EXTERN sqrtf
        EXTERN start_print_time
        EXTERN stop_print_time
        EXTERN strcat
        EXTERN strcmp
        EXTERN strcpy
        EXTERN strncpy
        EXTERN strtod
        EXTERN strtol
        EXTERN strtoul
        EXTERN temperature_change_frequency
        EXTERN thermalManager

        PUBLIC EXTI9_5_IRQHandler
        PUBLIC Line_Pixel
        PUBLIC Line_Pixel_TFT
        PUBLIC Running
        PUBLIC TimeIncrease
        PUBLIC _Z10clr_ticketv
        PUBLIC _Z10freeMemoryv
        PUBLIC _Z10gcode_M104v
        PUBLIC _Z10gcode_M105v
        PUBLIC _Z10gcode_M106v
        PUBLIC _Z10gcode_M107v
        PUBLIC _Z10gcode_M108v
        PUBLIC _Z10gcode_M109v
        PUBLIC _Z10gcode_M110v
        PUBLIC _Z10gcode_M111v
        PUBLIC _Z10gcode_M112v
        PUBLIC _Z10gcode_M114v
        PUBLIC _Z10gcode_M115v
        PUBLIC _Z10gcode_M117v
        PUBLIC _Z10gcode_M118v
        PUBLIC _Z10gcode_M119v
        PUBLIC _Z10gcode_M120v
        PUBLIC _Z10gcode_M121v
        PUBLIC _Z10gcode_M140v
        PUBLIC _Z10gcode_M200v
        PUBLIC _Z10gcode_M201v
        PUBLIC _Z10gcode_M203v
        PUBLIC _Z10gcode_M204v
        PUBLIC _Z10gcode_M205v
        PUBLIC _Z10gcode_M206v
        PUBLIC _Z10gcode_M211v
        PUBLIC _Z10gcode_M220v
        PUBLIC _Z10gcode_M221v
        PUBLIC _Z10gcode_M226v
        PUBLIC _Z10gcode_M301v
        PUBLIC _Z10gcode_M303v
        PUBLIC _Z10gcode_M355v
        PUBLIC _Z10gcode_M400v
        PUBLIC _Z10gcode_M410v
        PUBLIC _Z10gcode_M428v
        PUBLIC _Z10gcode_M500v
        PUBLIC _Z10gcode_M501v
        PUBLIC _Z10gcode_M502v
        PUBLIC _Z10gcode_M503v
        PUBLIC _Z10gcode_M907v
        PUBLIC _Z10gcode_M928v
        PUBLIC _Z10gcode_M998v
        PUBLIC _Z10gcode_M999v
        PUBLIC _Z10ok_to_sendv
        PUBLIC _Z10servo_initv
        PUBLIC _Z11InvertUint8PhS_
        PUBLIC _Z11gcode_G0_G1v
        PUBLIC _Z11gcode_G2_G3b
        PUBLIC _Z11lcd_refreshv
        PUBLIC _Z11tool_changehfb
        PUBLIC _Z12CRC16_XMODEMPhj
        PUBLIC _Z12InvertUint16PtS_
        PUBLIC _Z13find_next_bmpv
        PUBLIC _Z13gcode_M18_M84v
        PUBLIC _Z13home_all_axesv
        PUBLIC _Z13lcd_hasstatusv
        PUBLIC _Z13lcd_setstatusPKcb
        PUBLIC _Z13setup_killpinv
        PUBLIC _Z13strting2floatPhh
        PUBLIC _Z14mks_WriteToEprv
        PUBLIC _Z14serialprintPGMPKc
        PUBLIC _Z15_commit_commandb
        PUBLIC _Z15_enqueuecommandPKcb
        PUBLIC _Z15mks_setFeedratev
        PUBLIC _Z15setup_powerholdv
        PUBLIC _Z16gcode_line_errorPKcb
        PUBLIC _Z16lcd_setstatusPGMPKca
        PUBLIC _Z16mks_get_commandsv
        PUBLIC _Z17manage_inactivityb
        PUBLIC _Z17mkstft_ui_set_eprv
        PUBLIC _Z17quickstop_stepperv
        PUBLIC _Z18axis_unhomed_errorb
        PUBLIC _Z18disable_e_steppersv
        PUBLIC _Z18mks_setTemperaturev
        PUBLIC _Z18sync_plan_positionv
        PUBLIC _Z19clear_command_queuev
        PUBLIC _Z19do_blocking_move_toRKfS0_S0_S0_
        PUBLIC _Z19enable_all_steppersv
        PUBLIC _Z19get_serial_commandsv
        PUBLIC _Z19refresh_cmd_timeoutv
        PUBLIC _Z20SysTick_Handler_Userv
        PUBLIC _Z20disable_all_steppersv
        PUBLIC _Z20process_next_commandv
        PUBLIC _Z20sync_plan_position_ev
        PUBLIC _Z21do_blocking_move_to_xRKfS0_
        PUBLIC _Z21do_blocking_move_to_zRKfS0_
        PUBLIC _Z21gcode_get_destinationv
        PUBLIC _Z21lcd_reset_alert_levelv
        PUBLIC _Z21lcd_setalertstatusPGMPKc
        PUBLIC _Z21mks_WriteToEpr_pwroffv
        PUBLIC _Z21soft_endstop_min_initv
        PUBLIC _Z22do_blocking_move_to_xyRKfS0_S0_
        PUBLIC _Z22get_available_commandsv
        PUBLIC _Z22invalid_extruder_errorh
        PUBLIC _Z22mks_ReadFromEpr_pwroffv
        PUBLIC _Z22process_parsed_commandv
        PUBLIC _Z22report_mksdlp_positionv
        PUBLIC _Z23report_current_positionv
        PUBLIC _Z24FlushSerialRequestResendv
        PUBLIC _Z24enqueue_and_echo_commandPKcb
        PUBLIC _Z24get_homing_bump_feedrate8AxisEnum
        PUBLIC _Z24update_software_endstops8AxisEnum
        PUBLIC _Z26buffer_line_to_destinationf
        PUBLIC _Z26clamp_to_software_endstopsPf
        PUBLIC _Z26do_blocking_move_to_nowaitRKfS0_S0_S0_
        PUBLIC _Z27enqueue_and_echo_commands_PPKc
        PUBLIC _Z27get_cartesian_from_steppersv
        PUBLIC _Z27prepare_move_to_destinationv
        PUBLIC _Z28do_blocking_move_to_z_nowaitRKfS0_
        PUBLIC _Z28set_current_from_destinationv
        PUBLIC _Z28set_destination_from_currentv
        PUBLIC _Z31buffer_line_to_current_positionv
        PUBLIC _Z32get_target_extruder_from_commandt
        PUBLIC _Z34set_current_from_steppers_for_axis8AxisEnum
        PUBLIC _Z37prepare_move_to_destination_cartesianv
        PUBLIC _Z4idlev
        PUBLIC _Z4killPKc
        PUBLIC _Z4stopv
        PUBLIC _Z5dwellm
        PUBLIC _Z6strchrPci
        PUBLIC _Z6strstrPcPKc
        PUBLIC _Z7gcode_Th
        PUBLIC _Z7mks_G28Pc
        PUBLIC _Z7pft_getv
        PUBLIC _Z7strrchrPci
        PUBLIC _Z7suicidev
        PUBLIC _Z8gcode_G4v
        PUBLIC _Z8lcd_initv
        PUBLIC _Z8plan_arcRA4_KfRA2_S_b
        PUBLIC _Z9IsRunningv
        PUBLIC _Z9IsStoppedv
        PUBLIC _Z9gcode_G28b
        PUBLIC _Z9gcode_G92v
        PUBLIC _Z9gcode_M17v
        PUBLIC _Z9gcode_M20v
        PUBLIC _Z9gcode_M22v
        PUBLIC _Z9gcode_M23v
        PUBLIC _Z9gcode_M24v
        PUBLIC _Z9gcode_M25v
        PUBLIC _Z9gcode_M26v
        PUBLIC _Z9gcode_M27v
        PUBLIC _Z9gcode_M28v
        PUBLIC _Z9gcode_M29v
        PUBLIC _Z9gcode_M30v
        PUBLIC _Z9gcode_M31v
        PUBLIC _Z9gcode_M32v
        PUBLIC _Z9gcode_M42v
        PUBLIC _Z9gcode_M75v
        PUBLIC _Z9gcode_M76v
        PUBLIC _Z9gcode_M77v
        PUBLIC _Z9gcode_M81v
        PUBLIC _Z9gcode_M82v
        PUBLIC _Z9gcode_M83v
        PUBLIC _Z9gcode_M85v
        PUBLIC _Z9gcode_M92v
        PUBLIC _ZN10CardReader10isFileOpenEv
        PUBLIC _ZN10CardReader3eofEv
        PUBLIC _ZN10CardReader4getsEPhj
        PUBLIC _ZN10CardReader8setIndexEl
        PUBLIC _ZN10duration_tC1ERKj
        PUBLIC _ZN11GCodeParser10celsiusvalEcf
        PUBLIC _ZN11GCodeParser10value_boolEv
        PUBLIC _ZN11GCodeParser10value_byteEv
        PUBLIC _ZN11GCodeParser10value_longEv
        PUBLIC _ZN11GCodeParser11value_floatEv
        PUBLIC _ZN11GCodeParser11value_ulongEv
        PUBLIC _ZN11GCodeParser12value_millisEv
        PUBLIC _ZN11GCodeParser12value_ushortEv
        PUBLIC _ZN11GCodeParser13value_celsiusEv
        PUBLIC _ZN11GCodeParser14value_feedrateEv
        PUBLIC _ZN11GCodeParser16value_axis_unitsE8AxisEnum
        PUBLIC _ZN11GCodeParser18value_linear_unitsEv
        PUBLIC _ZN11GCodeParser19value_per_axis_unitE8AxisEnum
        PUBLIC _ZN11GCodeParser25value_millis_from_secondsEv
        PUBLIC _ZN11GCodeParser4seenEc
        PUBLIC _ZN11GCodeParser6intvalEcs
        PUBLIC _ZN11GCodeParser7boolvalEc
        PUBLIC _ZN11GCodeParser7bytevalEch
        PUBLIC _ZN11GCodeParser7seenvalEc
        PUBLIC _ZN11GCodeParser9has_valueEv
        PUBLIC _ZN11GCodeParser9linearvalEcf
        PUBLIC _ZN11GCodeParser9ushortvalEct
        PUBLIC _ZN11GCodeParser9value_intEv
        PUBLIC _ZN11Temperature12setTargetBedEf
        PUBLIC _ZN11Temperature15degTargetHotendEh
        PUBLIC _ZN11Temperature15isCoolingHotendEh
        PUBLIC _ZN11Temperature15setTargetHotendEfh
        PUBLIC _ZN11Temperature9degHotendEh
        PUBLIC _ZN11Temperature9updatePIDEv
        PUBLIC _ZN7MKS_DLP10get_HeightEv
        PUBLIC _ZN7MKS_DLP10pausePrintEv
        PUBLIC _ZN7MKS_DLP10quick_stopEv
        PUBLIC _ZN7MKS_DLP11buzzer_toneEtth
        PUBLIC _ZN7MKS_DLP11resumePrintEv
        PUBLIC _ZN7MKS_DLP11set_ZoffsetEv
        PUBLIC _ZN7MKS_DLP11status_initEv
        PUBLIC _ZN7MKS_DLP12ExposureTestEv
        PUBLIC _ZN7MKS_DLP12get_cpld_verEv
        PUBLIC _ZN7MKS_DLP13buzzer_enableEh
        PUBLIC _ZN7MKS_DLP13draw_printingEv
        PUBLIC _ZN7MKS_DLP13get_LedOnTimeEv
        PUBLIC _ZN7MKS_DLP13line_gen_dataEth
        PUBLIC _ZN7MKS_DLP13set_LedOnTimeEt
        PUBLIC _ZN7MKS_DLP14CleanDataTransEv
        PUBLIC _ZN7MKS_DLP14bank2disp_readEv
        PUBLIC _ZN7MKS_DLP14buzzer_pollingEv
        PUBLIC _ZN7MKS_DLP14get_LedOffTimeEv
        PUBLIC _ZN7MKS_DLP14line_fill_zeroEth
        PUBLIC _ZN7MKS_DLP14moveRelative_ZEff
        PUBLIC _ZN7MKS_DLP14reTransmissionEv
        PUBLIC _ZN7MKS_DLP14set_LedOffTimeEt
        PUBLIC _ZN7MKS_DLP14startFileprintEv
        PUBLIC _ZN7MKS_DLP15get_sdcard_bmpsEv
        PUBLIC _ZN7MKS_DLP15get_totalLayersEv
        PUBLIC _ZN7MKS_DLP15moveFistLayer_ZEv
        PUBLIC _ZN7MKS_DLP16Can_Resume_PrintEv
        PUBLIC _ZN7MKS_DLP16TFT_display_testEv
        PUBLIC _ZN7MKS_DLP16bank2disp_enableEhhh
        PUBLIC _ZN7MKS_DLP16bottomLayerPrintEv
        PUBLIC _ZN7MKS_DLP16get_BottomlayersEv
        PUBLIC _ZN7MKS_DLP16get_currentLayerEv
        PUBLIC _ZN7MKS_DLP16get_ttfStatus_ONEv
        PUBLIC _ZN7MKS_DLP16set_BottomlayersEt
        PUBLIC _ZN7MKS_DLP17PrintStatePollingEv
        PUBLIC _ZN7MKS_DLP17get_buzzer_statusEv
        PUBLIC _ZN7MKS_DLP17get_ttfStatus_OFFEv
        PUBLIC _ZN7MKS_DLP17line_gen_data_TFTEt
        PUBLIC _ZN7MKS_DLP18GeneralLayersPrintEv
        PUBLIC _ZN7MKS_DLP18Is_Paused_FinishedEv
        PUBLIC _ZN7MKS_DLP18contiuePrint_PwdwnEv
        PUBLIC _ZN7MKS_DLP18get_available_bmpsEv
        PUBLIC _ZN7MKS_DLP18get_totalPrintTimeEv
        PUBLIC _ZN7MKS_DLP18line_fill_all_zeroEcth
        PUBLIC _ZN7MKS_DLP19contiuePrint_pausedEv
        PUBLIC _ZN7MKS_DLP19get_BottomLedOnTimeEv
        PUBLIC _ZN7MKS_DLP19printingHasFinishedEv
        PUBLIC _ZN7MKS_DLP19set_BottomLedOnTimeEt
        PUBLIC _ZN7MKS_DLP20get_currentPrintTimeEv
        PUBLIC _ZN7MKS_DLP21bank2disp_enable_grayEhhhh
        PUBLIC _ZN7MKS_DLP22moveRelativeZandGetBmpEff
        PUBLIC _ZN7MKS_DLP22read_Information_layerEv
        PUBLIC _ZN7MKS_DLP22set_test_exposure_timeEt
        PUBLIC _ZN7MKS_DLP23ExposureData2TFT_circleEv
        PUBLIC _ZN7MKS_DLP23clean_Information_layerEv
        PUBLIC _ZN7MKS_DLP23draw_return_printing_uiEv
        PUBLIC _ZN7MKS_DLP23read_Information_pausedEv
        PUBLIC _ZN7MKS_DLP23write_Information_layerE15DLP_MOVE_STATUS
        PUBLIC _ZN7MKS_DLP24ExposureDataTrans_circleEv
        PUBLIC _ZN7MKS_DLP24ExposureDataTrans_squareEv
        PUBLIC _ZN7MKS_DLP24write_Information_pausedEv
        PUBLIC _ZN7MKS_DLP6led_onEv
        PUBLIC _ZN7MKS_DLP7getHeadEv
        PUBLIC _ZN7MKS_DLP7led_offEv
        PUBLIC _ZN7MKS_DLP8getHead1Ev
        PUBLIC _ZN7MKS_DLP8getHead2Ev
        PUBLIC _ZN7MKS_DLP8power_onEv
        PUBLIC _ZN7MKS_DLP9dlp_startEv
        PUBLIC _ZN7MKS_DLP9grag_testEv
        PUBLIC _ZN7MKS_DLP9moveMax_ZEv
        PUBLIC _ZN7MKS_DLP9power_offEv
        PUBLIC _ZN7MKS_DLP9stopPrintEv
        PUBLIC _ZN7MKS_DLPC1Ev
        PUBLIC _ZN7MKS_DLPC2Ev
        PUBLIC _ZN7Planner11buffer_lineEfffRKfS1_h
        PUBLIC _ZN7Planner13blocks_queuedEv
        PUBLIC _ZN7Planner15set_position_mmEfffRKf
        PUBLIC _ZN7Planner16refresh_e_factorEh
        PUBLIC _ZN7Planner17set_e_position_mmERKf
        PUBLIC _ZN7Planner17set_filament_sizeEhRKf
        PUBLIC _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
        PUBLIC _ZN8Endstops10not_homingEv
        PUBLIC _ZN8Endstops14hit_on_purposeEv
        PUBLIC _ZN8Endstops15enable_globallyEb
        PUBLIC _ZN8Endstops6enableEb
        PUBLIC _ZNK10duration_t3dayEv
        PUBLIC _ZNK10duration_t4hourEv
        PUBLIC _ZNK10duration_t4yearEv
        PUBLIC _ZNK10duration_t6minuteEv
        PUBLIC _ZNK10duration_t6secondEv
        PUBLIC _ZNK10duration_t8toStringEPc
        PUBLIC _ZTI5Print
        PUBLIC _ZZ10gcode_M104vEs
        PUBLIC _ZZ10gcode_M104vEs_0
        PUBLIC _ZZ10gcode_M104vEs_1
        PUBLIC _ZZ10gcode_M104vEs_2
        PUBLIC _ZZ10gcode_M104vEs_3
        PUBLIC _ZZ10gcode_M104vEs_4
        PUBLIC _ZZ10gcode_M105vEs
        PUBLIC _ZZ10gcode_M109vEs
        PUBLIC _ZZ10gcode_M109vEs_0
        PUBLIC _ZZ10gcode_M109vEs_1
        PUBLIC _ZZ10gcode_M109vEs_2
        PUBLIC _ZZ10gcode_M109vEs_3
        PUBLIC _ZZ10gcode_M109vEs_4
        PUBLIC _ZZ10gcode_M109vEs_5
        PUBLIC _ZZ10gcode_M109vEs_6
        PUBLIC _ZZ10gcode_M111vE11str_debug_1
        PUBLIC _ZZ10gcode_M111vE11str_debug_2
        PUBLIC _ZZ10gcode_M111vE11str_debug_4
        PUBLIC _ZZ10gcode_M111vE11str_debug_8
        PUBLIC _ZZ10gcode_M111vE12str_debug_16
        PUBLIC _ZZ10gcode_M111vE13debug_strings
        PUBLIC _ZZ10gcode_M111vEs_4
        PUBLIC _ZZ10gcode_M111vEs_5
        PUBLIC _ZZ10gcode_M112vEs
        PUBLIC _ZZ10gcode_M115vEs
        PUBLIC _ZZ10gcode_M115vEs_0
        PUBLIC _ZZ10gcode_M115vEs_1
        PUBLIC _ZZ10gcode_M115vEs_2
        PUBLIC _ZZ10gcode_M115vEs_3
        PUBLIC _ZZ10gcode_M115vEs_4
        PUBLIC _ZZ10gcode_M115vEs_5
        PUBLIC _ZZ10gcode_M115vEs_6
        PUBLIC _ZZ10gcode_M115vEs_7
        PUBLIC _ZZ10gcode_M115vEs_8
        PUBLIC _ZZ10gcode_M115vEs_9
        PUBLIC _ZZ10gcode_M115vEs__10_
        PUBLIC _ZZ10gcode_M115vEs__11_
        PUBLIC _ZZ10gcode_M115vEs__12_
        PUBLIC _ZZ10gcode_M115vEs__13_
        PUBLIC _ZZ10gcode_M118vEs
        PUBLIC _ZZ10gcode_M204vEs
        PUBLIC _ZZ10gcode_M204vEs_0
        PUBLIC _ZZ10gcode_M204vEs_1
        PUBLIC _ZZ10gcode_M204vEs_2
        PUBLIC _ZZ10gcode_M211vEs
        PUBLIC _ZZ10gcode_M211vEs_0
        PUBLIC _ZZ10gcode_M211vEs_1
        PUBLIC _ZZ10gcode_M211vEs_2
        PUBLIC _ZZ10gcode_M211vEs_3
        PUBLIC _ZZ10gcode_M211vEs_4
        PUBLIC _ZZ10gcode_M211vEs_5
        PUBLIC _ZZ10gcode_M211vEs_6
        PUBLIC _ZZ10gcode_M301vEs
        PUBLIC _ZZ10gcode_M301vEs_0
        PUBLIC _ZZ10gcode_M301vEs_1
        PUBLIC _ZZ10gcode_M301vEs_2
        PUBLIC _ZZ10gcode_M355vEs
        PUBLIC _ZZ10gcode_M428vEs
        PUBLIC _ZZ10gcode_M428vEs_0
        PUBLIC _ZZ10gcode_M428vEs_1
        PUBLIC _ZZ11gcode_G2_G3bEs
        PUBLIC _ZZ19get_serial_commandsvE14last_wait_time
        PUBLIC _ZZ19get_serial_commandsvE18serial_line_buffer
        PUBLIC _ZZ19get_serial_commandsvE19serial_comment_mode
        PUBLIC _ZZ19get_serial_commandsvEs
        PUBLIC _ZZ19get_serial_commandsvEs_0
        PUBLIC _ZZ19get_serial_commandsvEs_1
        PUBLIC _ZZ19get_serial_commandsvEs_2
        PUBLIC _ZZ19get_serial_commandsvEs_3
        PUBLIC _ZZ19get_serial_commandsvEs_4
        PUBLIC _ZZ19get_serial_commandsvEs_5
        PUBLIC _ZZ19get_serial_commandsvEs_6
        PUBLIC _ZZ19get_serial_commandsvEs_7
        PUBLIC _ZZ19get_serial_commandsvEs_8
        PUBLIC _ZZ22invalid_extruder_errorhEs
        PUBLIC _ZZ24get_homing_bump_feedrate8AxisEnumEs
        PUBLIC _ZZ8gcode_G4vEs
        PUBLIC _ZZ9gcode_M17vEs
        PUBLIC _ZZ9gcode_M20vEs
        PUBLIC _ZZ9gcode_M20vEs_0
        PUBLIC _ZZ9gcode_M31vEs
        PUBLIC _ZZ9gcode_M42vEs
        PUBLIC _ZZNK10duration_t8toStringEPcEs
        PUBLIC _ZZNK10duration_t8toStringEPcEs_0
        PUBLIC _ZZNK10duration_t8toStringEPcEs_1
        PUBLIC _ZZNK10duration_t8toStringEPcEs_2
        PUBLIC _ZZNK10duration_t8toStringEPcEs_3
        PUBLIC active_extruder
        PUBLIC axis_homed
        PUBLIC axis_known_position
        PUBLIC axis_relative_modes
        PUBLIC base_home_pos_P
        PUBLIC base_max_pos_P
        PUBLIC base_min_pos_P
        PUBLIC btn_beep_cnt
        PUBLIC btn_flg
        PUBLIC card
        PUBLIC cartes
        PUBLIC commands_in_queue
        PUBLIC continue_print_error_flg
        PUBLIC ctemp
        PUBLIC current_position
        PUBLIC destination
        PUBLIC fanSpeeds
        PUBLIC feedrate_mm_s
        PUBLIC feedrate_percentage
        PUBLIC home_bump_mm_P
        PUBLIC home_dir_P
        PUBLIC home_offset
        PUBLIC homing_feedrate_mm_s
        PUBLIC kill_c
        PUBLIC loop
        PUBLIC marlin_debug_flags
        PUBLIC max_length_P
        PUBLIC mksReprint
        PUBLIC mks_PrintStatePolling
        PUBLIC mks_ReadFromEpr
        PUBLIC mks_ReadFromFile
        PUBLIC mks_WriteToFile
        PUBLIC mks_clearDir
        PUBLIC mks_clearFile
        PUBLIC mks_contiuePrintDelta
        PUBLIC mks_contiuePrintPause
        PUBLIC mks_contiuePrintPwdwn
        PUBLIC mks_contiuePrint_UI
        PUBLIC mks_getPositionXYZE
        PUBLIC mks_heating_busy
        PUBLIC mks_initPrint
        PUBLIC mks_manual_leveling
        PUBLIC mks_moveXY
        PUBLIC mks_moveZ
        PUBLIC mks_pausePrint
        PUBLIC mks_pft_name
        PUBLIC mks_preExtrude
        PUBLIC mks_rePrintCheck
        PUBLIC mks_resumePrint
        PUBLIC mks_saveFileName
        PUBLIC mks_setPositionZ
        PUBLIC mksdlp
        PUBLIC mkstft_ui_init
        PUBLIC mkstft_ui_load
        PUBLIC position_shift
        PUBLIC preview_no_display
        PUBLIC previous_cmd_ms
        PUBLIC print_job_timer
        PUBLIC printing_rate_update_flag
        PUBLIC reTransmission_all_cnt
        PUBLIC reTransmission_data_cnt
        PUBLIC reTransmission_zero_cnt
        PUBLIC saved_feedrate_percentage
        PUBLIC serial_wait_tick
        PUBLIC setup
        PUBLIC soft_endstop_max
        PUBLIC soft_endstop_min
        PUBLIC soft_endstops_enabled
        PUBLIC spi1_hdmatx_CR
        PUBLIC t1
        PUBLIC t12
        PUBLIC t2
        PUBLIC target_extruder
        PUBLIC temper_error_flg
        PUBLIC wait_for_heatup
        PUBLIC workspace_offset
        PUBLIC z_high_count
        
          CFI Names cfiNames0
          CFI StackFrame CFA R13 DATA
          CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
          CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, R13:32, R14:32
          CFI Resource D0:64, D1:64, D2:64, D3:64, D4:64, D5:64, D6:64, D7:64
          CFI Resource D8:64, D9:64, D10:64, D11:64, D12:64, D13:64, D14:64
          CFI Resource D15:64
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 4
          CFI ReturnAddress R14 CODE
          CFI CFA R13+0
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R12 Undefined
          CFI R14 SameValue
          CFI D0 Undefined
          CFI D1 Undefined
          CFI D2 Undefined
          CFI D3 Undefined
          CFI D4 Undefined
          CFI D5 Undefined
          CFI D6 Undefined
          CFI D7 Undefined
          CFI D8 SameValue
          CFI D9 SameValue
          CFI D10 SameValue
          CFI D11 SameValue
          CFI D12 SameValue
          CFI D13 SameValue
          CFI D14 SameValue
          CFI D15 SameValue
          CFI EndCommon cfiCommon0
        
// E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\Marlin_main.cpp
//    1 /**
//    2  * Marlin 3D Printer Firmware
//    3  * Copyright (C) 2016, 2017 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
//    4  *
//    5  * Based on Sprinter and grbl.
//    6  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
//    7  *
//    8  * This program is free software: you can redistribute it and/or modify
//    9  * it under the terms of the GNU General Public License as published by
//   10  * the Free Software Foundation, either version 3 of the License, or
//   11  * (at your option) any later version.
//   12  *
//   13  * This program is distributed in the hope that it will be useful,
//   14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
//   15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   16  * GNU General Public License for more details.
//   17  *
//   18  * You should have received a copy of the GNU General Public License
//   19  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
//   20  *
//   21  */
//   22 
//   23 /**
//   24  * About Marlin
//   25  *
//   26  * This firmware is a mashup between Sprinter and grbl.
//   27  *  - https://github.com/kliment/Sprinter
//   28  *  - https://github.com/simen/grbl/tree
//   29  */
//   30 
//   31 /**
//   32  * -----------------
//   33  * G-Codes in Marlin
//   34  * -----------------
//   35  *
//   36  * Helpful G-code references:
//   37  *  - http://linuxcnc.org/handbook/gcode/g-code.html
//   38  *  - http://objects.reprap.org/wiki/Mendel_User_Manual:_RepRapGCodes
//   39  *
//   40  * Help to document Marlin's G-codes online:
//   41  *  - http://reprap.org/wiki/G-code
//   42  *  - https://github.com/MarlinFirmware/MarlinDocumentation
//   43  *
//   44  * -----------------
//   45  *
//   46  * "G" Codes
//   47  *
//   48  * G0   -> G1
//   49  * G1   - Coordinated Movement X Y Z E
//   50  * G2   - CW ARC
//   51  * G3   - CCW ARC
//   52  * G4   - Dwell S<seconds> or P<milliseconds>
//   53  * G5   - Cubic B-spline with XYZE destination and IJPQ offsets
//   54  * G10  - Retract filament according to settings of M207 (Requires FWRETRACT)
//   55  * G11  - Retract recover filament according to settings of M208 (Requires FWRETRACT)
//   56  * G12  - Clean tool (Requires NOZZLE_CLEAN_FEATURE)
//   57  * G17  - Select Plane XY (Requires CNC_WORKSPACE_PLANES)
//   58  * G18  - Select Plane ZX (Requires CNC_WORKSPACE_PLANES)
//   59  * G19  - Select Plane YZ (Requires CNC_WORKSPACE_PLANES)
//   60  * G20  - Set input units to inches (Requires INCH_MODE_SUPPORT)
//   61  * G21  - Set input units to millimeters (Requires INCH_MODE_SUPPORT)
//   62  * G26  - Mesh Validation Pattern (Requires G26_MESH_VALIDATION)
//   63  * G27  - Park Nozzle (Requires NOZZLE_PARK_FEATURE)
//   64  * G28  - Home one or more axes
//   65  * G29  - Start or continue the bed leveling probe procedure (Requires bed leveling)
//   66  * G30  - Single Z probe, probes bed at X Y location (defaults to current XY location)
//   67  * G31  - Dock sled (Z_PROBE_SLED only)
//   68  * G32  - Undock sled (Z_PROBE_SLED only)
//   69  * G33  - Delta Auto-Calibration (Requires DELTA_AUTO_CALIBRATION)
//   70  * G38  - Probe in any direction using the Z_MIN_PROBE (Requires G38_PROBE_TARGET)
//   71  * G42  - Coordinated move to a mesh point (Requires MESH_BED_LEVELING, AUTO_BED_LEVELING_BLINEAR, or AUTO_BED_LEVELING_UBL)
//   72  * G90  - Use Absolute Coordinates
//   73  * G91  - Use Relative Coordinates
//   74  * G92  - Set current position to coordinates given
//   75  *
//   76  * "M" Codes
//   77  *
//   78  * M0   - Unconditional stop - Wait for user to press a button on the LCD (Only if ULTRA_LCD is enabled)
//   79  * M1   -> M0
//   80  * M3   - Turn laser/spindle on, set spindle/laser speed/power, set rotation to clockwise
//   81  * M4   - Turn laser/spindle on, set spindle/laser speed/power, set rotation to counter-clockwise
//   82  * M5   - Turn laser/spindle off
//   83  * M17  - Enable/Power all stepper motors
//   84  * M18  - Disable all stepper motors; same as M84
//   85  * M20  - List SD card. (Requires SDSUPPORT)
//   86  * M21  - Init SD card. (Requires SDSUPPORT)
//   87  * M22  - Release SD card. (Requires SDSUPPORT)
//   88  * M23  - Select SD file: "M23 /path/file.gco". (Requires SDSUPPORT)
//   89  * M24  - Start/resume SD print. (Requires SDSUPPORT)
//   90  * M25  - Pause SD print. (Requires SDSUPPORT)
//   91  * M26  - Set SD position in bytes: "M26 S12345". (Requires SDSUPPORT)
//   92  * M27  - Report SD print status. (Requires SDSUPPORT)
//   93  * M28  - Start SD write: "M28 /path/file.gco". (Requires SDSUPPORT)
//   94  * M29  - Stop SD write. (Requires SDSUPPORT)
//   95  * M30  - Delete file from SD: "M30 /path/file.gco"
//   96  * M31  - Report time since last M109 or SD card start to serial.
//   97  * M32  - Select file and start SD print: "M32 [S<bytepos>] !/path/file.gco#". (Requires SDSUPPORT)
//   98  *        Use P to run other files as sub-programs: "M32 P !filename#"
//   99  *        The '#' is necessary when calling from within sd files, as it stops buffer prereading
//  100  * M33  - Get the longname version of a path. (Requires LONG_FILENAME_HOST_SUPPORT)
//  101  * M34  - Set SD Card sorting options. (Requires SDCARD_SORT_ALPHA)
//  102  * M42  - Change pin status via gcode: M42 P<pin> S<value>. LED pin assumed if P is omitted.
//  103  * M43  - Display pin status, watch pins for changes, watch endstops & toggle LED, Z servo probe test, toggle pins
//  104  * M48  - Measure Z Probe repeatability: M48 P<points> X<pos> Y<pos> V<level> E<engage> L<legs>. (Requires Z_MIN_PROBE_REPEATABILITY_TEST)
//  105  * M75  - Start the print job timer.
//  106  * M76  - Pause the print job timer.
//  107  * M77  - Stop the print job timer.
//  108  * M78  - Show statistical information about the print jobs. (Requires PRINTCOUNTER)
//  109  * M80  - Turn on Power Supply. (Requires POWER_SUPPLY > 0)
//  110  * M81  - Turn off Power Supply. (Requires POWER_SUPPLY > 0)
//  111  * M82  - Set E codes absolute (default).
//  112  * M83  - Set E codes relative while in Absolute (G90) mode.
//  113  * M84  - Disable steppers until next move, or use S<seconds> to specify an idle
//  114  *        duration after which steppers should turn off. S0 disables the timeout.
//  115  * M85  - Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
//  116  * M92  - Set planner.axis_steps_per_mm for one or more axes.
//  117  * M100 - Watch Free Memory (for debugging) (Requires M100_FREE_MEMORY_WATCHER)
//  118  * M104 - Set extruder target temp.
//  119  * M105 - Report current temperatures.
//  120  * M106 - Set print fan speed.
//  121  * M107 - Print fan off.
//  122  * M108 - Break out of heating loops (M109, M190, M303). With no controller, breaks out of M0/M1. (Requires EMERGENCY_PARSER)
//  123  * M109 - Sxxx Wait for extruder current temp to reach target temp. Waits only when heating
//  124  *        Rxxx Wait for extruder current temp to reach target temp. Waits when heating and cooling
//  125  *        If AUTOTEMP is enabled, S<mintemp> B<maxtemp> F<factor>. Exit autotemp by any M109 without F
//  126  * M110 - Set the current line number. (Used by host printing)
//  127  * M111 - Set debug flags: "M111 S<flagbits>". See flag bits defined in enum.h.
//  128  * M112 - Emergency stop.
//  129  * M113 - Get or set the timeout interval for Host Keepalive "busy" messages. (Requires HOST_KEEPALIVE_FEATURE)
//  130  * M114 - Report current position.
//  131  * M115 - Report capabilities. (Extended capabilities requires EXTENDED_CAPABILITIES_REPORT)
//  132  * M117 - Display a message on the controller screen. (Requires an LCD)
//  133  * M118 - Display a message in the host console.
//  134  * M119 - Report endstops status.
//  135  * M120 - Enable endstops detection.
//  136  * M121 - Disable endstops detection.
//  137  * M122 - Debug stepper (Requires HAVE_TMC2130)
//  138  * M125 - Save current position and move to filament change position. (Requires PARK_HEAD_ON_PAUSE)
//  139  * M126 - Solenoid Air Valve Open. (Requires BARICUDA)
//  140  * M127 - Solenoid Air Valve Closed. (Requires BARICUDA)
//  141  * M128 - EtoP Open. (Requires BARICUDA)
//  142  * M129 - EtoP Closed. (Requires BARICUDA)
//  143  * M140 - Set bed target temp. S<temp>
//  144  * M145 - Set heatup values for materials on the LCD. H<hotend> B<bed> F<fan speed> for S<material> (0=PLA, 1=ABS)
//  145  * M149 - Set temperature units. (Requires TEMPERATURE_UNITS_SUPPORT)
//  146  * M150 - Set Status LED Color as R<red> U<green> B<blue> P<bright>. Values 0-255. (Requires BLINKM, RGB_LED, RGBW_LED, NEOPIXEL_LED, or PCA9632).
//  147  * M155 - Auto-report temperatures with interval of S<seconds>. (Requires AUTO_REPORT_TEMPERATURES)
//  148  * M163 - Set a single proportion for a mixing extruder. (Requires MIXING_EXTRUDER)
//  149  * M164 - Save the mix as a virtual extruder. (Requires MIXING_EXTRUDER and MIXING_VIRTUAL_TOOLS)
//  150  * M165 - Set the proportions for a mixing extruder. Use parameters ABCDHI to set the mixing factors. (Requires MIXING_EXTRUDER)
//  151  * M190 - Sxxx Wait for bed current temp to reach target temp. ** Waits only when heating! **
//  152  *        Rxxx Wait for bed current temp to reach target temp. ** Waits for heating or cooling. **
//  153  * M200 - Set filament diameter, D<diameter>, setting E axis units to cubic. (Use S0 to revert to linear units.)
//  154  * M201 - Set max acceleration in units/s^2 for print moves: "M201 X<accel> Y<accel> Z<accel> E<accel>"
//  155  * M202 - Set max acceleration in units/s^2 for travel moves: "M202 X<accel> Y<accel> Z<accel> E<accel>" ** UNUSED IN MARLIN! **
//  156  * M203 - Set maximum feedrate: "M203 X<fr> Y<fr> Z<fr> E<fr>" in units/sec.
//  157  * M204 - Set default acceleration in units/sec^2: P<printing> R<extruder_only> T<travel>
//  158  * M205 - Set advanced settings. Current units apply:
//  159             S<print> T<travel> minimum speeds
//  160             B<minimum segment time>
//  161             X<max X jerk>, Y<max Y jerk>, Z<max Z jerk>, E<max E jerk>
//  162  * M206 - Set additional homing offset. (Disabled by NO_WORKSPACE_OFFSETS or DELTA)
//  163  * M207 - Set Retract Length: S<length>, Feedrate: F<units/min>, and Z lift: Z<distance>. (Requires FWRETRACT)
//  164  * M208 - Set Recover (unretract) Additional (!) Length: S<length> and Feedrate: F<units/min>. (Requires FWRETRACT)
//  165  * M209 - Turn Automatic Retract Detection on/off: S<0|1> (For slicers that don't support G10/11). (Requires FWRETRACT)
//  166           Every normal extrude-only move will be classified as retract depending on the direction.
//  167  * M211 - Enable, Disable, and/or Report software endstops: S<0|1> (Requires MIN_SOFTWARE_ENDSTOPS or MAX_SOFTWARE_ENDSTOPS)
//  168  * M218 - Set a tool offset: "M218 T<index> X<offset> Y<offset>". (Requires 2 or more extruders)
//  169  * M220 - Set Feedrate Percentage: "M220 S<percent>" (i.e., "FR" on the LCD)
//  170  * M221 - Set Flow Percentage: "M221 S<percent>"
//  171  * M226 - Wait until a pin is in a given state: "M226 P<pin> S<state>"
//  172  * M240 - Trigger a camera to take a photograph. (Requires CHDK or PHOTOGRAPH_PIN)
//  173  * M250 - Set LCD contrast: "M250 C<contrast>" (0-63). (Requires LCD support)
//  174  * M260 - i2c Send Data (Requires EXPERIMENTAL_I2CBUS)
//  175  * M261 - i2c Request Data (Requires EXPERIMENTAL_I2CBUS)
//  176  * M280 - Set servo position absolute: "M280 P<index> S<angle|µs>". (Requires servos)
//  177  * M290 - Babystepping (Requires BABYSTEPPING)
//  178  * M300 - Play beep sound S<frequency Hz> P<duration ms>
//  179  * M301 - Set PID parameters P I and D. (Requires PIDTEMP)
//  180  * M302 - Allow cold extrudes, or set the minimum extrude S<temperature>. (Requires PREVENT_COLD_EXTRUSION)
//  181  * M303 - PID relay autotune S<temperature> sets the target temperature. Default 150C. (Requires PIDTEMP)
//  182  * M304 - Set bed PID parameters P I and D. (Requires PIDTEMPBED)
//  183  * M350 - Set microstepping mode. (Requires digital microstepping pins.)
//  184  * M351 - Toggle MS1 MS2 pins directly. (Requires digital microstepping pins.)
//  185  * M355 - Set Case Light on/off and set brightness. (Requires CASE_LIGHT_PIN)
//  186  * M380 - Activate solenoid on active extruder. (Requires EXT_SOLENOID)
//  187  * M381 - Disable all solenoids. (Requires EXT_SOLENOID)
//  188  * M400 - Finish all moves.
//  189  * M401 - Lower Z probe. (Requires a probe)
//  190  * M402 - Raise Z probe. (Requires a probe)
//  191  * M404 - Display or set the Nominal Filament Width: "W<diameter>". (Requires FILAMENT_WIDTH_SENSOR)
//  192  * M405 - Enable Filament Sensor flow control. "M405 D<delay_cm>". (Requires FILAMENT_WIDTH_SENSOR)
//  193  * M406 - Disable Filament Sensor flow control. (Requires FILAMENT_WIDTH_SENSOR)
//  194  * M407 - Display measured filament diameter in millimeters. (Requires FILAMENT_WIDTH_SENSOR)
//  195  * M410 - Quickstop. Abort all planned moves.
//  196  * M420 - Enable/Disable Leveling (with current values) S1=enable S0=disable (Requires MESH_BED_LEVELING or ABL)
//  197  * M421 - Set a single Z coordinate in the Mesh Leveling grid. X<units> Y<units> Z<units> (Requires MESH_BED_LEVELING or AUTO_BED_LEVELING_UBL)
//  198  * M428 - Set the home_offset based on the current_position. Nearest edge applies. (Disabled by NO_WORKSPACE_OFFSETS or DELTA)
//  199  * M500 - Store parameters in EEPROM. (Requires EEPROM_SETTINGS)
//  200  * M501 - Restore parameters from EEPROM. (Requires EEPROM_SETTINGS)
//  201  * M502 - Revert to the default "factory settings". ** Does not write them to EEPROM! **
//  202  * M503 - Print the current settings (in memory): "M503 S<verbose>". S0 specifies compact output.
//  203  * M540 - Enable/disable SD card abort on endstop hit: "M540 S<state>". (Requires ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
//  204  * M600 - Pause for filament change: "M600 X<pos> Y<pos> Z<raise> E<first_retract> L<later_retract>". (Requires ADVANCED_PAUSE_FEATURE)
//  205  * M665 - Set delta configurations: "M665 L<diagonal rod> R<delta radius> S<segments/s> A<rod A trim mm> B<rod B trim mm> C<rod C trim mm> I<tower A trim angle> J<tower B trim angle> K<tower C trim angle>" (Requires DELTA)
//  206  * M666 - Set delta endstop adjustment. (Requires DELTA)
//  207  * M605 - Set dual x-carriage movement mode: "M605 S<mode> [X<x_offset>] [R<temp_offset>]". (Requires DUAL_X_CARRIAGE)
//  208  * M851 - Set Z probe's Z offset in current units. (Negative = below the nozzle.)
//  209  * M852 - Set skew factors: "M852 [I<xy>] [J<xz>] [K<yz>]". (Requires SKEW_CORRECTION_GCODE, and SKEW_CORRECTION_FOR_Z for IJ)
//  210  * M860 - Report the position of position encoder modules.
//  211  * M861 - Report the status of position encoder modules.
//  212  * M862 - Perform an axis continuity test for position encoder modules.
//  213  * M863 - Perform steps-per-mm calibration for position encoder modules.
//  214  * M864 - Change position encoder module I2C address.
//  215  * M865 - Check position encoder module firmware version.
//  216  * M866 - Report or reset position encoder module error count.
//  217  * M867 - Enable/disable or toggle error correction for position encoder modules.
//  218  * M868 - Report or set position encoder module error correction threshold.
//  219  * M869 - Report position encoder module error.
//  220  * M900 - Get and/or Set advance K factor and WH/D ratio. (Requires LIN_ADVANCE)
//  221  * M906 - Set or get motor current in milliamps using axis codes X, Y, Z, E. Report values if no axis codes given. (Requires HAVE_TMC2130 or HAVE_TMC2208)
//  222  * M907 - Set digital trimpot motor current using axis codes. (Requires a board with digital trimpots)
//  223  * M908 - Control digital trimpot directly. (Requires DAC_STEPPER_CURRENT or DIGIPOTSS_PIN)
//  224  * M909 - Print digipot/DAC current value. (Requires DAC_STEPPER_CURRENT)
//  225  * M910 - Commit digipot/DAC value to external EEPROM via I2C. (Requires DAC_STEPPER_CURRENT)
//  226  * M911 - Report stepper driver overtemperature pre-warn condition. (Requires HAVE_TMC2130 or HAVE_TMC2208)
//  227  * M912 - Clear stepper driver overtemperature pre-warn condition flag. (Requires HAVE_TMC2130 or HAVE_TMC2208)
//  228  * M913 - Set HYBRID_THRESHOLD speed. (Requires HYBRID_THRESHOLD)
//  229  * M914 - Set SENSORLESS_HOMING sensitivity. (Requires SENSORLESS_HOMING)
//  230  *
//  231  * M360 - SCARA calibration: Move to cal-position ThetaA (0 deg calibration)
//  232  * M361 - SCARA calibration: Move to cal-position ThetaB (90 deg calibration - steps per degree)
//  233  * M362 - SCARA calibration: Move to cal-position PsiA (0 deg calibration)
//  234  * M363 - SCARA calibration: Move to cal-position PsiB (90 deg calibration - steps per degree)
//  235  * M364 - SCARA calibration: Move to cal-position PSIC (90 deg to Theta calibration position)
//  236  *
//  237  * ************ Custom codes - This can change to suit future G-code regulations
//  238  * M928 - Start SD logging: "M928 filename.gco". Stop with M29. (Requires SDSUPPORT)
//  239  * M998	- Stop SD print. (Requires SDSUPPORT)
//  240  * M999 - Restart after being stopped by error
//  241  *
//  242  * "T" Codes
//  243  *
//  244  * T0-T3 - Select an extruder (tool) by index: "T<n> F<units/min>"
//  245  *
//  246  */
//  247 
//  248 #include "Marlin.h"
//  249 
//  250 #include "ultralcd.h"
//  251 #include "planner.h"
//  252 #include "stepper.h"
//  253 #include "endstops.h"
//  254 #include "temperature.h"
//  255 #include "cardreader.h"
//  256 #include "configuration_store.h"
//  257 #include "language.h"
//  258 #include "math.h"
//  259 #include "nozzle.h"
//  260 #include "duration_t.h"
//  261 #include "tim.h"
//  262 #include "gcode.h"
//  263 #include "least_squares_fit.h"
//  264 #include "mks_cfg.h"
//  265 #include "mks_reprint.h"
//  266 #include "mks_dlp_main.h"
//  267 #include "gui.h"
//  268 #include "draw_ready_print.h"
//  269 #include "draw_ui.h"
//  270 #include "draw_printing.h"
//  271 

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  272 volatile uint8_t temper_error_flg = 0;
temper_error_flg:
        DS8 1

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function _ZN7MKS_DLPC2Ev
          CFI FunCall _ZN7MKS_DLPC1Ev
        THUMB
// __code __interwork __softfp MKS_DLP::subobject MKS_DLP()
_ZN7MKS_DLPC2Ev:
        B.W      _ZN7MKS_DLPC1Ev
          CFI EndBlock cfiBlock0
//  273 
//  274 volatile uint8_t mks_heating_busy = 0;
//  275 
//  276 extern void Close_machine_display();
//  277 
//  278 extern uint8_t IsChooseAutoShutdown;
//  279 
//  280 extern uint8_t temperature_change_frequency;
//  281 extern uint8_t from_flash_pic;
//  282 
//  283 static uint32_t temperature_change_frequency_cnt = 0;
//  284 static uint32_t After_finish_print_time = 0;
//  285 
//  286 volatile uint32_t TimeIncrease;
//  287 uint8_t volatile printing_rate_update_flag;
//  288 uint8_t preview_no_display;
//  289 extern PRINT_TIME  print_time;
//  290 
//  291 
//  292 
//  293 #if HAS_ABL
//  294   #include "vector_3.h"
//  295   #if ENABLED(AUTO_BED_LEVELING_LINEAR)
//  296     #include "least_squares_fit.h"
//  297   #endif
//  298 #elif ENABLED(MESH_BED_LEVELING)
//  299   #include "mesh_bed_leveling.h"
//  300 #endif
//  301 
//  302 #if ENABLED(BEZIER_CURVE_SUPPORT)
//  303   #include "planner_bezier.h"
//  304 #endif
//  305 
//  306 #if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
//  307   #include "buzzer.h"
//  308 #endif
//  309 
//  310 #if ENABLED(USE_WATCHDOG)
//  311   #include "watchdog.h"
//  312 #endif
//  313 
//  314 #if ENABLED(MAX7219_DEBUG)
//  315   #include "Max7219_Debug_LEDs.h"
//  316 #endif
//  317 
//  318 #if HAS_COLOR_LEDS
//  319   #include "leds.h"
//  320 #endif
//  321 
//  322 #if HAS_SERVOS
//  323   #include "servo.h"
//  324 #endif
//  325 
//  326 #if HAS_DIGIPOTSS
//  327   #include <SPI.h>
//  328 #endif
//  329 
//  330 #if ENABLED(DAC_STEPPER_CURRENT)
//  331   #include "stepper_dac.h"
//  332 #endif
//  333 
//  334 #if ENABLED(EXPERIMENTAL_I2CBUS)
//  335   #include "twibus.h"
//  336 #endif
//  337 
//  338 #if ENABLED(I2C_POSITION_ENCODERS)
//  339   #include "I2CPositionEncoder.h"
//  340 #endif
//  341 
//  342 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
//  343   #include "endstop_interrupts.h"
//  344 #endif
//  345 
//  346 #if ENABLED(M100_FREE_MEMORY_WATCHER)
//  347   void gcode_M100();
//  348   void M100_dump_routine(const char * const title, const char *start, const char *end);
//  349 #endif
//  350 
//  351 #if ENABLED(G26_MESH_VALIDATION)
//  352   bool g26_debug_flag; // =false
//  353   void gcode_G26();
//  354 #endif
//  355 
//  356 #if ENABLED(SDSUPPORT)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function __sti__routine
        THUMB
// static __intrinsic __interwork __softfp void __sti__routine()
__sti__routine:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
//  357   CardReader card;
        LDR.W    R4,??DataTable92_6
        MOV      R0,R4
          CFI FunCall _ZN10CardReaderC1Ev
        BL       _ZN10CardReaderC1Ev
        ADDW     R0,R4,#+3464
          CFI FunCall _ZN9StopwatchC1Ev
        BL       _ZN9StopwatchC1Ev
        LDR.W    R0,??DataTable92_7
        LDR.W    R1,??DataTable92_8
        LDR      R2,[R1, #+4]
        STR      R2,[R0, #+12]
        LDR      R2,[R1, #+8]
        STR      R2,[R0, #+24]
        LDRSB    R2,[R1, #+1]
        CMP      R2,#+0
        BPL.N    ??__sti__routine_0
        VLDR     S0,[R1, #+4]
        B.N      ??__sti__routine_1
??__sti__routine_0:
        VLDR     S0,[R1, #+8]
??__sti__routine_1:
        VSTR     S0,[R0, #+36]
        VLDR     S0,[R1, #+8]
        VLDR     S1,[R1, #+4]
        VSUB.F32 S0,S0,S1
        VSTR     S0,[R0, #+48]
        LDRB     R1,[R1, #+1]
        STRB     R1,[R0, #+2]
        ADDW     R0,R4,#+2500
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7MKS_DLPC1Ev
        B.W      _ZN7MKS_DLPC1Ev
          CFI EndBlock cfiBlock1
//  358 #endif
//  359 
//  360 #if ENABLED(EXPERIMENTAL_I2CBUS)
//  361   TWIBus i2c;
//  362 #endif
//  363 
//  364 #if ENABLED(G38_PROBE_TARGET)
//  365   bool G38_move = false,
//  366        G38_endstop_hit = false;
//  367 #endif
//  368 
//  369 #if ENABLED(AUTO_BED_LEVELING_UBL)
//  370   #include "ubl.h"
//  371   extern bool defer_return_to_status;
//  372   unified_bed_leveling ubl;
//  373 #endif
//  374 
//  375 #if ENABLED(CNC_COORDINATE_SYSTEMS)
//  376   int8_t active_coordinate_system = -1; // machine space
//  377   float coordinate_system[MAX_COORDINATE_SYSTEMS][XYZ];
//  378 #endif
//  379 
//  380 bool Running = true;
//  381 
//  382 uint8_t marlin_debug_flags = DEBUG_NONE;
//  383 
//  384 /**
//  385  * Cartesian Current Position
//  386  *   Used to track the native machine position as moves are queued.
//  387  *   Used by 'buffer_line_to_current_position' to do a move after changing it.
//  388  *   Used by 'SYNC_PLAN_POSITION_KINEMATIC' to update 'planner.position'.
//  389  */
//  390 float current_position[XYZE] = { 0.0 };
//  391 
//  392 /**
//  393  * Cartesian Destination
//  394  *   The destination for a move, filled in by G-code movement commands,
//  395  *   and expected by functions like 'prepare_move_to_destination'.
//  396  *   Set with 'gcode_get_destination' or 'set_destination_from_current'.
//  397  */
//  398 float destination[XYZE] = { 0.0 };
//  399 
//  400 /**
//  401  * axis_homed
//  402  *   Flags that each linear axis was homed.
//  403  *   XYZ on cartesian, ABC on delta, ABZ on SCARA.
//  404  *
//  405  * axis_known_position
//  406  *   Flags that the position is known in each linear axis. Set when homed.
//  407  *   Cleared whenever a stepper powers off, potentially losing its position.
//  408  */
//  409 bool axis_homed[XYZ] = { false }, axis_known_position[XYZ] = { false };
//  410 
//  411 /**
//  412  * GCode line number handling. Hosts may opt to include line numbers when
//  413  * sending commands to Marlin, and lines will be checked for sequentiality.
//  414  * M110 N<int> sets the current line number.
//  415  */
//  416 static long gcode_N, gcode_LastN, Stopped_gcode_LastN = 0;
//  417 
//  418 /**
//  419  * GCode Command Queue
//  420  * A simple ring buffer of BUFSIZE command strings.
//  421  *
//  422  * Commands are copied into this buffer by the command injectors
//  423  * (immediate, serial, sd card) and they are processed sequentially by
//  424  * the main loop. The process_next_command function parses the next
//  425  * command and hands off execution to individual handler functions.
//  426  */
//  427 uint8_t commands_in_queue = 0; // Count of commands in the queue
//  428 static uint8_t cmd_queue_index_r = 0, // Ring buffer read position
//  429                cmd_queue_index_w = 0; // Ring buffer write position
//  430 #if ENABLED(M100_FREE_MEMORY_WATCHER)
//  431   char command_queue[BUFSIZE][MAX_CMD_SIZE];  // Necessary so M100 Free Memory Dumper can show us the commands and any corruption
//  432 #else                                         // This can be collapsed back to the way it was soon.
//  433 static char command_queue[BUFSIZE][MAX_CMD_SIZE];
//  434 #endif
//  435 
//  436 /**
//  437  * Next Injected Command pointer. NULL if no commands are being injected.
//  438  * Used by Marlin internally to ensure that commands initiated from within
//  439  * are enqueued ahead of any pending serial or sd card commands.
//  440  */
//  441 static const char *injected_commands_P = NULL;
//  442 
//  443 #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
//  444   TempUnit input_temp_units = TEMPUNIT_C;
//  445 #endif
//  446 
//  447 /**
//  448  * Feed rates are often configured with mm/m
//  449  * but the planner and stepper like mm/s units.
//  450  */
//  451  /*
//  452 static const float homing_feedrate_mm_s[] PROGMEM = {
//  453   #if ENABLED(DELTA)
//  454     MMM_TO_MMS(HOMING_FEEDRATE_Z), MMM_TO_MMS(HOMING_FEEDRATE_Z),
//  455   #else
//  456     MMM_TO_MMS(HOMING_FEEDRATE_XY), MMM_TO_MMS(HOMING_FEEDRATE_XY),
//  457   #endif
//  458   MMM_TO_MMS(HOMING_FEEDRATE_Z), 0
//  459 };
//  460 
//  461 FORCE_INLINE float homing_feedrate(const AxisEnum a) { return pgm_read_float(&homing_feedrate_mm_s[a]); }
//  462 */
//  463 
//  464 float  homing_feedrate_mm_s[4];
//  465 
//  466 float feedrate_mm_s = MMM_TO_MMS(1500.0);
//  467 static float saved_feedrate_mm_s;
//  468 int16_t feedrate_percentage = 100, saved_feedrate_percentage;
//  469 
//  470 // Initialized by settings.load()
//  471 bool axis_relative_modes[] = AXIS_RELATIVE_MODES;
//  472 
//  473 #if HAS_WORKSPACE_OFFSET
//  474   #if HAS_POSITION_SHIFT
//  475     // The distance that XYZ has been offset by G92. Reset by G28.
//  476     float position_shift[XYZ] = { 0 };
//  477   #endif
//  478   #if HAS_HOME_OFFSET
//  479     // This offset is added to the configured home position.
//  480     // Set by M206, M428, or menu item. Saved to EEPROM.
//  481     float home_offset[XYZ] = { 0 };
//  482   #endif
//  483   #if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
//  484     // The above two are combined to save on computes
//  485     float workspace_offset[XYZ] = { 0 };
//  486   #endif
//  487 #endif
//  488 
//  489 // Software Endstops are based on the configured limits.
//  490 /*
//  491 float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
//  492       soft_endstop_max[XYZ] = { X_MAX_BED, Y_MAX_BED, Z_MAX_POS };
//  493 */
//  494 float soft_endstop_min[XYZ],soft_endstop_max[XYZ];

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function _Z21soft_endstop_min_initv
          CFI NoCalls
        THUMB
//  495 void soft_endstop_min_init()
//  496 {
//  497         soft_endstop_min[0]= X_MIN_BED;
_Z21soft_endstop_min_initv:
        LDR.W    R0,??DataTable92_9
        MOVS     R1,#+0
        STR      R1,[R0, #+92]
//  498         soft_endstop_min[1]= X_MIN_BED;
        STR      R1,[R0, #+96]
//  499         soft_endstop_min[2]= Z_MIN_POS;
        LDR.W    R1,??DataTable92_8
        LDR      R2,[R1, #+4]
        STR      R2,[R0, #+100]
//  500 
//  501         soft_endstop_max[0] = X_MAX_BED;
        VLDR.W   S0,??DataTable76  ;; 0x43480000
        VSTR     S0,[R0, #+104]
//  502         soft_endstop_max[1] = Y_MAX_BED;
        VSTR     S0,[R0, #+108]
//  503         soft_endstop_max[2] = Z_MAX_POS;
        LDR      R1,[R1, #+8]
        STR      R1,[R0, #+112]
//  504 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock2
//  505 
//  506 #if HAS_SOFTWARE_ENDSTOPS
//  507   bool soft_endstops_enabled = true;
//  508   #if IS_KINEMATIC
//  509     float soft_endstop_radius, soft_endstop_radius_2;
//  510   #endif
//  511 #endif
//  512 
//  513 #if FAN_COUNT > 0
//  514   int fanSpeeds[FAN_COUNT] = { 0 };
//  515   #if ENABLED(EXTRA_FAN_SPEED)
//  516     int16_t old_fanSpeeds[FAN_COUNT],
//  517             new_fanSpeeds[FAN_COUNT];
//  518   #endif
//  519   #if ENABLED(PROBING_FANS_OFF)
//  520     bool fans_paused = false;
//  521     int16_t paused_fanSpeeds[FAN_COUNT] = { 0 };
//  522   #endif
//  523 #endif
//  524 
//  525 // The active extruder (tool). Set with T<extruder> command.
//  526 uint8_t active_extruder = 0;
//  527 
//  528 // Relative Mode. Enable with G91, disable with G90.
//  529 static bool relative_mode = false;
//  530 
//  531 // For M109 and M190, this flag may be cleared (by M108) to exit the wait loop
//  532 volatile bool wait_for_heatup = true;
//  533 
//  534 // For M0/M1, this flag may be cleared (by M108) to exit the wait-for-user loop
//  535 #if HAS_RESUME_CONTINUE
//  536   volatile bool wait_for_user = false;
//  537 #endif
//  538 
//  539 const char axis_codes[XYZE] = { 'X', 'Y', 'Z', 'E' };
//  540 
//  541 // Number of characters read in the current line of serial input
//  542 static int serial_count = 0;
//  543 
//  544 // Inactivity shutdown
//  545 millis_t previous_cmd_ms = 0;
//  546 static millis_t max_inactive_time = 0;
//  547 static millis_t stepper_inactive_time = (DEFAULT_STEPPER_DEACTIVE_TIME) * 1000UL;
//  548 
//  549 // Print Job Timer
//  550 #if ENABLED(PRINTCOUNTER)
//  551   PrintCounter print_job_timer = PrintCounter();
//  552 #else
//  553   Stopwatch print_job_timer = Stopwatch();
//  554 #endif
//  555 
//  556 // Buzzer - I2C on the LCD or a BEEPER_PIN
//  557 #if ENABLED(LCD_USE_I2C_BUZZER)
//  558   #define BUZZ(d,f) lcd_buzz(d, f)
//  559 #elif PIN_EXISTS(BEEPER)
//  560   Buzzer buzzer;
//  561   #define BUZZ(d,f) buzzer.tone(d, f)
//  562 #else
//  563   #define BUZZ(d,f) NOOP
//  564 #endif
//  565 
//  566 uint8_t target_extruder;
//  567 
//  568 #if HAS_BED_PROBE
//  569   float zprobe_zoffset; // Initialized by settings.load()
//  570 #endif
//  571 
//  572 #if HAS_ABL
//  573   float xy_probe_feedrate_mm_s = MMM_TO_MMS(XY_PROBE_SPEED);
//  574   #define XY_PROBE_FEEDRATE_MM_S xy_probe_feedrate_mm_s
//  575 #elif defined(XY_PROBE_SPEED)
//  576   #define XY_PROBE_FEEDRATE_MM_S MMM_TO_MMS(XY_PROBE_SPEED)
//  577 #else
//  578   #define XY_PROBE_FEEDRATE_MM_S PLANNER_XY_FEEDRATE()
//  579 #endif
//  580 
//  581 #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
//  582   #if ENABLED(DELTA)
//  583     #define ADJUST_DELTA(V) \ 
//  584       if (planner.leveling_active) { \ 
//  585         const float zadj = bilinear_z_offset(V); \ 
//  586         delta[A_AXIS] += zadj; \ 
//  587         delta[B_AXIS] += zadj; \ 
//  588         delta[C_AXIS] += zadj; \ 
//  589       }
//  590   #else
//  591     #define ADJUST_DELTA(V) if (planner.leveling_active) { delta[Z_AXIS] += bilinear_z_offset(V); }
//  592   #endif
//  593 #elif IS_KINEMATIC
//  594   #define ADJUST_DELTA(V) NOOP
//  595 #endif
//  596 
//  597 #if ENABLED(X_DUAL_ENDSTOPS)
//  598   float x_endstop_adj;                // Initialized by settings.load()
//  599 #endif
//  600 #if ENABLED(Y_DUAL_ENDSTOPS)
//  601   float y_endstop_adj;                // Initialized by settings.load()
//  602 #endif
//  603 #if ENABLED(Z_DUAL_ENDSTOPS)
//  604   float z_endstop_adj;                // Initialized by settings.load()
//  605 #endif
//  606 
//  607 // Extruder offsets
//  608 #if HOTENDS > 1
//  609   float hotend_offset[XYZ][HOTENDS];  // Initialized by settings.load()
//  610 #endif
//  611 
//  612 #if HAS_Z_SERVO_ENDSTOP
//  613   const int z_servo_angle[2] = Z_SERVO_ANGLES;
//  614 #endif
//  615 
//  616 #if ENABLED(BARICUDA)
//  617   uint8_t baricuda_valve_pressure = 0,
//  618           baricuda_e_to_p_pressure = 0;
//  619 #endif
//  620 
//  621 #if ENABLED(FWRETRACT)                      // Initialized by settings.load()...
//  622   bool autoretract_enabled,                 // M209 S - Autoretract switch
//  623        retracted[EXTRUDERS] = { false };    // Which extruders are currently retracted
//  624   float retract_length,                     // M207 S - G10 Retract length
//  625         retract_feedrate_mm_s,              // M207 F - G10 Retract feedrate
//  626         retract_zlift,                      // M207 Z - G10 Retract hop size
//  627         retract_recover_length,             // M208 S - G11 Recover length
//  628         retract_recover_feedrate_mm_s,      // M208 F - G11 Recover feedrate
//  629         swap_retract_length,                // M207 W - G10 Swap Retract length
//  630         swap_retract_recover_length,        // M208 W - G11 Swap Recover length
//  631         swap_retract_recover_feedrate_mm_s; // M208 R - G11 Swap Recover feedrate
//  632   #if EXTRUDERS > 1
//  633     bool retracted_swap[EXTRUDERS] = { false }; // Which extruders are swap-retracted
//  634   #else
//  635     constexpr bool retracted_swap[1] = { false };
//  636   #endif
//  637 #endif // FWRETRACT
//  638 
//  639 #if HAS_POWER_SWITCH
//  640   bool powersupply_on =
//  641     #if ENABLED(PS_DEFAULT_OFF)
//  642       false
//  643     #else
//  644       true
//  645     #endif
//  646   ;
//  647 #endif
//  648 
//  649 #if ENABLED(DELTA)
//  650 
//  651   float delta[ABC];
//  652 
//  653   // Initialized by settings.load()
//  654   float delta_height,
//  655         delta_endstop_adj[ABC] = { 0 },
//  656         delta_radius,
//  657         delta_tower_angle_trim[ABC],
//  658         delta_tower[ABC][2],
//  659         delta_diagonal_rod,
//  660         delta_calibration_radius,
//  661         delta_diagonal_rod_2_tower[ABC],
//  662         delta_segments_per_second,
//  663         delta_clip_start_height = Z_MAX_POS;
//  664 
//  665   float delta_safe_distance_from_top();
//  666 
//  667 #endif
//  668 
//  669 #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
//  670   int bilinear_grid_spacing[2], bilinear_start[2];
//  671   float bilinear_grid_factor[2],
//  672         z_values[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
//  673 #endif
//  674 
//  675 #if IS_SCARA
//  676   // Float constants for SCARA calculations
//  677   const float L1 = SCARA_LINKAGE_1, L2 = SCARA_LINKAGE_2,
//  678               L1_2 = sq(float(L1)), L1_2_2 = 2.0 * L1_2,
//  679               L2_2 = sq(float(L2));
//  680 
//  681   float delta_segments_per_second = SCARA_SEGMENTS_PER_SECOND,
//  682         delta[ABC];
//  683 #endif
//  684 
//  685 float cartes[XYZ] = { 0 };
//  686 
//  687 #if ENABLED(FILAMENT_WIDTH_SENSOR)
//  688   bool filament_sensor = false;                                 // M405 turns on filament sensor control. M406 turns it off.
//  689   float filament_width_nominal = DEFAULT_NOMINAL_FILAMENT_DIA,  // Nominal filament width. Change with M404.
//  690         filament_width_meas = DEFAULT_MEASURED_FILAMENT_DIA;    // Measured filament diameter
//  691   uint8_t meas_delay_cm = MEASUREMENT_DELAY_CM;                 // Distance delay setting
//  692   int8_t measurement_delay[MAX_MEASUREMENT_DELAY + 1],          // Ring buffer to delayed measurement. Store extruder factor after subtracting 100
//  693          filwidth_delay_index[2] = { 0, -1 };                   // Indexes into ring buffer
//  694 #endif
//  695 
//  696 #if ENABLED(FILAMENT_RUNOUT_SENSOR)
//  697   static bool filament_ran_out = false;
//  698 #endif
//  699 
//  700 #if ENABLED(ADVANCED_PAUSE_FEATURE)
//  701   AdvancedPauseMenuResponse advanced_pause_menu_response;
//  702 #endif
//  703 
//  704 #if ENABLED(MIXING_EXTRUDER)
//  705   float mixing_factor[MIXING_STEPPERS]; // Reciprocal of mix proportion. 0.0 = off, otherwise >= 1.0.
//  706   #if MIXING_VIRTUAL_TOOLS > 1
//  707     float mixing_virtual_tool_mix[MIXING_VIRTUAL_TOOLS][MIXING_STEPPERS];
//  708   #endif
//  709 #endif
//  710 
//  711 static bool send_ok[BUFSIZE];
//  712 
//  713 #if HAS_SERVOS
//  714   Servo servo[NUM_SERVOS];
//  715   #define MOVE_SERVO(I, P) servo[I].move(P)
//  716   #if HAS_Z_SERVO_ENDSTOP
//  717     #define DEPLOY_Z_SERVO() MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[0])
//  718     #define STOW_Z_SERVO() MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[1])
//  719   #endif
//  720 #endif
//  721 
//  722 #ifdef CHDK
//  723   millis_t chdkHigh = 0;
//  724   bool chdkActive = false;
//  725 #endif
//  726 
//  727 #if ENABLED(PID_EXTRUSION_SCALING)
//  728   int lpq_len = 20;
//  729 #endif
//  730 
//  731 #if ENABLED(HOST_KEEPALIVE_FEATURE)
//  732   MarlinBusyState busy_state = NOT_BUSY;
//  733   static millis_t next_busy_signal_ms = 0;
//  734   uint8_t host_keepalive_interval = DEFAULT_KEEPALIVE_INTERVAL;
//  735 #else
//  736   #define host_keepalive() NOOP
//  737 #endif
//  738 
//  739 #if ENABLED(I2C_POSITION_ENCODERS)
//  740   I2CPositionEncodersMgr I2CPEM;
//  741   uint8_t blockBufferIndexRef = 0;
//  742   millis_t lastUpdateMillis;
//  743 #endif
//  744 
//  745 #if ENABLED(CNC_WORKSPACE_PLANES)
//  746   static WorkspacePlane workspace_plane = PLANE_XY;
//  747 #endif
//  748 
//  749 //FORCE_INLINE float pgm_read_any(const float *p) { return pgm_read_float_near(p); }
//  750 //FORCE_INLINE signed char pgm_read_any(const signed char *p) { return pgm_read_byte_near(p); }
//  751 static inline float pgm_read_any(const float *p) { return (*(const float *)(p)); }
//  752 static inline signed char pgm_read_any(const signed char *p) { return (*(const signed char *)(p)); }
//  753 /*P
//  754 #define XYZ_CONSTS_FROM_CONFIG(type, array, CONFIG) \ 
//  755   static const PROGMEM type array##_P[XYZ] = { X_##CONFIG, Y_##CONFIG, Z_##CONFIG }; \ 
//  756   static inline type array(const AxisEnum axis) { return pgm_read_any(&array##_P[axis]); } \ 
//  757   typedef void __void_##CONFIG##__
//  758 */
//  759 #define XYZ_CONSTS_FROM_CONFIG(type, array, CONFIG) \ 
//  760 	  type array##_P[XYZ] = { X_##CONFIG, Y_##CONFIG, Z_##CONFIG }; \ 
//  761 	  static inline type array(AxisEnum axis) { return (array##_P[axis]); } 
//  762 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function _Z12base_min_pos8AxisEnum
          CFI NoCalls
        THUMB
//  763 XYZ_CONSTS_FROM_CONFIG(float, base_min_pos,   MIN_POS);
_Z12base_min_pos8AxisEnum:
        LDR.W    R1,??DataTable92_7
        ADD      R0,R1,R0, LSL #+2
        VLDR     S0,[R0, #+4]
        BX       LR               ;; return
          CFI EndBlock cfiBlock3

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function _Z12base_max_pos8AxisEnum
          CFI NoCalls
        THUMB
//  764 XYZ_CONSTS_FROM_CONFIG(float, base_max_pos,   MAX_POS);
_Z12base_max_pos8AxisEnum:
        LDR.W    R1,??DataTable92_7
        ADD      R0,R1,R0, LSL #+2
        VLDR     S0,[R0, #+16]
        BX       LR               ;; return
          CFI EndBlock cfiBlock4

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock5 Using cfiCommon0
          CFI Function _Z13base_home_pos8AxisEnum
          CFI NoCalls
        THUMB
//  765 XYZ_CONSTS_FROM_CONFIG(float, base_home_pos,  HOME_POS);
_Z13base_home_pos8AxisEnum:
        LDR.W    R1,??DataTable92_7
        ADD      R0,R1,R0, LSL #+2
        VLDR     S0,[R0, #+28]
        BX       LR               ;; return
          CFI EndBlock cfiBlock5

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock6 Using cfiCommon0
          CFI Function _Z10max_length8AxisEnum
          CFI NoCalls
        THUMB
//  766 XYZ_CONSTS_FROM_CONFIG(float, max_length,     MAX_LENGTH);
_Z10max_length8AxisEnum:
        LDR.W    R1,??DataTable92_7
        ADD      R0,R1,R0, LSL #+2
        VLDR     S0,[R0, #+40]
        BX       LR               ;; return
          CFI EndBlock cfiBlock6

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock7 Using cfiCommon0
          CFI Function _Z12home_bump_mm8AxisEnum
          CFI NoCalls
        THUMB
//  767 XYZ_CONSTS_FROM_CONFIG(float, home_bump_mm,   HOME_BUMP_MM);
_Z12home_bump_mm8AxisEnum:
        LDR.W    R1,??DataTable95
        ADD      R0,R1,R0, LSL #+2
        VLDR     S0,[R0, #0]
        BX       LR               ;; return
          CFI EndBlock cfiBlock7

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock8 Using cfiCommon0
          CFI Function _Z8home_dir8AxisEnum
          CFI NoCalls
        THUMB
//  768 XYZ_CONSTS_FROM_CONFIG(signed char, home_dir, HOME_DIR);
_Z8home_dir8AxisEnum:
        LDR.W    R1,??DataTable92_7
        LDRSB    R0,[R0, R1]
        BX       LR               ;; return
          CFI EndBlock cfiBlock8
//  769 
//  770 /**
//  771  * ***************************************************************************
//  772  * ******************************** FUNCTIONS ********************************
//  773  * ***************************************************************************
//  774  */
//  775 
//  776 void stop();
//  777 
//  778 void get_available_commands();
//  779 void process_next_command();
//  780 void process_parsed_command();
//  781 
//  782 void get_cartesian_from_steppers();
//  783 void set_current_from_steppers_for_axis(const AxisEnum axis);
//  784 
//  785 #if ENABLED(ARC_SUPPORT)
//  786   void plan_arc(const float (&cart)[XYZE], const float (&offset)[2], const bool clockwise);
//  787 #endif
//  788 
//  789 #if ENABLED(BEZIER_CURVE_SUPPORT)
//  790   void plan_cubic_move(const float (&offset)[4]);
//  791 #endif
//  792 
//  793 void tool_change(const uint8_t tmp_extruder, const float fr_mm_s=0.0, bool no_move=false);
//  794 void report_current_position();
//  795 void report_current_position_detail();
//  796 
//  797 #if ENABLED(DEBUG_LEVELING_FEATURE)
//  798   void print_xyz(const char* prefix, const char* suffix, const float x, const float y, const float z) {
//  799     serialprintPGM(prefix);
//  800     SERIAL_CHAR('(');
//  801     SERIAL_ECHO(x);
//  802     SERIAL_ECHOPAIR(", ", y);
//  803     SERIAL_ECHOPAIR(", ", z);
//  804     SERIAL_CHAR(')');
//  805     if (suffix) serialprintPGM(suffix); else SERIAL_EOL();
//  806   }
//  807 
//  808   void print_xyz(const char* prefix, const char* suffix, const float xyz[]) {
//  809     print_xyz(prefix, suffix, xyz[X_AXIS], xyz[Y_AXIS], xyz[Z_AXIS]);
//  810   }
//  811 
//  812   #if HAS_ABL
//  813     void print_xyz(const char* prefix, const char* suffix, const vector_3 &xyz) {
//  814       print_xyz(prefix, suffix, xyz.x, xyz.y, xyz.z);
//  815     }
//  816   #endif
//  817 
//  818   #define DEBUG_POS(SUFFIX,VAR) do { \ 
//  819     print_xyz(PSTR("  " STRINGIFY(VAR) "="), PSTR(" : " SUFFIX "\n"), VAR); }while(0)
//  820 #endif
//  821 
//  822 /**
//  823  * sync_plan_position
//  824  *
//  825  * Set the planner/stepper positions directly from current_position with
//  826  * no kinematic translation. Used for homing axes and cartesian/core syncing.
//  827  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock9 Using cfiCommon0
          CFI Function _Z18sync_plan_positionv
        THUMB
//  828 void sync_plan_position() {
//  829   #if ENABLED(DEBUG_LEVELING_FEATURE)
//  830     if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position", current_position);
//  831   #endif
//  832   planner.set_position_mm(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
_Z18sync_plan_positionv:
        LDR.W    R1,??DataTable92_9
        ADD      R0,R1,#+44
        VLDR     S2,[R1, #+40]
        VLDR     S1,[R1, #+36]
        VLDR     S0,[R1, #+32]
          CFI FunCall _ZN7Planner15set_position_mmEfffRKf
        B.W      _ZN7Planner15set_position_mmEfffRKf
          CFI EndBlock cfiBlock9
//  833 }
//  834 inline void sync_plan_position_e() { planner.set_e_position_mm(current_position[E_AXIS]); }
//  835 
//  836 #if IS_KINEMATIC
//  837 
//  838   inline void sync_plan_position_kinematic() {
//  839     #if ENABLED(DEBUG_LEVELING_FEATURE)
//  840       if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position_kinematic", current_position);
//  841     #endif
//  842     planner.set_position_mm_kinematic(current_position);
//  843   }
//  844   #define SYNC_PLAN_POSITION_KINEMATIC() sync_plan_position_kinematic()
//  845 
//  846 #else
//  847 
//  848   #define SYNC_PLAN_POSITION_KINEMATIC() sync_plan_position()
//  849 
//  850 #endif
//  851 
//  852 #if 0//ENABLED(SDSUPPORT)
//  853   #include "SdFatUtil.h"
//  854   int freeMemory() { return SdFatUtil::FreeRam(); }
//  855 #else
//  856 /*
//  857 extern "C" {
//  858   extern char __bss_end;
//  859   extern char __heap_start;
//  860   extern void* __brkval;
//  861 
//  862   int freeMemory() {
//  863     int free_memory;
//  864     if ((int)__brkval == 0)
//  865       free_memory = ((int)&free_memory) - ((int)&__bss_end);
//  866     else
//  867       free_memory = ((int)&free_memory) - ((int)__brkval);
//  868     return free_memory;
//  869   }
//  870 }
//  871 */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock10 Using cfiCommon0
          CFI Function _Z10freeMemoryv
          CFI NoCalls
        THUMB
//  872 	int freeMemory() { return 4396; }	//No free ram management
_Z10freeMemoryv:
        MOVW     R0,#+4396
        BX       LR               ;; return
          CFI EndBlock cfiBlock10
//  873 
//  874 #endif // !SDSUPPORT
//  875 
//  876 #if ENABLED(DIGIPOT_I2C)
//  877   extern void digipot_i2c_set_current(uint8_t channel, float current);
//  878   extern void digipot_i2c_init();
//  879 #endif
//  880 
//  881 /**
//  882  * Inject the next "immediate" command, when possible, onto the front of the queue.
//  883  * Return true if any immediate commands remain to inject.
//  884  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock11 Using cfiCommon0
          CFI Function _Z25drain_injected_commands_Pv
        THUMB
//  885 static bool drain_injected_commands_P() {
_Z25drain_injected_commands_Pv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+32
          CFI CFA R13+48
//  886   if (injected_commands_P != NULL) {
        LDR.W    R4,??DataTable95_1
        LDR      R1,[R4, #+0]
        CMP      R1,#+0
        BEQ.N    ??drain_injected_commands_P_0
//  887     size_t i = 0;
        MOVS     R5,#+0
//  888     char c, cmd[30];
//  889     //strncpy_P(cmd, injected_commands_P, sizeof(cmd) - 1);
//  890     strncpy(cmd, injected_commands_P, sizeof(cmd) - 1);	/*--mks--*/
        MOVS     R2,#+29
        ADD      R0,SP,#+0
          CFI FunCall strncpy
        BL       strncpy
//  891     cmd[sizeof(cmd) - 1] = '\0';
        ADD      R0,SP,#+0
        MOV      R1,R5
        STRB     R1,[R0, #+29]
        B.N      ??drain_injected_commands_P_1
//  892     while ((c = cmd[i]) && c != '\n') i++; // find the end of this gcode command
??drain_injected_commands_P_2:
        ADDS     R5,R5,#+1
??drain_injected_commands_P_1:
        LDRSB    R6,[R5, R0]
        CMP      R6,#+0
        BEQ.N    ??drain_injected_commands_P_3
        CMP      R6,#+10
        BNE.N    ??drain_injected_commands_P_2
//  893     cmd[i] = '\0';
??drain_injected_commands_P_3:
        STRB     R1,[R5, R0]
//  894     if (enqueue_and_echo_command(cmd))     // success?
          CFI FunCall _Z24enqueue_and_echo_commandPKcb
        BL       _Z24enqueue_and_echo_commandPKcb
        CMP      R0,#+0
        BEQ.N    ??drain_injected_commands_P_0
//  895       injected_commands_P = c ? injected_commands_P + i + 1 : NULL; // next command or done
        CMP      R6,#+0
        BEQ.N    ??drain_injected_commands_P_4
        LDR      R0,[R4, #+0]
        ADDS     R0,R5,R0
        ADDS     R0,R0,#+1
        STR      R0,[R4, #+0]
        B.N      ??drain_injected_commands_P_0
??drain_injected_commands_P_4:
        MOVS     R0,#+0
        STR      R0,[R4, #+0]
//  896   }
//  897   return (injected_commands_P != NULL);    // return whether any more remain
??drain_injected_commands_P_0:
        LDR      R0,[R4, #+0]
        CMP      R0,#+0
        BEQ.N    ??drain_injected_commands_P_5
        MOVS     R0,#+1
        B.N      ??drain_injected_commands_P_6
??drain_injected_commands_P_5:
        MOVS     R0,#+0
??drain_injected_commands_P_6:
        ADD      SP,SP,#+32
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock11
//  898 }
//  899 
//  900 /**
//  901  * Record one or many commands to run from program memory.
//  902  * Aborts the current queue, if any.
//  903  * Note: drain_injected_commands_P() must be called repeatedly to drain the commands afterwards
//  904  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock12 Using cfiCommon0
          CFI Function _Z27enqueue_and_echo_commands_PPKc
        THUMB
//  905 void enqueue_and_echo_commands_P(const char * const pgcode) {
//  906   injected_commands_P = pgcode;
_Z27enqueue_and_echo_commands_PPKc:
        LDR.W    R1,??DataTable95_1
        STR      R0,[R1, #+0]
//  907   drain_injected_commands_P(); // first command executed asap (when possible)
          CFI FunCall _Z25drain_injected_commands_Pv
        B.N      _Z25drain_injected_commands_Pv
          CFI EndBlock cfiBlock12
//  908 }
//  909 
//  910 /**
//  911  * Clear the Marlin command queue
//  912  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock13 Using cfiCommon0
          CFI Function _Z19clear_command_queuev
          CFI NoCalls
        THUMB
//  913 void clear_command_queue() {
//  914   cmd_queue_index_r = cmd_queue_index_w;
_Z19clear_command_queuev:
        LDR.W    R0,??DataTable92_9
        LDRB     R1,[R0, #+16]
        STRB     R1,[R0, #+15]
//  915   commands_in_queue = 0;
        MOVS     R1,#+0
        STRB     R1,[R0, #+14]
//  916 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock13
//  917 
//  918 /**
//  919  * Once a new command is in the ring buffer, call this to commit it
//  920  */
//  921 inline void _commit_command(bool say_ok) {
//  922   send_ok[cmd_queue_index_w] = say_ok;
//  923   if (++cmd_queue_index_w >= BUFSIZE) cmd_queue_index_w = 0;
//  924   commands_in_queue++;
//  925 }
//  926 
//  927 /**
//  928  * Copy a command from RAM into the main command buffer.
//  929  * Return true if the command was successfully added.
//  930  * Return false for a full buffer, or if the 'command' is a comment.
//  931  */
//  932 inline bool _enqueuecommand(const char* cmd, bool say_ok=false) {
//  933   if (*cmd == ';' || commands_in_queue >= BUFSIZE) return false;
//  934   strcpy(command_queue[cmd_queue_index_w], cmd);
//  935   _commit_command(say_ok);
//  936   return true;
//  937 }
//  938 
//  939 /**
//  940  * Enqueue with Serial Echo
//  941  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock14 Using cfiCommon0
          CFI Function _Z24enqueue_and_echo_commandPKcb
        THUMB
//  942 bool enqueue_and_echo_command(const char* cmd, bool say_ok/*=false*/) {
_Z24enqueue_and_echo_commandPKcb:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
//  943   if (_enqueuecommand(cmd, say_ok)) {
          CFI FunCall _Z15_enqueuecommandPKcb
        BL       _Z15_enqueuecommandPKcb
        CMP      R0,#+0
        BEQ.N    ??enqueue_and_echo_command_0
//  944     SERIAL_ECHO_START();
        LDR.W    R0,??DataTable95_2
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
//  945     SERIAL_ECHOPAIR(MSG_ENQUEUEING, cmd);
        MOV      R1,R4
        ADR.W    R0,`?<Constant "enqueueing \\"">`
          CFI FunCall _Z17serial_echopair_PPKcS0_
        BL       _Z17serial_echopair_PPKcS0_
//  946     SERIAL_CHAR('"');
        LDR.W    R4,??DataTable97
        MOVS     R1,#+34
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
//  947     SERIAL_EOL();
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
//  948     return true;
        MOVS     R0,#+1
        POP      {R4,PC}
//  949   }
//  950   return false;
??enqueue_and_echo_command_0:
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock14
//  951 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "enqueueing \\"">`:
        DC8 "enqueueing \""
        DC8 0, 0, 0
//  952 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock15 Using cfiCommon0
          CFI Function _Z13setup_killpinv
          CFI NoCalls
        THUMB
//  953 void setup_killpin() {
//  954   #if HAS_KILL
//  955     SET_INPUT_PULLUP(KILL_PIN);
//  956   #endif
//  957 }
_Z13setup_killpinv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock15
//  958 
//  959 #if ENABLED(FILAMENT_RUNOUT_SENSOR)
//  960 
//  961   void setup_filrunoutpin() {
//  962     #if ENABLED(ENDSTOPPULLUP_FIL_RUNOUT)
//  963       SET_INPUT_PULLUP(FIL_RUNOUT_PIN);
//  964     #else
//  965       SET_INPUT(FIL_RUNOUT_PIN);
//  966     #endif
//  967   }
//  968 
//  969 #endif
//  970 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock16 Using cfiCommon0
          CFI Function _Z15setup_powerholdv
          CFI NoCalls
        THUMB
//  971 void setup_powerhold() {
//  972   #if HAS_SUICIDE
//  973     OUT_WRITE(SUICIDE_PIN, HIGH);
//  974   #endif
//  975   #if HAS_POWER_SWITCH
//  976     #if ENABLED(PS_DEFAULT_OFF)
//  977       OUT_WRITE(PS_ON_PIN, PS_ON_ASLEEP);
//  978     #else
//  979       OUT_WRITE(PS_ON_PIN, PS_ON_AWAKE);
//  980     #endif
//  981   #endif
//  982 }
_Z15setup_powerholdv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock16
//  983 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock17 Using cfiCommon0
          CFI Function _Z7suicidev
          CFI NoCalls
        THUMB
//  984 void suicide() {
//  985   #if HAS_SUICIDE
//  986     OUT_WRITE(SUICIDE_PIN, LOW);
//  987   #endif
//  988 }
_Z7suicidev:
        BX       LR               ;; return
          CFI EndBlock cfiBlock17
//  989 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock18 Using cfiCommon0
          CFI Function _Z10servo_initv
          CFI NoCalls
        THUMB
//  990 void servo_init() {
//  991   #if NUM_SERVOS >= 1 && HAS_SERVO_0
//  992     servo[0].attach(SERVO0_PIN);
//  993     servo[0].detach(); // Just set up the pin. We don't have a position yet. Don't move to a random position.
//  994   #endif
//  995   #if NUM_SERVOS >= 2 && HAS_SERVO_1
//  996     servo[1].attach(SERVO1_PIN);
//  997     servo[1].detach();
//  998   #endif
//  999   #if NUM_SERVOS >= 3 && HAS_SERVO_2
// 1000     servo[2].attach(SERVO2_PIN);
// 1001     servo[2].detach();
// 1002   #endif
// 1003   #if NUM_SERVOS >= 4 && HAS_SERVO_3
// 1004     servo[3].attach(SERVO3_PIN);
// 1005     servo[3].detach();
// 1006   #endif
// 1007 
// 1008   #if HAS_Z_SERVO_ENDSTOP
// 1009     /**
// 1010      * Set position of Z Servo Endstop
// 1011      *
// 1012      * The servo might be deployed and positioned too low to stow
// 1013      * when starting up the machine or rebooting the board.
// 1014      * There's no way to know where the nozzle is positioned until
// 1015      * homing has been done - no homing with z-probe without init!
// 1016      *
// 1017      */
// 1018     STOW_Z_SERVO();
// 1019   #endif
// 1020 }
_Z10servo_initv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock18
// 1021 
// 1022 /**
// 1023  * Stepper Reset (RigidBoard, et.al.)
// 1024  */
// 1025 #if HAS_STEPPER_RESET
// 1026   void disableStepperDrivers() {
// 1027     OUT_WRITE(STEPPER_RESET_PIN, LOW);  // drive it down to hold in reset motor driver chips
// 1028   }
// 1029   void enableStepperDrivers() { SET_INPUT(STEPPER_RESET_PIN); }  // set to input, which allows it to be pulled high by pullups
// 1030 #endif
// 1031 
// 1032 #if ENABLED(EXPERIMENTAL_I2CBUS) && I2C_SLAVE_ADDRESS > 0
// 1033 
// 1034   void i2c_on_receive(int bytes) { // just echo all bytes received to serial
// 1035     i2c.receive(bytes);
// 1036   }
// 1037 
// 1038   void i2c_on_request() {          // just send dummy data for now
// 1039     i2c.reply("Hello World!\n");
// 1040   }
// 1041 
// 1042 #endif
// 1043 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock19 Using cfiCommon0
          CFI Function _Z16gcode_line_errorPKcb
        THUMB
// 1044 void gcode_line_error(const char* err, bool doFlush = true) {
_Z16gcode_line_errorPKcb:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R4,R0
        MOV      R5,R1
// 1045   SERIAL_ERROR_START();
        LDR.W    R0,??DataTable95_3
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 1046   serialprintPGM(err);
        MOV      R0,R4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 1047   SERIAL_ERRORLN(gcode_LastN);
        LDR.W    R4,??DataTable97
        LDR.W    R6,??DataTable98
        MOVS     R2,#+10
        LDR      R1,[R6, #+4]
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEli
        BL       _ZN5Print5printEli
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 1048   //Serial.println(gcode_N);
// 1049   if (doFlush) FlushSerialRequestResend();
        CMP      R5,#+0
        BEQ.N    ??gcode_line_error_0
          CFI FunCall _Z24FlushSerialRequestResendv
        BL       _Z24FlushSerialRequestResendv
// 1050   serial_count = 0;
??gcode_line_error_0:
        MOVS     R0,#+0
        STR      R0,[R6, #+12]
// 1051 }
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock19

        SECTION `.data`:DATA:REORDER:NOROOT(2)
axis_relative_modes:
        DATA
        DC8 0, 0, 0, 0
axis_homed:
        DC8 0, 0, 0, 0
axis_known_position:
        DC8 0, 0, 0, 0
mks_heating_busy:
        DC8 0
marlin_debug_flags:
        DC8 0
commands_in_queue:
        DC8 0
        DC8 0
        DC8 0
soft_endstops_enabled:
        DC8 1
active_extruder:
        DC8 0
        DC8 0
wait_for_heatup:
        DC8 1
target_extruder:
        DC8 0
// 1052 
// 1053 uint8_t serial_wait_tick = 0; //use to calculate the serial wait ticks
serial_wait_tick:
        DC8 0
        DC8 0
        DC8 0, 0, 0, 0
feedrate_percentage:
        DC16 100
saved_feedrate_percentage:
        DC8 0, 0
current_position:
        DC32 0H
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
destination:
        DC32 0H
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
homing_feedrate_mm_s:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
home_offset:
        DC32 0H
        DC8 0, 0, 0, 0, 0, 0, 0, 0
soft_endstop_min:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
soft_endstop_max:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0
feedrate_mm_s:
        DC32 41C80000H
        DC8 0, 0, 0, 0
position_shift:
        DC32 0H
        DC8 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

        SECTION `.data`:DATA:REORDER:NOROOT(2)
Running:
        DATA
        DC8 1
        DC8 0, 0, 0
        DC8 0, 0, 0, 0
        DC32 0
        DC32 0

        SECTION `.data`:DATA:REORDER:NOROOT(2)
home_dir_P:
        DATA
        DC8 -1, -1, 0, 0
base_min_pos_P:
        DC32 0H, 0H, 0H
base_max_pos_P:
        DC32 43480000H, 43480000H, 0H
base_home_pos_P:
        DC32 0H, 0H, 0H
max_length_P:
        DC32 43480000H, 43480000H, 0H

        SECTION `.data`:DATA:REORDER:NOROOT(2)
home_bump_mm_P:
        DATA
        DC32 40A00000H, 40A00000H, 40A00000H
// 1054 
// 1055 
// 1056 /**
// 1057  * Get all commands waiting on the serial port and queue them.
// 1058  * Exit when the buffer is full or when no more characters are
// 1059  * left on the serial port.
// 1060  */
// 1061 inline void get_serial_commands() {
// 1062   static char serial_line_buffer[MAX_CMD_SIZE];
// 1063   static bool serial_comment_mode = false;
// 1064   static millis_t last_wait_time = 0;
// 1065   const millis_t wait_ms = millis();
// 1066 
// 1067   // If the command buffer is empty for too long,
// 1068   // send "wait" to indicate Marlin is still waiting.
// 1069   #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
// 1070     static millis_t last_command_time = 0;
// 1071     const millis_t ms = millis();
// 1072     if (commands_in_queue == 0 && !MYSERIAL.available() && ELAPSED(ms, last_command_time + NO_TIMEOUTS)) {
// 1073       SERIAL_ECHOLNPGM(MSG_WAIT);
// 1074       last_command_time = ms;
// 1075     }
// 1076   #endif
// 1077 #if 1
// 1078   
// 1079 	  /*5s?¡§?2a2?|¨¬?????¡§2¡§oy?Y?¡§¡ã¡§¡§??a??¡§?D¡§¡éa?¡§2?????¨º??¡§|¡§o1¡§??wifi*/
// 1080 	 if (commands_in_queue == 0 && !MYSERIAL.available() && ELAPSED(wait_ms, last_wait_time + 1000)) {
// 1081 		if(serial_wait_tick <= 5)
// 1082 	  {
// 1083 		  serial_wait_tick ++;
// 1084 	  }
// 1085 		last_wait_time = wait_ms;
// 1086 	  }
// 1087 #endif
// 1088 
// 1089   /**
// 1090    * Loop while serial characters are incoming and the queue is not full
// 1091    */
// 1092   int c;
// 1093   while (commands_in_queue < BUFSIZE && (c = MYSERIAL.read()) >= 0) {
// 1094 
// 1095     char serial_char = c;
// 1096 	
// 1097 	serial_wait_tick = 0;
// 1098 
// 1099     /**
// 1100      * If the character ends the line
// 1101      */
// 1102     if (serial_char == '\n' || serial_char == '\r') {
// 1103 
// 1104       serial_comment_mode = false;                      // end of line == end of comment
// 1105 
// 1106       if (!serial_count) continue;                      // Skip empty lines
// 1107 
// 1108       serial_line_buffer[serial_count] = 0;             // Terminate string
// 1109       serial_count = 0;                                 // Reset buffer
// 1110 
// 1111       char* command = serial_line_buffer;
// 1112 
// 1113       while (*command == ' ') command++;                // Skip leading spaces
// 1114       char *npos = (*command == 'N') ? command : NULL;  // Require the N parameter to start the line
// 1115 
// 1116       if (npos) {
// 1117 
// 1118         bool M110 = strstr_P(command, PSTR("M110")) != NULL;
// 1119 
// 1120         if (M110) {
// 1121           char* n2pos = strchr(command + 4, 'N');
// 1122           if (n2pos) npos = n2pos;
// 1123         }
// 1124 
// 1125         gcode_N = strtol(npos + 1, NULL, 10);
// 1126 
// 1127         if (gcode_N != gcode_LastN + 1 && !M110) {
// 1128           gcode_line_error(PSTR(MSG_ERR_LINE_NO));
// 1129           return;
// 1130         }
// 1131 
// 1132         char *apos = strrchr(command, '*');
// 1133         if (apos) {
// 1134           uint8_t checksum = 0, count = uint8_t(apos - command);
// 1135           while (count) checksum ^= command[--count];
// 1136           if (strtol(apos + 1, NULL, 10) != checksum) {
// 1137             gcode_line_error(PSTR(MSG_ERR_CHECKSUM_MISMATCH));
// 1138             return;
// 1139           }
// 1140         }
// 1141         else {
// 1142           gcode_line_error(PSTR(MSG_ERR_NO_CHECKSUM));
// 1143           return;
// 1144         }
// 1145 
// 1146         gcode_LastN = gcode_N;
// 1147       }
// 1148 
// 1149       // Movement commands alert when stopped
// 1150       if (IsStopped()) {
// 1151         char* gpos = strchr(command, 'G');
// 1152         if (gpos) {
// 1153           const int codenum = strtol(gpos + 1, NULL, 10);
// 1154           switch (codenum) {
// 1155             case 0:
// 1156             case 1:
// 1157             case 2:
// 1158             case 3:
// 1159               SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
// 1160               LCD_MESSAGEPGM(MSG_STOPPED);
// 1161               break;
// 1162           }
// 1163         }
// 1164       }
// 1165 
// 1166       #if DISABLED(EMERGENCY_PARSER)
// 1167         // If command was e-stop process now
// 1168         if (strcmp(command, "M108") == 0) {
// 1169           wait_for_heatup = false;
// 1170           #if ENABLED(ULTIPANEL)
// 1171             wait_for_user = false;
// 1172           #endif
// 1173         }
// 1174         if (strcmp(command, "M112") == 0) kill(PSTR(MSG_KILLED));
// 1175         if (strcmp(command, "M410") == 0) { quickstop_stepper(); }
// 1176       #endif
// 1177 
// 1178       #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
// 1179         last_command_time = ms;
// 1180       #endif
// 1181 
// 1182       // Add the command to the queue
// 1183       _enqueuecommand(serial_line_buffer, true);
// 1184     }
// 1185     else if (serial_count >= MAX_CMD_SIZE - 1) {
// 1186       // Keep fetching, but ignore normal characters beyond the max length
// 1187       // The command will be injected when EOL is reached
// 1188     }
// 1189     else if (serial_char == '\\') {  // Handle escapes
// 1190       if ((c = MYSERIAL.read()) >= 0) {
// 1191         // if we have one more character, copy it over
// 1192         serial_char = c;
// 1193         if (!serial_comment_mode) serial_line_buffer[serial_count++] = serial_char;
// 1194       }
// 1195       // otherwise do nothing
// 1196     }
// 1197     else { // it's not a newline, carriage return or escape char
// 1198       if (serial_char == ';') serial_comment_mode = true;
// 1199       if (!serial_comment_mode) serial_line_buffer[serial_count++] = serial_char;
// 1200     }
// 1201 
// 1202   } // queue has space, serial has data
// 1203 }
// 1204 
// 1205 #if ENABLED(SDSUPPORT)
// 1206 
// 1207   /**
// 1208    * Get commands from the SD Card until the command buffer is full
// 1209    * or until the end of the file is reached. The special character '#'
// 1210    * can also interrupt buffering.
// 1211    */
// 1212   inline void get_sdcard_commands() {
// 1213     static bool stop_buffering = false,
// 1214                 sd_comment_mode = false;
// 1215 
// 1216     if (!card.sdprinting) return;
// 1217 
// 1218     /**
// 1219      * '#' stops reading from SD to the buffer prematurely, so procedural
// 1220      * macro calls are possible. If it occurs, stop_buffering is triggered
// 1221      * and the buffer is run dry; this character _can_ occur in serial com
// 1222      * due to checksums, however, no checksums are used in SD printing.
// 1223      */
// 1224 
// 1225     if (commands_in_queue == 0) stop_buffering = false;
// 1226 
// 1227     uint16_t sd_count = 0;
// 1228     bool card_eof = card.eof();
// 1229     while (commands_in_queue < BUFSIZE && !card_eof && !stop_buffering) {
// 1230       const int16_t n = card.get();
// 1231       char sd_char = (char)n;
// 1232       card_eof = card.eof();
// 1233       if (card_eof || n == -1
// 1234           || sd_char == '\n' || sd_char == '\r'
// 1235           || ((sd_char == '#' || sd_char == ':') && !sd_comment_mode)
// 1236       ) {
// 1237         if (card_eof) {
// 1238           gCfgItems.breakpoint_reprint_flg = 0;
// 1239           gCfgItems.breakpoint_z_pos = 0;
// 1240 
// 1241           card.printingHasFinished();
// 1242 
// 1243           if (card.sdprinting)
// 1244             sd_count = 0; // If a sub-file was printing, continue from call point
// 1245           else {
// 1246             SERIAL_PROTOCOLLNPGM(MSG_FILE_PRINTED);
// 1247             #if ENABLED(PRINTER_EVENT_LEDS)
// 1248               LCD_MESSAGEPGM(MSG_INFO_COMPLETED_PRINTS);
// 1249               leds.set_green();
// 1250               #if HAS_RESUME_CONTINUE
// 1251                 enqueue_and_echo_commands_P(PSTR("M0")); // end of the queue!
// 1252               #else
// 1253                 safe_delay(1000);
// 1254               #endif
// 1255               leds.set_off();
// 1256             #endif
// 1257             card.checkautostart(true);
// 1258 			
// 1259 			#if 1
// 1260 			
// 1261 			
// 1262 			//¡ä¨°¨ª¨º1??¨²?¡ê
// 1263 			if((gCfgItems.print_finish_close_machine_flg == 1)&&(IsChooseAutoShutdown==1))
// 1264 			    Close_machine_display();
// 1265 
// 1266             #endif 				
// 1267           }
// 1268         }
// 1269         else if (n == -1) {
// 1270           SERIAL_ERROR_START();
// 1271           SERIAL_ECHOLNPGM(MSG_SD_ERR_READ);
// 1272         }
// 1273         if (sd_char == '#') stop_buffering = true;
// 1274 
// 1275         sd_comment_mode = false; // for new command
// 1276 
// 1277         if (!sd_count) continue; // skip empty lines (and comment lines)
// 1278 
// 1279         command_queue[cmd_queue_index_w][sd_count] = '\0'; // terminate string
// 1280         sd_count = 0; // clear sd line buffer
// 1281 
// 1282         _commit_command(false);
// 1283       }
// 1284       else if (sd_count >= MAX_CMD_SIZE - 1) {
// 1285         /**
// 1286          * Keep fetching, but ignore normal characters beyond the max length
// 1287          * The command will be injected when EOL is reached
// 1288          */
// 1289       }
// 1290       else {
// 1291         if (sd_char == ';') sd_comment_mode = true;
// 1292         //if (!sd_comment_mode) command_queue[cmd_queue_index_w][sd_count++] = sd_char;
// 1293         if (!sd_comment_mode) 
// 1294         {
// 1295 			command_queue[cmd_queue_index_w][sd_count++] = sd_char;
// 1296 #if 0	//mks dlp			
// 1297 			if(sd_char == 0x5a ) //"Z"
// 1298 			{
// 1299 				mksReprint.sdpos = card.getsdpos()-3;	//"¡¤?2?????"
// 1300 				#if 1
// 1301 				mksReprint.sdpos_bak = mksReprint.sdpos;//sdpos_bak¦Ì?¨¨Y??¦Ì?¡ê????¡ä¨º1¨®?
// 1302 				if(gCfgItems.pwroff_save_mode != 1)//sd?¡§¡À¡ê¡ä???¦Ì?¨ºy?Y
// 1303                 #endif
// 1304 					mksReprint.refresh = true;
// 1305 			}
// 1306 #endif			
// 1307         }        
// 1308       }
// 1309     }
// 1310   }
// 1311 
// 1312 #endif // SDSUPPORT
// 1313 
// 1314 /**
// 1315  * Add to the circular command queue the next command from:
// 1316  *  - The command-injection queue (injected_commands_P)
// 1317  *  - The active serial input (usually USB)
// 1318  *  - The SD card file being actively printed
// 1319  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock20 Using cfiCommon0
          CFI Function _Z22get_available_commandsv
        THUMB
// 1320 void get_available_commands() {
_Z22get_available_commandsv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 1321 
// 1322   // if any immediate commands remain, don't get other commands yet
// 1323   if (drain_injected_commands_P()) return;
          CFI FunCall _Z25drain_injected_commands_Pv
        BL       _Z25drain_injected_commands_Pv
        CMP      R0,#+0
        BNE.N    ??get_available_commands_0
// 1324 
// 1325   get_serial_commands();
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z19get_serial_commandsv
        B.W      _Z19get_serial_commandsv
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??get_available_commands_0:
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock20
// 1326   
// 1327   #if ENABLED(SDSUPPORT) && DISABLED(MKS_DLP_BOARD)
// 1328     get_sdcard_commands();
// 1329   #endif
// 1330 }
// 1331 
// 1332 /**
// 1333  * Set target_extruder from the T parameter or the active_extruder
// 1334  *
// 1335  * Returns TRUE if the target is invalid
// 1336  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock21 Using cfiCommon0
          CFI Function _Z32get_target_extruder_from_commandt
        THUMB
// 1337 bool get_target_extruder_from_command(const uint16_t code) {
_Z32get_target_extruder_from_commandt:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R4,R0
// 1338   if (parser.seenval('T')) {
        MOVS     R0,#+84
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??get_target_extruder_from_command_0
// 1339     const int8_t e = parser.value_byte();
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        MOV      R5,R0
        SXTB     R5,R5
// 1340     if (e >= EXTRUDERS) {
        CMP      R5,#+1
        BLT.N    ??get_target_extruder_from_command_1
// 1341       SERIAL_ECHO_START();
        LDR.W    R0,??DataTable95_2
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 1342       SERIAL_CHAR('M');
        LDR.W    R6,??DataTable97
        MOVS     R1,#+77
        MOV      R0,R6
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 1343       SERIAL_ECHO(code);
        MOVS     R2,#+10
        MOV      R1,R4
        MOV      R0,R6
          CFI FunCall _ZN5Print5printEii
        BL       _ZN5Print5printEii
// 1344       SERIAL_ECHOLNPAIR(" " MSG_INVALID_EXTRUDER " ", e);
        MOV      R1,R5
        ADR.W    R0,`?<Constant " Invalid extruder ">`
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
        MOVS     R1,#+10
        MOV      R0,R6
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 1345       return true;
        MOVS     R0,#+1
        POP      {R4-R6,PC}
// 1346     }
// 1347     target_extruder = e;
??get_target_extruder_from_command_1:
        LDR.W    R0,??DataTable92_9
        STRB     R5,[R0, #+21]
        B.N      ??get_target_extruder_from_command_2
// 1348   }
// 1349   else
// 1350     target_extruder = active_extruder;
??get_target_extruder_from_command_0:
        LDR.W    R0,??DataTable92_9
        LDRB     R1,[R0, #+18]
        STRB     R1,[R0, #+21]
// 1351 
// 1352   return false;
??get_target_extruder_from_command_2:
        MOVS     R0,#+0
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock21
// 1353 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant " Invalid extruder ">`:
        DC8 " Invalid extruder "
        DC8 0
// 1354 
// 1355 #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
// 1356   bool extruder_duplication_enabled = false; // Used in Dual X mode 2
// 1357 #endif
// 1358 
// 1359 #if ENABLED(DUAL_X_CARRIAGE)
// 1360 
// 1361   static DualXMode dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
// 1362 
// 1363   static float x_home_pos(const int extruder) {
// 1364     if (extruder == 0)
// 1365       return base_home_pos(X_AXIS);
// 1366     else
// 1367       /**
// 1368        * In dual carriage mode the extruder offset provides an override of the
// 1369        * second X-carriage position when homed - otherwise X2_HOME_POS is used.
// 1370        * This allows soft recalibration of the second extruder home position
// 1371        * without firmware reflash (through the M218 command).
// 1372        */
// 1373       return hotend_offset[X_AXIS][1] > 0 ? hotend_offset[X_AXIS][1] : X2_HOME_POS;
// 1374   }
// 1375 
// 1376   static int x_home_dir(const int extruder) { return extruder ? X2_HOME_DIR : X_HOME_DIR; }
// 1377 
// 1378   static float inactive_extruder_x_pos = X2_MAX_POS; // used in mode 0 & 1
// 1379   static bool active_extruder_parked = false;        // used in mode 1 & 2
// 1380   static float raised_parked_position[XYZE];         // used in mode 1
// 1381   static millis_t delayed_move_time = 0;             // used in mode 1
// 1382   static float duplicate_extruder_x_offset = DEFAULT_DUPLICATION_X_OFFSET; // used in mode 2
// 1383   static int16_t duplicate_extruder_temp_offset = 0; // used in mode 2
// 1384 
// 1385 #endif // DUAL_X_CARRIAGE
// 1386 
// 1387 #if HAS_WORKSPACE_OFFSET || ENABLED(DUAL_X_CARRIAGE)
// 1388 
// 1389   /**
// 1390    * Software endstops can be used to monitor the open end of
// 1391    * an axis that has a hardware endstop on the other end. Or
// 1392    * they can prevent axes from moving past endstops and grinding.
// 1393    *
// 1394    * To keep doing their job as the coordinate system changes,
// 1395    * the software endstop positions must be refreshed to remain
// 1396    * at the same positions relative to the machine.
// 1397    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock22 Using cfiCommon0
          CFI Function _Z24update_software_endstops8AxisEnum
        THUMB
// 1398   void update_software_endstops(const AxisEnum axis) {
_Z24update_software_endstops8AxisEnum:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
// 1399     #if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
// 1400       workspace_offset[axis] = home_offset[axis] + position_shift[axis];
        LDR.W    R0,??DataTable92_9
        ADD      R5,R0,R4, LSL #+2
        VLDR     S0,[R5, #+80]
        VLDR     S1,[R5, #+128]
        VADD.F32 S0,S0,S1
        LDR.W    R0,??DataTable99
        ADD      R0,R0,R4, LSL #+2
        VSTR     S0,[R0, #0]
// 1401     #endif
// 1402 
// 1403     #if ENABLED(DUAL_X_CARRIAGE)
// 1404       if (axis == X_AXIS) {
// 1405 
// 1406         // In Dual X mode hotend_offset[X] is T1's home position
// 1407         float dual_max_x = max(hotend_offset[X_AXIS][1], X2_MAX_POS);
// 1408 
// 1409         if (active_extruder != 0) {
// 1410           // T1 can move from X2_MIN_POS to X2_MAX_POS or X2 home position (whichever is larger)
// 1411           soft_endstop_min[X_AXIS] = X2_MIN_POS;
// 1412           soft_endstop_max[X_AXIS] = dual_max_x;
// 1413         }
// 1414         else if (dual_x_carriage_mode == DXC_DUPLICATION_MODE) {
// 1415           // In Duplication Mode, T0 can move as far left as X_MIN_POS
// 1416           // but not so far to the right that T1 would move past the end
// 1417           soft_endstop_min[X_AXIS] = base_min_pos(X_AXIS);
// 1418           soft_endstop_max[X_AXIS] = min(base_max_pos(X_AXIS), dual_max_x - duplicate_extruder_x_offset);
// 1419         }
// 1420         else {
// 1421           // In other modes, T0 can move from X_MIN_POS to X_MAX_POS
// 1422           soft_endstop_min[axis] = base_min_pos(axis);
// 1423           soft_endstop_max[axis] = base_max_pos(axis);
// 1424         }
// 1425       }
// 1426     #elif ENABLED(DELTA)
// 1427       soft_endstop_min[axis] = base_min_pos(axis);
// 1428       soft_endstop_max[axis] = axis == Z_AXIS ? delta_height : base_max_pos(axis);
// 1429     #else
// 1430       soft_endstop_min[axis] = base_min_pos(axis);
        MOV      R0,R4
          CFI FunCall _Z12base_min_pos8AxisEnum
        BL       _Z12base_min_pos8AxisEnum
        VSTR     S0,[R5, #+92]
// 1431       soft_endstop_max[axis] = base_max_pos(axis);
        MOV      R0,R4
          CFI FunCall _Z12base_max_pos8AxisEnum
        BL       _Z12base_max_pos8AxisEnum
        VSTR     S0,[R5, #+104]
// 1432     #endif
// 1433 
// 1434     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1435       if (DEBUGGING(LEVELING)) {
// 1436         SERIAL_ECHOPAIR("For ", axis_codes[axis]);
// 1437         #if HAS_HOME_OFFSET
// 1438           SERIAL_ECHOPAIR(" axis:\n home_offset = ", home_offset[axis]);
// 1439         #endif
// 1440         #if HAS_POSITION_SHIFT
// 1441           SERIAL_ECHOPAIR("\n position_shift = ", position_shift[axis]);
// 1442         #endif
// 1443         SERIAL_ECHOPAIR("\n soft_endstop_min = ", soft_endstop_min[axis]);
// 1444         SERIAL_ECHOLNPAIR("\n soft_endstop_max = ", soft_endstop_max[axis]);
// 1445       }
// 1446     #endif
// 1447 
// 1448     #if ENABLED(DELTA)
// 1449       switch(axis) {
// 1450         case X_AXIS:
// 1451         case Y_AXIS:
// 1452           // Get a minimum radius for clamping
// 1453           soft_endstop_radius = MIN3(FABS(max(soft_endstop_min[X_AXIS], soft_endstop_min[Y_AXIS])), soft_endstop_max[X_AXIS], soft_endstop_max[Y_AXIS]);
// 1454           soft_endstop_radius_2 = sq(soft_endstop_radius);
// 1455           break;
// 1456         case Z_AXIS:
// 1457           delta_clip_start_height = soft_endstop_max[axis] - delta_safe_distance_from_top();
// 1458         default: break;
// 1459       }
// 1460     #endif
// 1461   }
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock22
// 1462 
// 1463 #endif // HAS_WORKSPACE_OFFSET || DUAL_X_CARRIAGE
// 1464 
// 1465 #if HAS_M206_COMMAND
// 1466   /**
// 1467    * Change the home offset for an axis, update the current
// 1468    * position and the software endstops to retain the same
// 1469    * relative distance to the new home.
// 1470    *
// 1471    * Since this changes the current_position, code should
// 1472    * call sync_plan_position soon after this.
// 1473    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock23 Using cfiCommon0
          CFI Function _Z15set_home_offset8AxisEnumf
        THUMB
// 1474   static void set_home_offset(const AxisEnum axis, const float v) {
// 1475     home_offset[axis] = v;
_Z15set_home_offset8AxisEnumf:
        LDR.W    R1,??DataTable92_9
        ADD      R1,R1,R0, LSL #+2
        VSTR     S0,[R1, #+80]
// 1476     update_software_endstops(axis);
          CFI FunCall _Z24update_software_endstops8AxisEnum
        B.N      _Z24update_software_endstops8AxisEnum
          CFI EndBlock cfiBlock23
// 1477   }
// 1478 #endif // HAS_M206_COMMAND
// 1479 
// 1480 /**
// 1481  * Set an axis' current position to its home position (after homing).
// 1482  *
// 1483  * For Core and Cartesian robots this applies one-to-one when an
// 1484  * individual axis has been homed.
// 1485  *
// 1486  * DELTA should wait until all homing is done before setting the XYZ
// 1487  * current_position to home, because homing is a single operation.
// 1488  * In the case where the axis positions are already known and previously
// 1489  * homed, DELTA could home to X or Y individually by moving either one
// 1490  * to the center. However, homing Z always homes XY and Z.
// 1491  *
// 1492  * SCARA should wait until all XY homing is done before setting the XY
// 1493  * current_position to home, because neither X nor Y is at home until
// 1494  * both are at home. Z can however be homed individually.
// 1495  *
// 1496  * Callers must sync the planner position after calling this!
// 1497  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock24 Using cfiCommon0
          CFI Function _Z19set_axis_is_at_home8AxisEnum
        THUMB
// 1498 static void set_axis_is_at_home(const AxisEnum axis) {
_Z19set_axis_is_at_home8AxisEnum:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R4,R0
// 1499   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1500     if (DEBUGGING(LEVELING)) {
// 1501       SERIAL_ECHOPAIR(">>> set_axis_is_at_home(", axis_codes[axis]);
// 1502       SERIAL_CHAR(')');
// 1503       SERIAL_EOL();
// 1504     }
// 1505   #endif
// 1506 
// 1507   axis_known_position[axis] = axis_homed[axis] = true;
        LDR.W    R5,??DataTable92_9
        ADDS     R0,R4,R5
        MOVS     R1,#+1
        STRB     R1,[R0, #+4]
        STRB     R1,[R0, #+8]
// 1508 
// 1509   #if HAS_POSITION_SHIFT
// 1510     position_shift[axis] = 0;
        ADD      R6,R5,R4, LSL #+2
        MOVS     R0,#+0
        STR      R0,[R6, #+128]
// 1511     update_software_endstops(axis);
        MOV      R0,R4
          CFI FunCall _Z24update_software_endstops8AxisEnum
        BL       _Z24update_software_endstops8AxisEnum
// 1512   #endif
// 1513 
// 1514   #if ENABLED(DUAL_X_CARRIAGE)
// 1515     if (axis == X_AXIS && (active_extruder == 1 || dual_x_carriage_mode == DXC_DUPLICATION_MODE)) {
// 1516       current_position[X_AXIS] = x_home_pos(active_extruder);
// 1517       return;
// 1518     }
// 1519   #endif
// 1520 
// 1521   #if ENABLED(MORGAN_SCARA)
// 1522 
// 1523     /**
// 1524      * Morgan SCARA homes XY at the same time
// 1525      */
// 1526     if (axis == X_AXIS || axis == Y_AXIS) {
// 1527 
// 1528       float homeposition[XYZ] = {
// 1529         base_home_pos(X_AXIS),
// 1530         base_home_pos(Y_AXIS),
// 1531         base_home_pos(Z_AXIS)
// 1532       };
// 1533 
// 1534       // SERIAL_ECHOPAIR("homeposition X:", homeposition[X_AXIS]);
// 1535       // SERIAL_ECHOLNPAIR(" Y:", homeposition[Y_AXIS]);
// 1536 
// 1537       /**
// 1538        * Get Home position SCARA arm angles using inverse kinematics,
// 1539        * and calculate homing offset using forward kinematics
// 1540        */
// 1541       inverse_kinematics(homeposition);
// 1542       forward_kinematics_SCARA(delta[A_AXIS], delta[B_AXIS]);
// 1543 
// 1544       // SERIAL_ECHOPAIR("Cartesian X:", cartes[X_AXIS]);
// 1545       // SERIAL_ECHOLNPAIR(" Y:", cartes[Y_AXIS]);
// 1546 
// 1547       current_position[axis] = cartes[axis];
// 1548 
// 1549       /**
// 1550        * SCARA home positions are based on configuration since the actual
// 1551        * limits are determined by the inverse kinematic transform.
// 1552        */
// 1553       soft_endstop_min[axis] = base_min_pos(axis); // + (cartes[axis] - base_home_pos(axis));
// 1554       soft_endstop_max[axis] = base_max_pos(axis); // + (cartes[axis] - base_home_pos(axis));
// 1555     }
// 1556     else
// 1557   #elif ENABLED(DELTA)
// 1558     if (axis == Z_AXIS)
// 1559       current_position[axis] = delta_height;
// 1560     else
// 1561   #endif
// 1562   {
// 1563     current_position[axis] = base_home_pos(axis);
        MOV      R0,R4
          CFI FunCall _Z13base_home_pos8AxisEnum
        BL       _Z13base_home_pos8AxisEnum
        VSTR     S0,[R6, #+32]
// 1564     current_position[C_AXIS] = home_offset[C_AXIS];   //mks_dlp 
        LDR      R0,[R5, #+88]
        STR      R0,[R5, #+40]
// 1565   }
// 1566 
// 1567   /**
// 1568    * Z Probe Z Homing? Account for the probe's Z offset.
// 1569    */
// 1570   //#if HAS_BED_PROBE && Z_HOME_DIR < 0
// 1571 #if 0
// 1572     if (axis == Z_AXIS) {
// 1573       #if HOMING_Z_WITH_PROBE
// 1574 
// 1575         current_position[Z_AXIS] -= zprobe_zoffset;
// 1576 
// 1577         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1578           if (DEBUGGING(LEVELING)) {
// 1579             SERIAL_ECHOLNPGM("*** Z HOMED WITH PROBE (Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN) ***");
// 1580             SERIAL_ECHOLNPAIR("> zprobe_zoffset = ", zprobe_zoffset);
// 1581           }
// 1582         #endif
// 1583 
// 1584       #elif ENABLED(DEBUG_LEVELING_FEATURE)
// 1585 
// 1586         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("*** Z HOMED TO ENDSTOP (Z_MIN_PROBE_ENDSTOP) ***");
// 1587 
// 1588       #endif
// 1589     }
// 1590   #endif
// 1591 
// 1592   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1593     if (DEBUGGING(LEVELING)) {
// 1594       #if HAS_HOME_OFFSET
// 1595         SERIAL_ECHOPAIR("> home_offset[", axis_codes[axis]);
// 1596         SERIAL_ECHOLNPAIR("] = ", home_offset[axis]);
// 1597       #endif
// 1598       DEBUG_POS("", current_position);
// 1599       SERIAL_ECHOPAIR("<<< set_axis_is_at_home(", axis_codes[axis]);
// 1600       SERIAL_CHAR(')');
// 1601       SERIAL_EOL();
// 1602     }
// 1603   #endif
// 1604 
// 1605   #if ENABLED(I2C_POSITION_ENCODERS)
// 1606     I2CPEM.homed(axis);
// 1607   #endif
// 1608 }
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock24
// 1609 
// 1610 /**
// 1611  * Some planner shorthand inline functions
// 1612  */
// 1613 inline float get_homing_bump_feedrate(const AxisEnum axis) {
// 1614   //static const uint8_t homing_bump_divisor[] PROGMEM = HOMING_BUMP_DIVISOR;
// 1615 	int  homing_bump_divisor[4];
// 1616 		homing_bump_divisor[0] = 2;
// 1617 		homing_bump_divisor[1] = 2;
// 1618 		homing_bump_divisor[2] = 4;
// 1619   uint8_t hbd = pgm_read_byte(&homing_bump_divisor[axis]);
// 1620   if (hbd < 1) {
// 1621     hbd = 10;
// 1622     SERIAL_ECHO_START();
// 1623     SERIAL_ECHOLNPGM("Warning: Homing Bump Divisor < 1");
// 1624   }
// 1625   //return homing_feedrate(axis) / hbd;
// 1626   return homing_feedrate_mm_s[axis] / hbd;
// 1627 }
// 1628 
// 1629 /**
// 1630  * Move the planner to the current position from wherever it last moved
// 1631  * (or from wherever it has been told it is located).
// 1632  */
// 1633 inline void buffer_line_to_current_position() {
// 1634   planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], feedrate_mm_s, active_extruder);
// 1635 }
// 1636 
// 1637 /**
// 1638  * Move the planner to the position stored in the destination array, which is
// 1639  * used by G0/G1/G2/G3/G5 and many other functions to set a destination.
// 1640  */
// 1641 inline void buffer_line_to_destination(const float fr_mm_s) {
// 1642   planner.buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], fr_mm_s, active_extruder);
// 1643 }
// 1644 
// 1645 #if IS_KINEMATIC
// 1646   /**
// 1647    * Calculate delta, start a line, and set current_position to destination
// 1648    */
// 1649   void prepare_uninterpolated_move_to_destination(const float fr_mm_s=0.0) {
// 1650     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1651       if (DEBUGGING(LEVELING)) DEBUG_POS("prepare_uninterpolated_move_to_destination", destination);
// 1652     #endif
// 1653 
// 1654     refresh_cmd_timeout();
// 1655 
// 1656     #if UBL_SEGMENTED
// 1657       // ubl segmented line will do z-only moves in single segment
// 1658       ubl.prepare_segmented_line_to(destination, MMS_SCALED(fr_mm_s ? fr_mm_s : feedrate_mm_s));
// 1659     #else
// 1660       if ( current_position[X_AXIS] == destination[X_AXIS]
// 1661         && current_position[Y_AXIS] == destination[Y_AXIS]
// 1662         && current_position[Z_AXIS] == destination[Z_AXIS]
// 1663         && current_position[E_AXIS] == destination[E_AXIS]
// 1664       ) return;
// 1665 
// 1666       planner.buffer_line_kinematic(destination, MMS_SCALED(fr_mm_s ? fr_mm_s : feedrate_mm_s), active_extruder);
// 1667     #endif
// 1668 
// 1669     set_current_from_destination();
// 1670   }
// 1671 #endif // IS_KINEMATIC
// 1672 
// 1673 /**
// 1674  *  Plan a move to (X, Y, Z) and set the current_position
// 1675  *  The final current_position may not be the one that was requested
// 1676  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock25 Using cfiCommon0
          CFI Function _Z19do_blocking_move_toRKfS0_S0_S0_
        THUMB
// 1677 void do_blocking_move_to(const float &rx, const float &ry, const float &rz, const float &fr_mm_s/*=0.0*/) {
_Z19do_blocking_move_toRKfS0_S0_S0_:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        VPUSH    {D8}
          CFI D8 Frame(CFA, -32)
          CFI CFA R13+32
        MOV      R6,R0
        MOV      R7,R1
        MOV      R4,R2
        MOV      R8,R3
// 1678   const float old_feedrate_mm_s = feedrate_mm_s;
        LDR.W    R5,??DataTable92_9
        VLDR     S16,[R5, #+120]
// 1679 
// 1680   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1681     if (DEBUGGING(LEVELING)) print_xyz(PSTR(">>> do_blocking_move_to"), NULL, LOGICAL_X_POSITION(rx), LOGICAL_Y_POSITION(ry), LOGICAL_Z_POSITION(rz));
// 1682   #endif
// 1683 
// 1684   const float z_feedrate = fr_mm_s ? fr_mm_s : homing_feedrate_mm_s[Z_AXIS];
        VLDR     S17,[R8, #0]
        VCMP.F32 S17,#0.0
        FMSTAT   
        BNE.N    ??do_blocking_move_to_0
        VLDR     S17,[R5, #+72]
// 1685 
// 1686   #if ENABLED(DELTA)
// 1687     if (!position_is_reachable(rx, ry)) return;
// 1688 
// 1689     feedrate_mm_s = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
// 1690 
// 1691     set_destination_from_current();          // sync destination at the start
// 1692 
// 1693     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1694       if (DEBUGGING(LEVELING)) DEBUG_POS("set_destination_from_current", destination);
// 1695     #endif
// 1696 
// 1697     // when in the danger zone
// 1698     if (current_position[Z_AXIS] > delta_clip_start_height) {
// 1699       if (rz > delta_clip_start_height) {   // staying in the danger zone
// 1700         destination[X_AXIS] = rx;           // move directly (uninterpolated)
// 1701         destination[Y_AXIS] = ry;
// 1702         destination[Z_AXIS] = rz;
// 1703         prepare_uninterpolated_move_to_destination(); // set_current_from_destination
// 1704         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1705           if (DEBUGGING(LEVELING)) DEBUG_POS("danger zone move", current_position);
// 1706         #endif
// 1707         return;
// 1708       }
// 1709       destination[Z_AXIS] = delta_clip_start_height;
// 1710       prepare_uninterpolated_move_to_destination(); // set_current_from_destination
// 1711       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1712         if (DEBUGGING(LEVELING)) DEBUG_POS("zone border move", current_position);
// 1713       #endif
// 1714     }
// 1715 
// 1716     if (rz > current_position[Z_AXIS]) {    // raising?
// 1717       destination[Z_AXIS] = rz;
// 1718       prepare_uninterpolated_move_to_destination(z_feedrate);   // set_current_from_destination
// 1719       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1720         if (DEBUGGING(LEVELING)) DEBUG_POS("z raise move", current_position);
// 1721       #endif
// 1722     }
// 1723 
// 1724     destination[X_AXIS] = rx;
// 1725     destination[Y_AXIS] = ry;
// 1726     prepare_move_to_destination();         // set_current_from_destination
// 1727     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1728       if (DEBUGGING(LEVELING)) DEBUG_POS("xy move", current_position);
// 1729     #endif
// 1730 
// 1731     if (rz < current_position[Z_AXIS]) {    // lowering?
// 1732       destination[Z_AXIS] = rz;
// 1733       prepare_uninterpolated_move_to_destination(z_feedrate);   // set_current_from_destination
// 1734       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1735         if (DEBUGGING(LEVELING)) DEBUG_POS("z lower move", current_position);
// 1736       #endif
// 1737     }
// 1738 
// 1739   #elif IS_SCARA
// 1740 
// 1741     if (!position_is_reachable(rx, ry)) return;
// 1742 
// 1743     set_destination_from_current();
// 1744 
// 1745     // If Z needs to raise, do it before moving XY
// 1746     if (destination[Z_AXIS] < rz) {
// 1747       destination[Z_AXIS] = rz;
// 1748       prepare_uninterpolated_move_to_destination(z_feedrate);
// 1749     }
// 1750 
// 1751     destination[X_AXIS] = rx;
// 1752     destination[Y_AXIS] = ry;
// 1753     prepare_uninterpolated_move_to_destination(fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S);
// 1754 
// 1755     // If Z needs to lower, do it after moving XY
// 1756     if (destination[Z_AXIS] > rz) {
// 1757       destination[Z_AXIS] = rz;
// 1758       prepare_uninterpolated_move_to_destination(z_feedrate);
// 1759     }
// 1760 
// 1761   #else
// 1762 
// 1763     // If Z needs to raise, do it before moving XY
// 1764     if (current_position[Z_AXIS] < rz) {
??do_blocking_move_to_0:
        VLDR     S0,[R5, #+40]
        VLDR     S1,[R4, #0]
        VCMP.F32 S0,S1
        FMSTAT   
        BPL.N    ??do_blocking_move_to_1
// 1765       feedrate_mm_s = z_feedrate;
        VSTR     S17,[R5, #+120]
// 1766       current_position[Z_AXIS] = rz;
        LDR      R0,[R4, #+0]
        STR      R0,[R5, #+40]
// 1767       buffer_line_to_current_position();
          CFI FunCall _Z31buffer_line_to_current_positionv
        BL       _Z31buffer_line_to_current_positionv
// 1768     }
// 1769 
// 1770     feedrate_mm_s = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
??do_blocking_move_to_1:
        VLDR     S0,[R8, #0]
        VCMP.F32 S0,#0.0
        FMSTAT   
        BEQ.N    ??do_blocking_move_to_2
        VSTR     S0,[R5, #+120]
        B.N      ??do_blocking_move_to_3
??do_blocking_move_to_2:
        LDR.W    R0,??DataTable99_1  ;; 0x43055555
        STR      R0,[R5, #+120]
// 1771     current_position[X_AXIS] = rx;
??do_blocking_move_to_3:
        LDR      R0,[R6, #+0]
        STR      R0,[R5, #+32]
// 1772     current_position[Y_AXIS] = ry;
        LDR      R0,[R7, #+0]
        STR      R0,[R5, #+36]
// 1773     buffer_line_to_current_position();
          CFI FunCall _Z31buffer_line_to_current_positionv
        BL       _Z31buffer_line_to_current_positionv
// 1774 
// 1775     // If Z needs to lower, do it after moving XY
// 1776     if (current_position[Z_AXIS] > rz) {
        VLDR     S0,[R4, #0]
        VLDR     S1,[R5, #+40]
        VCMP.F32 S0,S1
        FMSTAT   
        BPL.N    ??do_blocking_move_to_4
// 1777       feedrate_mm_s = z_feedrate;
        VSTR     S17,[R5, #+120]
// 1778       current_position[Z_AXIS] = rz;
        LDR      R0,[R4, #+0]
        STR      R0,[R5, #+40]
// 1779       buffer_line_to_current_position();
          CFI FunCall _Z31buffer_line_to_current_positionv
        BL       _Z31buffer_line_to_current_positionv
// 1780     }
// 1781 
// 1782   #endif
// 1783 
// 1784   stepper.synchronize();
??do_blocking_move_to_4:
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
// 1785 
// 1786   feedrate_mm_s = old_feedrate_mm_s;
        VSTR     S16,[R5, #+120]
// 1787 
// 1788   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1789     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< do_blocking_move_to");
// 1790   #endif
// 1791 }
        VPOP     {D8}
          CFI D8 SameValue
          CFI CFA R13+24
        POP      {R4-R8,PC}       ;; return
          CFI EndBlock cfiBlock25

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable76:
        DC32     0x43480000
// 1792 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock26 Using cfiCommon0
          CFI Function _Z26do_blocking_move_to_nowaitRKfS0_S0_S0_
        THUMB
// 1793 void do_blocking_move_to_nowait(const float &rx, const float &ry, const float &rz, const float &fr_mm_s/*=0.0*/) {
_Z26do_blocking_move_to_nowaitRKfS0_S0_S0_:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        VPUSH    {D8}
          CFI D8 Frame(CFA, -32)
          CFI CFA R13+32
        MOV      R6,R0
        MOV      R7,R1
        MOV      R4,R2
        MOV      R8,R3
// 1794   const float old_feedrate_mm_s = feedrate_mm_s;
        LDR.W    R5,??DataTable92_9
        VLDR     S16,[R5, #+120]
// 1795 
// 1796   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1797     if (DEBUGGING(LEVELING)) print_xyz(PSTR(">>> do_blocking_move_to"), NULL, LOGICAL_X_POSITION(rx), LOGICAL_Y_POSITION(ry), LOGICAL_Z_POSITION(rz));
// 1798   #endif
// 1799 
// 1800   const float z_feedrate = fr_mm_s ? fr_mm_s : homing_feedrate_mm_s[Z_AXIS];
        VLDR     S17,[R8, #0]
        VCMP.F32 S17,#0.0
        FMSTAT   
        BNE.N    ??do_blocking_move_to_nowait_0
        VLDR     S17,[R5, #+72]
// 1801 
// 1802   #if ENABLED(DELTA)
// 1803     if (!position_is_reachable(rx, ry)) return;
// 1804 
// 1805     feedrate_mm_s = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
// 1806 
// 1807     set_destination_from_current();          // sync destination at the start
// 1808 
// 1809     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1810       if (DEBUGGING(LEVELING)) DEBUG_POS("set_destination_from_current", destination);
// 1811     #endif
// 1812 
// 1813     // when in the danger zone
// 1814     if (current_position[Z_AXIS] > delta_clip_start_height) {
// 1815       if (rz > delta_clip_start_height) {   // staying in the danger zone
// 1816         destination[X_AXIS] = rx;           // move directly (uninterpolated)
// 1817         destination[Y_AXIS] = ry;
// 1818         destination[Z_AXIS] = rz;
// 1819         prepare_uninterpolated_move_to_destination(); // set_current_from_destination
// 1820         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1821           if (DEBUGGING(LEVELING)) DEBUG_POS("danger zone move", current_position);
// 1822         #endif
// 1823         return;
// 1824       }
// 1825       destination[Z_AXIS] = delta_clip_start_height;
// 1826       prepare_uninterpolated_move_to_destination(); // set_current_from_destination
// 1827       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1828         if (DEBUGGING(LEVELING)) DEBUG_POS("zone border move", current_position);
// 1829       #endif
// 1830     }
// 1831 
// 1832     if (rz > current_position[Z_AXIS]) {    // raising?
// 1833       destination[Z_AXIS] = rz;
// 1834       prepare_uninterpolated_move_to_destination(z_feedrate);   // set_current_from_destination
// 1835       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1836         if (DEBUGGING(LEVELING)) DEBUG_POS("z raise move", current_position);
// 1837       #endif
// 1838     }
// 1839 
// 1840     destination[X_AXIS] = rx;
// 1841     destination[Y_AXIS] = ry;
// 1842     prepare_move_to_destination();         // set_current_from_destination
// 1843     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1844       if (DEBUGGING(LEVELING)) DEBUG_POS("xy move", current_position);
// 1845     #endif
// 1846 
// 1847     if (rz < current_position[Z_AXIS]) {    // lowering?
// 1848       destination[Z_AXIS] = rz;
// 1849       prepare_uninterpolated_move_to_destination(z_feedrate);   // set_current_from_destination
// 1850       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1851         if (DEBUGGING(LEVELING)) DEBUG_POS("z lower move", current_position);
// 1852       #endif
// 1853     }
// 1854 
// 1855   #elif IS_SCARA
// 1856 
// 1857     if (!position_is_reachable(rx, ry)) return;
// 1858 
// 1859     set_destination_from_current();
// 1860 
// 1861     // If Z needs to raise, do it before moving XY
// 1862     if (destination[Z_AXIS] < rz) {
// 1863       destination[Z_AXIS] = rz;
// 1864       prepare_uninterpolated_move_to_destination(z_feedrate);
// 1865     }
// 1866 
// 1867     destination[X_AXIS] = rx;
// 1868     destination[Y_AXIS] = ry;
// 1869     prepare_uninterpolated_move_to_destination(fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S);
// 1870 
// 1871     // If Z needs to lower, do it after moving XY
// 1872     if (destination[Z_AXIS] > rz) {
// 1873       destination[Z_AXIS] = rz;
// 1874       prepare_uninterpolated_move_to_destination(z_feedrate);
// 1875     }
// 1876 
// 1877   #else
// 1878 
// 1879     // If Z needs to raise, do it before moving XY
// 1880     if (current_position[Z_AXIS] < rz) {
??do_blocking_move_to_nowait_0:
        VLDR     S0,[R5, #+40]
        VLDR     S1,[R4, #0]
        VCMP.F32 S0,S1
        FMSTAT   
        BPL.N    ??do_blocking_move_to_nowait_1
// 1881       feedrate_mm_s = z_feedrate;
        VSTR     S17,[R5, #+120]
// 1882       current_position[Z_AXIS] = rz;
        LDR      R0,[R4, #+0]
        STR      R0,[R5, #+40]
// 1883       buffer_line_to_current_position();
          CFI FunCall _Z31buffer_line_to_current_positionv
        BL       _Z31buffer_line_to_current_positionv
// 1884     }
// 1885 
// 1886     feedrate_mm_s = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
??do_blocking_move_to_nowait_1:
        VLDR     S0,[R8, #0]
        VCMP.F32 S0,#0.0
        FMSTAT   
        BEQ.N    ??do_blocking_move_to_nowait_2
        VSTR     S0,[R5, #+120]
        B.N      ??do_blocking_move_to_nowait_3
??do_blocking_move_to_nowait_2:
        LDR.W    R0,??DataTable99_1  ;; 0x43055555
        STR      R0,[R5, #+120]
// 1887     current_position[X_AXIS] = rx;
??do_blocking_move_to_nowait_3:
        LDR      R0,[R6, #+0]
        STR      R0,[R5, #+32]
// 1888     current_position[Y_AXIS] = ry;
        LDR      R0,[R7, #+0]
        STR      R0,[R5, #+36]
// 1889     buffer_line_to_current_position();
          CFI FunCall _Z31buffer_line_to_current_positionv
        BL       _Z31buffer_line_to_current_positionv
// 1890 
// 1891     // If Z needs to lower, do it after moving XY
// 1892     if (current_position[Z_AXIS] > rz) {
        VLDR     S0,[R4, #0]
        VLDR     S1,[R5, #+40]
        VCMP.F32 S0,S1
        FMSTAT   
        BPL.N    ??do_blocking_move_to_nowait_4
// 1893       feedrate_mm_s = z_feedrate;
        VSTR     S17,[R5, #+120]
// 1894       current_position[Z_AXIS] = rz;
        LDR      R0,[R4, #+0]
        STR      R0,[R5, #+40]
// 1895       buffer_line_to_current_position();
          CFI FunCall _Z31buffer_line_to_current_positionv
        BL       _Z31buffer_line_to_current_positionv
// 1896     }
// 1897 
// 1898   #endif
// 1899 
// 1900 //  stepper.synchronize();
// 1901 
// 1902   feedrate_mm_s = old_feedrate_mm_s;
??do_blocking_move_to_nowait_4:
        VSTR     S16,[R5, #+120]
// 1903 
// 1904   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1905     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< do_blocking_move_to");
// 1906   #endif
// 1907 }
        VPOP     {D8}
          CFI D8 SameValue
          CFI CFA R13+24
        POP      {R4-R8,PC}       ;; return
          CFI EndBlock cfiBlock26
// 1908 
// 1909 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock27 Using cfiCommon0
          CFI Function _Z21do_blocking_move_to_xRKfS0_
        THUMB
// 1910 void do_blocking_move_to_x(const float &rx, const float &fr_mm_s/*=0.0*/) {
_Z21do_blocking_move_to_xRKfS0_:
        PUSH     {R3,R4}
          CFI R4 Frame(CFA, -4)
          CFI CFA R13+8
// 1911   do_blocking_move_to(rx, current_position[Y_AXIS], current_position[Z_AXIS], fr_mm_s);
        LDR.W    R4,??DataTable92_9
        MOV      R3,R1
        ADD      R2,R4,#+40
        ADD      R1,R4,#+36
        ADD      SP,SP,#+4
          CFI CFA R13+4
        POP      {R4}
          CFI R4 SameValue
          CFI CFA R13+0
          CFI FunCall _Z19do_blocking_move_toRKfS0_S0_S0_
        B.N      _Z19do_blocking_move_toRKfS0_S0_S0_
          CFI EndBlock cfiBlock27
// 1912 }

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock28 Using cfiCommon0
          CFI Function _Z21do_blocking_move_to_zRKfS0_
        THUMB
// 1913 void do_blocking_move_to_z(const float &rz, const float &fr_mm_s/*=0.0*/) {
_Z21do_blocking_move_to_zRKfS0_:
        PUSH     {R3,R4}
          CFI R4 Frame(CFA, -4)
          CFI CFA R13+8
// 1914   do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], rz, fr_mm_s);
        LDR.W    R4,??DataTable92_9
        MOV      R3,R1
        MOV      R2,R0
        ADD      R1,R4,#+36
        ADD      R0,R4,#+32
        ADD      SP,SP,#+4
          CFI CFA R13+4
        POP      {R4}
          CFI R4 SameValue
          CFI CFA R13+0
          CFI FunCall _Z19do_blocking_move_toRKfS0_S0_S0_
        B.N      _Z19do_blocking_move_toRKfS0_S0_S0_
          CFI EndBlock cfiBlock28
// 1915 }

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock29 Using cfiCommon0
          CFI Function _Z28do_blocking_move_to_z_nowaitRKfS0_
        THUMB
// 1916 void do_blocking_move_to_z_nowait(const float &rz, const float &fr_mm_s/*=0.0*/) {
_Z28do_blocking_move_to_z_nowaitRKfS0_:
        PUSH     {R3,R4}
          CFI R4 Frame(CFA, -4)
          CFI CFA R13+8
// 1917   do_blocking_move_to_nowait(current_position[X_AXIS], current_position[Y_AXIS], rz, fr_mm_s);
        LDR.W    R4,??DataTable92_9
        MOV      R3,R1
        MOV      R2,R0
        ADD      R1,R4,#+36
        ADD      R0,R4,#+32
        ADD      SP,SP,#+4
          CFI CFA R13+4
        POP      {R4}
          CFI R4 SameValue
          CFI CFA R13+0
          CFI FunCall _Z26do_blocking_move_to_nowaitRKfS0_S0_S0_
        B.N      _Z26do_blocking_move_to_nowaitRKfS0_S0_S0_
          CFI EndBlock cfiBlock29
// 1918 }
// 1919 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock30 Using cfiCommon0
          CFI Function _Z22do_blocking_move_to_xyRKfS0_S0_
        THUMB
// 1920 void do_blocking_move_to_xy(const float &rx, const float &ry, const float &fr_mm_s/*=0.0*/) {
// 1921   do_blocking_move_to(rx, ry, current_position[Z_AXIS], fr_mm_s);
_Z22do_blocking_move_to_xyRKfS0_S0_:
        MOV      R3,R2
        LDR.W    R2,??DataTable99_3
          CFI FunCall _Z19do_blocking_move_toRKfS0_S0_S0_
        B.N      _Z19do_blocking_move_toRKfS0_S0_S0_
          CFI EndBlock cfiBlock30
// 1922 }
// 1923 
// 1924 //
// 1925 // Prepare to do endstop or probe moves
// 1926 // with custom feedrates.
// 1927 //
// 1928 //  - Save current feedrates
// 1929 //  - Reset the rate multiplier
// 1930 //  - Reset the command timeout
// 1931 //  - Enable the endstops (for endstop moves)
// 1932 //

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock31 Using cfiCommon0
          CFI Function _Z31setup_for_endstop_or_probe_movev
        THUMB
// 1933 static void setup_for_endstop_or_probe_move() {
// 1934   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1935     if (DEBUGGING(LEVELING)) DEBUG_POS("setup_for_endstop_or_probe_move", current_position);
// 1936   #endif
// 1937   saved_feedrate_mm_s = feedrate_mm_s;
_Z31setup_for_endstop_or_probe_movev:
        LDR.W    R0,??DataTable92_9
        LDR      R1,[R0, #+120]
        STR      R1,[R0, #+124]
// 1938   saved_feedrate_percentage = feedrate_percentage;
        LDRH     R1,[R0, #+28]
        STRH     R1,[R0, #+30]
// 1939   feedrate_percentage = 100;
        MOVS     R1,#+100
        STRH     R1,[R0, #+28]
// 1940   refresh_cmd_timeout();
          CFI FunCall _Z19refresh_cmd_timeoutv
        B.W      _Z19refresh_cmd_timeoutv
          CFI EndBlock cfiBlock31
// 1941 }
// 1942 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock32 Using cfiCommon0
          CFI Function _Z36clean_up_after_endstop_or_probe_movev
        THUMB
// 1943 static void clean_up_after_endstop_or_probe_move() {
// 1944   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1945     if (DEBUGGING(LEVELING)) DEBUG_POS("clean_up_after_endstop_or_probe_move", current_position);
// 1946   #endif
// 1947   feedrate_mm_s = saved_feedrate_mm_s;
_Z36clean_up_after_endstop_or_probe_movev:
        LDR.W    R0,??DataTable92_9
        LDR      R1,[R0, #+124]
        STR      R1,[R0, #+120]
// 1948   feedrate_percentage = saved_feedrate_percentage;
        LDRH     R1,[R0, #+30]
        STRH     R1,[R0, #+28]
// 1949   refresh_cmd_timeout();
          CFI FunCall _Z19refresh_cmd_timeoutv
        B.W      _Z19refresh_cmd_timeoutv
          CFI EndBlock cfiBlock32
// 1950 }
// 1951 
// 1952 #if HAS_BED_PROBE
// 1953   /**
// 1954    * Raise Z to a minimum height to make room for a probe to move
// 1955    */
// 1956   inline void do_probe_raise(const float z_raise) {
// 1957     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1958       if (DEBUGGING(LEVELING)) {
// 1959         SERIAL_ECHOPAIR("do_probe_raise(", z_raise);
// 1960         SERIAL_CHAR(')');
// 1961         SERIAL_EOL();
// 1962       }
// 1963     #endif
// 1964 
// 1965     float z_dest = z_raise;
// 1966     if (zprobe_zoffset < 0) z_dest -= zprobe_zoffset;
// 1967 
// 1968     if (z_dest > current_position[Z_AXIS])
// 1969       do_blocking_move_to_z(z_dest);
// 1970   }
// 1971 
// 1972 #endif // HAS_BED_PROBE
// 1973 
// 1974 #if HAS_AXIS_UNHOMED_ERR
// 1975 #if defined(MKS_DLP_BOARD)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock33 Using cfiCommon0
          CFI Function _Z18axis_unhomed_errorb
        THUMB
// 1976   bool axis_unhomed_error(const bool z/*=true*/) {
_Z18axis_unhomed_errorb:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 1977     #if ENABLED(HOME_AFTER_DEACTIVATE)
// 1978       const bool zz = z && !axis_known_position[Z_AXIS];
// 1979     #else
// 1980       const bool zz = z && !axis_homed[Z_AXIS];
        CMP      R0,#+0
        BEQ.N    ??axis_unhomed_error_0
        LDR.W    R0,??DataTable92_9
        LDRB     R0,[R0, #+6]
        EOR      R4,R0,#0x1
        B.N      ??axis_unhomed_error_1
??axis_unhomed_error_0:
        MOVS     R4,#+0
// 1981     #endif
// 1982     if (zz) {
??axis_unhomed_error_1:
        CMP      R4,#+0
        BEQ.N    ??axis_unhomed_error_2
// 1983       SERIAL_ECHO_START();
        LDR.W    R0,??DataTable95_2
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 1984       SERIAL_ECHOPGM(MSG_HOME " ");
        ADR.W    R0,`?<Constant "Home ">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 1985       if (zz) SERIAL_ECHOPGM(MSG_Z);
        CMP      R4,#+0
        BEQ.N    ??axis_unhomed_error_3
        ADR.N    R0,??DataTable91  ;; "Z"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 1986       SERIAL_ECHOLNPGM(" " MSG_FIRST);
??axis_unhomed_error_3:
        ADR.W    R0,`?<Constant " first\\n">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 1987 
// 1988       #if ENABLED(ULTRA_LCD)
// 1989         lcd_status_printf_P(0, PSTR(MSG_HOME " %s%s%s " MSG_FIRST), xx ? MSG_X : "", yy ? MSG_Y : "", zz ? MSG_Z : "");
// 1990       #endif
// 1991       return true;
        MOVS     R0,#+1
        POP      {R4,PC}
// 1992     }
// 1993     return false;
??axis_unhomed_error_2:
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock33
// 1994   }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Home ">`:
        DC8 "Home "
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant " first\\n">`:
        DC8 " first\012"
// 1995 #else
// 1996 bool axis_unhomed_error(const bool x/*=true*/, const bool y/*=true*/, const bool z/*=true*/) {
// 1997   #if ENABLED(HOME_AFTER_DEACTIVATE)
// 1998 	const bool xx = x && !axis_known_position[X_AXIS],
// 1999 			   yy = y && !axis_known_position[Y_AXIS],
// 2000 			   zz = z && !axis_known_position[Z_AXIS];
// 2001   #else
// 2002 	const bool xx = x && !axis_homed[X_AXIS],
// 2003 			   yy = y && !axis_homed[Y_AXIS],
// 2004 			   zz = z && !axis_homed[Z_AXIS];
// 2005   #endif
// 2006   if (xx || yy || zz) {
// 2007 	SERIAL_ECHO_START();
// 2008 	SERIAL_ECHOPGM(MSG_HOME " ");
// 2009 	if (xx) SERIAL_ECHOPGM(MSG_X);
// 2010 	if (yy) SERIAL_ECHOPGM(MSG_Y);
// 2011 	if (zz) SERIAL_ECHOPGM(MSG_Z);
// 2012 	SERIAL_ECHOLNPGM(" " MSG_FIRST);
// 2013 
// 2014 	#if ENABLED(ULTRA_LCD)
// 2015 	  lcd_status_printf_P(0, PSTR(MSG_HOME " %s%s%s " MSG_FIRST), xx ? MSG_X : "", yy ? MSG_Y : "", zz ? MSG_Z : "");
// 2016 	#endif
// 2017 	return true;
// 2018   }
// 2019   return false;
// 2020 }
// 2021 
// 2022 #endif
// 2023 #endif // HAS_AXIS_UNHOMED_ERR
// 2024 
// 2025 #if ENABLED(Z_PROBE_SLED)
// 2026 
// 2027   #ifndef SLED_DOCKING_OFFSET
// 2028     #define SLED_DOCKING_OFFSET 0
// 2029   #endif
// 2030 
// 2031   /**
// 2032    * Method to dock/undock a sled designed by Charles Bell.
// 2033    *
// 2034    * stow[in]     If false, move to MAX_X and engage the solenoid
// 2035    *              If true, move to MAX_X and release the solenoid
// 2036    */
// 2037   static void dock_sled(bool stow) {
// 2038     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2039       if (DEBUGGING(LEVELING)) {
// 2040         SERIAL_ECHOPAIR("dock_sled(", stow);
// 2041         SERIAL_CHAR(')');
// 2042         SERIAL_EOL();
// 2043       }
// 2044     #endif
// 2045 
// 2046     // Dock sled a bit closer to ensure proper capturing
// 2047     do_blocking_move_to_x(X_MAX_POS + SLED_DOCKING_OFFSET - ((stow) ? 1 : 0));
// 2048 
// 2049     #if HAS_SOLENOID_1 && DISABLED(EXT_SOLENOID)
// 2050       WRITE(SOL1_PIN, !stow); // switch solenoid
// 2051     #endif
// 2052   }
// 2053 
// 2054 #elif ENABLED(Z_PROBE_ALLEN_KEY)
// 2055 
// 2056   FORCE_INLINE void do_blocking_move_to(const float (&raw)[XYZ], const float &fr_mm_s) {
// 2057     do_blocking_move_to(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], fr_mm_s);
// 2058   }
// 2059 
// 2060   void run_deploy_moves_script() {
// 2061     #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_Z)
// 2062       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_X
// 2063         #define Z_PROBE_ALLEN_KEY_DEPLOY_1_X current_position[X_AXIS]
// 2064       #endif
// 2065       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_Y
// 2066         #define Z_PROBE_ALLEN_KEY_DEPLOY_1_Y current_position[Y_AXIS]
// 2067       #endif
// 2068       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_Z
// 2069         #define Z_PROBE_ALLEN_KEY_DEPLOY_1_Z current_position[Z_AXIS]
// 2070       #endif
// 2071       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE
// 2072         #define Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE 0.0
// 2073       #endif
// 2074       const float deploy_1[] = { Z_PROBE_ALLEN_KEY_DEPLOY_1_X, Z_PROBE_ALLEN_KEY_DEPLOY_1_Y, Z_PROBE_ALLEN_KEY_DEPLOY_1_Z };
// 2075       do_blocking_move_to(deploy_1, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE));
// 2076     #endif
// 2077     #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_Z)
// 2078       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_X
// 2079         #define Z_PROBE_ALLEN_KEY_DEPLOY_2_X current_position[X_AXIS]
// 2080       #endif
// 2081       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_Y
// 2082         #define Z_PROBE_ALLEN_KEY_DEPLOY_2_Y current_position[Y_AXIS]
// 2083       #endif
// 2084       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_Z
// 2085         #define Z_PROBE_ALLEN_KEY_DEPLOY_2_Z current_position[Z_AXIS]
// 2086       #endif
// 2087       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE
// 2088         #define Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE 0.0
// 2089       #endif
// 2090       const float deploy_2[] = { Z_PROBE_ALLEN_KEY_DEPLOY_2_X, Z_PROBE_ALLEN_KEY_DEPLOY_2_Y, Z_PROBE_ALLEN_KEY_DEPLOY_2_Z };
// 2091       do_blocking_move_to(deploy_2, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE));
// 2092     #endif
// 2093     #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_Z)
// 2094       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_X
// 2095         #define Z_PROBE_ALLEN_KEY_DEPLOY_3_X current_position[X_AXIS]
// 2096       #endif
// 2097       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_Y
// 2098         #define Z_PROBE_ALLEN_KEY_DEPLOY_3_Y current_position[Y_AXIS]
// 2099       #endif
// 2100       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_Z
// 2101         #define Z_PROBE_ALLEN_KEY_DEPLOY_3_Z current_position[Z_AXIS]
// 2102       #endif
// 2103       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE
// 2104         #define Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE 0.0
// 2105       #endif
// 2106       const float deploy_3[] = { Z_PROBE_ALLEN_KEY_DEPLOY_3_X, Z_PROBE_ALLEN_KEY_DEPLOY_3_Y, Z_PROBE_ALLEN_KEY_DEPLOY_3_Z };
// 2107       do_blocking_move_to(deploy_3, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE));
// 2108     #endif
// 2109     #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_Z)
// 2110       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_X
// 2111         #define Z_PROBE_ALLEN_KEY_DEPLOY_4_X current_position[X_AXIS]
// 2112       #endif
// 2113       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_Y
// 2114         #define Z_PROBE_ALLEN_KEY_DEPLOY_4_Y current_position[Y_AXIS]
// 2115       #endif
// 2116       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_Z
// 2117         #define Z_PROBE_ALLEN_KEY_DEPLOY_4_Z current_position[Z_AXIS]
// 2118       #endif
// 2119       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE
// 2120         #define Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE 0.0
// 2121       #endif
// 2122       const float deploy_4[] = { Z_PROBE_ALLEN_KEY_DEPLOY_4_X, Z_PROBE_ALLEN_KEY_DEPLOY_4_Y, Z_PROBE_ALLEN_KEY_DEPLOY_4_Z };
// 2123       do_blocking_move_to(deploy_4, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE));
// 2124     #endif
// 2125     #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_Z)
// 2126       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_X
// 2127         #define Z_PROBE_ALLEN_KEY_DEPLOY_5_X current_position[X_AXIS]
// 2128       #endif
// 2129       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_Y
// 2130         #define Z_PROBE_ALLEN_KEY_DEPLOY_5_Y current_position[Y_AXIS]
// 2131       #endif
// 2132       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_Z
// 2133         #define Z_PROBE_ALLEN_KEY_DEPLOY_5_Z current_position[Z_AXIS]
// 2134       #endif
// 2135       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE
// 2136         #define Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE 0.0
// 2137       #endif
// 2138       const float deploy_5[] = { Z_PROBE_ALLEN_KEY_DEPLOY_5_X, Z_PROBE_ALLEN_KEY_DEPLOY_5_Y, Z_PROBE_ALLEN_KEY_DEPLOY_5_Z };
// 2139       do_blocking_move_to(deploy_5, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE));
// 2140     #endif
// 2141   }
// 2142 
// 2143   void run_stow_moves_script() {
// 2144     #if defined(Z_PROBE_ALLEN_KEY_STOW_1_X) || defined(Z_PROBE_ALLEN_KEY_STOW_1_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_1_Z)
// 2145       #ifndef Z_PROBE_ALLEN_KEY_STOW_1_X
// 2146         #define Z_PROBE_ALLEN_KEY_STOW_1_X current_position[X_AXIS]
// 2147       #endif
// 2148       #ifndef Z_PROBE_ALLEN_KEY_STOW_1_Y
// 2149         #define Z_PROBE_ALLEN_KEY_STOW_1_Y current_position[Y_AXIS]
// 2150       #endif
// 2151       #ifndef Z_PROBE_ALLEN_KEY_STOW_1_Z
// 2152         #define Z_PROBE_ALLEN_KEY_STOW_1_Z current_position[Z_AXIS]
// 2153       #endif
// 2154       #ifndef Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE
// 2155         #define Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE 0.0
// 2156       #endif
// 2157       const float stow_1[] = { Z_PROBE_ALLEN_KEY_STOW_1_X, Z_PROBE_ALLEN_KEY_STOW_1_Y, Z_PROBE_ALLEN_KEY_STOW_1_Z };
// 2158       do_blocking_move_to(stow_1, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE));
// 2159     #endif
// 2160     #if defined(Z_PROBE_ALLEN_KEY_STOW_2_X) || defined(Z_PROBE_ALLEN_KEY_STOW_2_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_2_Z)
// 2161       #ifndef Z_PROBE_ALLEN_KEY_STOW_2_X
// 2162         #define Z_PROBE_ALLEN_KEY_STOW_2_X current_position[X_AXIS]
// 2163       #endif
// 2164       #ifndef Z_PROBE_ALLEN_KEY_STOW_2_Y
// 2165         #define Z_PROBE_ALLEN_KEY_STOW_2_Y current_position[Y_AXIS]
// 2166       #endif
// 2167       #ifndef Z_PROBE_ALLEN_KEY_STOW_2_Z
// 2168         #define Z_PROBE_ALLEN_KEY_STOW_2_Z current_position[Z_AXIS]
// 2169       #endif
// 2170       #ifndef Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE
// 2171         #define Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE 0.0
// 2172       #endif
// 2173       const float stow_2[] = { Z_PROBE_ALLEN_KEY_STOW_2_X, Z_PROBE_ALLEN_KEY_STOW_2_Y, Z_PROBE_ALLEN_KEY_STOW_2_Z };
// 2174       do_blocking_move_to(stow_2, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE));
// 2175     #endif
// 2176     #if defined(Z_PROBE_ALLEN_KEY_STOW_3_X) || defined(Z_PROBE_ALLEN_KEY_STOW_3_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_3_Z)
// 2177       #ifndef Z_PROBE_ALLEN_KEY_STOW_3_X
// 2178         #define Z_PROBE_ALLEN_KEY_STOW_3_X current_position[X_AXIS]
// 2179       #endif
// 2180       #ifndef Z_PROBE_ALLEN_KEY_STOW_3_Y
// 2181         #define Z_PROBE_ALLEN_KEY_STOW_3_Y current_position[Y_AXIS]
// 2182       #endif
// 2183       #ifndef Z_PROBE_ALLEN_KEY_STOW_3_Z
// 2184         #define Z_PROBE_ALLEN_KEY_STOW_3_Z current_position[Z_AXIS]
// 2185       #endif
// 2186       #ifndef Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE
// 2187         #define Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE 0.0
// 2188       #endif
// 2189       const float stow_3[] = { Z_PROBE_ALLEN_KEY_STOW_3_X, Z_PROBE_ALLEN_KEY_STOW_3_Y, Z_PROBE_ALLEN_KEY_STOW_3_Z };
// 2190       do_blocking_move_to(stow_3, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE));
// 2191     #endif
// 2192     #if defined(Z_PROBE_ALLEN_KEY_STOW_4_X) || defined(Z_PROBE_ALLEN_KEY_STOW_4_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_4_Z)
// 2193       #ifndef Z_PROBE_ALLEN_KEY_STOW_4_X
// 2194         #define Z_PROBE_ALLEN_KEY_STOW_4_X current_position[X_AXIS]
// 2195       #endif
// 2196       #ifndef Z_PROBE_ALLEN_KEY_STOW_4_Y
// 2197         #define Z_PROBE_ALLEN_KEY_STOW_4_Y current_position[Y_AXIS]
// 2198       #endif
// 2199       #ifndef Z_PROBE_ALLEN_KEY_STOW_4_Z
// 2200         #define Z_PROBE_ALLEN_KEY_STOW_4_Z current_position[Z_AXIS]
// 2201       #endif
// 2202       #ifndef Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE
// 2203         #define Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE 0.0
// 2204       #endif
// 2205       const float stow_4[] = { Z_PROBE_ALLEN_KEY_STOW_4_X, Z_PROBE_ALLEN_KEY_STOW_4_Y, Z_PROBE_ALLEN_KEY_STOW_4_Z };
// 2206       do_blocking_move_to(stow_4, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE));
// 2207     #endif
// 2208     #if defined(Z_PROBE_ALLEN_KEY_STOW_5_X) || defined(Z_PROBE_ALLEN_KEY_STOW_5_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_5_Z)
// 2209       #ifndef Z_PROBE_ALLEN_KEY_STOW_5_X
// 2210         #define Z_PROBE_ALLEN_KEY_STOW_5_X current_position[X_AXIS]
// 2211       #endif
// 2212       #ifndef Z_PROBE_ALLEN_KEY_STOW_5_Y
// 2213         #define Z_PROBE_ALLEN_KEY_STOW_5_Y current_position[Y_AXIS]
// 2214       #endif
// 2215       #ifndef Z_PROBE_ALLEN_KEY_STOW_5_Z
// 2216         #define Z_PROBE_ALLEN_KEY_STOW_5_Z current_position[Z_AXIS]
// 2217       #endif
// 2218       #ifndef Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE
// 2219         #define Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE 0.0
// 2220       #endif
// 2221       const float stow_5[] = { Z_PROBE_ALLEN_KEY_STOW_5_X, Z_PROBE_ALLEN_KEY_STOW_5_Y, Z_PROBE_ALLEN_KEY_STOW_5_Z };
// 2222       do_blocking_move_to(stow_5, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE));
// 2223     #endif
// 2224   }
// 2225 
// 2226 #endif // Z_PROBE_ALLEN_KEY
// 2227 
// 2228 #if ENABLED(PROBING_FANS_OFF)
// 2229 
// 2230   void fans_pause(const bool p) {
// 2231     if (p != fans_paused) {
// 2232       fans_paused = p;
// 2233       if (p)
// 2234         for (uint8_t x = 0; x < FAN_COUNT; x++) {
// 2235           paused_fanSpeeds[x] = fanSpeeds[x];
// 2236           fanSpeeds[x] = 0;
// 2237         }
// 2238       else
// 2239         for (uint8_t x = 0; x < FAN_COUNT; x++)
// 2240           fanSpeeds[x] = paused_fanSpeeds[x];
// 2241     }
// 2242   }
// 2243 
// 2244 #endif // PROBING_FANS_OFF
// 2245 
// 2246 #if HAS_BED_PROBE
// 2247 
// 2248   // TRIGGERED_WHEN_STOWED_TEST can easily be extended to servo probes, ... if needed.
// 2249   #if ENABLED(PROBE_IS_TRIGGERED_WHEN_STOWED_TEST)
// 2250     #if ENABLED(Z_MIN_PROBE_ENDSTOP)
// 2251       #define _TRIGGERED_WHEN_STOWED_TEST (READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)
// 2252     #else
// 2253       #define _TRIGGERED_WHEN_STOWED_TEST (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)
// 2254     #endif
// 2255   #endif
// 2256 
// 2257   #if QUIET_PROBING
// 2258     void probing_pause(const bool p) {
// 2259       #if ENABLED(PROBING_HEATERS_OFF)
// 2260         thermalManager.pause(p);
// 2261       #endif
// 2262       #if ENABLED(PROBING_FANS_OFF)
// 2263         fans_pause(p);
// 2264       #endif
// 2265       if (p) safe_delay(
// 2266         #if DELAY_BEFORE_PROBING > 25
// 2267           DELAY_BEFORE_PROBING
// 2268         #else
// 2269           25
// 2270         #endif
// 2271       );
// 2272     }
// 2273   #endif // QUIET_PROBING
// 2274 
// 2275   #if ENABLED(BLTOUCH)
// 2276 
// 2277     void bltouch_command(int angle) {
// 2278       MOVE_SERVO(Z_ENDSTOP_SERVO_NR, angle);  // Give the BL-Touch the command and wait
// 2279       safe_delay(BLTOUCH_DELAY);
// 2280     }
// 2281 
// 2282     bool set_bltouch_deployed(const bool deploy) {
// 2283       if (deploy && TEST_BLTOUCH()) {      // If BL-Touch says it's triggered
// 2284         bltouch_command(BLTOUCH_RESET);    //  try to reset it.
// 2285         bltouch_command(BLTOUCH_DEPLOY);   // Also needs to deploy and stow to
// 2286         bltouch_command(BLTOUCH_STOW);     //  clear the triggered condition.
// 2287         safe_delay(1500);                  // Wait for internal self-test to complete.
// 2288                                            //  (Measured completion time was 0.65 seconds
// 2289                                            //   after reset, deploy, and stow sequence)
// 2290         if (TEST_BLTOUCH()) {              // If it still claims to be triggered...
// 2291           SERIAL_ERROR_START();
// 2292           SERIAL_ERRORLNPGM(MSG_STOP_BLTOUCH);
// 2293           stop();                          // punt!
// 2294           return true;
// 2295         }
// 2296       }
// 2297 
// 2298       bltouch_command(deploy ? BLTOUCH_DEPLOY : BLTOUCH_STOW);
// 2299 
// 2300       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2301         if (DEBUGGING(LEVELING)) {
// 2302           SERIAL_ECHOPAIR("set_bltouch_deployed(", deploy);
// 2303           SERIAL_CHAR(')');
// 2304           SERIAL_EOL();
// 2305         }
// 2306       #endif
// 2307 
// 2308       return false;
// 2309     }
// 2310 
// 2311   #endif // BLTOUCH
// 2312 
// 2313   // returns false for ok and true for failure
// 2314   bool set_probe_deployed(bool deploy) {
// 2315 
// 2316     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2317       if (DEBUGGING(LEVELING)) {
// 2318         DEBUG_POS("set_probe_deployed", current_position);
// 2319         SERIAL_ECHOLNPAIR("deploy: ", deploy);
// 2320       }
// 2321     #endif
// 2322 
// 2323     if (endstops.z_probe_enabled == deploy) return false;
// 2324 
// 2325     // Make room for probe
// 2326     //do_probe_raise(_Z_CLEARANCE_DEPLOY_PROBE);
// 2327     do_probe_raise(Z_CLEARANCE_DEPLOY_PROBE>Z_CLEARANCE_BETWEEN_PROBES ? Z_CLEARANCE_DEPLOY_PROBE : Z_CLEARANCE_BETWEEN_PROBES);
// 2328 
// 2329     #if ENABLED(Z_PROBE_SLED) || ENABLED(Z_PROBE_ALLEN_KEY)
// 2330       #if ENABLED(Z_PROBE_SLED)
// 2331         #define _AUE_ARGS true, false, false
// 2332       #else
// 2333         #define _AUE_ARGS
// 2334       #endif
// 2335       if (axis_unhomed_error(_AUE_ARGS)) {
// 2336         SERIAL_ERROR_START();
// 2337         SERIAL_ERRORLNPGM(MSG_STOP_UNHOMED);
// 2338         stop();
// 2339         return true;
// 2340       }
// 2341     #endif
// 2342 
// 2343     const float oldXpos = current_position[X_AXIS],
// 2344                 oldYpos = current_position[Y_AXIS];
// 2345 
// 2346     #ifdef _TRIGGERED_WHEN_STOWED_TEST
// 2347 
// 2348       // If endstop is already false, the Z probe is deployed
// 2349       if (_TRIGGERED_WHEN_STOWED_TEST == deploy) {     // closed after the probe specific actions.
// 2350                                                        // Would a goto be less ugly?
// 2351         //while (!_TRIGGERED_WHEN_STOWED_TEST) idle(); // would offer the opportunity
// 2352                                                        // for a triggered when stowed manual probe.
// 2353 
// 2354         if (!deploy) endstops.enable_z_probe(false); // Switch off triggered when stowed probes early
// 2355                                                      // otherwise an Allen-Key probe can't be stowed.
// 2356     #endif
// 2357 
// 2358         #if ENABLED(SOLENOID_PROBE)
// 2359 
// 2360           #if HAS_SOLENOID_1
// 2361             WRITE(SOL1_PIN, deploy);
// 2362           #endif
// 2363 
// 2364         #elif ENABLED(Z_PROBE_SLED)
// 2365 
// 2366           dock_sled(!deploy);
// 2367 
// 2368         #elif HAS_Z_SERVO_ENDSTOP && DISABLED(BLTOUCH)
// 2369 
// 2370           MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[deploy ? 0 : 1]);
// 2371 
// 2372         #elif ENABLED(Z_PROBE_ALLEN_KEY)
// 2373 
// 2374           deploy ? run_deploy_moves_script() : run_stow_moves_script();
// 2375 
// 2376         #endif
// 2377 
// 2378     #ifdef _TRIGGERED_WHEN_STOWED_TEST
// 2379       } // _TRIGGERED_WHEN_STOWED_TEST == deploy
// 2380 
// 2381       if (_TRIGGERED_WHEN_STOWED_TEST == deploy) { // State hasn't changed?
// 2382 
// 2383         if (IsRunning()) {
// 2384           SERIAL_ERROR_START();
// 2385           SERIAL_ERRORLNPGM("Z-Probe failed");
// 2386           LCD_ALERTMESSAGEPGM("Err: ZPROBE");
// 2387         }
// 2388         stop();
// 2389         return true;
// 2390 
// 2391       } // _TRIGGERED_WHEN_STOWED_TEST == deploy
// 2392 
// 2393     #endif
// 2394 
// 2395     do_blocking_move_to(oldXpos, oldYpos, current_position[Z_AXIS]); // return to position before deploy
// 2396     endstops.enable_z_probe(deploy);
// 2397     return false;
// 2398   }
// 2399 
// 2400   /**
// 2401    * @brief Used by run_z_probe to do a single Z probe move.
// 2402    *
// 2403    * @param  z        Z destination
// 2404    * @param  fr_mm_s  Feedrate in mm/s
// 2405    * @return true to indicate an error
// 2406    */
// 2407   static bool do_probe_move(const float z, const float fr_mm_m) {
// 2408     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2409       if (DEBUGGING(LEVELING)) DEBUG_POS(">>> do_probe_move", current_position);
// 2410     #endif
// 2411 
// 2412     // Deploy BLTouch at the start of any probe
// 2413     #if ENABLED(BLTOUCH)
// 2414       if (set_bltouch_deployed(true)) return true;
// 2415     #endif
// 2416 
// 2417     #if QUIET_PROBING
// 2418       probing_pause(true);
// 2419     #endif
// 2420 
// 2421     // Move down until probe triggered
// 2422     do_blocking_move_to_z(z, MMM_TO_MMS(fr_mm_m));
// 2423 
// 2424     // Check to see if the probe was triggered
// 2425     const bool probe_triggered = TEST(Endstops::endstop_hit_bits,
// 2426       #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
// 2427         Z_MIN
// 2428       #else
// 2429         Z_MIN_PROBE
// 2430       #endif
// 2431     );
// 2432 
// 2433     #if QUIET_PROBING
// 2434       probing_pause(false);
// 2435     #endif
// 2436 
// 2437     // Retract BLTouch immediately after a probe if it was triggered
// 2438     #if ENABLED(BLTOUCH)
// 2439       if (probe_triggered && set_bltouch_deployed(false)) return true;
// 2440     #endif
// 2441 
// 2442     // Clear endstop flags
// 2443     endstops.hit_on_purpose();
// 2444 
// 2445     // Get Z where the steppers were interrupted
// 2446     set_current_from_steppers_for_axis(Z_AXIS);
// 2447 
// 2448     // Tell the planner where we actually are
// 2449     SYNC_PLAN_POSITION_KINEMATIC();
// 2450 
// 2451     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2452       if (DEBUGGING(LEVELING)) DEBUG_POS("<<< do_probe_move", current_position);
// 2453     #endif
// 2454 
// 2455     return !probe_triggered;
// 2456   }
// 2457 
// 2458   /**
// 2459    * @details Used by probe_pt to do a single Z probe at the current position.
// 2460    *          Leaves current_position[Z_AXIS] at the height where the probe triggered.
// 2461    *
// 2462    * @return The raw Z position where the probe was triggered
// 2463    */
// 2464   static float run_z_probe() {
// 2465 
// 2466     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2467       if (DEBUGGING(LEVELING)) DEBUG_POS(">>> run_z_probe", current_position);
// 2468     #endif
// 2469 
// 2470     // Prevent stepper_inactive_time from running out and EXTRUDER_RUNOUT_PREVENT from extruding
// 2471     refresh_cmd_timeout();
// 2472 
// 2473     // Double-probing does a fast probe followed by a slow probe
// 2474     #if MULTIPLE_PROBING == 2
// 2475 
// 2476       // Do a first probe at the fast speed
// 2477       if (do_probe_move(-10, Z_PROBE_SPEED_FAST)) return NAN;
// 2478 
// 2479       float first_probe_z = current_position[Z_AXIS];
// 2480 
// 2481       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2482         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("1st Probe Z:", first_probe_z);
// 2483       #endif
// 2484 
// 2485       // move up to make clearance for the probe
// 2486       do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
// 2487 
// 2488     #else
// 2489 
// 2490       // If the nozzle is above the travel height then
// 2491       // move down quickly before doing the slow probe
// 2492       float z = Z_CLEARANCE_DEPLOY_PROBE;
// 2493       if (zprobe_zoffset < 0) z -= zprobe_zoffset;
// 2494 
// 2495       if (z < current_position[Z_AXIS]) {
// 2496 
// 2497         // If we don't make it to the z position (i.e. the probe triggered), move up to make clearance for the probe
// 2498         if (!do_probe_move(z, Z_PROBE_SPEED_FAST))
// 2499           do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
// 2500       }
// 2501     #endif
// 2502 
// 2503     #if MULTIPLE_PROBING > 2
// 2504       float probes_total = 0;
// 2505       for (uint8_t p = MULTIPLE_PROBING + 1; --p;) {
// 2506     #endif
// 2507 
// 2508         // move down slowly to find bed
// 2509         if (do_probe_move(-10, Z_PROBE_SPEED_SLOW)) return NAN;
// 2510 
// 2511     #if MULTIPLE_PROBING > 2
// 2512         probes_total += current_position[Z_AXIS];
// 2513         if (p > 1) do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
// 2514       }
// 2515     #endif
// 2516 
// 2517     #if MULTIPLE_PROBING > 2
// 2518 
// 2519       // Return the average value of all probes
// 2520       return probes_total * (1.0 / (MULTIPLE_PROBING));
// 2521 
// 2522     #elif MULTIPLE_PROBING == 2
// 2523 
// 2524       const float z2 = current_position[Z_AXIS];
// 2525 
// 2526       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2527         if (DEBUGGING(LEVELING)) {
// 2528           SERIAL_ECHOPAIR("2nd Probe Z:", z2);
// 2529           SERIAL_ECHOLNPAIR(" Discrepancy:", first_probe_z - z2);
// 2530         }
// 2531       #endif
// 2532 
// 2533       // Return a weighted average of the fast and slow probes
// 2534       return (z2 * 3.0 + first_probe_z * 2.0) * 0.2;
// 2535 
// 2536     #else
// 2537 
// 2538       // Return the single probe result
// 2539       return current_position[Z_AXIS];
// 2540 
// 2541     #endif
// 2542 
// 2543     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2544       if (DEBUGGING(LEVELING)) DEBUG_POS("<<< run_z_probe", current_position);
// 2545     #endif
// 2546   }
// 2547 
// 2548   /**
// 2549    * - Move to the given XY
// 2550    * - Deploy the probe, if not already deployed
// 2551    * - Probe the bed, get the Z position
// 2552    * - Depending on the 'stow' flag
// 2553    *   - Stow the probe, or
// 2554    *   - Raise to the BETWEEN height
// 2555    * - Return the probed Z position
// 2556    */
// 2557   float probe_pt(const float &rx, const float &ry, const bool stow, const uint8_t verbose_level, const bool probe_relative=true) {
// 2558     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2559       if (DEBUGGING(LEVELING)) {
// 2560         SERIAL_ECHOPAIR(">>> probe_pt(", LOGICAL_X_POSITION(rx));
// 2561         SERIAL_ECHOPAIR(", ", LOGICAL_Y_POSITION(ry));
// 2562         SERIAL_ECHOPAIR(", ", stow ? "" : "no ");
// 2563         SERIAL_ECHOLNPGM("stow)");
// 2564         DEBUG_POS("", current_position);
// 2565       }
// 2566     #endif
// 2567 
// 2568     // TODO: Adapt for SCARA, where the offset rotates
// 2569     float nx = rx, ny = ry;
// 2570     if (probe_relative) {
// 2571       if (!position_is_reachable_by_probe(rx, ry)) return NAN;  // The given position is in terms of the probe
// 2572       nx -= (X_PROBE_OFFSET_FROM_EXTRUDER);                     // Get the nozzle position
// 2573       ny -= (Y_PROBE_OFFSET_FROM_EXTRUDER);
// 2574     }
// 2575     else if (!position_is_reachable(nx, ny)) return NAN;        // The given position is in terms of the nozzle
// 2576 
// 2577     const float nz =
// 2578       #if ENABLED(DELTA)
// 2579         // Move below clip height or xy move will be aborted by do_blocking_move_to
// 2580         min(current_position[Z_AXIS], delta_clip_start_height)
// 2581       #else
// 2582         current_position[Z_AXIS]
// 2583       #endif
// 2584     ;
// 2585 
// 2586     const float old_feedrate_mm_s = feedrate_mm_s;
// 2587     feedrate_mm_s = XY_PROBE_FEEDRATE_MM_S;
// 2588 
// 2589     // Move the probe to the starting XYZ
// 2590     do_blocking_move_to(nx, ny, nz);
// 2591 
// 2592     float measured_z = NAN;
// 2593     if (!DEPLOY_PROBE()) {
// 2594       measured_z = run_z_probe() + zprobe_zoffset;
// 2595 
// 2596       if (!stow)
// 2597         do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
// 2598       else
// 2599         if (STOW_PROBE()) measured_z = NAN;
// 2600     }
// 2601 
// 2602     if (verbose_level > 2) {
// 2603       SERIAL_PROTOCOLPGM("Bed X: ");
// 2604       SERIAL_PROTOCOL_F(LOGICAL_X_POSITION(rx), 3);
// 2605       SERIAL_PROTOCOLPGM(" Y: ");
// 2606       SERIAL_PROTOCOL_F(LOGICAL_Y_POSITION(ry), 3);
// 2607       SERIAL_PROTOCOLPGM(" Z: ");
// 2608       SERIAL_PROTOCOL_F(measured_z, 3);
// 2609       SERIAL_EOL();
// 2610     }
// 2611 
// 2612     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2613       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< probe_pt");
// 2614     #endif
// 2615 
// 2616     feedrate_mm_s = old_feedrate_mm_s;
// 2617 
// 2618     if (isnan(measured_z)) {
// 2619       LCD_MESSAGEPGM(MSG_ERR_PROBING_FAILED);
// 2620       SERIAL_ERROR_START();
// 2621       SERIAL_ERRORLNPGM(MSG_ERR_PROBING_FAILED);
// 2622     }
// 2623 
// 2624     return measured_z;
// 2625   }
// 2626 
// 2627 #endif // HAS_BED_PROBE
// 2628 
// 2629 #if HAS_LEVELING
// 2630 
// 2631   bool leveling_is_valid() {
// 2632     return
// 2633       #if ENABLED(MESH_BED_LEVELING)
// 2634         mbl.has_mesh
// 2635       #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 2636         !!bilinear_grid_spacing[X_AXIS]
// 2637       #elif ENABLED(AUTO_BED_LEVELING_UBL)
// 2638         true
// 2639       #else // 3POINT, LINEAR
// 2640         true
// 2641       #endif
// 2642     ;
// 2643   }
// 2644 
// 2645   /**
// 2646    * Turn bed leveling on or off, fixing the current
// 2647    * position as-needed.
// 2648    *
// 2649    * Disable: Current position = physical position
// 2650    *  Enable: Current position = "unleveled" physical position
// 2651    */
// 2652   void set_bed_leveling_enabled(const bool enable/*=true*/) {
// 2653 
// 2654     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 2655       const bool can_change = (!enable || leveling_is_valid());
// 2656     #else
// 2657       constexpr bool can_change = true;
// 2658     #endif
// 2659 
// 2660     if (can_change && enable != planner.leveling_active) {
// 2661 
// 2662       #if ENABLED(MESH_BED_LEVELING)
// 2663 
// 2664         if (!enable)
// 2665           planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS]);
// 2666 
// 2667         const bool enabling = enable && leveling_is_valid();
// 2668         planner.leveling_active = enabling;
// 2669         if (enabling) planner.unapply_leveling(current_position);
// 2670 
// 2671       #elif ENABLED(AUTO_BED_LEVELING_UBL)
// 2672         #if PLANNER_LEVELING
// 2673           if (planner.leveling_active) {                       // leveling from on to off
// 2674             // change unleveled current_position to physical current_position without moving steppers.
// 2675             planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS]);
// 2676             planner.leveling_active = false;                   // disable only AFTER calling apply_leveling
// 2677           }
// 2678           else {                                        // leveling from off to on
// 2679             planner.leveling_active = true;                    // enable BEFORE calling unapply_leveling, otherwise ignored
// 2680             // change physical current_position to unleveled current_position without moving steppers.
// 2681             planner.unapply_leveling(current_position);
// 2682           }
// 2683         #else
// 2684           planner.leveling_active = enable;                    // just flip the bit, current_position will be wrong until next move.
// 2685         #endif
// 2686 
// 2687       #else // ABL
// 2688 
// 2689         #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 2690           // Force bilinear_z_offset to re-calculate next time
// 2691           const float reset[XYZ] = { -9999.999, -9999.999, 0 };
// 2692           (void)bilinear_z_offset(reset);
// 2693         #endif
// 2694 
// 2695         // Enable or disable leveling compensation in the planner
// 2696         planner.leveling_active = enable;
// 2697 
// 2698         if (!enable)
// 2699           // When disabling just get the current position from the steppers.
// 2700           // This will yield the smallest error when first converted back to steps.
// 2701           set_current_from_steppers_for_axis(
// 2702             #if ABL_PLANAR
// 2703               ALL_AXES
// 2704             #else
// 2705               Z_AXIS
// 2706             #endif
// 2707           );
// 2708         else
// 2709           // When enabling, remove compensation from the current position,
// 2710           // so compensation will give the right stepper counts.
// 2711           planner.unapply_leveling(current_position);
// 2712 
// 2713         SYNC_PLAN_POSITION_KINEMATIC();
// 2714 
// 2715       #endif // ABL
// 2716     }
// 2717   }
// 2718 
// 2719   #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
// 2720 
// 2721     void set_z_fade_height(const float zfh, const bool do_report/*=true*/) {
// 2722 
// 2723       if (planner.z_fade_height == zfh) return; // do nothing if no change
// 2724 
// 2725       const bool level_active = planner.leveling_active;
// 2726 
// 2727       #if ENABLED(AUTO_BED_LEVELING_UBL)
// 2728         if (level_active) set_bed_leveling_enabled(false);  // turn off before changing fade height for proper apply/unapply leveling to maintain current_position
// 2729       #endif
// 2730 
// 2731       planner.set_z_fade_height(zfh);
// 2732 
// 2733       if (level_active) {
// 2734         const float oldpos[] = { current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] };
// 2735         #if ENABLED(AUTO_BED_LEVELING_UBL)
// 2736           set_bed_leveling_enabled(true);  // turn back on after changing fade height
// 2737         #else
// 2738           set_current_from_steppers_for_axis(
// 2739             #if ABL_PLANAR
// 2740               ALL_AXES
// 2741             #else
// 2742               Z_AXIS
// 2743             #endif
// 2744           );
// 2745           SYNC_PLAN_POSITION_KINEMATIC();
// 2746         #endif
// 2747         if (do_report && memcmp(oldpos, current_position, sizeof(oldpos)))
// 2748           report_current_position();
// 2749       }
// 2750     }
// 2751 
// 2752   #endif // LEVELING_FADE_HEIGHT
// 2753 
// 2754   /**
// 2755    * Reset calibration results to zero.
// 2756    */
// 2757   void reset_bed_level() {
// 2758     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2759       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("reset_bed_level");
// 2760     #endif
// 2761     set_bed_leveling_enabled(false);
// 2762     #if ENABLED(MESH_BED_LEVELING)
// 2763       if (leveling_is_valid()) {
// 2764         mbl.reset();
// 2765         mbl.has_mesh = false;
// 2766       }
// 2767     #elif ENABLED(AUTO_BED_LEVELING_UBL)
// 2768       ubl.reset();
// 2769     #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 2770       bilinear_start[X_AXIS] = bilinear_start[Y_AXIS] =
// 2771       bilinear_grid_spacing[X_AXIS] = bilinear_grid_spacing[Y_AXIS] = 0;
// 2772       for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
// 2773         for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
// 2774           z_values[x][y] = NAN;
// 2775     #elif ABL_PLANAR
// 2776       planner.bed_level_matrix.set_to_identity();
// 2777     #endif
// 2778   }
// 2779 
// 2780 #endif // HAS_LEVELING
// 2781 
// 2782 #if ENABLED(AUTO_BED_LEVELING_BILINEAR) || ENABLED(MESH_BED_LEVELING)
// 2783 
// 2784   /**
// 2785    * Enable to produce output in JSON format suitable
// 2786    * for SCAD or JavaScript mesh visualizers.
// 2787    *
// 2788    * Visualize meshes in OpenSCAD using the included script.
// 2789    *
// 2790    *   buildroot/shared/scripts/MarlinMesh.scad
// 2791    */
// 2792   //#define SCAD_MESH_OUTPUT
// 2793 
// 2794   /**
// 2795    * Print calibration results for plotting or manual frame adjustment.
// 2796    */
// 2797   static void print_2d_array(const uint8_t sx, const uint8_t sy, const uint8_t precision, float (*fn)(const uint8_t, const uint8_t)) {
// 2798     #ifndef SCAD_MESH_OUTPUT
// 2799       for (uint8_t x = 0; x < sx; x++) {
// 2800         for (uint8_t i = 0; i < precision + 2 + (x < 10 ? 1 : 0); i++)
// 2801           SERIAL_PROTOCOLCHAR(' ');
// 2802         SERIAL_PROTOCOL((int)x);
// 2803       }
// 2804       SERIAL_EOL();
// 2805     #endif
// 2806     #ifdef SCAD_MESH_OUTPUT
// 2807       SERIAL_PROTOCOLLNPGM("measured_z = ["); // open 2D array
// 2808     #endif
// 2809     for (uint8_t y = 0; y < sy; y++) {
// 2810       #ifdef SCAD_MESH_OUTPUT
// 2811         SERIAL_PROTOCOLPGM(" [");           // open sub-array
// 2812       #else
// 2813         if (y < 10) SERIAL_PROTOCOLCHAR(' ');
// 2814         SERIAL_PROTOCOL((int)y);
// 2815       #endif
// 2816       for (uint8_t x = 0; x < sx; x++) {
// 2817         SERIAL_PROTOCOLCHAR(' ');
// 2818         const float offset = fn(x, y);
// 2819         if (!isnan(offset)) {
// 2820           if (offset >= 0) SERIAL_PROTOCOLCHAR('+');
// 2821           SERIAL_PROTOCOL_F(offset, precision);
// 2822         }
// 2823         else {
// 2824           #ifdef SCAD_MESH_OUTPUT
// 2825             for (uint8_t i = 3; i < precision + 3; i++)
// 2826               SERIAL_PROTOCOLCHAR(' ');
// 2827             SERIAL_PROTOCOLPGM("NAN");
// 2828           #else
// 2829             for (uint8_t i = 0; i < precision + 3; i++)
// 2830               SERIAL_PROTOCOLCHAR(i ? '=' : ' ');
// 2831           #endif
// 2832         }
// 2833         #ifdef SCAD_MESH_OUTPUT
// 2834           if (x < sx - 1) SERIAL_PROTOCOLCHAR(',');
// 2835         #endif
// 2836       }
// 2837       #ifdef SCAD_MESH_OUTPUT
// 2838         SERIAL_PROTOCOLCHAR(' ');
// 2839         SERIAL_PROTOCOLCHAR(']');                     // close sub-array
// 2840         if (y < sy - 1) SERIAL_PROTOCOLCHAR(',');
// 2841       #endif
// 2842       SERIAL_EOL();
// 2843     }
// 2844     #ifdef SCAD_MESH_OUTPUT
// 2845       SERIAL_PROTOCOLPGM("];");                       // close 2D array
// 2846     #endif
// 2847     SERIAL_EOL();
// 2848   }
// 2849 
// 2850 #endif
// 2851 
// 2852 #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 2853 
// 2854   /**
// 2855    * Extrapolate a single point from its neighbors
// 2856    */
// 2857   static void extrapolate_one_point(const uint8_t x, const uint8_t y, const int8_t xdir, const int8_t ydir) {
// 2858     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2859       if (DEBUGGING(LEVELING)) {
// 2860         SERIAL_ECHOPGM("Extrapolate [");
// 2861         if (x < 10) SERIAL_CHAR(' ');
// 2862         SERIAL_ECHO((int)x);
// 2863         SERIAL_CHAR(xdir ? (xdir > 0 ? '+' : '-') : ' ');
// 2864         SERIAL_CHAR(' ');
// 2865         if (y < 10) SERIAL_CHAR(' ');
// 2866         SERIAL_ECHO((int)y);
// 2867         SERIAL_CHAR(ydir ? (ydir > 0 ? '+' : '-') : ' ');
// 2868         SERIAL_CHAR(']');
// 2869       }
// 2870     #endif
// 2871     if (!isnan(z_values[x][y])) {
// 2872       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2873         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM(" (done)");
// 2874       #endif
// 2875       return;  // Don't overwrite good values.
// 2876     }
// 2877     SERIAL_EOL();
// 2878 
// 2879     // Get X neighbors, Y neighbors, and XY neighbors
// 2880     const uint8_t x1 = x + xdir, y1 = y + ydir, x2 = x1 + xdir, y2 = y1 + ydir;
// 2881     float a1 = z_values[x1][y ], a2 = z_values[x2][y ],
// 2882           b1 = z_values[x ][y1], b2 = z_values[x ][y2],
// 2883           c1 = z_values[x1][y1], c2 = z_values[x2][y2];
// 2884 
// 2885     // Treat far unprobed points as zero, near as equal to far
// 2886     if (isnan(a2)) a2 = 0.0; if (isnan(a1)) a1 = a2;
// 2887     if (isnan(b2)) b2 = 0.0; if (isnan(b1)) b1 = b2;
// 2888     if (isnan(c2)) c2 = 0.0; if (isnan(c1)) c1 = c2;
// 2889 
// 2890     const float a = 2 * a1 - a2, b = 2 * b1 - b2, c = 2 * c1 - c2;
// 2891 
// 2892     // Take the average instead of the median
// 2893     z_values[x][y] = (a + b + c) / 3.0;
// 2894 
// 2895     // Median is robust (ignores outliers).
// 2896     // z_values[x][y] = (a < b) ? ((b < c) ? b : (c < a) ? a : c)
// 2897     //                                : ((c < b) ? b : (a < c) ? a : c);
// 2898   }
// 2899 
// 2900   //Enable this if your SCARA uses 180° of total area
// 2901   //#define EXTRAPOLATE_FROM_EDGE
// 2902 
// 2903   #if ENABLED(EXTRAPOLATE_FROM_EDGE)
// 2904     #if GRID_MAX_POINTS_X < GRID_MAX_POINTS_Y
// 2905       #define HALF_IN_X
// 2906     #elif GRID_MAX_POINTS_Y < GRID_MAX_POINTS_X
// 2907       #define HALF_IN_Y
// 2908     #endif
// 2909   #endif
// 2910 
// 2911   /**
// 2912    * Fill in the unprobed points (corners of circular print surface)
// 2913    * using linear extrapolation, away from the center.
// 2914    */
// 2915   static void extrapolate_unprobed_bed_level() {
// 2916     #ifdef HALF_IN_X
// 2917       constexpr uint8_t ctrx2 = 0, xlen = GRID_MAX_POINTS_X - 1;
// 2918     #else
// 2919       constexpr uint8_t ctrx1 = (GRID_MAX_POINTS_X - 1) / 2, // left-of-center
// 2920                         ctrx2 = (GRID_MAX_POINTS_X) / 2,     // right-of-center
// 2921                         xlen = ctrx1;
// 2922     #endif
// 2923 
// 2924     #ifdef HALF_IN_Y
// 2925       constexpr uint8_t ctry2 = 0, ylen = GRID_MAX_POINTS_Y - 1;
// 2926     #else
// 2927       constexpr uint8_t ctry1 = (GRID_MAX_POINTS_Y - 1) / 2, // top-of-center
// 2928                         ctry2 = (GRID_MAX_POINTS_Y) / 2,     // bottom-of-center
// 2929                         ylen = ctry1;
// 2930     #endif
// 2931 
// 2932     for (uint8_t xo = 0; xo <= xlen; xo++)
// 2933       for (uint8_t yo = 0; yo <= ylen; yo++) {
// 2934         uint8_t x2 = ctrx2 + xo, y2 = ctry2 + yo;
// 2935         #ifndef HALF_IN_X
// 2936           const uint8_t x1 = ctrx1 - xo;
// 2937         #endif
// 2938         #ifndef HALF_IN_Y
// 2939           const uint8_t y1 = ctry1 - yo;
// 2940           #ifndef HALF_IN_X
// 2941             extrapolate_one_point(x1, y1, +1, +1);   //  left-below + +
// 2942           #endif
// 2943           extrapolate_one_point(x2, y1, -1, +1);     // right-below - +
// 2944         #endif
// 2945         #ifndef HALF_IN_X
// 2946           extrapolate_one_point(x1, y2, +1, -1);     //  left-above + -
// 2947         #endif
// 2948         extrapolate_one_point(x2, y2, -1, -1);       // right-above - -
// 2949       }
// 2950 
// 2951   }
// 2952 
// 2953   static void print_bilinear_leveling_grid() {
// 2954     SERIAL_ECHOLNPGM("Bilinear Leveling Grid:");
// 2955     print_2d_array(GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y, 3,
// 2956       [](const uint8_t ix, const uint8_t iy) { return z_values[ix][iy]; }
// 2957     );
// 2958   }
// 2959 
// 2960   #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 2961 
// 2962     #define ABL_GRID_POINTS_VIRT_X (GRID_MAX_POINTS_X - 1) * (BILINEAR_SUBDIVISIONS) + 1
// 2963     #define ABL_GRID_POINTS_VIRT_Y (GRID_MAX_POINTS_Y - 1) * (BILINEAR_SUBDIVISIONS) + 1
// 2964     #define ABL_TEMP_POINTS_X (GRID_MAX_POINTS_X + 2)
// 2965     #define ABL_TEMP_POINTS_Y (GRID_MAX_POINTS_Y + 2)
// 2966     float z_values_virt[ABL_GRID_POINTS_VIRT_X][ABL_GRID_POINTS_VIRT_Y];
// 2967     int bilinear_grid_spacing_virt[2] = { 0 };
// 2968     float bilinear_grid_factor_virt[2] = { 0 };
// 2969 
// 2970     static void print_bilinear_leveling_grid_virt() {
// 2971       SERIAL_ECHOLNPGM("Subdivided with CATMULL ROM Leveling Grid:");
// 2972       print_2d_array(ABL_GRID_POINTS_VIRT_X, ABL_GRID_POINTS_VIRT_Y, 5,
// 2973         [](const uint8_t ix, const uint8_t iy) { return z_values_virt[ix][iy]; }
// 2974       );
// 2975     }
// 2976 
// 2977     #define LINEAR_EXTRAPOLATION(E, I) ((E) * 2 - (I))
// 2978     float bed_level_virt_coord(const uint8_t x, const uint8_t y) {
// 2979       uint8_t ep = 0, ip = 1;
// 2980       if (!x || x == ABL_TEMP_POINTS_X - 1) {
// 2981         if (x) {
// 2982           ep = GRID_MAX_POINTS_X - 1;
// 2983           ip = GRID_MAX_POINTS_X - 2;
// 2984         }
// 2985         if (WITHIN(y, 1, ABL_TEMP_POINTS_Y - 2))
// 2986           return LINEAR_EXTRAPOLATION(
// 2987             z_values[ep][y - 1],
// 2988             z_values[ip][y - 1]
// 2989           );
// 2990         else
// 2991           return LINEAR_EXTRAPOLATION(
// 2992             bed_level_virt_coord(ep + 1, y),
// 2993             bed_level_virt_coord(ip + 1, y)
// 2994           );
// 2995       }
// 2996       if (!y || y == ABL_TEMP_POINTS_Y - 1) {
// 2997         if (y) {
// 2998           ep = GRID_MAX_POINTS_Y - 1;
// 2999           ip = GRID_MAX_POINTS_Y - 2;
// 3000         }
// 3001         if (WITHIN(x, 1, ABL_TEMP_POINTS_X - 2))
// 3002           return LINEAR_EXTRAPOLATION(
// 3003             z_values[x - 1][ep],
// 3004             z_values[x - 1][ip]
// 3005           );
// 3006         else
// 3007           return LINEAR_EXTRAPOLATION(
// 3008             bed_level_virt_coord(x, ep + 1),
// 3009             bed_level_virt_coord(x, ip + 1)
// 3010           );
// 3011       }
// 3012       return z_values[x - 1][y - 1];
// 3013     }
// 3014 
// 3015     static float bed_level_virt_cmr(const float p[4], const uint8_t i, const float t) {
// 3016       return (
// 3017           p[i-1] * -t * sq(1 - t)
// 3018         + p[i]   * (2 - 5 * sq(t) + 3 * t * sq(t))
// 3019         + p[i+1] * t * (1 + 4 * t - 3 * sq(t))
// 3020         - p[i+2] * sq(t) * (1 - t)
// 3021       ) * 0.5;
// 3022     }
// 3023 
// 3024     static float bed_level_virt_2cmr(const uint8_t x, const uint8_t y, const float &tx, const float &ty) {
// 3025       float row[4], column[4];
// 3026       for (uint8_t i = 0; i < 4; i++) {
// 3027         for (uint8_t j = 0; j < 4; j++) {
// 3028           column[j] = bed_level_virt_coord(i + x - 1, j + y - 1);
// 3029         }
// 3030         row[i] = bed_level_virt_cmr(column, 1, ty);
// 3031       }
// 3032       return bed_level_virt_cmr(row, 1, tx);
// 3033     }
// 3034 
// 3035     void bed_level_virt_interpolate() {
// 3036       bilinear_grid_spacing_virt[X_AXIS] = bilinear_grid_spacing[X_AXIS] / (BILINEAR_SUBDIVISIONS);
// 3037       bilinear_grid_spacing_virt[Y_AXIS] = bilinear_grid_spacing[Y_AXIS] / (BILINEAR_SUBDIVISIONS);
// 3038       bilinear_grid_factor_virt[X_AXIS] = RECIPROCAL(bilinear_grid_spacing_virt[X_AXIS]);
// 3039       bilinear_grid_factor_virt[Y_AXIS] = RECIPROCAL(bilinear_grid_spacing_virt[Y_AXIS]);
// 3040       for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
// 3041         for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
// 3042           for (uint8_t ty = 0; ty < BILINEAR_SUBDIVISIONS; ty++)
// 3043             for (uint8_t tx = 0; tx < BILINEAR_SUBDIVISIONS; tx++) {
// 3044               if ((ty && y == GRID_MAX_POINTS_Y - 1) || (tx && x == GRID_MAX_POINTS_X - 1))
// 3045                 continue;
// 3046               z_values_virt[x * (BILINEAR_SUBDIVISIONS) + tx][y * (BILINEAR_SUBDIVISIONS) + ty] =
// 3047                 bed_level_virt_2cmr(
// 3048                   x + 1,
// 3049                   y + 1,
// 3050                   (float)tx / (BILINEAR_SUBDIVISIONS),
// 3051                   (float)ty / (BILINEAR_SUBDIVISIONS)
// 3052                 );
// 3053             }
// 3054     }
// 3055   #endif // ABL_BILINEAR_SUBDIVISION
// 3056 
// 3057   // Refresh after other values have been updated
// 3058   void refresh_bed_level() {
// 3059     bilinear_grid_factor[X_AXIS] = RECIPROCAL(bilinear_grid_spacing[X_AXIS]);
// 3060     bilinear_grid_factor[Y_AXIS] = RECIPROCAL(bilinear_grid_spacing[Y_AXIS]);
// 3061     #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 3062       bed_level_virt_interpolate();
// 3063     #endif
// 3064   }
// 3065 
// 3066 #endif // AUTO_BED_LEVELING_BILINEAR
// 3067 
// 3068 /**
// 3069  * Home an individual linear axis
// 3070  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock34 Using cfiCommon0
          CFI Function _Z14do_homing_move8AxisEnumff
        THUMB
// 3071 static void do_homing_move(const AxisEnum axis, const float distance, const float fr_mm_s=0.0) {
_Z14do_homing_move8AxisEnumff:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        VPUSH    {D8}
          CFI D8 Frame(CFA, -24)
          CFI CFA R13+24
        SUB      SP,SP,#+8
          CFI CFA R13+32
        VMOV.F32 S16,S0
        VMOV.F32 S17,S1
        LDR.N    R4,??DataTable92_9
        ADD      R5,R4,R0, LSL #+2
        MOVS     R0,#+0
        STR      R0,[R5, #+32]
// 3072 
// 3073   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3074     if (DEBUGGING(LEVELING)) {
// 3075       SERIAL_ECHOPAIR(">>> do_homing_move(", axis_codes[axis]);
// 3076       SERIAL_ECHOPAIR(", ", distance);
// 3077       SERIAL_ECHOPAIR(", ", fr_mm_s);
// 3078       SERIAL_CHAR(')');
// 3079       SERIAL_EOL();
// 3080     }
// 3081   #endif
// 3082 
// 3083 //  #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
// 3084 #if 0    
// 3085     const bool deploy_bltouch = (axis == Z_AXIS && distance < 0);
// 3086     if (deploy_bltouch) set_bltouch_deployed(true);
// 3087   #endif
// 3088 
// 3089   #if QUIET_PROBING
// 3090     if (axis == Z_AXIS) probing_pause(true);
// 3091   #endif
// 3092 
// 3093   // Tell the planner the axis is at 0
// 3094   current_position[axis] = 0;
// 3095 
// 3096   #if IS_SCARA
// 3097     SYNC_PLAN_POSITION_KINEMATIC();
// 3098     current_position[axis] = distance;
// 3099     inverse_kinematics(current_position);
// 3100     planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate(axis), active_extruder);
// 3101   #else
// 3102     sync_plan_position();
          CFI FunCall _Z18sync_plan_positionv
        BL       _Z18sync_plan_positionv
// 3103     current_position[axis] = distance;
        VSTR     S16,[R5, #+32]
// 3104     //planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate(axis), active_extruder);
// 3105     planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate_mm_s[axis], active_extruder);
        VCMP.F32 S17,#0.0
        FMSTAT   
        BEQ.N    ??do_homing_move_0
        VSTR     S17,[SP, #+0]
        B.N      ??do_homing_move_1
??do_homing_move_0:
        LDR      R0,[R5, #+64]
        STR      R0,[SP, #+0]
??do_homing_move_1:
        LDRB     R2,[R4, #+18]
        ADD      R1,SP,#+0
        ADD      R0,R4,#+44
        VLDR     S2,[R4, #+40]
        VLDR     S1,[R4, #+36]
        VLDR     S0,[R4, #+32]
          CFI FunCall _ZN7Planner11buffer_lineEfffRKfS1_h
        BL       _ZN7Planner11buffer_lineEfffRKfS1_h
// 3106 
// 3107   #endif
// 3108 
// 3109   stepper.synchronize();
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
// 3110 
// 3111   #if QUIET_PROBING
// 3112     if (axis == Z_AXIS) probing_pause(false);
// 3113   #endif
// 3114 
// 3115 //  #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
// 3116 #if 0    
// 3117     if (deploy_bltouch) set_bltouch_deployed(false);
// 3118   #endif
// 3119 
// 3120   endstops.hit_on_purpose();
          CFI FunCall _ZN8Endstops14hit_on_purposeEv
        BL       _ZN8Endstops14hit_on_purposeEv
// 3121 
// 3122   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3123     if (DEBUGGING(LEVELING)) {
// 3124       SERIAL_ECHOPAIR("<<< do_homing_move(", axis_codes[axis]);
// 3125       SERIAL_CHAR(')');
// 3126       SERIAL_EOL();
// 3127     }
// 3128   #endif
// 3129 }
        ADD      SP,SP,#+8
          CFI CFA R13+24
        VPOP     {D8}
          CFI D8 SameValue
          CFI CFA R13+16
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock34
// 3130 
// 3131 /**
// 3132  * TMC2130 specific sensorless homing using stallGuard2.
// 3133  * stallGuard2 only works when in spreadCycle mode.
// 3134  * spreadCycle and stealthChop are mutually exclusive.
// 3135  */
// 3136 #if ENABLED(SENSORLESS_HOMING)
// 3137   template<typename TMC>
// 3138   void tmc_sensorless_homing(TMC &st, bool enable=true) {
// 3139     #if ENABLED(STEALTHCHOP)
// 3140       if (enable) {
// 3141         st.coolstep_min_speed(1024UL * 1024UL - 1UL);
// 3142         st.stealthChop(0);
// 3143       }
// 3144       else {
// 3145         st.coolstep_min_speed(0);
// 3146         st.stealthChop(1);
// 3147       }
// 3148     #endif
// 3149 
// 3150     st.diag1_stall(enable ? 1 : 0);
// 3151   }
// 3152 #endif
// 3153 
// 3154 /**
// 3155  * Home an individual "raw axis" to its endstop.
// 3156  * This applies to XYZ on Cartesian and Core robots, and
// 3157  * to the individual ABC steppers on DELTA and SCARA.
// 3158  *
// 3159  * At the end of the procedure the axis is marked as
// 3160  * homed and the current position of that axis is updated.
// 3161  * Kinematic robots should wait till all axes are homed
// 3162  * before updating the current position.
// 3163  */
// 3164 
// 3165 #define HOMEAXIS(LETTER) homeaxis(LETTER##_AXIS)
// 3166 

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock35 Using cfiCommon0
          CFI Function _Z8homeaxis8AxisEnum
        THUMB
// 3167 static void homeaxis(const AxisEnum axis) {
_Z8homeaxis8AxisEnum:
        PUSH     {R3-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+32
        VPUSH    {D8}
          CFI D8 Frame(CFA, -40)
          CFI CFA R13+40
        MOV      R4,R0
// 3168 
// 3169   #if IS_SCARA
// 3170     // Only Z homing (with probe) is permitted
// 3171     if (axis != Z_AXIS) { BUZZ(100, 880); return; }
// 3172   #else
// 3173     #define CAN_HOME(A) \ 
// 3174       (axis == A##_AXIS && ((A##_MIN_PIN > -1 && A##_HOME_DIR < 0) || (A##_MAX_PIN > -1 && A##_HOME_DIR > 0)))
// 3175     if (!CAN_HOME(X) && !CAN_HOME(Y) && !CAN_HOME(Z)) return;
        MOV      R5,R4
        CMP      R5,#+2
        BNE.N    ??homeaxis_0
        LDR.N    R0,??DataTable92_8
        LDRSB    R0,[R0, #+1]
        CMP      R0,#+0
        BEQ.N    ??homeaxis_0
// 3176   #endif
// 3177 
// 3178   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3179     if (DEBUGGING(LEVELING)) {
// 3180       SERIAL_ECHOPAIR(">>> homeaxis(", axis_codes[axis]);
// 3181       SERIAL_CHAR(')');
// 3182       SERIAL_EOL();
// 3183     }
// 3184   #endif
// 3185 
// 3186   const int axis_home_dir =
// 3187     #if ENABLED(DUAL_X_CARRIAGE)
// 3188       (axis == X_AXIS) ? x_home_dir(active_extruder) :
// 3189     #endif
// 3190     home_dir(axis);
        MOV      R0,R4
          CFI FunCall _Z8home_dir8AxisEnum
        BL       _Z8home_dir8AxisEnum
        VMOV     S17,R0
// 3191 
// 3192   // Homing Z towards the bed? Deploy the Z probe or endstop.
// 3193   #if HOMING_Z_WITH_PROBE
// 3194     if (axis == Z_AXIS && DEPLOY_PROBE()) return;
// 3195   #endif
// 3196 
// 3197   // Set flags for X, Y, Z motor locking
// 3198   #if ENABLED(X_DUAL_ENDSTOPS)
// 3199     if (axis == X_AXIS) stepper.set_homing_flag_x(true);
// 3200   #endif
// 3201   #if ENABLED(Y_DUAL_ENDSTOPS)
// 3202     if (axis == Y_AXIS) stepper.set_homing_flag_y(true);
// 3203   #endif
// 3204   #if ENABLED(Z_DUAL_ENDSTOPS)
// 3205     if (axis == Z_AXIS) stepper.set_homing_flag_z(true);
// 3206   #endif
// 3207 
// 3208   // Disable stealthChop if used. Enable diag1 pin on driver.
// 3209   #if ENABLED(SENSORLESS_HOMING)
// 3210     #if ENABLED(X_IS_TMC2130)
// 3211       if (axis == X_AXIS) tmc_sensorless_homing(stepperX);
// 3212     #endif
// 3213     #if ENABLED(Y_IS_TMC2130)
// 3214       if (axis == Y_AXIS) tmc_sensorless_homing(stepperY);
// 3215     #endif
// 3216   #endif
// 3217 
// 3218   // Fast move towards endstop until triggered
// 3219   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3220     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 1 Fast:");
// 3221   #endif
// 3222   mksdlp.quick_stop_ena = false;
        LDR.N    R6,??DataTable92_6
        MOVS     R0,#+0
        STRB     R0,[R6, #+3245]
// 3223   do_homing_move(axis, 1.5 * max_length(axis) * axis_home_dir);
        MOV      R0,R4
          CFI FunCall _Z10max_length8AxisEnum
        BL       _Z10max_length8AxisEnum
        VLDR.W   S1,??DataTable91_1  ;; 0x0
        VMOV.F32 S16,S1
        VMOV     R0,S0
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOVS     R2,#+0
        LDR.W    R3,??DataTable99_5  ;; 0x3ff80000
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R8,R0
        MOV      R9,R1
        VMOV     R0,S17
          CFI FunCall __aeabi_i2d
        BL       __aeabi_i2d
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        VMOV     S0,R0
        VMOV.F32 S1,S16
        MOV      R0,R4
          CFI FunCall _Z14do_homing_move8AxisEnumff
        BL       _Z14do_homing_move8AxisEnumff
// 3224   
// 3225   mksdlp.buzzer_tone(500,100,2);
        ADDW     R7,R6,#+2500
        MOVS     R3,#+2
        MOVS     R2,#+100
        MOV      R1,#+500
        MOV      R0,R7
          CFI FunCall _ZN7MKS_DLP11buzzer_toneEtth
        BL       _ZN7MKS_DLP11buzzer_toneEtth
// 3226   // When homing Z with probe respect probe clearance
// 3227   const float bump = axis_home_dir * (
// 3228     //#if HOMING_Z_WITH_PROBE
// 3229 #if 0                                 
// 3230       (axis == Z_AXIS) ? max(Z_CLEARANCE_BETWEEN_PROBES, home_bump_mm(Z_AXIS)) :
// 3231     #endif
// 3232     home_bump_mm(axis)
// 3233   );
        VCVT.F32.S32 S16,S17
        MOV      R0,R4
          CFI FunCall _Z12home_bump_mm8AxisEnum
        BL       _Z12home_bump_mm8AxisEnum
        VMUL.F32 S16,S16,S0
// 3234 
// 3235   // If a second homing move is configured...
// 3236   if (bump) {
        VCMP.F32 S16,#0.0
        FMSTAT   
        BEQ.N    ??homeaxis_1
// 3237     // Move away from the endstop by the axis HOME_BUMP_MM
// 3238     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3239       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Move Away:");
// 3240     #endif
// 3241 	if(!mksdlp.quick_stop_ena)
        LDRB     R0,[R6, #+3245]
        CMP      R0,#+0
        BNE.N    ??homeaxis_2
// 3242 		{
// 3243 	    do_homing_move(axis, -bump);
        VLDR.W   S1,??DataTable91_1  ;; 0x0
        VNEG.F32 S0,S16
        MOV      R0,R4
          CFI FunCall _Z14do_homing_move8AxisEnumff
        BL       _Z14do_homing_move8AxisEnumff
// 3244 		}
// 3245     // Slow move towards endstop until triggered
// 3246     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3247       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 2 Slow:");
// 3248     #endif
// 3249 	if(!mksdlp.quick_stop_ena)
??homeaxis_2:
        LDRB     R0,[R6, #+3245]
        CMP      R0,#+0
        BNE.N    ??homeaxis_1
// 3250 		{
// 3251   	  	do_homing_move(axis, 2 * bump, get_homing_bump_feedrate(axis));
        MOV      R0,R4
          CFI FunCall _Z24get_homing_bump_feedrate8AxisEnum
        BL       _Z24get_homing_bump_feedrate8AxisEnum
        VMOV.F32 S1,S0
        VMOV.F32 S0,#2.0
        VMUL.F32 S0,S16,S0
        MOV      R0,R4
          CFI FunCall _Z14do_homing_move8AxisEnumff
        BL       _Z14do_homing_move8AxisEnumff
// 3252 		mksdlp.buzzer_tone(500,100,2);
        MOVS     R3,#+2
        MOVS     R2,#+100
        MOV      R1,#+500
        MOV      R0,R7
          CFI FunCall _ZN7MKS_DLP11buzzer_toneEtth
        BL       _ZN7MKS_DLP11buzzer_toneEtth
// 3253 		}
// 3254   }
// 3255 
// 3256   /**
// 3257    * Home axes that have dual endstops... differently
// 3258    */
// 3259   #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
// 3260     const bool pos_dir = axis_home_dir > 0;
// 3261     #if ENABLED(X_DUAL_ENDSTOPS)
// 3262       if (axis == X_AXIS) {
// 3263         const bool lock_x1 = pos_dir ? (x_endstop_adj > 0) : (x_endstop_adj < 0);
// 3264         const float adj = FABS(x_endstop_adj);
// 3265         if (lock_x1) stepper.set_x_lock(true); else stepper.set_x2_lock(true);
// 3266         do_homing_move(axis, pos_dir ? -adj : adj);
// 3267         if (lock_x1) stepper.set_x_lock(false); else stepper.set_x2_lock(false);
// 3268         stepper.set_homing_flag_x(false);
// 3269       }
// 3270     #endif
// 3271     #if ENABLED(Y_DUAL_ENDSTOPS)
// 3272       if (axis == Y_AXIS) {
// 3273         const bool lock_y1 = pos_dir ? (y_endstop_adj > 0) : (y_endstop_adj < 0);
// 3274         const float adj = FABS(y_endstop_adj);
// 3275         if (lock_y1) stepper.set_y_lock(true); else stepper.set_y2_lock(true);
// 3276         do_homing_move(axis, pos_dir ? -adj : adj);
// 3277         if (lock_y1) stepper.set_y_lock(false); else stepper.set_y2_lock(false);
// 3278         stepper.set_homing_flag_y(false);
// 3279       }
// 3280     #endif
// 3281     #if ENABLED(Z_DUAL_ENDSTOPS)
// 3282       if (axis == Z_AXIS) {
// 3283         const bool lock_z1 = pos_dir ? (z_endstop_adj > 0) : (z_endstop_adj < 0);
// 3284         const float adj = FABS(z_endstop_adj);
// 3285         if (lock_z1) stepper.set_z_lock(true); else stepper.set_z2_lock(true);
// 3286         do_homing_move(axis, pos_dir ? -adj : adj);
// 3287         if (lock_z1) stepper.set_z_lock(false); else stepper.set_z2_lock(false);
// 3288         stepper.set_homing_flag_z(false);
// 3289       }
// 3290     #endif
// 3291   #endif
// 3292 
// 3293   #if IS_SCARA
// 3294 
// 3295     set_axis_is_at_home(axis);
// 3296     SYNC_PLAN_POSITION_KINEMATIC();
// 3297 
// 3298   #elif ENABLED(DELTA)
// 3299 
// 3300     // Delta has already moved all three towers up in G28
// 3301     // so here it re-homes each tower in turn.
// 3302     // Delta homing treats the axes as normal linear axes.
// 3303 
// 3304     // retrace by the amount specified in delta_endstop_adj + additional 0.1mm in order to have minimum steps
// 3305     if (delta_endstop_adj[axis] * Z_HOME_DIR <= 0) {
// 3306       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3307         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("delta_endstop_adj:");
// 3308       #endif
// 3309       do_homing_move(axis, delta_endstop_adj[axis] - 0.1 * Z_HOME_DIR);
// 3310     }
// 3311 
// 3312   #else
// 3313 
// 3314     // For cartesian/core machines,
// 3315     // set the axis to its home position
// 3316     axis_homed[Z_AXIS]=false;
??homeaxis_1:
        LDR.N    R7,??DataTable92_9
        MOVS     R0,#+0
        STRB     R0,[R7, #+6]
// 3317   if(!mksdlp.quick_stop_ena)
        LDRB     R0,[R6, #+3245]
        CMP      R0,#+0
        BNE.N    ??homeaxis_0
// 3318   	{
// 3319     set_axis_is_at_home(axis);
        MOV      R0,R4
          CFI FunCall _Z19set_axis_is_at_home8AxisEnum
        BL       _Z19set_axis_is_at_home8AxisEnum
// 3320     sync_plan_position();
          CFI FunCall _Z18sync_plan_positionv
        BL       _Z18sync_plan_positionv
// 3321     destination[axis] = current_position[axis];
        ADD      R0,R7,R5, LSL #+2
        LDR      R1,[R0, #+32]
        STR      R1,[R0, #+48]
// 3322   	}
// 3323     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3324       if (DEBUGGING(LEVELING)) DEBUG_POS("> AFTER set_axis_is_at_home", current_position);
// 3325     #endif
// 3326 
// 3327   #endif
// 3328 
// 3329   // Re-enable stealthChop if used. Disable diag1 pin on driver.
// 3330   #if ENABLED(SENSORLESS_HOMING)
// 3331     #if ENABLED(X_IS_TMC2130)
// 3332       if (axis == X_AXIS) tmc_sensorless_homing(stepperX, false);
// 3333     #endif
// 3334     #if ENABLED(Y_IS_TMC2130)
// 3335       if (axis == Y_AXIS) tmc_sensorless_homing(stepperY, false);
// 3336     #endif
// 3337   #endif
// 3338 
// 3339   // Put away the Z probe
// 3340   //#if HOMING_Z_WITH_PROBE
// 3341 #if 0      
// 3342     if (axis == Z_AXIS && STOW_PROBE()) return;
// 3343   #endif
// 3344 
// 3345   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3346     if (DEBUGGING(LEVELING)) {
// 3347       SERIAL_ECHOPAIR("<<< homeaxis(", axis_codes[axis]);
// 3348       SERIAL_CHAR(')');
// 3349       SERIAL_EOL();
// 3350     }
// 3351   #endif
// 3352 } // homeaxis()
??homeaxis_0:
        VPOP     {D8}
          CFI D8 SameValue
          CFI CFA R13+32
        POP      {R0,R4-R9,PC}    ;; return
          CFI EndBlock cfiBlock35
// 3353 
// 3354 #if ENABLED(FWRETRACT)
// 3355 
// 3356   /**
// 3357    * Retract or recover according to firmware settings
// 3358    *
// 3359    * This function handles retract/recover moves for G10 and G11,
// 3360    * plus auto-retract moves sent from G0/G1 when E-only moves are done.
// 3361    *
// 3362    * To simplify the logic, doubled retract/recover moves are ignored.
// 3363    *
// 3364    * Note: Z lift is done transparently to the planner. Aborting
// 3365    *       a print between G10 and G11 may corrupt the Z position.
// 3366    *
// 3367    * Note: Auto-retract will apply the set Z hop in addition to any Z hop
// 3368    *       included in the G-code. Use M207 Z0 to to prevent double hop.
// 3369    */
// 3370   void retract(const bool retracting
// 3371     #if EXTRUDERS > 1
// 3372       , bool swapping = false
// 3373     #endif
// 3374   ) {
// 3375 
// 3376     static float hop_amount = 0.0;  // Total amount lifted, for use in recover
// 3377 
// 3378     // Prevent two retracts or recovers in a row
// 3379     if (retracted[active_extruder] == retracting) return;
// 3380 
// 3381     // Prevent two swap-retract or recovers in a row
// 3382     #if EXTRUDERS > 1
// 3383       // Allow G10 S1 only after G10
// 3384       if (swapping && retracted_swap[active_extruder] == retracting) return;
// 3385       // G11 priority to recover the long retract if activated
// 3386       if (!retracting) swapping = retracted_swap[active_extruder];
// 3387     #else
// 3388       const bool swapping = false;
// 3389     #endif
// 3390 
// 3391     /* // debugging
// 3392       SERIAL_ECHOLNPAIR("retracting ", retracting);
// 3393       SERIAL_ECHOLNPAIR("swapping ", swapping);
// 3394       SERIAL_ECHOLNPAIR("active extruder ", active_extruder);
// 3395       for (uint8_t i = 0; i < EXTRUDERS; ++i) {
// 3396         SERIAL_ECHOPAIR("retracted[", i);
// 3397         SERIAL_ECHOLNPAIR("] ", retracted[i]);
// 3398         SERIAL_ECHOPAIR("retracted_swap[", i);
// 3399         SERIAL_ECHOLNPAIR("] ", retracted_swap[i]);
// 3400       }
// 3401       SERIAL_ECHOLNPAIR("current_position[z] ", current_position[Z_AXIS]);
// 3402       SERIAL_ECHOLNPAIR("hop_amount ", hop_amount);
// 3403     //*/
// 3404 
// 3405     const bool has_zhop = retract_zlift > 0.01;     // Is there a hop set?
// 3406     const float old_feedrate_mm_s = feedrate_mm_s;
// 3407 
// 3408     // The current position will be the destination for E and Z moves
// 3409     set_destination_from_current();
// 3410     stepper.synchronize();  // Wait for buffered moves to complete
// 3411 
// 3412     const float renormalize = 1.0 / planner.e_factor[active_extruder];
// 3413 
// 3414     if (retracting) {
// 3415       // Retract by moving from a faux E position back to the current E position
// 3416       feedrate_mm_s = retract_feedrate_mm_s;
// 3417       current_position[E_AXIS] += (swapping ? swap_retract_length : retract_length) * renormalize;
// 3418       sync_plan_position_e();
// 3419       prepare_move_to_destination();
// 3420 
// 3421       // Is a Z hop set, and has the hop not yet been done?
// 3422       if (has_zhop && !hop_amount) {
// 3423         hop_amount += retract_zlift;                        // Carriage is raised for retraction hop
// 3424         feedrate_mm_s = planner.max_feedrate_mm_s[Z_AXIS];  // Z feedrate to max
// 3425         current_position[Z_AXIS] -= retract_zlift;          // Pretend current pos is lower. Next move raises Z.
// 3426         SYNC_PLAN_POSITION_KINEMATIC();                     // Set the planner to the new position
// 3427         prepare_move_to_destination();                      // Raise up to the old current pos
// 3428         feedrate_mm_s = retract_feedrate_mm_s;              // Restore feedrate
// 3429       }
// 3430     }
// 3431     else {
// 3432       // If a hop was done and Z hasn't changed, undo the Z hop
// 3433       if (hop_amount) {
// 3434         current_position[Z_AXIS] += retract_zlift;          // Pretend current pos is lower. Next move raises Z.
// 3435         SYNC_PLAN_POSITION_KINEMATIC();                     // Set the planner to the new position
// 3436         feedrate_mm_s = planner.max_feedrate_mm_s[Z_AXIS];  // Z feedrate to max
// 3437         prepare_move_to_destination();                      // Raise up to the old current pos
// 3438         hop_amount = 0.0;                                   // Clear hop
// 3439       }
// 3440 
// 3441       // A retract multiplier has been added here to get faster swap recovery
// 3442       feedrate_mm_s = swapping ? swap_retract_recover_feedrate_mm_s : retract_recover_feedrate_mm_s;
// 3443 
// 3444       const float move_e = swapping ? swap_retract_length + swap_retract_recover_length : retract_length + retract_recover_length;
// 3445       current_position[E_AXIS] -= move_e * renormalize;
// 3446       sync_plan_position_e();
// 3447       prepare_move_to_destination();                        // Recover E
// 3448     }
// 3449 
// 3450     feedrate_mm_s = old_feedrate_mm_s;                      // Restore original feedrate
// 3451 
// 3452     retracted[active_extruder] = retracting;                // Active extruder now retracted / recovered
// 3453 
// 3454     // If swap retract/recover update the retracted_swap flag too
// 3455     #if EXTRUDERS > 1
// 3456       if (swapping) retracted_swap[active_extruder] = retracting;
// 3457     #endif
// 3458 
// 3459     /* // debugging
// 3460       SERIAL_ECHOLNPAIR("retracting ", retracting);
// 3461       SERIAL_ECHOLNPAIR("swapping ", swapping);
// 3462       SERIAL_ECHOLNPAIR("active_extruder ", active_extruder);
// 3463       for (uint8_t i = 0; i < EXTRUDERS; ++i) {
// 3464         SERIAL_ECHOPAIR("retracted[", i);
// 3465         SERIAL_ECHOLNPAIR("] ", retracted[i]);
// 3466         SERIAL_ECHOPAIR("retracted_swap[", i);
// 3467         SERIAL_ECHOLNPAIR("] ", retracted_swap[i]);
// 3468       }
// 3469       SERIAL_ECHOLNPAIR("current_position[z] ", current_position[Z_AXIS]);
// 3470       SERIAL_ECHOLNPAIR("hop_amount ", hop_amount);
// 3471     //*/
// 3472 
// 3473   }
// 3474 
// 3475 #endif // FWRETRACT
// 3476 
// 3477 #if ENABLED(MIXING_EXTRUDER)
// 3478 
// 3479   void normalize_mix() {
// 3480     float mix_total = 0.0;
// 3481     for (uint8_t i = 0; i < MIXING_STEPPERS; i++) mix_total += RECIPROCAL(mixing_factor[i]);
// 3482     // Scale all values if they don't add up to ~1.0
// 3483     if (!NEAR(mix_total, 1.0)) {
// 3484       SERIAL_PROTOCOLLNPGM("Warning: Mix factors must add up to 1.0. Scaling.");
// 3485       for (uint8_t i = 0; i < MIXING_STEPPERS; i++) mixing_factor[i] *= mix_total;
// 3486     }
// 3487   }
// 3488 
// 3489   #if ENABLED(DIRECT_MIXING_IN_G1)
// 3490     // Get mixing parameters from the GCode
// 3491     // The total "must" be 1.0 (but it will be normalized)
// 3492     // If no mix factors are given, the old mix is preserved
// 3493     void gcode_get_mix() {
// 3494       const char* mixing_codes = "ABCDHI";
// 3495       byte mix_bits = 0;
// 3496       for (uint8_t i = 0; i < MIXING_STEPPERS; i++) {
// 3497         if (parser.seenval(mixing_codes[i])) {
// 3498           SBI(mix_bits, i);
// 3499           float v = parser.value_float();
// 3500           NOLESS(v, 0.0);
// 3501           mixing_factor[i] = RECIPROCAL(v);
// 3502         }
// 3503       }
// 3504       // If any mixing factors were included, clear the rest
// 3505       // If none were included, preserve the last mix
// 3506       if (mix_bits) {
// 3507         for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
// 3508           if (!TEST(mix_bits, i)) mixing_factor[i] = 0.0;
// 3509         normalize_mix();
// 3510       }
// 3511     }
// 3512   #endif
// 3513 
// 3514 #endif
// 3515 
// 3516 /**
// 3517  * ***************************************************************************
// 3518  * ***************************** G-CODE HANDLING *****************************
// 3519  * ***************************************************************************
// 3520  */
// 3521 
// 3522 /**
// 3523  * Set XYZE destination and feedrate from the current GCode command
// 3524  *
// 3525  *  - Set destination from included axis codes
// 3526  *  - Set to current for missing axis codes
// 3527  *  - Set the feedrate, if included
// 3528  */

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock36 Using cfiCommon0
          CFI Function _Z21gcode_get_destinationv
        THUMB
// 3529 void gcode_get_destination() {
_Z21gcode_get_destinationv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
// 3530   LOOP_XYZE(i) {
        MOVS     R4,#+0
        LDR.N    R6,??DataTable92_9
        B.N      ??gcode_get_destination_0
// 3531     if (parser.seen(axis_codes[i])) {
// 3532       const float v = parser.value_axis_units((AxisEnum)i) + (axis_relative_modes[i] || relative_mode ? current_position[i] : 0);
// 3533       //destination[i] = i == E_AXIS ? v : LOGICAL_TO_NATIVE(v, i);
// 3534       destination[i] = v;
// 3535     }
// 3536     else
// 3537       destination[i] = current_position[i];
??gcode_get_destination_1:
        LDR      R0,[R5, #+32]
        STR      R0,[R5, #+48]
??gcode_get_destination_2:
        ADDS     R4,R4,#+1
??gcode_get_destination_0:
        CMP      R4,#+4
        BGE.N    ??gcode_get_destination_3
        ADD      R5,R6,R4, LSL #+2
        ADR.W    R0,axis_codes
        LDRSB    R0,[R4, R0]
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_get_destination_1
        MOV      R0,R4
        SXTB     R0,R0
          CFI FunCall _ZN11GCodeParser16value_axis_unitsE8AxisEnum
        BL       _ZN11GCodeParser16value_axis_unitsE8AxisEnum
        LDRB     R0,[R4, R6]
        LDRB     R1,[R6, #+19]
        ORRS     R0,R1,R0
        BEQ.N    ??gcode_get_destination_4
        VLDR     S1,[R5, #+32]
        B.N      ??gcode_get_destination_5
??gcode_get_destination_4:
        VLDR.W   S1,??DataTable91_1  ;; 0x0
??gcode_get_destination_5:
        VADD.F32 S0,S0,S1
        VSTR     S0,[R5, #+48]
        B.N      ??gcode_get_destination_2
// 3538   }
// 3539 
// 3540   if (parser.linearval('F') > 0.0)
??gcode_get_destination_3:
        VLDR.W   S0,??DataTable91_1  ;; 0x0
        MOVS     R0,#+70
          CFI FunCall _ZN11GCodeParser9linearvalEcf
        BL       _ZN11GCodeParser9linearvalEcf
        VCMP.F32 S0,#0.0
        FMSTAT   
        BLE.N    ??gcode_get_destination_6
// 3541     feedrate_mm_s = MMM_TO_MMS(parser.value_feedrate());
          CFI FunCall _ZN11GCodeParser14value_feedrateEv
        BL       _ZN11GCodeParser14value_feedrateEv
        VLDR.W   S1,??DataTable92  ;; 0x42700000
        VDIV.F32 S0,S0,S1
        MOV      R0,R6
        VSTR     S0,[R0, #+120]
// 3542 
// 3543   #if ENABLED(PRINTCOUNTER)
// 3544     if (!DEBUGGING(DRYRUN))
// 3545       print_job_timer.incFilamentUsed(destination[E_AXIS] - current_position[E_AXIS]);
// 3546   #endif
// 3547 
// 3548   // Get ABCDHI mixing factors
// 3549   #if ENABLED(MIXING_EXTRUDER) && ENABLED(DIRECT_MIXING_IN_G1)
// 3550     gcode_get_mix();
// 3551   #endif
// 3552 }
??gcode_get_destination_6:
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock36

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
axis_codes:
        DC8 88, 89, 90, 69
// 3553 
// 3554 #if ENABLED(HOST_KEEPALIVE_FEATURE)
// 3555 
// 3556   /**
// 3557    * Output a "busy" message at regular intervals
// 3558    * while the machine is not accepting commands.
// 3559    */
// 3560   void host_keepalive() {
// 3561     const millis_t ms = millis();
// 3562     if (host_keepalive_interval && busy_state != NOT_BUSY) {
// 3563       if (PENDING(ms, next_busy_signal_ms)) return;
// 3564       switch (busy_state) {
// 3565         case IN_HANDLER:
// 3566         case IN_PROCESS:
// 3567           SERIAL_ECHO_START();
// 3568           SERIAL_ECHOLNPGM(MSG_BUSY_PROCESSING);
// 3569           break;
// 3570         case PAUSED_FOR_USER:
// 3571           SERIAL_ECHO_START();
// 3572           SERIAL_ECHOLNPGM(MSG_BUSY_PAUSED_FOR_USER);
// 3573           break;
// 3574         case PAUSED_FOR_INPUT:
// 3575           SERIAL_ECHO_START();
// 3576           SERIAL_ECHOLNPGM(MSG_BUSY_PAUSED_FOR_INPUT);
// 3577           break;
// 3578         default:
// 3579           break;
// 3580       }
// 3581     }
// 3582     next_busy_signal_ms = ms + host_keepalive_interval * 1000UL;
// 3583   }
// 3584 
// 3585 #endif // HOST_KEEPALIVE_FEATURE
// 3586 
// 3587 
// 3588 /**************************************************
// 3589  ***************** GCode Handlers *****************
// 3590  **************************************************/
// 3591 
// 3592 #if ENABLED(NO_MOTION_BEFORE_HOMING)
// 3593   #define G0_G1_CONDITION !axis_unhomed_error(parser.seen('X'), parser.seen('Y'), parser.seen('Z'))
// 3594 #else
// 3595   #define G0_G1_CONDITION true
// 3596 #endif
// 3597 
// 3598 /**
// 3599  * G0, G1: Coordinated movement of X Y Z E axes
// 3600  */
// 3601 inline void gcode_G0_G1(
// 3602   #if IS_SCARA
// 3603     bool fast_move=false
// 3604   #endif
// 3605 ) {
// 3606   if (IsRunning() && G0_G1_CONDITION) {
// 3607     gcode_get_destination(); // For X Y Z E F
// 3608 
// 3609     #if ENABLED(FWRETRACT)
// 3610       if (MIN_AUTORETRACT <= MAX_AUTORETRACT) {
// 3611         // When M209 Autoretract is enabled, convert E-only moves to firmware retract/recover moves
// 3612         if (autoretract_enabled && parser.seen('E') && !(parser.seen('X') || parser.seen('Y') || parser.seen('Z'))) {
// 3613           const float echange = destination[E_AXIS] - current_position[E_AXIS];
// 3614           // Is this a retract or recover move?
// 3615           if (WITHIN(FABS(echange), MIN_AUTORETRACT, MAX_AUTORETRACT) && retracted[active_extruder] == (echange > 0.0)) {
// 3616             current_position[E_AXIS] = destination[E_AXIS]; // Hide a G1-based retract/recover from calculations
// 3617             sync_plan_position_e();                         // AND from the planner
// 3618             return retract(echange < 0.0);                  // Firmware-based retract/recover (double-retract ignored)
// 3619           }
// 3620         }
// 3621       }
// 3622     #endif // FWRETRACT
// 3623 
// 3624     #if IS_SCARA
// 3625       fast_move ? prepare_uninterpolated_move_to_destination() : prepare_move_to_destination();
// 3626     #else
// 3627       prepare_move_to_destination();
// 3628     #endif
// 3629 
// 3630     #if ENABLED(NANODLP_Z_SYNC)
// 3631       #if ENABLED(NANODLP_ALL_AXIS)
// 3632         #define _MOVE_SYNC true                 // For any move wait and output sync message
// 3633       #else
// 3634         #define _MOVE_SYNC parser.seenval('Z')  // Only for Z move
// 3635       #endif
// 3636       if (_MOVE_SYNC) {
// 3637         stepper.synchronize();
// 3638         SERIAL_ECHOLNPGM(MSG_Z_MOVE_COMP);
// 3639       }
// 3640     #endif
// 3641   }
// 3642 }
// 3643 
// 3644 /**
// 3645  * G2: Clockwise Arc
// 3646  * G3: Counterclockwise Arc
// 3647  *
// 3648  * This command has two forms: IJ-form and R-form.
// 3649  *
// 3650  *  - I specifies an X offset. J specifies a Y offset.
// 3651  *    At least one of the IJ parameters is required.
// 3652  *    X and Y can be omitted to do a complete circle.
// 3653  *    The given XY is not error-checked. The arc ends
// 3654  *     based on the angle of the destination.
// 3655  *    Mixing I or J with R will throw an error.
// 3656  *
// 3657  *  - R specifies the radius. X or Y is required.
// 3658  *    Omitting both X and Y will throw an error.
// 3659  *    X or Y must differ from the current XY.
// 3660  *    Mixing R with I or J will throw an error.
// 3661  *
// 3662  *  - P specifies the number of full circles to do
// 3663  *    before the specified arc move.
// 3664  *
// 3665  *  Examples:
// 3666  *
// 3667  *    G2 I10           ; CW circle centered at X+10
// 3668  *    G3 X20 Y12 R14   ; CCW circle with r=14 ending at X20 Y12
// 3669  */
// 3670 #if ENABLED(ARC_SUPPORT)
// 3671 
// 3672   inline void gcode_G2_G3(const bool clockwise) {
// 3673     #if ENABLED(NO_MOTION_BEFORE_HOMING)
// 3674       if (axis_unhomed_error()) return;
// 3675     #endif
// 3676 
// 3677     if (IsRunning()) {
// 3678 
// 3679       #if ENABLED(SF_ARC_FIX)
// 3680         const bool relative_mode_backup = relative_mode;
// 3681         relative_mode = true;
// 3682       #endif
// 3683 
// 3684       gcode_get_destination();
// 3685 
// 3686       #if ENABLED(SF_ARC_FIX)
// 3687         relative_mode = relative_mode_backup;
// 3688       #endif
// 3689 
// 3690       float arc_offset[2] = { 0.0, 0.0 };
// 3691       if (parser.seenval('R')) {
// 3692         const float r = parser.value_linear_units(),
// 3693                     p1 = current_position[X_AXIS], q1 = current_position[Y_AXIS],
// 3694                     p2 = destination[X_AXIS], q2 = destination[Y_AXIS];
// 3695         if (r && (p2 != p1 || q2 != q1)) {
// 3696           const float e = clockwise ^ (r < 0) ? -1 : 1,           // clockwise -1/1, counterclockwise 1/-1
// 3697                       dx = p2 - p1, dy = q2 - q1,                 // X and Y differences
// 3698                       d = HYPOT(dx, dy),                          // Linear distance between the points
// 3699                       h = SQRT(sq(r) - sq(d * 0.5)),              // Distance to the arc pivot-point
// 3700                       mx = (p1 + p2) * 0.5, my = (q1 + q2) * 0.5, // Point between the two points
// 3701                       sx = -dy / d, sy = dx / d,                  // Slope of the perpendicular bisector
// 3702                       cx = mx + e * h * sx, cy = my + e * h * sy; // Pivot-point of the arc
// 3703           arc_offset[0] = cx - p1;
// 3704           arc_offset[1] = cy - q1;
// 3705         }
// 3706       }
// 3707       else {
// 3708         if (parser.seenval('I')) arc_offset[0] = parser.value_linear_units();
// 3709         if (parser.seenval('J')) arc_offset[1] = parser.value_linear_units();
// 3710       }
// 3711 
// 3712       if (arc_offset[0] || arc_offset[1]) {
// 3713 
// 3714         #if ENABLED(ARC_P_CIRCLES)
// 3715           // P indicates number of circles to do
// 3716           int8_t circles_to_do = parser.byteval('P');
// 3717           if (!WITHIN(circles_to_do, 0, 100)) {
// 3718             SERIAL_ERROR_START();
// 3719             SERIAL_ERRORLNPGM(MSG_ERR_ARC_ARGS);
// 3720           }
// 3721           while (circles_to_do--)
// 3722             plan_arc(current_position, arc_offset, clockwise);
// 3723         #endif
// 3724 
// 3725         // Send the arc to the planner
// 3726         plan_arc(destination, arc_offset, clockwise);
// 3727         refresh_cmd_timeout();
// 3728       }
// 3729       else {
// 3730         // Bad arguments
// 3731         SERIAL_ERROR_START();
// 3732         SERIAL_ERRORLNPGM(MSG_ERR_ARC_ARGS);
// 3733       }
// 3734     }
// 3735   }
// 3736 
// 3737 #endif // ARC_SUPPORT
// 3738 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock37 Using cfiCommon0
          CFI Function _Z5dwellm
        THUMB
// 3739 void dwell(millis_t time) {
_Z5dwellm:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
// 3740   refresh_cmd_timeout();
          CFI FunCall _Z19refresh_cmd_timeoutv
        BL       _Z19refresh_cmd_timeoutv
// 3741   time += previous_cmd_ms;
        LDR.W    R0,??DataTable106
        LDR      R0,[R0, #+0]
        ADDS     R4,R0,R4
        B.N      ??dwell_0
// 3742   while (PENDING(millis(), time)) idle();
??dwell_1:
          CFI FunCall _Z4idlev
        BL       _Z4idlev
??dwell_0:
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        SUBS     R0,R0,R4
        BMI.N    ??dwell_1
// 3743 }
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock37
// 3744 
// 3745 /**
// 3746  * G4: Dwell S<seconds> or P<milliseconds>
// 3747  */
// 3748 inline void gcode_G4() {
// 3749   millis_t dwell_ms = 0;
// 3750 
// 3751   if (parser.seenval('P')) dwell_ms = parser.value_millis(); // milliseconds to wait
// 3752   if (parser.seenval('S')) dwell_ms = parser.value_millis_from_seconds(); // seconds to wait
// 3753 
// 3754   stepper.synchronize();
// 3755   #if ENABLED(NANODLP_Z_SYNC)
// 3756     SERIAL_ECHOLNPGM(MSG_Z_MOVE_COMP);
// 3757   #endif
// 3758 
// 3759   if (!lcd_hasstatus()) LCD_MESSAGEPGM(MSG_DWELL);
// 3760 
// 3761   dwell(dwell_ms);
// 3762 }
// 3763 
// 3764 #if ENABLED(BEZIER_CURVE_SUPPORT)
// 3765 
// 3766   /**
// 3767    * Parameters interpreted according to:
// 3768    * http://linuxcnc.org/docs/2.6/html/gcode/gcode.html#sec:G5-Cubic-Spline
// 3769    * However I, J omission is not supported at this point; all
// 3770    * parameters can be omitted and default to zero.
// 3771    */
// 3772 
// 3773   /**
// 3774    * G5: Cubic B-spline
// 3775    */
// 3776   inline void gcode_G5() {
// 3777     #if ENABLED(NO_MOTION_BEFORE_HOMING)
// 3778       if (axis_unhomed_error()) return;
// 3779     #endif
// 3780 
// 3781     if (IsRunning()) {
// 3782 
// 3783       #if ENABLED(CNC_WORKSPACE_PLANES)
// 3784         if (workspace_plane != PLANE_XY) {
// 3785           SERIAL_ERROR_START();
// 3786           SERIAL_ERRORLNPGM(MSG_ERR_BAD_PLANE_MODE);
// 3787           return;
// 3788         }
// 3789       #endif
// 3790 
// 3791       gcode_get_destination();
// 3792 
// 3793       const float offset[] = {
// 3794         parser.linearval('I'),
// 3795         parser.linearval('J'),
// 3796         parser.linearval('P'),
// 3797         parser.linearval('Q')
// 3798       };
// 3799 
// 3800       plan_cubic_move(offset);
// 3801     }
// 3802   }
// 3803 
// 3804 #endif // BEZIER_CURVE_SUPPORT
// 3805 
// 3806 #if ENABLED(FWRETRACT)
// 3807 
// 3808   /**
// 3809    * G10 - Retract filament according to settings of M207
// 3810    */
// 3811   inline void gcode_G10() {
// 3812     #if EXTRUDERS > 1
// 3813       const bool rs = parser.boolval('S');
// 3814       retracted_swap[active_extruder] = rs; // Use 'S' for swap, default to false
// 3815     #endif
// 3816     retract(true
// 3817       #if EXTRUDERS > 1
// 3818         , rs
// 3819       #endif
// 3820     );
// 3821   }
// 3822 
// 3823   /**
// 3824    * G11 - Recover filament according to settings of M208
// 3825    */
// 3826   inline void gcode_G11() { retract(false); }
// 3827 
// 3828 #endif // FWRETRACT
// 3829 
// 3830 #if ENABLED(NOZZLE_CLEAN_FEATURE)
// 3831   /**
// 3832    * G12: Clean the nozzle
// 3833    */
// 3834   inline void gcode_G12() {
// 3835     // Don't allow nozzle cleaning without homing first
// 3836     if (axis_unhomed_error()) return;
// 3837 
// 3838     const uint8_t pattern = parser.ushortval('P', 0),
// 3839                   strokes = parser.ushortval('S', NOZZLE_CLEAN_STROKES),
// 3840                   objects = parser.ushortval('T', NOZZLE_CLEAN_TRIANGLES);
// 3841     const float radius = parser.floatval('R', NOZZLE_CLEAN_CIRCLE_RADIUS);
// 3842 
// 3843     Nozzle::clean(pattern, strokes, radius, objects);
// 3844   }
// 3845 #endif
// 3846 
// 3847 #if ENABLED(CNC_WORKSPACE_PLANES)
// 3848 
// 3849   inline void report_workspace_plane() {
// 3850     SERIAL_ECHO_START();
// 3851     SERIAL_ECHOPGM("Workspace Plane ");
// 3852     serialprintPGM(
// 3853       workspace_plane == PLANE_YZ ? PSTR("YZ\n") :
// 3854       workspace_plane == PLANE_ZX ? PSTR("ZX\n") :
// 3855                                     PSTR("XY\n")
// 3856     );
// 3857   }
// 3858 
// 3859   inline void set_workspace_plane(const WorkspacePlane plane) {
// 3860     workspace_plane = plane;
// 3861     if (DEBUGGING(INFO)) report_workspace_plane();
// 3862   }
// 3863 
// 3864   /**
// 3865    * G17: Select Plane XY
// 3866    * G18: Select Plane ZX
// 3867    * G19: Select Plane YZ
// 3868    */
// 3869   inline void gcode_G17() { set_workspace_plane(PLANE_XY); }
// 3870   inline void gcode_G18() { set_workspace_plane(PLANE_ZX); }
// 3871   inline void gcode_G19() { set_workspace_plane(PLANE_YZ); }
// 3872 
// 3873 #endif // CNC_WORKSPACE_PLANES
// 3874 
// 3875 #if ENABLED(CNC_COORDINATE_SYSTEMS)
// 3876 
// 3877   /**
// 3878    * Select a coordinate system and update the workspace offset.
// 3879    * System index -1 is used to specify machine-native.
// 3880    */
// 3881   bool select_coordinate_system(const int8_t _new) {
// 3882     if (active_coordinate_system == _new) return false;
// 3883     float old_offset[XYZ] = { 0 }, new_offset[XYZ] = { 0 };
// 3884     if (WITHIN(active_coordinate_system, 0, MAX_COORDINATE_SYSTEMS - 1))
// 3885       COPY(old_offset, coordinate_system[active_coordinate_system]);
// 3886     if (WITHIN(_new, 0, MAX_COORDINATE_SYSTEMS - 1))
// 3887       COPY(new_offset, coordinate_system[_new]);
// 3888     active_coordinate_system = _new;
// 3889     LOOP_XYZ(i) {
// 3890       const float diff = new_offset[i] - old_offset[i];
// 3891       if (diff) {
// 3892         position_shift[i] += diff;
// 3893         update_software_endstops((AxisEnum)i);
// 3894       }
// 3895     }
// 3896     return true;
// 3897   }
// 3898 
// 3899   /**
// 3900    * In CNC G-code G53 is like a modifier
// 3901    * It precedes a movement command (or other modifiers) on the same line.
// 3902    * This is the first command to use parser.chain() to make this possible.
// 3903    */
// 3904   inline void gcode_G53() {
// 3905     // If this command has more following...
// 3906     if (parser.chain()) {
// 3907       const int8_t _system = active_coordinate_system;
// 3908       active_coordinate_system = -1;
// 3909       process_parsed_command();
// 3910       active_coordinate_system = _system;
// 3911     }
// 3912   }
// 3913 
// 3914   /**
// 3915    * G54-G59.3: Select a new workspace
// 3916    *
// 3917    * A workspace is an XYZ offset to the machine native space.
// 3918    * All workspaces default to 0,0,0 at start, or with EEPROM
// 3919    * support they may be restored from a previous session.
// 3920    *
// 3921    * G92 is used to set the current workspace's offset.
// 3922    */
// 3923   inline void gcode_G54_59(uint8_t subcode=0) {
// 3924     const int8_t _space = parser.codenum - 54 + subcode;
// 3925     if (select_coordinate_system(_space)) {
// 3926       SERIAL_PROTOCOLLNPAIR("Select workspace ", _space);
// 3927       report_current_position();
// 3928     }
// 3929   }
// 3930   FORCE_INLINE void gcode_G54() { gcode_G54_59(); }
// 3931   FORCE_INLINE void gcode_G55() { gcode_G54_59(); }
// 3932   FORCE_INLINE void gcode_G56() { gcode_G54_59(); }
// 3933   FORCE_INLINE void gcode_G57() { gcode_G54_59(); }
// 3934   FORCE_INLINE void gcode_G58() { gcode_G54_59(); }
// 3935   FORCE_INLINE void gcode_G59() { gcode_G54_59(parser.subcode); }
// 3936 
// 3937 #endif
// 3938 
// 3939 #if ENABLED(INCH_MODE_SUPPORT)
// 3940   /**
// 3941    * G20: Set input mode to inches
// 3942    */
// 3943   inline void gcode_G20() { parser.set_input_linear_units(LINEARUNIT_INCH); }
// 3944 
// 3945   /**
// 3946    * G21: Set input mode to millimeters
// 3947    */
// 3948   inline void gcode_G21() { parser.set_input_linear_units(LINEARUNIT_MM); }
// 3949 #endif
// 3950 
// 3951 #if ENABLED(NOZZLE_PARK_FEATURE)
// 3952   /**
// 3953    * G27: Park the nozzle
// 3954    */
// 3955   inline void gcode_G27() {
// 3956     // Don't allow nozzle parking without homing first
// 3957     if (axis_unhomed_error()) return;
// 3958     Nozzle::park(parser.ushortval('P'));
// 3959   }
// 3960 #endif // NOZZLE_PARK_FEATURE
// 3961 
// 3962 #if ENABLED(QUICK_HOME)
// 3963 
// 3964   static void quick_home_xy() {
// 3965 
// 3966     // Pretend the current position is 0,0
// 3967     current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
// 3968     sync_plan_position();
// 3969 
// 3970     const int x_axis_home_dir =
// 3971       #if ENABLED(DUAL_X_CARRIAGE)
// 3972         x_home_dir(active_extruder)
// 3973       #else
// 3974         home_dir(X_AXIS)
// 3975       #endif
// 3976     ;
// 3977 
// 3978     const float mlx = max_length(X_AXIS),
// 3979                 mly = max_length(Y_AXIS),
// 3980                 mlratio = mlx > mly ? mly / mlx : mlx / mly,
// 3981                 fr_mm_s = min(homing_feedrate_mm_s[X_AXIS], homing_feedrate_mm_s[Y_AXIS]) * SQRT(sq(mlratio) + 1.0);
// 3982 
// 3983     do_blocking_move_to_xy(1.5 * mlx * x_axis_home_dir, 1.5 * mly * home_dir(Y_AXIS), fr_mm_s);
// 3984     endstops.hit_on_purpose(); // clear endstop hit flags
// 3985     current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
// 3986   }
// 3987 
// 3988 #endif // QUICK_HOME
// 3989 
// 3990 #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3991 
// 3992   void log_machine_info() {
// 3993     SERIAL_ECHOPGM("Machine Type: ");
// 3994     #if ENABLED(DELTA)
// 3995       SERIAL_ECHOLNPGM("Delta");
// 3996     #elif IS_SCARA
// 3997       SERIAL_ECHOLNPGM("SCARA");
// 3998     #elif IS_CORE
// 3999       SERIAL_ECHOLNPGM("Core");
// 4000     #else
// 4001       SERIAL_ECHOLNPGM("Cartesian");
// 4002     #endif
// 4003 
// 4004     SERIAL_ECHOPGM("Probe: ");
// 4005     #if ENABLED(PROBE_MANUALLY)
// 4006       SERIAL_ECHOLNPGM("PROBE_MANUALLY");
// 4007     #elif ENABLED(FIX_MOUNTED_PROBE)
// 4008       SERIAL_ECHOLNPGM("FIX_MOUNTED_PROBE");
// 4009     #elif ENABLED(BLTOUCH)
// 4010       SERIAL_ECHOLNPGM("BLTOUCH");
// 4011     #elif HAS_Z_SERVO_ENDSTOP
// 4012       SERIAL_ECHOLNPGM("SERVO PROBE");
// 4013     #elif ENABLED(Z_PROBE_SLED)
// 4014       SERIAL_ECHOLNPGM("Z_PROBE_SLED");
// 4015     #elif ENABLED(Z_PROBE_ALLEN_KEY)
// 4016       SERIAL_ECHOLNPGM("Z_PROBE_ALLEN_KEY");
// 4017     #else
// 4018       SERIAL_ECHOLNPGM("NONE");
// 4019     #endif
// 4020 
// 4021     #if HAS_BED_PROBE
// 4022       SERIAL_ECHOPAIR("Probe Offset X:", X_PROBE_OFFSET_FROM_EXTRUDER);
// 4023       SERIAL_ECHOPAIR(" Y:", Y_PROBE_OFFSET_FROM_EXTRUDER);
// 4024       SERIAL_ECHOPAIR(" Z:", zprobe_zoffset);
// 4025       #if X_PROBE_OFFSET_FROM_EXTRUDER > 0
// 4026         SERIAL_ECHOPGM(" (Right");
// 4027       #elif X_PROBE_OFFSET_FROM_EXTRUDER < 0
// 4028         SERIAL_ECHOPGM(" (Left");
// 4029       #elif Y_PROBE_OFFSET_FROM_EXTRUDER != 0
// 4030         SERIAL_ECHOPGM(" (Middle");
// 4031       #else
// 4032         SERIAL_ECHOPGM(" (Aligned With");
// 4033       #endif
// 4034       #if Y_PROBE_OFFSET_FROM_EXTRUDER > 0
// 4035         SERIAL_ECHOPGM("-Back");
// 4036       #elif Y_PROBE_OFFSET_FROM_EXTRUDER < 0
// 4037         SERIAL_ECHOPGM("-Front");
// 4038       #elif X_PROBE_OFFSET_FROM_EXTRUDER != 0
// 4039         SERIAL_ECHOPGM("-Center");
// 4040       #endif
// 4041       if (zprobe_zoffset < 0)
// 4042         SERIAL_ECHOPGM(" & Below");
// 4043       else if (zprobe_zoffset > 0)
// 4044         SERIAL_ECHOPGM(" & Above");
// 4045       else
// 4046         SERIAL_ECHOPGM(" & Same Z as");
// 4047       SERIAL_ECHOLNPGM(" Nozzle)");
// 4048     #endif
// 4049 
// 4050     #if HAS_ABL
// 4051       SERIAL_ECHOPGM("Auto Bed Leveling: ");
// 4052       #if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 4053         SERIAL_ECHOPGM("LINEAR");
// 4054       #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 4055         SERIAL_ECHOPGM("BILINEAR");
// 4056       #elif ENABLED(AUTO_BED_LEVELING_3POINT)
// 4057         SERIAL_ECHOPGM("3POINT");
// 4058       #elif ENABLED(AUTO_BED_LEVELING_UBL)
// 4059         SERIAL_ECHOPGM("UBL");
// 4060       #endif
// 4061       if (planner.leveling_active) {
// 4062         SERIAL_ECHOLNPGM(" (enabled)");
// 4063         #if ABL_PLANAR
// 4064           const float diff[XYZ] = {
// 4065             stepper.get_axis_position_mm(X_AXIS) - current_position[X_AXIS],
// 4066             stepper.get_axis_position_mm(Y_AXIS) - current_position[Y_AXIS],
// 4067             stepper.get_axis_position_mm(Z_AXIS) - current_position[Z_AXIS]
// 4068           };
// 4069           SERIAL_ECHOPGM("ABL Adjustment X");
// 4070           if (diff[X_AXIS] > 0) SERIAL_CHAR('+');
// 4071           SERIAL_ECHO(diff[X_AXIS]);
// 4072           SERIAL_ECHOPGM(" Y");
// 4073           if (diff[Y_AXIS] > 0) SERIAL_CHAR('+');
// 4074           SERIAL_ECHO(diff[Y_AXIS]);
// 4075           SERIAL_ECHOPGM(" Z");
// 4076           if (diff[Z_AXIS] > 0) SERIAL_CHAR('+');
// 4077           SERIAL_ECHO(diff[Z_AXIS]);
// 4078         #elif ENABLED(AUTO_BED_LEVELING_UBL)
// 4079           SERIAL_ECHOPAIR("UBL Adjustment Z", stepper.get_axis_position_mm(Z_AXIS) - current_position[Z_AXIS]);
// 4080         #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 4081           SERIAL_ECHOPAIR("ABL Adjustment Z", bilinear_z_offset(current_position));
// 4082         #endif
// 4083       }
// 4084       else
// 4085         SERIAL_ECHOLNPGM(" (disabled)");
// 4086 
// 4087       SERIAL_EOL();
// 4088 
// 4089     #elif ENABLED(MESH_BED_LEVELING)
// 4090 
// 4091       SERIAL_ECHOPGM("Mesh Bed Leveling");
// 4092       if (planner.leveling_active) {
// 4093         float rz = current_position[Z_AXIS];
// 4094         planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], rz);
// 4095         SERIAL_ECHOLNPGM(" (enabled)");
// 4096         SERIAL_ECHOPAIR("MBL Adjustment Z", rz);
// 4097       }
// 4098       else
// 4099         SERIAL_ECHOPGM(" (disabled)");
// 4100 
// 4101       SERIAL_EOL();
// 4102 
// 4103     #endif // MESH_BED_LEVELING
// 4104   }
// 4105 
// 4106 #endif // DEBUG_LEVELING_FEATURE
// 4107 
// 4108 #if ENABLED(DELTA)
// 4109 
// 4110   /**
// 4111    * A delta can only safely home all axes at the same time
// 4112    * This is like quick_home_xy() but for 3 towers.
// 4113    */
// 4114   inline bool home_delta() {
// 4115     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4116       if (DEBUGGING(LEVELING)) DEBUG_POS(">>> home_delta", current_position);
// 4117     #endif
// 4118     // Init the current position of all carriages to 0,0,0
// 4119     ZERO(current_position);
// 4120     sync_plan_position();
// 4121 
// 4122     // Move all carriages together linearly until an endstop is hit.
// 4123     current_position[X_AXIS] = current_position[Y_AXIS] = current_position[Z_AXIS] = (delta_height + 10);
// 4124     feedrate_mm_s = homing_feedrate_mm_s[X_AXIS];
// 4125     buffer_line_to_current_position();
// 4126     stepper.synchronize();
// 4127 
// 4128     // If an endstop was not hit, then damage can occur if homing is continued.
// 4129     // This can occur if the delta height not set correctly.
// 4130     if (!(Endstops::endstop_hit_bits & (_BV(X_MAX) | _BV(Y_MAX) | _BV(Z_MAX)))) {
// 4131       LCD_MESSAGEPGM(MSG_ERR_HOMING_FAILED);
// 4132       SERIAL_ERROR_START();
// 4133       SERIAL_ERRORLNPGM(MSG_ERR_HOMING_FAILED);
// 4134       return false;
// 4135     }
// 4136 
// 4137     endstops.hit_on_purpose(); // clear endstop hit flags
// 4138 
// 4139     // At least one carriage has reached the top.
// 4140     // Now re-home each carriage separately.
// 4141     HOMEAXIS(A);
// 4142     HOMEAXIS(B);
// 4143     HOMEAXIS(C);
// 4144 
// 4145     // Set all carriages to their home positions
// 4146     // Do this here all at once for Delta, because
// 4147     // XYZ isn't ABC. Applying this per-tower would
// 4148     // give the impression that they are the same.
// 4149     LOOP_XYZ(i) set_axis_is_at_home((AxisEnum)i);
// 4150 
// 4151     SYNC_PLAN_POSITION_KINEMATIC();
// 4152 
// 4153     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4154       if (DEBUGGING(LEVELING)) DEBUG_POS("<<< home_delta", current_position);
// 4155     #endif
// 4156 
// 4157     return true;
// 4158   }
// 4159 
// 4160 #endif // DELTA
// 4161 
// 4162 #if ENABLED(Z_SAFE_HOMING)
// 4163 
// 4164   inline void home_z_safely() {
// 4165 
// 4166     // Disallow Z homing if X or Y are unknown
// 4167     if (!axis_known_position[X_AXIS] || !axis_known_position[Y_AXIS]) {
// 4168       LCD_MESSAGEPGM(MSG_ERR_Z_HOMING);
// 4169       SERIAL_ECHO_START();
// 4170       SERIAL_ECHOLNPGM(MSG_ERR_Z_HOMING);
// 4171       return;
// 4172     }
// 4173 
// 4174     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4175       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Z_SAFE_HOMING >>>");
// 4176     #endif
// 4177 
// 4178     SYNC_PLAN_POSITION_KINEMATIC();
// 4179 
// 4180     /**
// 4181      * Move the Z probe (or just the nozzle) to the safe homing point
// 4182      */
// 4183     destination[X_AXIS] = Z_SAFE_HOMING_X_POINT;
// 4184     destination[Y_AXIS] = Z_SAFE_HOMING_Y_POINT;
// 4185     destination[Z_AXIS] = current_position[Z_AXIS]; // Z is already at the right height
// 4186 
// 4187     #if HOMING_Z_WITH_PROBE
// 4188       destination[X_AXIS] -= X_PROBE_OFFSET_FROM_EXTRUDER;
// 4189       destination[Y_AXIS] -= Y_PROBE_OFFSET_FROM_EXTRUDER;
// 4190     #endif
// 4191 
// 4192     if (position_is_reachable(destination[X_AXIS], destination[Y_AXIS])) {
// 4193 
// 4194       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4195         if (DEBUGGING(LEVELING)) DEBUG_POS("Z_SAFE_HOMING", destination);
// 4196       #endif
// 4197 
// 4198       // This causes the carriage on Dual X to unpark
// 4199       #if ENABLED(DUAL_X_CARRIAGE)
// 4200         active_extruder_parked = false;
// 4201       #endif
// 4202 
// 4203       do_blocking_move_to_xy(destination[X_AXIS], destination[Y_AXIS]);
// 4204       HOMEAXIS(Z);
// 4205     }
// 4206     else {
// 4207       LCD_MESSAGEPGM(MSG_ZPROBE_OUT);
// 4208       SERIAL_ECHO_START();
// 4209       SERIAL_ECHOLNPGM(MSG_ZPROBE_OUT);
// 4210     }
// 4211 
// 4212     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4213       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< Z_SAFE_HOMING");
// 4214     #endif
// 4215   }
// 4216 
// 4217 #endif // Z_SAFE_HOMING
// 4218 
// 4219 #if ENABLED(PROBE_MANUALLY)
// 4220   bool g29_in_progress = false;
// 4221 #else
// 4222   constexpr bool g29_in_progress = false;
// 4223 #endif
// 4224 
// 4225 /**
// 4226  * G28: Home all axes according to settings
// 4227  *
// 4228  * Parameters
// 4229  *
// 4230  *  None  Home to all axes with no parameters.
// 4231  *        With QUICK_HOME enabled XY will home together, then Z.
// 4232  *
// 4233  * Cartesian parameters
// 4234  *
// 4235  *  X   Home to the X endstop
// 4236  *  Y   Home to the Y endstop
// 4237  *  Z   Home to the Z endstop
// 4238  *
// 4239  */
// 4240 inline void gcode_G28(const bool always_home_all) {
// 4241 
// 4242   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4243     if (DEBUGGING(LEVELING)) {
// 4244       SERIAL_ECHOLNPGM(">>> gcode_G28");
// 4245       log_machine_info();
// 4246     }
// 4247   #endif
// 4248 
// 4249   // Wait for planner moves to finish!
// 4250   stepper.synchronize();
// 4251 
// 4252   // Cancel the active G29 session
// 4253   #if ENABLED(PROBE_MANUALLY)
// 4254     g29_in_progress = false;
// 4255   #endif
// 4256 
// 4257   // Disable the leveling matrix before homing
// 4258   #if HAS_LEVELING
// 4259     #if ENABLED(AUTO_BED_LEVELING_UBL)
// 4260       const bool ubl_state_at_entry = planner.leveling_active;
// 4261     #endif
// 4262     set_bed_leveling_enabled(false);
// 4263   #endif
// 4264 
// 4265   #if ENABLED(CNC_WORKSPACE_PLANES)
// 4266     workspace_plane = PLANE_XY;
// 4267   #endif
// 4268 
// 4269   // Always home with tool 0 active
// 4270   #if HOTENDS > 1
// 4271     const uint8_t old_tool_index = active_extruder;
// 4272     tool_change(0, 0, true);
// 4273   #endif
// 4274 
// 4275   #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
// 4276     extruder_duplication_enabled = false;
// 4277   #endif
// 4278 
// 4279   setup_for_endstop_or_probe_move();
// 4280   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4281     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> endstops.enable(true)");
// 4282   #endif
// 4283   endstops.enable(true); // Enable endstops for next homing move
// 4284 
// 4285   #if ENABLED(DELTA)
// 4286 
// 4287     home_delta();
// 4288     UNUSED(always_home_all);
// 4289 
// 4290   #else // NOT DELTA
// 4291 
// 4292     const bool homeX = always_home_all || parser.seen('X'),
// 4293                homeY = always_home_all || parser.seen('Y'),
// 4294                homeZ = always_home_all || parser.seen('Z'),
// 4295                home_all = (!homeX && !homeY && !homeZ) || (homeX && homeY && homeZ);
// 4296 
// 4297     set_destination_from_current();
// 4298 
// 4299     //#if Z_HOME_DIR > 0  // If homing away from BED do Z first
// 4300 if(Z_HOME_DIR > 0)
// 4301 {
// 4302       if (home_all || homeZ) {
// 4303         HOMEAXIS(Z);
// 4304         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4305           if (DEBUGGING(LEVELING)) DEBUG_POS("> HOMEAXIS(Z)", current_position);
// 4306         #endif
// 4307       }
// 4308 }
// 4309     //#endif
// 4310 
// 4311     if (home_all || homeX || homeY) {
// 4312       // Raise Z before homing any other axes and z is not already high enough (never lower z)
// 4313       destination[Z_AXIS] = Z_HOMING_HEIGHT;
// 4314       if (destination[Z_AXIS] > current_position[Z_AXIS]) {
// 4315 
// 4316         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4317           if (DEBUGGING(LEVELING))
// 4318             SERIAL_ECHOLNPAIR("Raise Z (before homing) to ", destination[Z_AXIS]);
// 4319         #endif
// 4320 
// 4321         do_blocking_move_to_z(destination[Z_AXIS]);
// 4322       }
// 4323     }
// 4324 
// 4325     #if ENABLED(QUICK_HOME)
// 4326 
// 4327       if (home_all || (homeX && homeY)) quick_home_xy();
// 4328 
// 4329     #endif
// 4330 
// 4331     #if ENABLED(HOME_Y_BEFORE_X)
// 4332 
// 4333       // Home Y
// 4334       if (home_all || homeY) {
// 4335         HOMEAXIS(Y);
// 4336         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4337           if (DEBUGGING(LEVELING)) DEBUG_POS("> homeY", current_position);
// 4338         #endif
// 4339       }
// 4340 
// 4341     #endif
// 4342 
// 4343     // Home X
// 4344     if (home_all || homeX) {
// 4345 
// 4346       #if ENABLED(DUAL_X_CARRIAGE)
// 4347 
// 4348         // Always home the 2nd (right) extruder first
// 4349         active_extruder = 1;
// 4350         HOMEAXIS(X);
// 4351 
// 4352         // Remember this extruder's position for later tool change
// 4353         inactive_extruder_x_pos = current_position[X_AXIS];
// 4354 
// 4355         // Home the 1st (left) extruder
// 4356         active_extruder = 0;
// 4357         HOMEAXIS(X);
// 4358 
// 4359         // Consider the active extruder to be parked
// 4360         COPY(raised_parked_position, current_position);
// 4361         delayed_move_time = 0;
// 4362         active_extruder_parked = true;
// 4363 
// 4364       #else
// 4365 
// 4366         HOMEAXIS(X);
// 4367 
// 4368       #endif
// 4369 
// 4370       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4371         if (DEBUGGING(LEVELING)) DEBUG_POS("> homeX", current_position);
// 4372       #endif
// 4373     }
// 4374 
// 4375     #if DISABLED(HOME_Y_BEFORE_X)
// 4376       // Home Y
// 4377       if (home_all || homeY) {
// 4378         HOMEAXIS(Y);
// 4379         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4380           if (DEBUGGING(LEVELING)) DEBUG_POS("> homeY", current_position);
// 4381         #endif
// 4382       }
// 4383     #endif
// 4384 
// 4385     // Home Z last if homing towards the bed
// 4386     //#if Z_HOME_DIR < 0
// 4387     if(Z_HOME_DIR < 0)
// 4388     {
// 4389       if (home_all || homeZ) {
// 4390         #if ENABLED(Z_SAFE_HOMING)
// 4391           home_z_safely();
// 4392         #else
// 4393           HOMEAXIS(Z);
// 4394         #endif
// 4395         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4396           if (DEBUGGING(LEVELING)) DEBUG_POS("> (home_all || homeZ) > final", current_position);
// 4397         #endif
// 4398       } // home_all || homeZ
// 4399     }
// 4400     //#endif // Z_HOME_DIR < 0
// 4401 
// 4402     SYNC_PLAN_POSITION_KINEMATIC();
// 4403 
// 4404   #endif // !DELTA (gcode_G28)
// 4405 
// 4406   endstops.not_homing();
// 4407 
// 4408   #if ENABLED(DELTA) && ENABLED(DELTA_HOME_TO_SAFE_ZONE)
// 4409     // move to a height where we can use the full xy-area
// 4410     do_blocking_move_to_z(delta_clip_start_height);
// 4411   #endif
// 4412 
// 4413   #if ENABLED(AUTO_BED_LEVELING_UBL)
// 4414     set_bed_leveling_enabled(ubl_state_at_entry);
// 4415   #endif
// 4416 
// 4417   clean_up_after_endstop_or_probe_move();
// 4418 
// 4419   // Restore the active tool after homing
// 4420   #if HOTENDS > 1
// 4421     #if ENABLED(PARKING_EXTRUDER)
// 4422       #define NO_FETCH false // fetch the previous toolhead
// 4423     #else
// 4424       #define NO_FETCH true
// 4425     #endif
// 4426     tool_change(old_tool_index, 0, NO_FETCH);
// 4427   #endif
// 4428 
// 4429   lcd_refresh();
// 4430 
// 4431   report_current_position();
// 4432 
// 4433   #if ENABLED(NANODLP_Z_SYNC)
// 4434     #if ENABLED(NANODLP_ALL_AXIS)
// 4435       #define _HOME_SYNC true                 // For any axis, output sync text.
// 4436     #else
// 4437       #define _HOME_SYNC (home_all || homeZ)  // Only for Z-axis
// 4438     #endif
// 4439     if (_HOME_SYNC)
// 4440       SERIAL_ECHOLNPGM(MSG_Z_MOVE_COMP);
// 4441   #endif
// 4442 
// 4443   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4444     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< gcode_G28");
// 4445   #endif
// 4446 } // G28
// 4447 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock38 Using cfiCommon0
          CFI Function _Z13home_all_axesv
        THUMB
// 4448 void home_all_axes() { gcode_G28(true); }
_Z13home_all_axesv:
        MOVS     R0,#+1
          CFI FunCall _Z9gcode_G28b
        B.W      _Z9gcode_G28b
          CFI EndBlock cfiBlock38
// 4449 
// 4450 #if HAS_PROBING_PROCEDURE
// 4451 
// 4452   void out_of_range_error(const char* p_edge) {
// 4453     SERIAL_PROTOCOLPGM("?Probe ");
// 4454     serialprintPGM(p_edge);
// 4455     SERIAL_PROTOCOLLNPGM(" position out of range.");
// 4456   }
// 4457 
// 4458 #endif
// 4459 
// 4460 #if ENABLED(MESH_BED_LEVELING) || ENABLED(PROBE_MANUALLY)
// 4461 
// 4462   #if ENABLED(LCD_BED_LEVELING)
// 4463     //extern 
// 4464     bool lcd_wait_for_move;
// 4465   #else
// 4466     constexpr bool lcd_wait_for_move = false;
// 4467   #endif
// 4468 
// 4469   inline void _manual_goto_xy(const float &rx, const float &ry) {
// 4470 
// 4471     #if MANUAL_PROBE_HEIGHT > 0
// 4472       const float prev_z = current_position[Z_AXIS];
// 4473       do_blocking_move_to(rx, ry, MANUAL_PROBE_HEIGHT);
// 4474       do_blocking_move_to_z(prev_z);
// 4475     #else
// 4476       do_blocking_move_to_xy(rx, ry);
// 4477     #endif
// 4478 
// 4479     current_position[X_AXIS] = rx;
// 4480     current_position[Y_AXIS] = ry;
// 4481 
// 4482     #if ENABLED(LCD_BED_LEVELING)
// 4483       lcd_wait_for_move = false;
// 4484     #endif
// 4485   }
// 4486 
// 4487 #endif
// 4488 
// 4489 #if ENABLED(MESH_BED_LEVELING)
// 4490 
// 4491   // Save 130 bytes with non-duplication of PSTR
// 4492   void echo_not_entered() { SERIAL_PROTOCOLLNPGM(" not entered."); }
// 4493 
// 4494   void mbl_mesh_report() {
// 4495     SERIAL_PROTOCOLLNPGM("Num X,Y: " STRINGIFY(GRID_MAX_POINTS_X) "," STRINGIFY(GRID_MAX_POINTS_Y));
// 4496     SERIAL_PROTOCOLPGM("Z offset: "); SERIAL_PROTOCOL_F(mbl.z_offset, 5);
// 4497     SERIAL_PROTOCOLLNPGM("\nMeasured points:");
// 4498     print_2d_array(GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y, 5,
// 4499       [](const uint8_t ix, const uint8_t iy) { return mbl.z_values[ix][iy]; }
// 4500     );
// 4501   }
// 4502 
// 4503   /**
// 4504    * G29: Mesh-based Z probe, probes a grid and produces a
// 4505    *      mesh to compensate for variable bed height
// 4506    *
// 4507    * Parameters With MESH_BED_LEVELING:
// 4508    *
// 4509    *  S0              Produce a mesh report
// 4510    *  S1              Start probing mesh points
// 4511    *  S2              Probe the next mesh point
// 4512    *  S3 Xn Yn Zn.nn  Manually modify a single point
// 4513    *  S4 Zn.nn        Set z offset. Positive away from bed, negative closer to bed.
// 4514    *  S5              Reset and disable mesh
// 4515    *
// 4516    * The S0 report the points as below
// 4517    *
// 4518    *  +----> X-axis  1-n
// 4519    *  |
// 4520    *  |
// 4521    *  v Y-axis  1-n
// 4522    *
// 4523    */
// 4524   inline void gcode_G29() {
// 4525 
// 4526     static int mbl_probe_index = -1;
// 4527     #if HAS_SOFTWARE_ENDSTOPS
// 4528       static bool enable_soft_endstops;
// 4529     #endif
// 4530 
// 4531     const MeshLevelingState state = (MeshLevelingState)parser.byteval('S', (int8_t)MeshReport);
// 4532     if (!WITHIN(state, 0, 5)) {
// 4533       SERIAL_PROTOCOLLNPGM("S out of range (0-5).");
// 4534       return;
// 4535     }
// 4536 
// 4537     int8_t px, py;
// 4538 
// 4539     switch (state) {
// 4540       case MeshReport:
// 4541         if (leveling_is_valid()) {
// 4542           SERIAL_PROTOCOLLNPAIR("State: ", planner.leveling_active ? MSG_ON : MSG_OFF);
// 4543           mbl_mesh_report();
// 4544         }
// 4545         else
// 4546           SERIAL_PROTOCOLLNPGM("Mesh bed leveling has no data.");
// 4547         break;
// 4548 
// 4549       case MeshStart:
// 4550         mbl.reset();
// 4551         mbl_probe_index = 0;
// 4552         enqueue_and_echo_commands_P(lcd_wait_for_move ? PSTR("G29 S2") : PSTR("G28\nG29 S2"));
// 4553         break;
// 4554 
// 4555       case MeshNext:
// 4556         if (mbl_probe_index < 0) {
// 4557           SERIAL_PROTOCOLLNPGM("Start mesh probing with \"G29 S1\" first.");
// 4558           return;
// 4559         }
// 4560         // For each G29 S2...
// 4561         if (mbl_probe_index == 0) {
// 4562           #if HAS_SOFTWARE_ENDSTOPS
// 4563             // For the initial G29 S2 save software endstop state
// 4564             enable_soft_endstops = soft_endstops_enabled;
// 4565           #endif
// 4566         }
// 4567         else {
// 4568           // For G29 S2 after adjusting Z.
// 4569           mbl.set_zigzag_z(mbl_probe_index - 1, current_position[Z_AXIS]);
// 4570           #if HAS_SOFTWARE_ENDSTOPS
// 4571             soft_endstops_enabled = enable_soft_endstops;
// 4572           #endif
// 4573         }
// 4574         // If there's another point to sample, move there with optional lift.
// 4575         if (mbl_probe_index < GRID_MAX_POINTS) {
// 4576           mbl.zigzag(mbl_probe_index, px, py);
// 4577           _manual_goto_xy(mbl.index_to_xpos[px], mbl.index_to_ypos[py]);
// 4578 
// 4579           #if HAS_SOFTWARE_ENDSTOPS
// 4580             // Disable software endstops to allow manual adjustment
// 4581             // If G29 is not completed, they will not be re-enabled
// 4582             soft_endstops_enabled = false;
// 4583           #endif
// 4584 
// 4585           mbl_probe_index++;
// 4586         }
// 4587         else {
// 4588           // One last "return to the bed" (as originally coded) at completion
// 4589           current_position[Z_AXIS] = Z_MIN_POS + MANUAL_PROBE_HEIGHT;
// 4590           buffer_line_to_current_position();
// 4591           stepper.synchronize();
// 4592 
// 4593           // After recording the last point, activate home and activate
// 4594           mbl_probe_index = -1;
// 4595           SERIAL_PROTOCOLLNPGM("Mesh probing done.");
// 4596           BUZZ(100, 659);
// 4597           BUZZ(100, 698);
// 4598           mbl.has_mesh = true;
// 4599 
// 4600           home_all_axes();
// 4601           set_bed_leveling_enabled(true);
// 4602 
// 4603           #if ENABLED(MESH_G28_REST_ORIGIN)
// 4604             current_position[Z_AXIS] = Z_MIN_POS;
// 4605             set_destination_from_current();
// 4606             buffer_line_to_destination(homing_feedrate_mm_s[Z_AXIS]);
// 4607             stepper.synchronize();
// 4608           #endif
// 4609 
// 4610           #if ENABLED(LCD_BED_LEVELING)
// 4611             lcd_wait_for_move = false;
// 4612           #endif
// 4613         }
// 4614         break;
// 4615 
// 4616       case MeshSet:
// 4617         if (parser.seenval('X')) {
// 4618           px = parser.value_int() - 1;
// 4619           if (!WITHIN(px, 0, GRID_MAX_POINTS_X - 1)) {
// 4620             SERIAL_PROTOCOLLNPGM("X out of range (1-" STRINGIFY(GRID_MAX_POINTS_X) ").");
// 4621             return;
// 4622           }
// 4623         }
// 4624         else {
// 4625           SERIAL_CHAR('X'); echo_not_entered();
// 4626           return;
// 4627         }
// 4628 
// 4629         if (parser.seenval('Y')) {
// 4630           py = parser.value_int() - 1;
// 4631           if (!WITHIN(py, 0, GRID_MAX_POINTS_Y - 1)) {
// 4632             SERIAL_PROTOCOLLNPGM("Y out of range (1-" STRINGIFY(GRID_MAX_POINTS_Y) ").");
// 4633             return;
// 4634           }
// 4635         }
// 4636         else {
// 4637           SERIAL_CHAR('Y'); echo_not_entered();
// 4638           return;
// 4639         }
// 4640 
// 4641         if (parser.seenval('Z'))
// 4642           mbl.z_values[px][py] = parser.value_linear_units();
// 4643         else {
// 4644           SERIAL_CHAR('Z'); echo_not_entered();
// 4645           return;
// 4646         }
// 4647         break;
// 4648 
// 4649       case MeshSetZOffset:
// 4650         if (parser.seenval('Z'))
// 4651           mbl.z_offset = parser.value_linear_units();
// 4652         else {
// 4653           SERIAL_CHAR('Z'); echo_not_entered();
// 4654           return;
// 4655         }
// 4656         break;
// 4657 
// 4658       case MeshReset:
// 4659         reset_bed_level();
// 4660         break;
// 4661 
// 4662     } // switch(state)
// 4663 
// 4664     if (state == MeshStart || state == MeshNext) {
// 4665       SERIAL_PROTOCOLPAIR("MBL G29 point ", min(mbl_probe_index, GRID_MAX_POINTS));
// 4666       SERIAL_PROTOCOLLNPAIR(" of ", int(GRID_MAX_POINTS));
// 4667     }
// 4668 
// 4669     report_current_position();
// 4670   }
// 4671 
// 4672 #elif OLDSCHOOL_ABL
// 4673 
// 4674   #if ABL_GRID
// 4675     #if ENABLED(PROBE_Y_FIRST)
// 4676       #define PR_OUTER_VAR xCount
// 4677       #define PR_OUTER_END abl_grid_points_x
// 4678       #define PR_INNER_VAR yCount
// 4679       #define PR_INNER_END abl_grid_points_y
// 4680     #else
// 4681       #define PR_OUTER_VAR yCount
// 4682       #define PR_OUTER_END abl_grid_points_y
// 4683       #define PR_INNER_VAR xCount
// 4684       #define PR_INNER_END abl_grid_points_x
// 4685     #endif
// 4686   #endif
// 4687 
// 4688   /**
// 4689    * G29: Detailed Z probe, probes the bed at 3 or more points.
// 4690    *      Will fail if the printer has not been homed with G28.
// 4691    *
// 4692    * Enhanced G29 Auto Bed Leveling Probe Routine
// 4693    *
// 4694    *  D  Dry-Run mode. Just evaluate the bed Topology - Don't apply
// 4695    *     or alter the bed level data. Useful to check the topology
// 4696    *     after a first run of G29.
// 4697    *
// 4698    *  J  Jettison current bed leveling data
// 4699    *
// 4700    *  V  Set the verbose level (0-4). Example: "G29 V3"
// 4701    *
// 4702    * Parameters With LINEAR leveling only:
// 4703    *
// 4704    *  P  Set the size of the grid that will be probed (P x P points).
// 4705    *     Example: "G29 P4"
// 4706    *
// 4707    *  X  Set the X size of the grid that will be probed (X x Y points).
// 4708    *     Example: "G29 X7 Y5"
// 4709    *
// 4710    *  Y  Set the Y size of the grid that will be probed (X x Y points).
// 4711    *
// 4712    *  T  Generate a Bed Topology Report. Example: "G29 P5 T" for a detailed report.
// 4713    *     This is useful for manual bed leveling and finding flaws in the bed (to
// 4714    *     assist with part placement).
// 4715    *     Not supported by non-linear delta printer bed leveling.
// 4716    *
// 4717    * Parameters With LINEAR and BILINEAR leveling only:
// 4718    *
// 4719    *  S  Set the XY travel speed between probe points (in units/min)
// 4720    *
// 4721    *  F  Set the Front limit of the probing grid
// 4722    *  B  Set the Back limit of the probing grid
// 4723    *  L  Set the Left limit of the probing grid
// 4724    *  R  Set the Right limit of the probing grid
// 4725    *
// 4726    * Parameters with DEBUG_LEVELING_FEATURE only:
// 4727    *
// 4728    *  C  Make a totally fake grid with no actual probing.
// 4729    *     For use in testing when no probing is possible.
// 4730    *
// 4731    * Parameters with BILINEAR leveling only:
// 4732    *
// 4733    *  Z  Supply an additional Z probe offset
// 4734    *
// 4735    * Extra parameters with PROBE_MANUALLY:
// 4736    *
// 4737    *  To do manual probing simply repeat G29 until the procedure is complete.
// 4738    *  The first G29 accepts parameters. 'G29 Q' for status, 'G29 A' to abort.
// 4739    *
// 4740    *  Q  Query leveling and G29 state
// 4741    *
// 4742    *  A  Abort current leveling procedure
// 4743    *
// 4744    * Extra parameters with BILINEAR only:
// 4745    *
// 4746    *  W  Write a mesh point. (If G29 is idle.)
// 4747    *  I  X index for mesh point
// 4748    *  J  Y index for mesh point
// 4749    *  X  X for mesh point, overrides I
// 4750    *  Y  Y for mesh point, overrides J
// 4751    *  Z  Z for mesh point. Otherwise, raw current Z.
// 4752    *
// 4753    * Without PROBE_MANUALLY:
// 4754    *
// 4755    *  E  By default G29 will engage the Z probe, test the bed, then disengage.
// 4756    *     Include "E" to engage/disengage the Z probe for each sample.
// 4757    *     There's no extra effect if you have a fixed Z probe.
// 4758    *
// 4759    */
// 4760   inline void gcode_G29() {
// 4761 
// 4762     // G29 Q is also available if debugging
// 4763     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4764       const bool query = parser.seen('Q');
// 4765       const uint8_t old_debug_flags = marlin_debug_flags;
// 4766       if (query) marlin_debug_flags |= DEBUG_LEVELING;
// 4767       if (DEBUGGING(LEVELING)) {
// 4768         DEBUG_POS(">>> G29", current_position);
// 4769         log_machine_info();
// 4770       }
// 4771       marlin_debug_flags = old_debug_flags;
// 4772       #if DISABLED(PROBE_MANUALLY)
// 4773         if (query) return;
// 4774       #endif
// 4775     #endif
// 4776 
// 4777     #if ENABLED(PROBE_MANUALLY)
// 4778       const bool seenA = parser.seen('A'), seenQ = parser.seen('Q'), no_action = seenA || seenQ;
// 4779     #endif
// 4780 
// 4781     #if ENABLED(DEBUG_LEVELING_FEATURE) && DISABLED(PROBE_MANUALLY)
// 4782       const bool faux = parser.boolval('C');
// 4783     #elif ENABLED(PROBE_MANUALLY)
// 4784       const bool faux = no_action;
// 4785     #else
// 4786       bool constexpr faux = false;
// 4787     #endif
// 4788 
// 4789     // Don't allow auto-leveling without homing first
// 4790     if (axis_unhomed_error()) return;
// 4791 
// 4792     // Define local vars 'static' for manual probing, 'auto' otherwise
// 4793     #if ENABLED(PROBE_MANUALLY)
// 4794       #define ABL_VAR static
// 4795     #else
// 4796       #define ABL_VAR
// 4797     #endif
// 4798 
// 4799     ABL_VAR int verbose_level;
// 4800     ABL_VAR float xProbe, yProbe, measured_z;
// 4801     ABL_VAR bool dryrun, abl_should_enable;
// 4802 
// 4803     #if ENABLED(PROBE_MANUALLY) || ENABLED(AUTO_BED_LEVELING_LINEAR)
// 4804       ABL_VAR int abl_probe_index;
// 4805     #endif
// 4806 
// 4807     #if HAS_SOFTWARE_ENDSTOPS && ENABLED(PROBE_MANUALLY)
// 4808       ABL_VAR bool enable_soft_endstops = true;
// 4809     #endif
// 4810 
// 4811     #if ABL_GRID
// 4812 
// 4813       #if ENABLED(PROBE_MANUALLY)
// 4814         ABL_VAR uint8_t PR_OUTER_VAR;
// 4815         ABL_VAR  int8_t PR_INNER_VAR;
// 4816       #endif
// 4817 
// 4818       ABL_VAR int left_probe_bed_position, right_probe_bed_position, front_probe_bed_position, back_probe_bed_position;
// 4819       ABL_VAR float xGridSpacing = 0, yGridSpacing = 0;
// 4820 
// 4821       #if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 4822         ABL_VAR uint8_t abl_grid_points_x = GRID_MAX_POINTS_X,
// 4823                         abl_grid_points_y = GRID_MAX_POINTS_Y;
// 4824         ABL_VAR bool do_topography_map;
// 4825       #else // Bilinear
// 4826         uint8_t constexpr abl_grid_points_x = GRID_MAX_POINTS_X,
// 4827                           abl_grid_points_y = GRID_MAX_POINTS_Y;
// 4828       #endif
// 4829 
// 4830       #if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 4831         ABL_VAR int abl2;
// 4832       #elif ENABLED(PROBE_MANUALLY) // Bilinear
// 4833         int constexpr abl2 = GRID_MAX_POINTS;
// 4834       #endif
// 4835 
// 4836       #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 4837 
// 4838         ABL_VAR float zoffset;
// 4839 
// 4840       #elif ENABLED(AUTO_BED_LEVELING_LINEAR)
// 4841 
// 4842         ABL_VAR int indexIntoAB[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
// 4843 
// 4844         ABL_VAR float eqnAMatrix[GRID_MAX_POINTS * 3], // "A" matrix of the linear system of equations
// 4845                       eqnBVector[GRID_MAX_POINTS],     // "B" vector of Z points
// 4846                       mean;
// 4847       #endif
// 4848 
// 4849     #elif ENABLED(AUTO_BED_LEVELING_3POINT)
// 4850 
// 4851       #if ENABLED(PROBE_MANUALLY)
// 4852         int constexpr abl2 = 3; // used to show total points
// 4853       #endif
// 4854 
// 4855       // Probe at 3 arbitrary points
// 4856       ABL_VAR vector_3 points[3] = {
// 4857         vector_3(ABL_PROBE_PT_1_X, ABL_PROBE_PT_1_Y, 0),
// 4858         vector_3(ABL_PROBE_PT_2_X, ABL_PROBE_PT_2_Y, 0),
// 4859         vector_3(ABL_PROBE_PT_3_X, ABL_PROBE_PT_3_Y, 0)
// 4860       };
// 4861 
// 4862     #endif // AUTO_BED_LEVELING_3POINT
// 4863 
// 4864     #if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 4865       struct linear_fit_data lsf_results;
// 4866       incremental_LSF_reset(&lsf_results);
// 4867     #endif
// 4868 
// 4869     /**
// 4870      * On the initial G29 fetch command parameters.
// 4871      */
// 4872     if (!g29_in_progress) {
// 4873 
// 4874       #if ENABLED(PROBE_MANUALLY) || ENABLED(AUTO_BED_LEVELING_LINEAR)
// 4875         abl_probe_index = -1;
// 4876       #endif
// 4877 
// 4878       abl_should_enable = planner.leveling_active;
// 4879 
// 4880       #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 4881 
// 4882         if (parser.seen('W')) {
// 4883           if (!leveling_is_valid()) {
// 4884             SERIAL_ERROR_START();
// 4885             SERIAL_ERRORLNPGM("No bilinear grid");
// 4886             return;
// 4887           }
// 4888 
// 4889           const float rz = parser.seenval('Z') ? RAW_Z_POSITION(parser.value_linear_units()) : current_position[Z_AXIS];
// 4890           if (!WITHIN(rz, -10, 10)) {
// 4891             SERIAL_ERROR_START();
// 4892             SERIAL_ERRORLNPGM("Bad Z value");
// 4893             return;
// 4894           }
// 4895 
// 4896           const float rx = RAW_X_POSITION(parser.linearval('X', NAN)),
// 4897                       ry = RAW_Y_POSITION(parser.linearval('Y', NAN));
// 4898           int8_t i = parser.byteval('I', -1),
// 4899                  j = parser.byteval('J', -1);
// 4900 
// 4901           if (!isnan(rx) && !isnan(ry)) {
// 4902             // Get nearest i / j from rx / ry
// 4903             i = (rx - bilinear_start[X_AXIS] + 0.5 * xGridSpacing) / xGridSpacing;
// 4904             j = (ry - bilinear_start[Y_AXIS] + 0.5 * yGridSpacing) / yGridSpacing;
// 4905             i = constrain(i, 0, GRID_MAX_POINTS_X - 1);
// 4906             j = constrain(j, 0, GRID_MAX_POINTS_Y - 1);
// 4907           }
// 4908           if (WITHIN(i, 0, GRID_MAX_POINTS_X - 1) && WITHIN(j, 0, GRID_MAX_POINTS_Y)) {
// 4909             set_bed_leveling_enabled(false);
// 4910             z_values[i][j] = rz;
// 4911             #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 4912               bed_level_virt_interpolate();
// 4913             #endif
// 4914             set_bed_leveling_enabled(abl_should_enable);
// 4915             if (abl_should_enable) report_current_position();
// 4916           }
// 4917           return;
// 4918         } // parser.seen('W')
// 4919 
// 4920       #endif
// 4921 
// 4922       // Jettison bed leveling data
// 4923       if (parser.seen('J')) {
// 4924         reset_bed_level();
// 4925         return;
// 4926       }
// 4927 
// 4928       verbose_level = parser.intval('V');
// 4929       if (!WITHIN(verbose_level, 0, 4)) {
// 4930         SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-4).");
// 4931         return;
// 4932       }
// 4933 
// 4934       dryrun = parser.boolval('D')
// 4935         #if ENABLED(PROBE_MANUALLY)
// 4936           || no_action
// 4937         #endif
// 4938       ;
// 4939 
// 4940       #if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 4941 
// 4942         do_topography_map = verbose_level > 2 || parser.boolval('T');
// 4943 
// 4944         // X and Y specify points in each direction, overriding the default
// 4945         // These values may be saved with the completed mesh
// 4946         abl_grid_points_x = parser.intval('X', GRID_MAX_POINTS_X);
// 4947         abl_grid_points_y = parser.intval('Y', GRID_MAX_POINTS_Y);
// 4948         if (parser.seenval('P')) abl_grid_points_x = abl_grid_points_y = parser.value_int();
// 4949 
// 4950         if (abl_grid_points_x < 2 || abl_grid_points_y < 2) {
// 4951           SERIAL_PROTOCOLLNPGM("?Number of probe points is implausible (2 minimum).");
// 4952           return;
// 4953         }
// 4954 
// 4955         abl2 = abl_grid_points_x * abl_grid_points_y;
// 4956         mean = 0;
// 4957 
// 4958       #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 4959 
// 4960         zoffset = parser.linearval('Z');
// 4961 
// 4962       #endif
// 4963 
// 4964       #if ABL_GRID
// 4965 
// 4966         xy_probe_feedrate_mm_s = MMM_TO_MMS(parser.linearval('S', XY_PROBE_SPEED));
// 4967 
// 4968         left_probe_bed_position  = parser.seenval('L') ? (int)RAW_X_POSITION(parser.value_linear_units()) : LEFT_PROBE_BED_POSITION;
// 4969         right_probe_bed_position = parser.seenval('R') ? (int)RAW_X_POSITION(parser.value_linear_units()) : RIGHT_PROBE_BED_POSITION;
// 4970         front_probe_bed_position = parser.seenval('F') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : FRONT_PROBE_BED_POSITION;
// 4971         back_probe_bed_position  = parser.seenval('B') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : BACK_PROBE_BED_POSITION;
// 4972 
// 4973         const bool left_out_l = left_probe_bed_position < MIN_PROBE_X,
// 4974                    left_out = left_out_l || left_probe_bed_position > right_probe_bed_position - (MIN_PROBE_EDGE),
// 4975                    right_out_r = right_probe_bed_position > MAX_PROBE_X,
// 4976                    right_out = right_out_r || right_probe_bed_position < left_probe_bed_position + MIN_PROBE_EDGE,
// 4977                    front_out_f = front_probe_bed_position < MIN_PROBE_Y,
// 4978                    front_out = front_out_f || front_probe_bed_position > back_probe_bed_position - (MIN_PROBE_EDGE),
// 4979                    back_out_b = back_probe_bed_position > MAX_PROBE_Y,
// 4980                    back_out = back_out_b || back_probe_bed_position < front_probe_bed_position + MIN_PROBE_EDGE;
// 4981 
// 4982         if (left_out || right_out || front_out || back_out) {
// 4983           if (left_out) {
// 4984             out_of_range_error(PSTR("(L)eft"));
// 4985             left_probe_bed_position = left_out_l ? MIN_PROBE_X : right_probe_bed_position - (MIN_PROBE_EDGE);
// 4986           }
// 4987           if (right_out) {
// 4988             out_of_range_error(PSTR("(R)ight"));
// 4989             right_probe_bed_position = right_out_r ? MAX_PROBE_X : left_probe_bed_position + MIN_PROBE_EDGE;
// 4990           }
// 4991           if (front_out) {
// 4992             out_of_range_error(PSTR("(F)ront"));
// 4993             front_probe_bed_position = front_out_f ? MIN_PROBE_Y : back_probe_bed_position - (MIN_PROBE_EDGE);
// 4994           }
// 4995           if (back_out) {
// 4996             out_of_range_error(PSTR("(B)ack"));
// 4997             back_probe_bed_position = back_out_b ? MAX_PROBE_Y : front_probe_bed_position + MIN_PROBE_EDGE;
// 4998           }
// 4999           return;
// 5000         }
// 5001 
// 5002         // probe at the points of a lattice grid
// 5003         xGridSpacing = (right_probe_bed_position - left_probe_bed_position) / (abl_grid_points_x - 1);
// 5004         yGridSpacing = (back_probe_bed_position - front_probe_bed_position) / (abl_grid_points_y - 1);
// 5005 
// 5006       #endif // ABL_GRID
// 5007 
// 5008       if (verbose_level > 0) {
// 5009         SERIAL_PROTOCOLPGM("G29 Auto Bed Leveling");
// 5010         if (dryrun) SERIAL_PROTOCOLPGM(" (DRYRUN)");
// 5011         SERIAL_EOL();
// 5012       }
// 5013 
// 5014       stepper.synchronize();
// 5015 
// 5016       // Disable auto bed leveling during G29.
// 5017       // Be formal so G29 can be done successively without G28.
// 5018       set_bed_leveling_enabled(false);
// 5019 
// 5020       #if HAS_BED_PROBE
// 5021         // Deploy the probe. Probe will raise if needed.
// 5022         if (DEPLOY_PROBE()) {
// 5023           set_bed_leveling_enabled(abl_should_enable);
// 5024           return;
// 5025         }
// 5026       #endif
// 5027 
// 5028       if (!faux) setup_for_endstop_or_probe_move();
// 5029 
// 5030       #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 5031 
// 5032         #if ENABLED(PROBE_MANUALLY)
// 5033           if (!no_action)
// 5034         #endif
// 5035         if ( xGridSpacing != bilinear_grid_spacing[X_AXIS]
// 5036           || yGridSpacing != bilinear_grid_spacing[Y_AXIS]
// 5037           || left_probe_bed_position != bilinear_start[X_AXIS]
// 5038           || front_probe_bed_position != bilinear_start[Y_AXIS]
// 5039         ) {
// 5040           // Reset grid to 0.0 or "not probed". (Also disables ABL)
// 5041           reset_bed_level();
// 5042 
// 5043           // Initialize a grid with the given dimensions
// 5044           bilinear_grid_spacing[X_AXIS] = xGridSpacing;
// 5045           bilinear_grid_spacing[Y_AXIS] = yGridSpacing;
// 5046           bilinear_start[X_AXIS] = left_probe_bed_position;
// 5047           bilinear_start[Y_AXIS] = front_probe_bed_position;
// 5048 
// 5049           // Can't re-enable (on error) until the new grid is written
// 5050           abl_should_enable = false;
// 5051         }
// 5052 
// 5053       #endif // AUTO_BED_LEVELING_BILINEAR
// 5054 
// 5055       #if ENABLED(AUTO_BED_LEVELING_3POINT)
// 5056 
// 5057         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5058           if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> 3-point Leveling");
// 5059         #endif
// 5060 
// 5061         // Probe at 3 arbitrary points
// 5062         points[0].z = points[1].z = points[2].z = 0;
// 5063 
// 5064       #endif // AUTO_BED_LEVELING_3POINT
// 5065 
// 5066     } // !g29_in_progress
// 5067 
// 5068     #if ENABLED(PROBE_MANUALLY)
// 5069 
// 5070       // For manual probing, get the next index to probe now.
// 5071       // On the first probe this will be incremented to 0.
// 5072       if (!no_action) {
// 5073         ++abl_probe_index;
// 5074         g29_in_progress = true;
// 5075       }
// 5076 
// 5077       // Abort current G29 procedure, go back to idle state
// 5078       if (seenA && g29_in_progress) {
// 5079         SERIAL_PROTOCOLLNPGM("Manual G29 aborted");
// 5080         #if HAS_SOFTWARE_ENDSTOPS
// 5081           soft_endstops_enabled = enable_soft_endstops;
// 5082         #endif
// 5083         set_bed_leveling_enabled(abl_should_enable);
// 5084         g29_in_progress = false;
// 5085         #if ENABLED(LCD_BED_LEVELING)
// 5086           lcd_wait_for_move = false;
// 5087         #endif
// 5088       }
// 5089 
// 5090       // Query G29 status
// 5091       if (verbose_level || seenQ) {
// 5092         SERIAL_PROTOCOLPGM("Manual G29 ");
// 5093         if (g29_in_progress) {
// 5094           SERIAL_PROTOCOLPAIR("point ", min(abl_probe_index + 1, abl2));
// 5095           SERIAL_PROTOCOLLNPAIR(" of ", abl2);
// 5096         }
// 5097         else
// 5098           SERIAL_PROTOCOLLNPGM("idle");
// 5099       }
// 5100 
// 5101       if (no_action) return;
// 5102 
// 5103       if (abl_probe_index == 0) {
// 5104         // For the initial G29 save software endstop state
// 5105         #if HAS_SOFTWARE_ENDSTOPS
// 5106           enable_soft_endstops = soft_endstops_enabled;
// 5107         #endif
// 5108       }
// 5109       else {
// 5110         // For G29 after adjusting Z.
// 5111         // Save the previous Z before going to the next point
// 5112         measured_z = current_position[Z_AXIS];
// 5113 
// 5114         #if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5115 
// 5116           mean += measured_z;
// 5117           eqnBVector[abl_probe_index] = measured_z;
// 5118           eqnAMatrix[abl_probe_index + 0 * abl2] = xProbe;
// 5119           eqnAMatrix[abl_probe_index + 1 * abl2] = yProbe;
// 5120           eqnAMatrix[abl_probe_index + 2 * abl2] = 1;
// 5121 
// 5122           incremental_LSF(&lsf_results, xProbe, yProbe, measured_z);
// 5123 
// 5124         #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 5125 
// 5126           z_values[xCount][yCount] = measured_z + zoffset;
// 5127 
// 5128           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5129             if (DEBUGGING(LEVELING)) {
// 5130               SERIAL_PROTOCOLPAIR("Save X", xCount);
// 5131               SERIAL_PROTOCOLPAIR(" Y", yCount);
// 5132               SERIAL_PROTOCOLLNPAIR(" Z", measured_z + zoffset);
// 5133             }
// 5134           #endif
// 5135 
// 5136         #elif ENABLED(AUTO_BED_LEVELING_3POINT)
// 5137 
// 5138           points[abl_probe_index].z = measured_z;
// 5139 
// 5140         #endif
// 5141       }
// 5142 
// 5143       //
// 5144       // If there's another point to sample, move there with optional lift.
// 5145       //
// 5146 
// 5147       #if ABL_GRID
// 5148 
// 5149         // Skip any unreachable points
// 5150         while (abl_probe_index < abl2) {
// 5151 
// 5152           // Set xCount, yCount based on abl_probe_index, with zig-zag
// 5153           PR_OUTER_VAR = abl_probe_index / PR_INNER_END;
// 5154           PR_INNER_VAR = abl_probe_index - (PR_OUTER_VAR * PR_INNER_END);
// 5155 
// 5156           // Probe in reverse order for every other row/column
// 5157           bool zig = (PR_OUTER_VAR & 1); // != ((PR_OUTER_END) & 1);
// 5158 
// 5159           if (zig) PR_INNER_VAR = (PR_INNER_END - 1) - PR_INNER_VAR;
// 5160 
// 5161           const float xBase = xCount * xGridSpacing + left_probe_bed_position,
// 5162                       yBase = yCount * yGridSpacing + front_probe_bed_position;
// 5163 
// 5164           xProbe = FLOOR(xBase + (xBase < 0 ? 0 : 0.5));
// 5165           yProbe = FLOOR(yBase + (yBase < 0 ? 0 : 0.5));
// 5166 
// 5167           #if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5168             indexIntoAB[xCount][yCount] = abl_probe_index;
// 5169           #endif
// 5170 
// 5171           // Keep looping till a reachable point is found
// 5172           if (position_is_reachable(xProbe, yProbe)) break;
// 5173           ++abl_probe_index;
// 5174         }
// 5175 
// 5176         // Is there a next point to move to?
// 5177         if (abl_probe_index < abl2) {
// 5178           _manual_goto_xy(xProbe, yProbe); // Can be used here too!
// 5179           #if HAS_SOFTWARE_ENDSTOPS
// 5180             // Disable software endstops to allow manual adjustment
// 5181             // If G29 is not completed, they will not be re-enabled
// 5182             soft_endstops_enabled = false;
// 5183           #endif
// 5184           return;
// 5185         }
// 5186         else {
// 5187 
// 5188           // Leveling done! Fall through to G29 finishing code below
// 5189 
// 5190           SERIAL_PROTOCOLLNPGM("Grid probing done.");
// 5191 
// 5192           // Re-enable software endstops, if needed
// 5193           #if HAS_SOFTWARE_ENDSTOPS
// 5194             soft_endstops_enabled = enable_soft_endstops;
// 5195           #endif
// 5196         }
// 5197 
// 5198       #elif ENABLED(AUTO_BED_LEVELING_3POINT)
// 5199 
// 5200         // Probe at 3 arbitrary points
// 5201         if (abl_probe_index < abl2) {
// 5202           xProbe = points[abl_probe_index].x;
// 5203           yProbe = points[abl_probe_index].y;
// 5204           _manual_goto_xy(xProbe, yProbe);
// 5205           #if HAS_SOFTWARE_ENDSTOPS
// 5206             // Disable software endstops to allow manual adjustment
// 5207             // If G29 is not completed, they will not be re-enabled
// 5208             soft_endstops_enabled = false;
// 5209           #endif
// 5210           return;
// 5211         }
// 5212         else {
// 5213 
// 5214           SERIAL_PROTOCOLLNPGM("3-point probing done.");
// 5215 
// 5216           // Re-enable software endstops, if needed
// 5217           #if HAS_SOFTWARE_ENDSTOPS
// 5218             soft_endstops_enabled = enable_soft_endstops;
// 5219           #endif
// 5220 
// 5221           if (!dryrun) {
// 5222             vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
// 5223             if (planeNormal.z < 0) {
// 5224               planeNormal.x *= -1;
// 5225               planeNormal.y *= -1;
// 5226               planeNormal.z *= -1;
// 5227             }
// 5228             planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
// 5229 
// 5230             // Can't re-enable (on error) until the new grid is written
// 5231             abl_should_enable = false;
// 5232           }
// 5233 
// 5234         }
// 5235 
// 5236       #endif // AUTO_BED_LEVELING_3POINT
// 5237 
// 5238     #else // !PROBE_MANUALLY
// 5239     {
// 5240       const bool stow_probe_after_each = parser.boolval('E');
// 5241 
// 5242       measured_z = 0;
// 5243 
// 5244       #if ABL_GRID
// 5245 
// 5246         bool zig = PR_OUTER_END & 1;  // Always end at RIGHT and BACK_PROBE_BED_POSITION
// 5247 
// 5248         measured_z = 0;
// 5249 
// 5250         // Outer loop is Y with PROBE_Y_FIRST disabled
// 5251         for (uint8_t PR_OUTER_VAR = 0; PR_OUTER_VAR < PR_OUTER_END && !isnan(measured_z); PR_OUTER_VAR++) {
// 5252 
// 5253           int8_t inStart, inStop, inInc;
// 5254 
// 5255           if (zig) { // away from origin
// 5256             inStart = 0;
// 5257             inStop = PR_INNER_END;
// 5258             inInc = 1;
// 5259           }
// 5260           else {     // towards origin
// 5261             inStart = PR_INNER_END - 1;
// 5262             inStop = -1;
// 5263             inInc = -1;
// 5264           }
// 5265 
// 5266           zig ^= true; // zag
// 5267 
// 5268           // Inner loop is Y with PROBE_Y_FIRST enabled
// 5269           for (int8_t PR_INNER_VAR = inStart; PR_INNER_VAR != inStop; PR_INNER_VAR += inInc) {
// 5270 
// 5271             float xBase = left_probe_bed_position + xGridSpacing * xCount,
// 5272                   yBase = front_probe_bed_position + yGridSpacing * yCount;
// 5273 
// 5274             xProbe = FLOOR(xBase + (xBase < 0 ? 0 : 0.5));
// 5275             yProbe = FLOOR(yBase + (yBase < 0 ? 0 : 0.5));
// 5276 
// 5277             #if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5278               indexIntoAB[xCount][yCount] = ++abl_probe_index; // 0...
// 5279             #endif
// 5280 
// 5281             #if IS_KINEMATIC
// 5282               // Avoid probing outside the round or hexagonal area
// 5283               if (!position_is_reachable_by_probe(xProbe, yProbe)) continue;
// 5284             #endif
// 5285 
// 5286             measured_z = faux ? 0.001 * random(-100, 101) : probe_pt(xProbe, yProbe, stow_probe_after_each, verbose_level);
// 5287 
// 5288             if (isnan(measured_z)) {
// 5289               set_bed_leveling_enabled(abl_should_enable);
// 5290               break;
// 5291             }
// 5292 
// 5293             #if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5294 
// 5295               mean += measured_z;
// 5296               eqnBVector[abl_probe_index] = measured_z;
// 5297               eqnAMatrix[abl_probe_index + 0 * abl2] = xProbe;
// 5298               eqnAMatrix[abl_probe_index + 1 * abl2] = yProbe;
// 5299               eqnAMatrix[abl_probe_index + 2 * abl2] = 1;
// 5300 
// 5301               incremental_LSF(&lsf_results, xProbe, yProbe, measured_z);
// 5302 
// 5303             #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 5304 
// 5305               z_values[xCount][yCount] = measured_z + zoffset;
// 5306 
// 5307             #endif
// 5308 
// 5309             abl_should_enable = false;
// 5310             idle();
// 5311 
// 5312           } // inner
// 5313         } // outer
// 5314 
// 5315       #elif ENABLED(AUTO_BED_LEVELING_3POINT)
// 5316 
// 5317         // Probe at 3 arbitrary points
// 5318 
// 5319         for (uint8_t i = 0; i < 3; ++i) {
// 5320           // Retain the last probe position
// 5321           xProbe = points[i].x;
// 5322           yProbe = points[i].y;
// 5323           measured_z = faux ? 0.001 * random(-100, 101) : probe_pt(xProbe, yProbe, stow_probe_after_each, verbose_level);
// 5324           if (isnan(measured_z)) {
// 5325             set_bed_leveling_enabled(abl_should_enable);
// 5326             break;
// 5327           }
// 5328           points[i].z = measured_z;
// 5329         }
// 5330 
// 5331         if (!dryrun && !isnan(measured_z)) {
// 5332           vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
// 5333           if (planeNormal.z < 0) {
// 5334             planeNormal.x *= -1;
// 5335             planeNormal.y *= -1;
// 5336             planeNormal.z *= -1;
// 5337           }
// 5338           planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
// 5339 
// 5340           // Can't re-enable (on error) until the new grid is written
// 5341           abl_should_enable = false;
// 5342         }
// 5343 
// 5344       #endif // AUTO_BED_LEVELING_3POINT
// 5345 
// 5346       // Raise to _Z_CLEARANCE_DEPLOY_PROBE. Stow the probe.
// 5347       if (STOW_PROBE()) {
// 5348         set_bed_leveling_enabled(abl_should_enable);
// 5349         measured_z = NAN;
// 5350       }
// 5351     }
// 5352     #endif // !PROBE_MANUALLY
// 5353 
// 5354     //
// 5355     // G29 Finishing Code
// 5356     //
// 5357     // Unless this is a dry run, auto bed leveling will
// 5358     // definitely be enabled after this point.
// 5359     //
// 5360     // If code above wants to continue leveling, it should
// 5361     // return or loop before this point.
// 5362     //
// 5363 
// 5364     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5365       if (DEBUGGING(LEVELING)) DEBUG_POS("> probing complete", current_position);
// 5366     #endif
// 5367 
// 5368     #if ENABLED(PROBE_MANUALLY)
// 5369       g29_in_progress = false;
// 5370       #if ENABLED(LCD_BED_LEVELING)
// 5371         lcd_wait_for_move = false;
// 5372       #endif
// 5373     #endif
// 5374 
// 5375     // Calculate leveling, print reports, correct the position
// 5376     if (!isnan(measured_z)) {
// 5377       #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 5378 
// 5379         if (!dryrun) extrapolate_unprobed_bed_level();
// 5380         print_bilinear_leveling_grid();
// 5381 
// 5382         refresh_bed_level();
// 5383 
// 5384         #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 5385           print_bilinear_leveling_grid_virt();
// 5386         #endif
// 5387 
// 5388       #elif ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5389 
// 5390         // For LINEAR leveling calculate matrix, print reports, correct the position
// 5391 
// 5392         /**
// 5393          * solve the plane equation ax + by + d = z
// 5394          * A is the matrix with rows [x y 1] for all the probed points
// 5395          * B is the vector of the Z positions
// 5396          * the normal vector to the plane is formed by the coefficients of the
// 5397          * plane equation in the standard form, which is Vx*x+Vy*y+Vz*z+d = 0
// 5398          * so Vx = -a Vy = -b Vz = 1 (we want the vector facing towards positive Z
// 5399          */
// 5400         float plane_equation_coefficients[3];
// 5401 
// 5402         finish_incremental_LSF(&lsf_results);
// 5403         plane_equation_coefficients[0] = -lsf_results.A;  // We should be able to eliminate the '-' on these three lines and down below
// 5404         plane_equation_coefficients[1] = -lsf_results.B;  // but that is not yet tested.
// 5405         plane_equation_coefficients[2] = -lsf_results.D;
// 5406 
// 5407         mean /= abl2;
// 5408 
// 5409         if (verbose_level) {
// 5410           SERIAL_PROTOCOLPGM("Eqn coefficients: a: ");
// 5411           SERIAL_PROTOCOL_F(plane_equation_coefficients[0], 8);
// 5412           SERIAL_PROTOCOLPGM(" b: ");
// 5413           SERIAL_PROTOCOL_F(plane_equation_coefficients[1], 8);
// 5414           SERIAL_PROTOCOLPGM(" d: ");
// 5415           SERIAL_PROTOCOL_F(plane_equation_coefficients[2], 8);
// 5416           SERIAL_EOL();
// 5417           if (verbose_level > 2) {
// 5418             SERIAL_PROTOCOLPGM("Mean of sampled points: ");
// 5419             SERIAL_PROTOCOL_F(mean, 8);
// 5420             SERIAL_EOL();
// 5421           }
// 5422         }
// 5423 
// 5424         // Create the matrix but don't correct the position yet
// 5425         if (!dryrun)
// 5426           planner.bed_level_matrix = matrix_3x3::create_look_at(
// 5427             vector_3(-plane_equation_coefficients[0], -plane_equation_coefficients[1], 1)    // We can eliminate the '-' here and up above
// 5428           );
// 5429 
// 5430         // Show the Topography map if enabled
// 5431         if (do_topography_map) {
// 5432 
// 5433           SERIAL_PROTOCOLLNPGM("\nBed Height Topography:\n"
// 5434                                  "   +--- BACK --+\n"
// 5435                                  "   |           |\n"
// 5436                                  " L |    (+)    | R\n"
// 5437                                  " E |           | I\n"
// 5438                                  " F | (-) N (+) | G\n"
// 5439                                  " T |           | H\n"
// 5440                                  "   |    (-)    | T\n"
// 5441                                  "   |           |\n"
// 5442                                  "   O-- FRONT --+\n"
// 5443                                  " (0,0)");
// 5444 
// 5445           float min_diff = 999;
// 5446 
// 5447           for (int8_t yy = abl_grid_points_y - 1; yy >= 0; yy--) {
// 5448             for (uint8_t xx = 0; xx < abl_grid_points_x; xx++) {
// 5449               int ind = indexIntoAB[xx][yy];
// 5450               float diff = eqnBVector[ind] - mean,
// 5451                     x_tmp = eqnAMatrix[ind + 0 * abl2],
// 5452                     y_tmp = eqnAMatrix[ind + 1 * abl2],
// 5453                     z_tmp = 0;
// 5454 
// 5455               apply_rotation_xyz(planner.bed_level_matrix, x_tmp, y_tmp, z_tmp);
// 5456 
// 5457               NOMORE(min_diff, eqnBVector[ind] - z_tmp);
// 5458 
// 5459               if (diff >= 0.0)
// 5460                 SERIAL_PROTOCOLPGM(" +");   // Include + for column alignment
// 5461               else
// 5462                 SERIAL_PROTOCOLCHAR(' ');
// 5463               SERIAL_PROTOCOL_F(diff, 5);
// 5464             } // xx
// 5465             SERIAL_EOL();
// 5466           } // yy
// 5467           SERIAL_EOL();
// 5468 
// 5469           if (verbose_level > 3) {
// 5470             SERIAL_PROTOCOLLNPGM("\nCorrected Bed Height vs. Bed Topology:");
// 5471 
// 5472             for (int8_t yy = abl_grid_points_y - 1; yy >= 0; yy--) {
// 5473               for (uint8_t xx = 0; xx < abl_grid_points_x; xx++) {
// 5474                 int ind = indexIntoAB[xx][yy];
// 5475                 float x_tmp = eqnAMatrix[ind + 0 * abl2],
// 5476                       y_tmp = eqnAMatrix[ind + 1 * abl2],
// 5477                       z_tmp = 0;
// 5478 
// 5479                 apply_rotation_xyz(planner.bed_level_matrix, x_tmp, y_tmp, z_tmp);
// 5480 
// 5481                 float diff = eqnBVector[ind] - z_tmp - min_diff;
// 5482                 if (diff >= 0.0)
// 5483                   SERIAL_PROTOCOLPGM(" +");
// 5484                 // Include + for column alignment
// 5485                 else
// 5486                   SERIAL_PROTOCOLCHAR(' ');
// 5487                 SERIAL_PROTOCOL_F(diff, 5);
// 5488               } // xx
// 5489               SERIAL_EOL();
// 5490             } // yy
// 5491             SERIAL_EOL();
// 5492           }
// 5493         } //do_topography_map
// 5494 
// 5495       #endif // AUTO_BED_LEVELING_LINEAR
// 5496 
// 5497       #if ABL_PLANAR
// 5498 
// 5499         // For LINEAR and 3POINT leveling correct the current position
// 5500 
// 5501         if (verbose_level > 0)
// 5502           planner.bed_level_matrix.debug(PSTR("\n\nBed Level Correction Matrix:"));
// 5503 
// 5504         if (!dryrun) {
// 5505           //
// 5506           // Correct the current XYZ position based on the tilted plane.
// 5507           //
// 5508 
// 5509           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5510             if (DEBUGGING(LEVELING)) DEBUG_POS("G29 uncorrected XYZ", current_position);
// 5511           #endif
// 5512 
// 5513           float converted[XYZ];
// 5514           COPY(converted, current_position);
// 5515 
// 5516           planner.leveling_active = true;
// 5517           planner.unapply_leveling(converted); // use conversion machinery
// 5518           planner.leveling_active = false;
// 5519 
// 5520           // Use the last measured distance to the bed, if possible
// 5521           if ( NEAR(current_position[X_AXIS], xProbe - (X_PROBE_OFFSET_FROM_EXTRUDER))
// 5522             && NEAR(current_position[Y_AXIS], yProbe - (Y_PROBE_OFFSET_FROM_EXTRUDER))
// 5523           ) {
// 5524             const float simple_z = current_position[Z_AXIS] - measured_z;
// 5525             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5526               if (DEBUGGING(LEVELING)) {
// 5527                 SERIAL_ECHOPAIR("Z from Probe:", simple_z);
// 5528                 SERIAL_ECHOPAIR("  Matrix:", converted[Z_AXIS]);
// 5529                 SERIAL_ECHOLNPAIR("  Discrepancy:", simple_z - converted[Z_AXIS]);
// 5530               }
// 5531             #endif
// 5532             converted[Z_AXIS] = simple_z;
// 5533           }
// 5534 
// 5535           // The rotated XY and corrected Z are now current_position
// 5536           COPY(current_position, converted);
// 5537 
// 5538           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5539             if (DEBUGGING(LEVELING)) DEBUG_POS("G29 corrected XYZ", current_position);
// 5540           #endif
// 5541         }
// 5542 
// 5543       #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 5544 
// 5545         if (!dryrun) {
// 5546           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5547             if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("G29 uncorrected Z:", current_position[Z_AXIS]);
// 5548           #endif
// 5549 
// 5550           // Unapply the offset because it is going to be immediately applied
// 5551           // and cause compensation movement in Z
// 5552           current_position[Z_AXIS] -= bilinear_z_offset(current_position);
// 5553 
// 5554           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5555             if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR(" corrected Z:", current_position[Z_AXIS]);
// 5556           #endif
// 5557         }
// 5558 
// 5559       #endif // ABL_PLANAR
// 5560 
// 5561       #ifdef Z_PROBE_END_SCRIPT
// 5562         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5563           if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
// 5564         #endif
// 5565         enqueue_and_echo_commands_P(PSTR(Z_PROBE_END_SCRIPT));
// 5566         stepper.synchronize();
// 5567       #endif
// 5568 
// 5569       // Auto Bed Leveling is complete! Enable if possible.
// 5570       planner.leveling_active = dryrun ? abl_should_enable : true;
// 5571     } // !isnan(measured_z)
// 5572 
// 5573     // Restore state after probing
// 5574     if (!faux) clean_up_after_endstop_or_probe_move();
// 5575 
// 5576     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5577       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< G29");
// 5578     #endif
// 5579 
// 5580     report_current_position();
// 5581 
// 5582     KEEPALIVE_STATE(IN_HANDLER);
// 5583 
// 5584     if (planner.leveling_active)
// 5585       SYNC_PLAN_POSITION_KINEMATIC();
// 5586   }
// 5587 
// 5588 #endif // OLDSCHOOL_ABL
// 5589 
// 5590 #if HAS_BED_PROBE
// 5591 
// 5592   /**
// 5593    * G30: Do a single Z probe at the current XY
// 5594    *
// 5595    * Parameters:
// 5596    *
// 5597    *   X   Probe X position (default current X)
// 5598    *   Y   Probe Y position (default current Y)
// 5599    *   E   Engage the probe for each probe
// 5600    */
// 5601   inline void gcode_G30() {
// 5602     const float xpos = parser.linearval('X', current_position[X_AXIS] + X_PROBE_OFFSET_FROM_EXTRUDER),
// 5603                 ypos = parser.linearval('Y', current_position[Y_AXIS] + Y_PROBE_OFFSET_FROM_EXTRUDER);
// 5604 
// 5605     if (!position_is_reachable_by_probe(xpos, ypos)) return;
// 5606 
// 5607     // Disable leveling so the planner won't mess with us
// 5608     #if HAS_LEVELING
// 5609       set_bed_leveling_enabled(false);
// 5610     #endif
// 5611 
// 5612     setup_for_endstop_or_probe_move();
// 5613 
// 5614     const float measured_z = probe_pt(xpos, ypos, parser.boolval('E'), 1);
// 5615 
// 5616     if (!isnan(measured_z)) {
// 5617       SERIAL_PROTOCOLPAIR("Bed X: ", FIXFLOAT(xpos));
// 5618       SERIAL_PROTOCOLPAIR(" Y: ", FIXFLOAT(ypos));
// 5619       SERIAL_PROTOCOLLNPAIR(" Z: ", FIXFLOAT(measured_z));
// 5620     }
// 5621 
// 5622     clean_up_after_endstop_or_probe_move();
// 5623 
// 5624     report_current_position();
// 5625   }
// 5626 
// 5627   #if ENABLED(Z_PROBE_SLED)
// 5628 
// 5629     /**
// 5630      * G31: Deploy the Z probe
// 5631      */
// 5632     inline void gcode_G31() { DEPLOY_PROBE(); }
// 5633 
// 5634     /**
// 5635      * G32: Stow the Z probe
// 5636      */
// 5637     inline void gcode_G32() { STOW_PROBE(); }
// 5638 
// 5639   #endif // Z_PROBE_SLED
// 5640 
// 5641 #endif // HAS_BED_PROBE
// 5642 
// 5643 #if ENABLED(DELTA_AUTO_CALIBRATION)
// 5644 
// 5645   constexpr uint8_t _7P_STEP = 1,              // 7-point step - to change number of calibration points
// 5646                     _4P_STEP = _7P_STEP * 2,   // 4-point step
// 5647                     NPP      = _7P_STEP * 6;   // number of calibration points on the radius
// 5648   enum CalEnum {                               // the 7 main calibration points - add definitions if needed
// 5649     CEN      = 0,
// 5650     __A      = 1,
// 5651     _AB      = __A + _7P_STEP,
// 5652     __B      = _AB + _7P_STEP,
// 5653     _BC      = __B + _7P_STEP,
// 5654     __C      = _BC + _7P_STEP,
// 5655     _CA      = __C + _7P_STEP,
// 5656   };
// 5657 
// 5658   #define LOOP_CAL_PT(VAR, S, N) for (uint8_t VAR=S; VAR<=NPP; VAR+=N)
// 5659   #define F_LOOP_CAL_PT(VAR, S, N) for (float VAR=S; VAR<NPP+0.9999; VAR+=N)
// 5660   #define I_LOOP_CAL_PT(VAR, S, N) for (float VAR=S; VAR>CEN+0.9999; VAR-=N)
// 5661   #define LOOP_CAL_ALL(VAR) LOOP_CAL_PT(VAR, CEN, 1)
// 5662   #define LOOP_CAL_RAD(VAR) LOOP_CAL_PT(VAR, __A, _7P_STEP)
// 5663   #define LOOP_CAL_ACT(VAR, _4P, _OP) LOOP_CAL_PT(VAR, _OP ? _AB : __A, _4P ? _4P_STEP : _7P_STEP)
// 5664 
// 5665   static void print_signed_float(const char * const prefix, const float &f) {
// 5666     SERIAL_PROTOCOLPGM("  ");
// 5667     serialprintPGM(prefix);
// 5668     SERIAL_PROTOCOLCHAR(':');
// 5669     if (f >= 0) SERIAL_CHAR('+');
// 5670     SERIAL_PROTOCOL_F(f, 2);
// 5671   }
// 5672 
// 5673   static void print_G33_settings(const bool end_stops, const bool tower_angles) {
// 5674     SERIAL_PROTOCOLPAIR(".Height:", delta_height);
// 5675     if (end_stops) {
// 5676       print_signed_float(PSTR("Ex"), delta_endstop_adj[A_AXIS]);
// 5677       print_signed_float(PSTR("Ey"), delta_endstop_adj[B_AXIS]);
// 5678       print_signed_float(PSTR("Ez"), delta_endstop_adj[C_AXIS]);
// 5679     }
// 5680     if (end_stops && tower_angles) {
// 5681       SERIAL_PROTOCOLPAIR("  Radius:", delta_radius);
// 5682       SERIAL_EOL();
// 5683       SERIAL_CHAR('.');
// 5684       SERIAL_PROTOCOL_SP(13);
// 5685     }
// 5686     if (tower_angles) {
// 5687       print_signed_float(PSTR("Tx"), delta_tower_angle_trim[A_AXIS]);
// 5688       print_signed_float(PSTR("Ty"), delta_tower_angle_trim[B_AXIS]);
// 5689       print_signed_float(PSTR("Tz"), delta_tower_angle_trim[C_AXIS]);
// 5690     }
// 5691     if ((!end_stops && tower_angles) || (end_stops && !tower_angles)) { // XOR
// 5692       SERIAL_PROTOCOLPAIR("  Radius:", delta_radius);
// 5693     }
// 5694     SERIAL_EOL();
// 5695   }
// 5696 
// 5697   static void print_G33_results(const float z_at_pt[NPP + 1], const bool tower_points, const bool opposite_points) {
// 5698     SERIAL_PROTOCOLPGM(".    ");
// 5699     print_signed_float(PSTR("c"), z_at_pt[CEN]);
// 5700     if (tower_points) {
// 5701       print_signed_float(PSTR(" x"), z_at_pt[__A]);
// 5702       print_signed_float(PSTR(" y"), z_at_pt[__B]);
// 5703       print_signed_float(PSTR(" z"), z_at_pt[__C]);
// 5704     }
// 5705     if (tower_points && opposite_points) {
// 5706       SERIAL_EOL();
// 5707       SERIAL_CHAR('.');
// 5708       SERIAL_PROTOCOL_SP(13);
// 5709     }
// 5710     if (opposite_points) {
// 5711       print_signed_float(PSTR("yz"), z_at_pt[_BC]);
// 5712       print_signed_float(PSTR("zx"), z_at_pt[_CA]);
// 5713       print_signed_float(PSTR("xy"), z_at_pt[_AB]);
// 5714     }
// 5715     SERIAL_EOL();
// 5716   }
// 5717 
// 5718   /**
// 5719    * After G33:
// 5720    *  - Move to the print ceiling (DELTA_HOME_TO_SAFE_ZONE only)
// 5721    *  - Stow the probe
// 5722    *  - Restore endstops state
// 5723    *  - Select the old tool, if needed
// 5724    */
// 5725   static void G33_cleanup(
// 5726     #if HOTENDS > 1
// 5727       const uint8_t old_tool_index
// 5728     #endif
// 5729   ) {
// 5730     #if ENABLED(DELTA_HOME_TO_SAFE_ZONE)
// 5731       do_blocking_move_to_z(delta_clip_start_height);
// 5732     #endif
// 5733     STOW_PROBE();
// 5734     clean_up_after_endstop_or_probe_move();
// 5735     #if HOTENDS > 1
// 5736       tool_change(old_tool_index, 0, true);
// 5737     #endif
// 5738   }
// 5739 
// 5740   inline float calibration_probe(const float nx, const float ny, const bool stow) {
// 5741     #if HAS_BED_PROBE
// 5742       return probe_pt(nx, ny, stow, 0, false);
// 5743     #else
// 5744       UNUSED(stow);
// 5745       return lcd_probe_pt(nx, ny);
// 5746     #endif
// 5747   }
// 5748 
// 5749   static float probe_G33_points(float z_at_pt[NPP + 1], const int8_t probe_points, const bool towers_set, const bool stow_after_each) {
// 5750     const bool _0p_calibration      = probe_points == 0,
// 5751                _1p_calibration      = probe_points == 1,
// 5752                _4p_calibration      = probe_points == 2,
// 5753                _4p_opposite_points  = _4p_calibration && !towers_set,
// 5754                _7p_calibration      = probe_points >= 3 || probe_points == 0,
// 5755                _7p_no_intermediates = probe_points == 3,
// 5756                _7p_1_intermediates  = probe_points == 4,
// 5757                _7p_2_intermediates  = probe_points == 5,
// 5758                _7p_4_intermediates  = probe_points == 6,
// 5759                _7p_6_intermediates  = probe_points == 7,
// 5760                _7p_8_intermediates  = probe_points == 8,
// 5761                _7p_11_intermediates = probe_points == 9,
// 5762                _7p_14_intermediates = probe_points == 10,
// 5763                _7p_intermed_points  = probe_points >= 4,
// 5764                _7p_6_centre         = probe_points >= 5 && probe_points <= 7,
// 5765                _7p_9_centre         = probe_points >= 8;
// 5766 
// 5767     LOOP_CAL_ALL(axis) z_at_pt[axis] = 0.0;
// 5768 
// 5769     if (!_0p_calibration) {
// 5770 
// 5771       if (!_7p_no_intermediates && !_7p_4_intermediates && !_7p_11_intermediates) { // probe the center
// 5772         z_at_pt[CEN] += calibration_probe(0, 0, stow_after_each);
// 5773         if (isnan(z_at_pt[CEN])) return NAN;
// 5774       }
// 5775 
// 5776       if (_7p_calibration) { // probe extra center points
// 5777         const float start  = _7p_9_centre ? _CA + _7P_STEP / 3.0 : _7p_6_centre ? _CA : __C,
// 5778                     steps  = _7p_9_centre ? _4P_STEP / 3.0 : _7p_6_centre ? _7P_STEP : _4P_STEP;
// 5779         I_LOOP_CAL_PT(axis, start, steps) {
// 5780           const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
// 5781                       r = delta_calibration_radius * 0.1;
// 5782           z_at_pt[CEN] += calibration_probe(cos(a) * r, sin(a) * r, stow_after_each);
// 5783           if (isnan(z_at_pt[CEN])) return NAN;
// 5784        }
// 5785         z_at_pt[CEN] /= float(_7p_2_intermediates ? 7 : probe_points);
// 5786       }
// 5787 
// 5788       if (!_1p_calibration) {  // probe the radius
// 5789         const CalEnum start  = _4p_opposite_points ? _AB : __A;
// 5790         const float   steps  = _7p_14_intermediates ? _7P_STEP / 15.0 : // 15r * 6 + 10c = 100
// 5791                                _7p_11_intermediates ? _7P_STEP / 12.0 : // 12r * 6 +  9c = 81
// 5792                                _7p_8_intermediates  ? _7P_STEP /  9.0 : //  9r * 6 + 10c = 64
// 5793                                _7p_6_intermediates  ? _7P_STEP /  7.0 : //  7r * 6 +  7c = 49
// 5794                                _7p_4_intermediates  ? _7P_STEP /  5.0 : //  5r * 6 +  6c = 36
// 5795                                _7p_2_intermediates  ? _7P_STEP /  3.0 : //  3r * 6 +  7c = 25
// 5796                                _7p_1_intermediates  ? _7P_STEP /  2.0 : //  2r * 6 +  4c = 16
// 5797                                _7p_no_intermediates ? _7P_STEP :        //  1r * 6 +  3c = 9
// 5798                                _4P_STEP;                                // .5r * 6 +  1c = 4
// 5799         bool zig_zag = true;
// 5800         F_LOOP_CAL_PT(axis, start, _7p_9_centre ? steps * 3 : steps) {
// 5801           const int8_t offset = _7p_9_centre ? 1 : 0;
// 5802           for (int8_t circle = -offset; circle <= offset; circle++) {
// 5803             const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
// 5804                         r = delta_calibration_radius * (1 + 0.1 * (zig_zag ? circle : - circle)),
// 5805                         interpol = fmod(axis, 1);
// 5806             const float z_temp = calibration_probe(cos(a) * r, sin(a) * r, stow_after_each);
// 5807             if (isnan(z_temp)) return NAN;
// 5808             // split probe point to neighbouring calibration points
// 5809             z_at_pt[uint8_t(round(axis - interpol + NPP - 1)) % NPP + 1] += z_temp * sq(cos(RADIANS(interpol * 90)));
// 5810             z_at_pt[uint8_t(round(axis - interpol))           % NPP + 1] += z_temp * sq(sin(RADIANS(interpol * 90)));
// 5811           }
// 5812           zig_zag = !zig_zag;
// 5813         }
// 5814         if (_7p_intermed_points)
// 5815           LOOP_CAL_RAD(axis)
// 5816             z_at_pt[axis] /= _7P_STEP / steps;
// 5817       }
// 5818 
// 5819       float S1 = z_at_pt[CEN],
// 5820             S2 = sq(z_at_pt[CEN]);
// 5821       int16_t N = 1;
// 5822       if (!_1p_calibration) { // std dev from zero plane
// 5823         LOOP_CAL_ACT(axis, _4p_calibration, _4p_opposite_points) {
// 5824           S1 += z_at_pt[axis];
// 5825           S2 += sq(z_at_pt[axis]);
// 5826           N++;
// 5827         }
// 5828         return round(SQRT(S2 / N) * 1000.0) / 1000.0 + 0.00001;
// 5829       }
// 5830     }
// 5831 
// 5832     return 0.00001;
// 5833   }
// 5834 
// 5835   #if HAS_BED_PROBE
// 5836 
// 5837     static bool G33_auto_tune() {
// 5838       float z_at_pt[NPP + 1]      = { 0.0 },
// 5839             z_at_pt_base[NPP + 1] = { 0.0 },
// 5840             z_temp, h_fac = 0.0, r_fac = 0.0, a_fac = 0.0, norm = 0.8;
// 5841 
// 5842       #define ZP(N,I) ((N) * z_at_pt[I])
// 5843       #define Z06(I)  ZP(6, I)
// 5844       #define Z03(I)  ZP(3, I)
// 5845       #define Z02(I)  ZP(2, I)
// 5846       #define Z01(I)  ZP(1, I)
// 5847       #define Z32(I)  ZP(3/2, I)
// 5848 
// 5849       SERIAL_PROTOCOLPGM("AUTO TUNE baseline");
// 5850       SERIAL_EOL();
// 5851       if (isnan(probe_G33_points(z_at_pt_base, 3, true, false))) return false;
// 5852       print_G33_results(z_at_pt_base, true, true);
// 5853 
// 5854       LOOP_XYZ(axis) {
// 5855         delta_endstop_adj[axis] -= 1.0;
// 5856         recalc_delta_settings();
// 5857 
// 5858         endstops.enable(true);
// 5859         if (!home_delta()) return false;
// 5860         endstops.not_homing();
// 5861 
// 5862         SERIAL_PROTOCOLPGM("Tuning E");
// 5863         SERIAL_CHAR(tolower(axis_codes[axis]));
// 5864         SERIAL_EOL();
// 5865 
// 5866         if (isnan(probe_G33_points(z_at_pt, 3, true, false))) return false;
// 5867         LOOP_CAL_ALL(axis) z_at_pt[axis] -= z_at_pt_base[axis];
// 5868         print_G33_results(z_at_pt, true, true);
// 5869         delta_endstop_adj[axis] += 1.0;
// 5870         recalc_delta_settings();
// 5871         switch (axis) {
// 5872           case A_AXIS :
// 5873             h_fac += 4.0 / (Z03(CEN) +Z01(__A)                               +Z32(_CA) +Z32(_AB)); // Offset by X-tower end-stop
// 5874             break;
// 5875           case B_AXIS :
// 5876             h_fac += 4.0 / (Z03(CEN)           +Z01(__B)           +Z32(_BC)           +Z32(_AB)); // Offset by Y-tower end-stop
// 5877             break;
// 5878           case C_AXIS :
// 5879             h_fac += 4.0 / (Z03(CEN)                     +Z01(__C) +Z32(_BC) +Z32(_CA)          ); // Offset by Z-tower end-stop
// 5880             break;
// 5881         }
// 5882       }
// 5883       h_fac /= 3.0;
// 5884       h_fac *= norm; // Normalize to 1.02 for Kossel mini
// 5885 
// 5886       for (int8_t zig_zag = -1; zig_zag < 2; zig_zag += 2) {
// 5887         delta_radius += 1.0 * zig_zag;
// 5888         recalc_delta_settings();
// 5889 
// 5890         endstops.enable(true);
// 5891         if (!home_delta()) return false;
// 5892         endstops.not_homing();
// 5893 
// 5894         SERIAL_PROTOCOLPGM("Tuning R");
// 5895         SERIAL_PROTOCOL(zig_zag == -1 ? "-" : "+");
// 5896         SERIAL_EOL();
// 5897         if (isnan(probe_G33_points(z_at_pt, 3, true, false))) return false;
// 5898         LOOP_CAL_ALL(axis) z_at_pt[axis] -= z_at_pt_base[axis];
// 5899         print_G33_results(z_at_pt, true, true);
// 5900         delta_radius -= 1.0 * zig_zag;
// 5901         recalc_delta_settings();
// 5902         r_fac -= zig_zag * 6.0 / (Z03(__A) +Z03(__B) +Z03(__C) +Z03(_BC) +Z03(_CA) +Z03(_AB)); // Offset by delta radius
// 5903       }
// 5904       r_fac /= 2.0;
// 5905       r_fac *= 3 * norm; // Normalize to 2.25 for Kossel mini
// 5906 
// 5907       LOOP_XYZ(axis) {
// 5908         delta_tower_angle_trim[axis] += 1.0;
// 5909         delta_endstop_adj[(axis + 1) % 3] -= 1.0 / 4.5;
// 5910         delta_endstop_adj[(axis + 2) % 3] += 1.0 / 4.5;
// 5911         z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
// 5912         delta_height -= z_temp;
// 5913         LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
// 5914         recalc_delta_settings();
// 5915 
// 5916         endstops.enable(true);
// 5917         if (!home_delta()) return false;
// 5918         endstops.not_homing();
// 5919 
// 5920         SERIAL_PROTOCOLPGM("Tuning T");
// 5921         SERIAL_CHAR(tolower(axis_codes[axis]));
// 5922         SERIAL_EOL();
// 5923 
// 5924         if (isnan(probe_G33_points(z_at_pt, 3, true, false))) return false;
// 5925         LOOP_CAL_ALL(axis) z_at_pt[axis] -= z_at_pt_base[axis];
// 5926         print_G33_results(z_at_pt, true, true);
// 5927 
// 5928         delta_tower_angle_trim[axis] -= 1.0;
// 5929         delta_endstop_adj[(axis+1) % 3] += 1.0/4.5;
// 5930         delta_endstop_adj[(axis+2) % 3] -= 1.0/4.5;
// 5931         z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
// 5932         delta_height -= z_temp;
// 5933         LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
// 5934         recalc_delta_settings();
// 5935         switch (axis) {
// 5936           case A_AXIS :
// 5937             a_fac += 4.0 / (          Z06(__B) -Z06(__C)           +Z06(_CA) -Z06(_AB)); // Offset by alpha tower angle
// 5938             break;
// 5939           case B_AXIS :
// 5940             a_fac += 4.0 / (-Z06(__A)          +Z06(__C) -Z06(_BC)           +Z06(_AB)); // Offset by beta tower angle
// 5941             break;
// 5942           case C_AXIS :
// 5943             a_fac += 4.0 / (Z06(__A) -Z06(__B)           +Z06(_BC) -Z06(_CA)          ); // Offset by gamma tower angle
// 5944             break;
// 5945         }
// 5946       }
// 5947       a_fac /= 3.0;
// 5948       a_fac *= norm; // Normalize to 0.83 for Kossel mini
// 5949 
// 5950       endstops.enable(true);
// 5951       if (!home_delta()) return false;
// 5952       endstops.not_homing();
// 5953       print_signed_float(PSTR( "H_FACTOR: "), h_fac);
// 5954       print_signed_float(PSTR(" R_FACTOR: "), r_fac);
// 5955       print_signed_float(PSTR(" A_FACTOR: "), a_fac);
// 5956       SERIAL_EOL();
// 5957       SERIAL_PROTOCOLPGM("Copy these values to Configuration.h");
// 5958       SERIAL_EOL();
// 5959       return true;
// 5960     }
// 5961 
// 5962   #endif // HAS_BED_PROBE
// 5963 
// 5964   /**
// 5965    * G33 - Delta '1-4-7-point' Auto-Calibration
// 5966    *       Calibrate height, endstops, delta radius, and tower angles.
// 5967    *
// 5968    * Parameters:
// 5969    *
// 5970    *   Pn  Number of probe points:
// 5971    *      P0     No probe. Normalize only.
// 5972    *      P1     Probe center and set height only.
// 5973    *      P2     Probe center and towers. Set height, endstops and delta radius.
// 5974    *      P3     Probe all positions: center, towers and opposite towers. Set all.
// 5975    *      P4-P10 Probe all positions + at different itermediate locations and average them.
// 5976    *
// 5977    *   T   Don't calibrate tower angle corrections
// 5978    *
// 5979    *   Cn.nn  Calibration precision; when omitted calibrates to maximum precision
// 5980    *
// 5981    *   Fn  Force to run at least n iterations and takes the best result
// 5982    *
// 5983    *   A   Auto tune calibartion factors (set in Configuration.h)
// 5984    *
// 5985    *   Vn  Verbose level:
// 5986    *      V0  Dry-run mode. Report settings and probe results. No calibration.
// 5987    *      V1  Report start and end settings only
// 5988    *      V2  Report settings at each iteration
// 5989    *      V3  Report settings and probe results
// 5990    *
// 5991    *   E   Engage the probe for each point
// 5992    */
// 5993   inline void gcode_G33() {
// 5994 
// 5995     const int8_t probe_points = parser.intval('P', DELTA_CALIBRATION_DEFAULT_POINTS);
// 5996     if (!WITHIN(probe_points, 0, 10)) {
// 5997       SERIAL_PROTOCOLLNPGM("?(P)oints is implausible (0-10).");
// 5998       return;
// 5999     }
// 6000 
// 6001     const int8_t verbose_level = parser.byteval('V', 1);
// 6002     if (!WITHIN(verbose_level, 0, 3)) {
// 6003       SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-3).");
// 6004       return;
// 6005     }
// 6006 
// 6007     const float calibration_precision = parser.floatval('C', 0.0);
// 6008     if (calibration_precision < 0) {
// 6009       SERIAL_PROTOCOLLNPGM("?(C)alibration precision is implausible (>=0).");
// 6010       return;
// 6011     }
// 6012 
// 6013     const int8_t force_iterations = parser.intval('F', 0);
// 6014     if (!WITHIN(force_iterations, 0, 30)) {
// 6015       SERIAL_PROTOCOLLNPGM("?(F)orce iteration is implausible (0-30).");
// 6016       return;
// 6017     }
// 6018 
// 6019     const bool towers_set           = !parser.boolval('T'),
// 6020                auto_tune            = parser.boolval('A'),
// 6021                stow_after_each      = parser.boolval('E'),
// 6022                _0p_calibration      = probe_points == 0,
// 6023                _1p_calibration      = probe_points == 1,
// 6024                _4p_calibration      = probe_points == 2,
// 6025                _7p_9_centre         = probe_points >= 8,
// 6026                _tower_results       = (_4p_calibration && towers_set)
// 6027                                       || probe_points >= 3 || probe_points == 0,
// 6028                _opposite_results    = (_4p_calibration && !towers_set)
// 6029                                       || probe_points >= 3 || probe_points == 0,
// 6030                _endstop_results     = probe_points != 1,
// 6031                _angle_results       = (probe_points >= 3 || probe_points == 0) && towers_set;
// 6032     const static char save_message[] PROGMEM = "Save with M500 and/or copy to Configuration.h";
// 6033     int8_t iterations = 0;
// 6034     float test_precision,
// 6035           zero_std_dev = (verbose_level ? 999.0 : 0.0), // 0.0 in dry-run mode : forced end
// 6036           zero_std_dev_min = zero_std_dev,
// 6037           e_old[ABC] = {
// 6038             delta_endstop_adj[A_AXIS],
// 6039             delta_endstop_adj[B_AXIS],
// 6040             delta_endstop_adj[C_AXIS]
// 6041           },
// 6042           dr_old = delta_radius,
// 6043           zh_old = delta_height,
// 6044           ta_old[ABC] = {
// 6045             delta_tower_angle_trim[A_AXIS],
// 6046             delta_tower_angle_trim[B_AXIS],
// 6047             delta_tower_angle_trim[C_AXIS]
// 6048           };
// 6049 
// 6050     SERIAL_PROTOCOLLNPGM("G33 Auto Calibrate");
// 6051 
// 6052     if (!_1p_calibration && !_0p_calibration) {  // test if the outer radius is reachable
// 6053       LOOP_CAL_RAD(axis) {
// 6054         const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
// 6055                     r = delta_calibration_radius * (1 + (_7p_9_centre ? 0.1 : 0.0));
// 6056         if (!position_is_reachable(cos(a) * r, sin(a) * r)) {
// 6057           SERIAL_PROTOCOLLNPGM("?(M665 B)ed radius is implausible.");
// 6058           return;
// 6059         }
// 6060       }
// 6061     }
// 6062 
// 6063     stepper.synchronize();
// 6064     #if HAS_LEVELING
// 6065       reset_bed_level(); // After calibration bed-level data is no longer valid
// 6066     #endif
// 6067 
// 6068     #if HOTENDS > 1
// 6069       const uint8_t old_tool_index = active_extruder;
// 6070       tool_change(0, 0, true);
// 6071       #define G33_CLEANUP() G33_cleanup(old_tool_index)
// 6072     #else
// 6073       #define G33_CLEANUP() G33_cleanup()
// 6074     #endif
// 6075 
// 6076     setup_for_endstop_or_probe_move();
// 6077     endstops.enable(true);
// 6078     if (!_0p_calibration) {
// 6079       if (!home_delta())
// 6080         return;
// 6081       endstops.not_homing();
// 6082     }
// 6083 
// 6084     if (auto_tune) {
// 6085       #if HAS_BED_PROBE
// 6086         G33_auto_tune();
// 6087       #else
// 6088         SERIAL_PROTOCOLLNPGM("A probe is needed for auto-tune");
// 6089       #endif
// 6090       G33_CLEANUP();
// 6091       return;
// 6092     }
// 6093 
// 6094     // Report settings
// 6095 
// 6096     const char *checkingac = PSTR("Checking... AC"); // TODO: Make translatable string
// 6097     serialprintPGM(checkingac);
// 6098     if (verbose_level == 0) SERIAL_PROTOCOLPGM(" (DRY-RUN)");
// 6099     SERIAL_EOL();
// 6100     lcd_setstatusPGM(checkingac);
// 6101 
// 6102     print_G33_settings(_endstop_results, _angle_results);
// 6103 
// 6104     do {
// 6105 
// 6106       float z_at_pt[NPP + 1] = { 0.0 };
// 6107 
// 6108       test_precision = zero_std_dev;
// 6109 
// 6110       iterations++;
// 6111 
// 6112       // Probe the points
// 6113 
// 6114       zero_std_dev = probe_G33_points(z_at_pt, probe_points, towers_set, stow_after_each);
// 6115       if (isnan(zero_std_dev)) {
// 6116         SERIAL_PROTOCOLPGM("Correct delta_radius with M665 R or end-stops with M666 X Y Z");
// 6117         SERIAL_EOL();
// 6118         return G33_CLEANUP();
// 6119       }
// 6120 
// 6121       // Solve matrices
// 6122 
// 6123       if ((zero_std_dev < test_precision || iterations <= force_iterations) && zero_std_dev > calibration_precision) {
// 6124         if (zero_std_dev < zero_std_dev_min) {
// 6125           COPY(e_old, delta_endstop_adj);
// 6126           dr_old = delta_radius;
// 6127           zh_old = delta_height;
// 6128           COPY(ta_old, delta_tower_angle_trim);
// 6129         }
// 6130 
// 6131         float e_delta[ABC] = { 0.0 }, r_delta = 0.0, t_delta[ABC] = { 0.0 };
// 6132         const float r_diff = delta_radius - delta_calibration_radius,
// 6133                     h_factor = 1 / 6.0 *
// 6134                       #ifdef H_FACTOR
// 6135                         (H_FACTOR),                                       // Set in Configuration.h
// 6136                       #else
// 6137                         (1.00 + r_diff * 0.001),                          // 1.02 for r_diff = 20mm
// 6138                       #endif
// 6139                     r_factor = 1 / 6.0 *
// 6140                       #ifdef R_FACTOR
// 6141                         -(R_FACTOR),                                      // Set in Configuration.h
// 6142                       #else
// 6143                         -(1.75 + 0.005 * r_diff + 0.001 * sq(r_diff)),    // 2.25 for r_diff = 20mm
// 6144                       #endif
// 6145                     a_factor = 1 / 6.0 *
// 6146                       #ifdef A_FACTOR
// 6147                         (A_FACTOR);                                       // Set in Configuration.h
// 6148                       #else
// 6149                         (66.66 / delta_calibration_radius);               // 0.83 for cal_rd = 80mm
// 6150                       #endif
// 6151 
// 6152         #define ZP(N,I) ((N) * z_at_pt[I])
// 6153         #define Z6(I) ZP(6, I)
// 6154         #define Z4(I) ZP(4, I)
// 6155         #define Z2(I) ZP(2, I)
// 6156         #define Z1(I) ZP(1, I)
// 6157 
// 6158         #if !HAS_BED_PROBE
// 6159           test_precision = 0.00; // forced end
// 6160         #endif
// 6161 
// 6162         switch (probe_points) {
// 6163           case 0:
// 6164             test_precision = 0.00; // forced end
// 6165             break;
// 6166 
// 6167           case 1:
// 6168             test_precision = 0.00; // forced end
// 6169             LOOP_XYZ(axis) e_delta[axis] = Z1(CEN);
// 6170             break;
// 6171 
// 6172           case 2:
// 6173             if (towers_set) {
// 6174               e_delta[A_AXIS] = (Z6(CEN) +Z4(__A) -Z2(__B) -Z2(__C)) * h_factor;
// 6175               e_delta[B_AXIS] = (Z6(CEN) -Z2(__A) +Z4(__B) -Z2(__C)) * h_factor;
// 6176               e_delta[C_AXIS] = (Z6(CEN) -Z2(__A) -Z2(__B) +Z4(__C)) * h_factor;
// 6177               r_delta         = (Z6(CEN) -Z2(__A) -Z2(__B) -Z2(__C)) * r_factor;
// 6178             }
// 6179             else {
// 6180               e_delta[A_AXIS] = (Z6(CEN) -Z4(_BC) +Z2(_CA) +Z2(_AB)) * h_factor;
// 6181               e_delta[B_AXIS] = (Z6(CEN) +Z2(_BC) -Z4(_CA) +Z2(_AB)) * h_factor;
// 6182               e_delta[C_AXIS] = (Z6(CEN) +Z2(_BC) +Z2(_CA) -Z4(_AB)) * h_factor;
// 6183               r_delta         = (Z6(CEN) -Z2(_BC) -Z2(_CA) -Z2(_AB)) * r_factor;
// 6184             }
// 6185             break;
// 6186 
// 6187           default:
// 6188             e_delta[A_AXIS] = (Z6(CEN) +Z2(__A) -Z1(__B) -Z1(__C) -Z2(_BC) +Z1(_CA) +Z1(_AB)) * h_factor;
// 6189             e_delta[B_AXIS] = (Z6(CEN) -Z1(__A) +Z2(__B) -Z1(__C) +Z1(_BC) -Z2(_CA) +Z1(_AB)) * h_factor;
// 6190             e_delta[C_AXIS] = (Z6(CEN) -Z1(__A) -Z1(__B) +Z2(__C) +Z1(_BC) +Z1(_CA) -Z2(_AB)) * h_factor;
// 6191             r_delta         = (Z6(CEN) -Z1(__A) -Z1(__B) -Z1(__C) -Z1(_BC) -Z1(_CA) -Z1(_AB)) * r_factor;
// 6192 
// 6193             if (towers_set) {
// 6194               t_delta[A_AXIS] = (         -Z4(__B) +Z4(__C)          -Z4(_CA) +Z4(_AB)) * a_factor;
// 6195               t_delta[B_AXIS] = ( Z4(__A)          -Z4(__C) +Z4(_BC)          -Z4(_AB)) * a_factor;
// 6196               t_delta[C_AXIS] = (-Z4(__A) +Z4(__B)          -Z4(_BC) +Z4(_CA)         ) * a_factor;
// 6197               e_delta[A_AXIS] += (t_delta[B_AXIS] - t_delta[C_AXIS]) / 4.5;
// 6198               e_delta[B_AXIS] += (t_delta[C_AXIS] - t_delta[A_AXIS]) / 4.5;
// 6199               e_delta[C_AXIS] += (t_delta[A_AXIS] - t_delta[B_AXIS]) / 4.5;
// 6200             }
// 6201             break;
// 6202         }
// 6203 
// 6204         LOOP_XYZ(axis) delta_endstop_adj[axis] += e_delta[axis];
// 6205         delta_radius += r_delta;
// 6206         LOOP_XYZ(axis) delta_tower_angle_trim[axis] += t_delta[axis];
// 6207       }
// 6208       else if (zero_std_dev >= test_precision) {   // step one back
// 6209         COPY(delta_endstop_adj, e_old);
// 6210         delta_radius = dr_old;
// 6211         delta_height = zh_old;
// 6212         COPY(delta_tower_angle_trim, ta_old);
// 6213       }
// 6214 
// 6215       if (verbose_level != 0) {                                    // !dry run
// 6216         // normalise angles to least squares
// 6217         if (_angle_results) {
// 6218           float a_sum = 0.0;
// 6219           LOOP_XYZ(axis) a_sum += delta_tower_angle_trim[axis];
// 6220           LOOP_XYZ(axis) delta_tower_angle_trim[axis] -= a_sum / 3.0;
// 6221         }
// 6222 
// 6223         // adjust delta_height and endstops by the max amount
// 6224         const float z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
// 6225         delta_height -= z_temp;
// 6226         LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
// 6227       }
// 6228       recalc_delta_settings();
// 6229       NOMORE(zero_std_dev_min, zero_std_dev);
// 6230 
// 6231       // print report
// 6232 
// 6233       if (verbose_level > 2)
// 6234         print_G33_results(z_at_pt, _tower_results, _opposite_results);
// 6235 
// 6236       if (verbose_level != 0) {                                    // !dry run
// 6237         if ((zero_std_dev >= test_precision && iterations > force_iterations) || zero_std_dev <= calibration_precision) {  // end iterations
// 6238           SERIAL_PROTOCOLPGM("Calibration OK");
// 6239           SERIAL_PROTOCOL_SP(32);
// 6240           #if HAS_BED_PROBE
// 6241             if (zero_std_dev >= test_precision && !_1p_calibration)
// 6242               SERIAL_PROTOCOLPGM("rolling back.");
// 6243             else
// 6244           #endif
// 6245             {
// 6246               SERIAL_PROTOCOLPGM("std dev:");
// 6247               SERIAL_PROTOCOL_F(zero_std_dev_min, 3);
// 6248             }
// 6249           SERIAL_EOL();
// 6250           char mess[21];
// 6251           strcpy_P(mess, PSTR("Calibration sd:"));
// 6252           if (zero_std_dev_min < 1)
// 6253             sprintf_P(&mess[15], PSTR("0.%03i"), (int)round(zero_std_dev_min * 1000.0));
// 6254           else
// 6255             sprintf_P(&mess[15], PSTR("%03i.x"), (int)round(zero_std_dev_min));
// 6256           lcd_setstatus(mess);
// 6257           print_G33_settings(_endstop_results, _angle_results);
// 6258           serialprintPGM(save_message);
// 6259           SERIAL_EOL();
// 6260         }
// 6261         else {                                                     // !end iterations
// 6262           char mess[15];
// 6263           if (iterations < 31)
// 6264             sprintf_P(mess, PSTR("Iteration : %02i"), (int)iterations);
// 6265           else
// 6266             strcpy_P(mess, PSTR("No convergence"));
// 6267           SERIAL_PROTOCOL(mess);
// 6268           SERIAL_PROTOCOL_SP(32);
// 6269           SERIAL_PROTOCOLPGM("std dev:");
// 6270           SERIAL_PROTOCOL_F(zero_std_dev, 3);
// 6271           SERIAL_EOL();
// 6272           lcd_setstatus(mess);
// 6273           if (verbose_level > 1)
// 6274             print_G33_settings(_endstop_results, _angle_results);
// 6275         }
// 6276       }
// 6277       else {                                                       // dry run
// 6278         const char *enddryrun = PSTR("End DRY-RUN");
// 6279         serialprintPGM(enddryrun);
// 6280         SERIAL_PROTOCOL_SP(35);
// 6281         SERIAL_PROTOCOLPGM("std dev:");
// 6282         SERIAL_PROTOCOL_F(zero_std_dev, 3);
// 6283         SERIAL_EOL();
// 6284 
// 6285         char mess[21];
// 6286         strcpy_P(mess, enddryrun);
// 6287         strcpy_P(&mess[11], PSTR(" sd:"));
// 6288         if (zero_std_dev < 1)
// 6289           sprintf_P(&mess[15], PSTR("0.%03i"), (int)round(zero_std_dev * 1000.0));
// 6290         else
// 6291           sprintf_P(&mess[15], PSTR("%03i.x"), (int)round(zero_std_dev));
// 6292         lcd_setstatus(mess);
// 6293       }
// 6294 
// 6295       endstops.enable(true);
// 6296       if (!home_delta())
// 6297         return;
// 6298       endstops.not_homing();
// 6299 
// 6300     }
// 6301     while (((zero_std_dev < test_precision && iterations < 31) || iterations <= force_iterations) && zero_std_dev > calibration_precision);
// 6302 
// 6303     G33_CLEANUP();
// 6304   }
// 6305 
// 6306 #endif // DELTA_AUTO_CALIBRATION
// 6307 
// 6308 #if ENABLED(G38_PROBE_TARGET)
// 6309 
// 6310   static bool G38_run_probe() {
// 6311 
// 6312     bool G38_pass_fail = false;
// 6313 
// 6314     #if MULTIPLE_PROBING > 1
// 6315       // Get direction of move and retract
// 6316       float retract_mm[XYZ];
// 6317       LOOP_XYZ(i) {
// 6318         float dist = destination[i] - current_position[i];
// 6319         retract_mm[i] = FABS(dist) < G38_MINIMUM_MOVE ? 0 : home_bump_mm((AxisEnum)i) * (dist > 0 ? -1 : 1);
// 6320       }
// 6321     #endif
// 6322 
// 6323     stepper.synchronize();  // wait until the machine is idle
// 6324 
// 6325     // Move until destination reached or target hit
// 6326     endstops.enable(true);
// 6327     G38_move = true;
// 6328     G38_endstop_hit = false;
// 6329     prepare_move_to_destination();
// 6330     stepper.synchronize();
// 6331     G38_move = false;
// 6332 
// 6333     endstops.hit_on_purpose();
// 6334     set_current_from_steppers_for_axis(ALL_AXES);
// 6335     SYNC_PLAN_POSITION_KINEMATIC();
// 6336 
// 6337     if (G38_endstop_hit) {
// 6338 
// 6339       G38_pass_fail = true;
// 6340 
// 6341       #if MULTIPLE_PROBING > 1
// 6342         // Move away by the retract distance
// 6343         set_destination_from_current();
// 6344         LOOP_XYZ(i) destination[i] += retract_mm[i];
// 6345         endstops.enable(false);
// 6346         prepare_move_to_destination();
// 6347         stepper.synchronize();
// 6348 
// 6349         feedrate_mm_s /= 4;
// 6350 
// 6351         // Bump the target more slowly
// 6352         LOOP_XYZ(i) destination[i] -= retract_mm[i] * 2;
// 6353 
// 6354         endstops.enable(true);
// 6355         G38_move = true;
// 6356         prepare_move_to_destination();
// 6357         stepper.synchronize();
// 6358         G38_move = false;
// 6359 
// 6360         set_current_from_steppers_for_axis(ALL_AXES);
// 6361         SYNC_PLAN_POSITION_KINEMATIC();
// 6362       #endif
// 6363     }
// 6364 
// 6365     endstops.hit_on_purpose();
// 6366     endstops.not_homing();
// 6367     return G38_pass_fail;
// 6368   }
// 6369 
// 6370   /**
// 6371    * G38.2 - probe toward workpiece, stop on contact, signal error if failure
// 6372    * G38.3 - probe toward workpiece, stop on contact
// 6373    *
// 6374    * Like G28 except uses Z min probe for all axes
// 6375    */
// 6376   inline void gcode_G38(bool is_38_2) {
// 6377     // Get X Y Z E F
// 6378     gcode_get_destination();
// 6379 
// 6380     setup_for_endstop_or_probe_move();
// 6381 
// 6382     // If any axis has enough movement, do the move
// 6383     LOOP_XYZ(i)
// 6384       if (FABS(destination[i] - current_position[i]) >= G38_MINIMUM_MOVE) {
// 6385         if (!parser.seenval('F')) feedrate_mm_s = homing_feedrate_mm_s[(AxisEnum)i];
// 6386         // If G38.2 fails throw an error
// 6387         if (!G38_run_probe() && is_38_2) {
// 6388           SERIAL_ERROR_START();
// 6389           SERIAL_ERRORLNPGM("Failed to reach target");
// 6390         }
// 6391         break;
// 6392       }
// 6393 
// 6394     clean_up_after_endstop_or_probe_move();
// 6395   }
// 6396 
// 6397 #endif // G38_PROBE_TARGET
// 6398 
// 6399 #if HAS_MESH
// 6400 
// 6401   /**
// 6402    * G42: Move X & Y axes to mesh coordinates (I & J)
// 6403    */
// 6404   inline void gcode_G42() {
// 6405     #if ENABLED(NO_MOTION_BEFORE_HOMING)
// 6406       if (axis_unhomed_error()) return;
// 6407     #endif
// 6408 
// 6409     if (IsRunning()) {
// 6410       const bool hasI = parser.seenval('I');
// 6411       const int8_t ix = hasI ? parser.value_int() : 0;
// 6412       const bool hasJ = parser.seenval('J');
// 6413       const int8_t iy = hasJ ? parser.value_int() : 0;
// 6414 
// 6415       if ((hasI && !WITHIN(ix, 0, GRID_MAX_POINTS_X - 1)) || (hasJ && !WITHIN(iy, 0, GRID_MAX_POINTS_Y - 1))) {
// 6416         SERIAL_ECHOLNPGM(MSG_ERR_MESH_XY);
// 6417         return;
// 6418       }
// 6419 
// 6420       set_destination_from_current();
// 6421       if (hasI) destination[X_AXIS] = _GET_MESH_X(ix);
// 6422       if (hasJ) destination[Y_AXIS] = _GET_MESH_Y(iy);
// 6423       if (parser.boolval('P')) {
// 6424         if (hasI) destination[X_AXIS] -= X_PROBE_OFFSET_FROM_EXTRUDER;
// 6425         if (hasJ) destination[Y_AXIS] -= Y_PROBE_OFFSET_FROM_EXTRUDER;
// 6426       }
// 6427 
// 6428       const float fval = parser.linearval('F');
// 6429       if (fval > 0.0) feedrate_mm_s = MMM_TO_MMS(fval);
// 6430 
// 6431       // SCARA kinematic has "safe" XY raw moves
// 6432       #if IS_SCARA
// 6433         prepare_uninterpolated_move_to_destination();
// 6434       #else
// 6435         prepare_move_to_destination();
// 6436       #endif
// 6437     }
// 6438   }
// 6439 
// 6440 #endif // HAS_MESH
// 6441 
// 6442 /**
// 6443  * G92: Set current position to given X Y Z E
// 6444  */
// 6445 inline void gcode_G92() {
// 6446 
// 6447   stepper.synchronize();
// 6448 
// 6449   #if ENABLED(CNC_COORDINATE_SYSTEMS)
// 6450     switch (parser.subcode) {
// 6451       case 1:
// 6452         // Zero the G92 values and restore current position
// 6453         #if !IS_SCARA
// 6454           LOOP_XYZ(i) {
// 6455             const float v = position_shift[i];
// 6456             if (v) {
// 6457               position_shift[i] = 0;
// 6458               update_software_endstops((AxisEnum)i);
// 6459             }
// 6460           }
// 6461         #endif // Not SCARA
// 6462         return;
// 6463     }
// 6464   #endif
// 6465 
// 6466   #if ENABLED(CNC_COORDINATE_SYSTEMS)
// 6467     #define IS_G92_0 (parser.subcode == 0)
// 6468   #else
// 6469     #define IS_G92_0 true
// 6470   #endif
// 6471 
// 6472   bool didE = false;
// 6473 //  #if IS_SCARA || !HAS_POSITION_SHIFT
// 6474   #if 1	//mks dlp
// 6475     bool didXYZ = false;
// 6476   #else
// 6477     constexpr bool didXYZ = false;
// 6478   #endif
// 6479 
// 6480   if (IS_G92_0) LOOP_XYZE(i) {
// 6481     if (parser.seenval(axis_codes[i])) {
// 6482       const float l = parser.value_axis_units((AxisEnum)i),
// 6483                   v = i == E_AXIS ? l : LOGICAL_TO_NATIVE(l, i),
// 6484                   d = v - current_position[i];
// 6485       if (!NEAR_ZERO(d)) {
// 6486         //#if IS_SCARA || !HAS_POSITION_SHIFT
// 6487 		#if 1	//mks dlp
// 6488           if (i == E_AXIS) didE = true; else didXYZ = true;
// 6489           current_position[i] = v;        // Without workspaces revert to Marlin 1.0 behavior
// 6490         #elif HAS_POSITION_SHIFT
// 6491           if (i == E_AXIS) {
// 6492             didE = true;
// 6493             current_position[E_AXIS] = v; // When using coordinate spaces, only E is set directly
// 6494           }
// 6495           else {
// 6496             position_shift[i] += d;       // Other axes simply offset the coordinate space
// 6497             update_software_endstops((AxisEnum)i);
// 6498           }
// 6499         #endif
// 6500       }
// 6501     }
// 6502   }
// 6503 
// 6504   #if ENABLED(CNC_COORDINATE_SYSTEMS)
// 6505     // Apply workspace offset to the active coordinate system
// 6506     if (WITHIN(active_coordinate_system, 0, MAX_COORDINATE_SYSTEMS - 1))
// 6507       COPY(coordinate_system[active_coordinate_system], position_shift);
// 6508   #endif
// 6509 
// 6510   if (didXYZ)
// 6511     SYNC_PLAN_POSITION_KINEMATIC();
// 6512   else if (didE)
// 6513     sync_plan_position_e();
// 6514 
// 6515   report_current_position();
// 6516 }
// 6517 
// 6518 #if HAS_RESUME_CONTINUE
// 6519 
// 6520   /**
// 6521    * M0: Unconditional stop - Wait for user button press on LCD
// 6522    * M1: Conditional stop   - Wait for user button press on LCD
// 6523    */
// 6524   inline void gcode_M0_M1() {
// 6525     const char * const args = parser.string_arg;
// 6526 
// 6527     millis_t ms = 0;
// 6528     bool hasP = false, hasS = false;
// 6529     if (parser.seenval('P')) {
// 6530       ms = parser.value_millis(); // milliseconds to wait
// 6531       hasP = ms > 0;
// 6532     }
// 6533     if (parser.seenval('S')) {
// 6534       ms = parser.value_millis_from_seconds(); // seconds to wait
// 6535       hasS = ms > 0;
// 6536     }
// 6537 
// 6538     #if ENABLED(ULTIPANEL)
// 6539 
// 6540       if (!hasP && !hasS && args && *args)
// 6541         lcd_setstatus(args, true);
// 6542       else {
// 6543         LCD_MESSAGEPGM(MSG_USERWAIT);
// 6544         #if ENABLED(LCD_PROGRESS_BAR) && PROGRESS_MSG_EXPIRE > 0
// 6545           dontExpireStatus();
// 6546         #endif
// 6547       }
// 6548 
// 6549     #else
// 6550 
// 6551       if (!hasP && !hasS && args && *args) {
// 6552         SERIAL_ECHO_START();
// 6553         SERIAL_ECHOLN(args);
// 6554       }
// 6555 
// 6556     #endif
// 6557 
// 6558     KEEPALIVE_STATE(PAUSED_FOR_USER);
// 6559     wait_for_user = true;
// 6560 
// 6561     stepper.synchronize();
// 6562     refresh_cmd_timeout();
// 6563 
// 6564     if (ms > 0) {
// 6565       ms += previous_cmd_ms;  // wait until this time for a click
// 6566       while (PENDING(millis(), ms) && wait_for_user) idle();
// 6567     }
// 6568     else {
// 6569       #if ENABLED(ULTIPANEL)
// 6570         if (lcd_detected()) {
// 6571           while (wait_for_user) idle();
// 6572           print_job_timer.isPaused() ? LCD_MESSAGEPGM(WELCOME_MSG) : LCD_MESSAGEPGM(MSG_RESUMING);
// 6573         }
// 6574       #else
// 6575         while (wait_for_user) idle();
// 6576       #endif
// 6577     }
// 6578 
// 6579     wait_for_user = false;
// 6580     KEEPALIVE_STATE(IN_HANDLER);
// 6581   }
// 6582 
// 6583 #endif // HAS_RESUME_CONTINUE
// 6584 
// 6585 #if ENABLED(SPINDLE_LASER_ENABLE)
// 6586   /**
// 6587    * M3: Spindle Clockwise
// 6588    * M4: Spindle Counter-clockwise
// 6589    *
// 6590    *  S0 turns off spindle.
// 6591    *
// 6592    *  If no speed PWM output is defined then M3/M4 just turns it on.
// 6593    *
// 6594    *  At least 12.8KHz (50Hz * 256) is needed for spindle PWM.
// 6595    *  Hardware PWM is required. ISRs are too slow.
// 6596    *
// 6597    * NOTE: WGM for timers 3, 4, and 5 must be either Mode 1 or Mode 5.
// 6598    *       No other settings give a PWM signal that goes from 0 to 5 volts.
// 6599    *
// 6600    *       The system automatically sets WGM to Mode 1, so no special
// 6601    *       initialization is needed.
// 6602    *
// 6603    *       WGM bits for timer 2 are automatically set by the system to
// 6604    *       Mode 1. This produces an acceptable 0 to 5 volt signal.
// 6605    *       No special initialization is needed.
// 6606    *
// 6607    * NOTE: A minimum PWM frequency of 50 Hz is needed. All prescaler
// 6608    *       factors for timers 2, 3, 4, and 5 are acceptable.
// 6609    *
// 6610    *  SPINDLE_LASER_ENABLE_PIN needs an external pullup or it may power on
// 6611    *  the spindle/laser during power-up or when connecting to the host
// 6612    *  (usually goes through a reset which sets all I/O pins to tri-state)
// 6613    *
// 6614    *  PWM duty cycle goes from 0 (off) to 255 (always on).
// 6615    */
// 6616 
// 6617   // Wait for spindle to come up to speed
// 6618   inline void delay_for_power_up() { dwell(SPINDLE_LASER_POWERUP_DELAY); }
// 6619 
// 6620   // Wait for spindle to stop turning
// 6621   inline void delay_for_power_down() { dwell(SPINDLE_LASER_POWERDOWN_DELAY); }
// 6622 
// 6623   /**
// 6624    * ocr_val_mode() is used for debugging and to get the points needed to compute the RPM vs ocr_val line
// 6625    *
// 6626    * it accepts inputs of 0-255
// 6627    */
// 6628 
// 6629   inline void ocr_val_mode() {
// 6630     uint8_t spindle_laser_power = parser.value_byte();
// 6631     WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT); // turn spindle on (active low)
// 6632     if (SPINDLE_LASER_PWM_INVERT) spindle_laser_power = 255 - spindle_laser_power;
// 6633     analogWrite(SPINDLE_LASER_PWM_PIN, spindle_laser_power);
// 6634   }
// 6635 
// 6636   inline void gcode_M3_M4(bool is_M3) {
// 6637 
// 6638     stepper.synchronize();   // wait until previous movement commands (G0/G0/G2/G3) have completed before playing with the spindle
// 6639     #if SPINDLE_DIR_CHANGE
// 6640       const bool rotation_dir = (is_M3 && !SPINDLE_INVERT_DIR || !is_M3 && SPINDLE_INVERT_DIR) ? HIGH : LOW;
// 6641       if (SPINDLE_STOP_ON_DIR_CHANGE \ 
// 6642          && READ(SPINDLE_LASER_ENABLE_PIN) == SPINDLE_LASER_ENABLE_INVERT \ 
// 6643          && READ(SPINDLE_DIR_PIN) != rotation_dir
// 6644       ) {
// 6645         WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);  // turn spindle off
// 6646         delay_for_power_down();
// 6647       }
// 6648       WRITE(SPINDLE_DIR_PIN, rotation_dir);
// 6649     #endif
// 6650 
// 6651     /**
// 6652      * Our final value for ocr_val is an unsigned 8 bit value between 0 and 255 which usually means uint8_t.
// 6653      * Went to uint16_t because some of the uint8_t calculations would sometimes give 1000 0000 rather than 1111 1111.
// 6654      * Then needed to AND the uint16_t result with 0x00FF to make sure we only wrote the byte of interest.
// 6655      */
// 6656     #if ENABLED(SPINDLE_LASER_PWM)
// 6657       if (parser.seen('O')) ocr_val_mode();
// 6658       else {
// 6659         const float spindle_laser_power = parser.floatval('S');
// 6660         if (spindle_laser_power == 0) {
// 6661           WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);                                    // turn spindle off (active low)
// 6662           analogWrite(SPINDLE_LASER_PWM_PIN, SPINDLE_LASER_PWM_INVERT ? 255 : 0);                           // only write low byte
// 6663           delay_for_power_down();
// 6664         }
// 6665         else {
// 6666           int16_t ocr_val = (spindle_laser_power - (SPEED_POWER_INTERCEPT)) * (1.0 / (SPEED_POWER_SLOPE));  // convert RPM to PWM duty cycle
// 6667           NOMORE(ocr_val, 255);                                                                             // limit to max the Atmel PWM will support
// 6668           if (spindle_laser_power <= SPEED_POWER_MIN)
// 6669             ocr_val = (SPEED_POWER_MIN - (SPEED_POWER_INTERCEPT)) * (1.0 / (SPEED_POWER_SLOPE));            // minimum setting
// 6670           if (spindle_laser_power >= SPEED_POWER_MAX)
// 6671             ocr_val = (SPEED_POWER_MAX - (SPEED_POWER_INTERCEPT)) * (1.0 / (SPEED_POWER_SLOPE));            // limit to max RPM
// 6672           if (SPINDLE_LASER_PWM_INVERT) ocr_val = 255 - ocr_val;
// 6673           WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT);                                     // turn spindle on (active low)
// 6674           analogWrite(SPINDLE_LASER_PWM_PIN, ocr_val & 0xFF);                                               // only write low byte
// 6675           delay_for_power_up();
// 6676         }
// 6677       }
// 6678     #else
// 6679       WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT); // turn spindle on (active low) if spindle speed option not enabled
// 6680       delay_for_power_up();
// 6681     #endif
// 6682   }
// 6683 
// 6684  /**
// 6685   * M5 turn off spindle
// 6686   */
// 6687   inline void gcode_M5() {
// 6688     stepper.synchronize();
// 6689     WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);
// 6690     delay_for_power_down();
// 6691   }
// 6692 
// 6693 #endif // SPINDLE_LASER_ENABLE
// 6694 
// 6695 /**
// 6696  * M17: Enable power on all stepper motors
// 6697  */
// 6698 inline void gcode_M17() {
// 6699   LCD_MESSAGEPGM(MSG_NO_MOVE);
// 6700   enable_all_steppers();
// 6701 }
// 6702 
// 6703 #if ENABLED(ADVANCED_PAUSE_FEATURE)
// 6704 
// 6705   static float resume_position[XYZE];
// 6706   static bool move_away_flag = false;
// 6707   #if ENABLED(SDSUPPORT)
// 6708     static bool sd_print_paused = false;
// 6709   #endif
// 6710 
// 6711   static void filament_change_beep(const int8_t max_beep_count, const bool init=false) {
// 6712     static millis_t next_buzz = 0;
// 6713     static int8_t runout_beep = 0;
// 6714 
// 6715     if (init) next_buzz = runout_beep = 0;
// 6716 
// 6717     const millis_t ms = millis();
// 6718     if (ELAPSED(ms, next_buzz)) {
// 6719       if (max_beep_count < 0 || runout_beep < max_beep_count + 5) { // Only beep as long as we're supposed to
// 6720         next_buzz = ms + ((max_beep_count < 0 || runout_beep < max_beep_count) ? 2500 : 400);
// 6721         BUZZ(300, 2000);
// 6722         runout_beep++;
// 6723       }
// 6724     }
// 6725   }
// 6726 
// 6727   static void ensure_safe_temperature() {
// 6728     bool heaters_heating = true;
// 6729 
// 6730     wait_for_heatup = true;    // M108 will clear this
// 6731     while (wait_for_heatup && heaters_heating) {
// 6732       idle();
// 6733       heaters_heating = false;
// 6734       HOTEND_LOOP() {
// 6735         if (thermalManager.degTargetHotend(e) && abs(thermalManager.degHotend(e) - thermalManager.degTargetHotend(e)) > TEMP_HYSTERESIS) {
// 6736           heaters_heating = true;
// 6737           #if ENABLED(ULTIPANEL)
// 6738             lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_WAIT_FOR_NOZZLES_TO_HEAT);
// 6739           #endif
// 6740           break;
// 6741         }
// 6742       }
// 6743     }
// 6744   }
// 6745 
// 6746   #if IS_KINEMATIC
// 6747     #define RUNPLAN(RATE_MM_S) planner.buffer_line_kinematic(destination, RATE_MM_S, active_extruder)
// 6748   #else
// 6749     #define RUNPLAN(RATE_MM_S) buffer_line_to_destination(RATE_MM_S)
// 6750   #endif
// 6751 
// 6752   void do_pause_e_move(const float &length, const float fr) {
// 6753     current_position[E_AXIS] += length / planner.e_factor[active_extruder];
// 6754     set_destination_from_current();
// 6755     RUNPLAN(fr);
// 6756     stepper.synchronize();
// 6757   }
// 6758 
// 6759   static bool pause_print(const float &retract, const point_t &park_point, const float &unload_length = 0,
// 6760                           const int8_t max_beep_count = 0, const bool show_lcd = false
// 6761   ) {
// 6762     if (move_away_flag) return false; // already paused
// 6763 
// 6764     #ifdef ACTION_ON_PAUSE
// 6765       SERIAL_ECHOLNPGM("//action:" ACTION_ON_PAUSE);
// 6766     #endif
// 6767 
// 6768     if (!DEBUGGING(DRYRUN) && unload_length != 0) {
// 6769       #if ENABLED(PREVENT_COLD_EXTRUSION)
// 6770         if (!thermalManager.allow_cold_extrude &&
// 6771             thermalManager.degTargetHotend(active_extruder) < thermalManager.extrude_min_temp) {
// 6772           SERIAL_ERROR_START();
// 6773           SERIAL_ERRORLNPGM(MSG_TOO_COLD_FOR_M600);
// 6774           return false;
// 6775         }
// 6776       #endif
// 6777 
// 6778       ensure_safe_temperature(); // wait for extruder to heat up before unloading
// 6779     }
// 6780 
// 6781     // Indicate that the printer is paused
// 6782     move_away_flag = true;
// 6783 
// 6784     // Pause the print job and timer
// 6785     #if ENABLED(SDSUPPORT)
// 6786       if (card.sdprinting) {
// 6787         card.pauseSDPrint();
// 6788         sd_print_paused = true;
// 6789       }
// 6790     #endif
// 6791     print_job_timer.pause();
// 6792 
// 6793     // Show initial message and wait for synchronize steppers
// 6794     if (show_lcd) {
// 6795       #if ENABLED(ULTIPANEL)
// 6796         lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INIT);
// 6797       #endif
// 6798     }
// 6799 
// 6800     // Save current position
// 6801     stepper.synchronize();
// 6802     COPY(resume_position, current_position);
// 6803 
// 6804     // Initial retract before move to filament change position
// 6805     if (retract && !thermalManager.tooColdToExtrude(active_extruder))
// 6806       do_pause_e_move(retract, PAUSE_PARK_RETRACT_FEEDRATE);
// 6807 
// 6808     // Park the nozzle by moving up by z_lift and then moving to (x_pos, y_pos)
// 6809     Nozzle::park(2, park_point);
// 6810 
// 6811     if (unload_length != 0) {
// 6812       if (show_lcd) {
// 6813         #if ENABLED(ULTIPANEL)
// 6814           lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_UNLOAD);
// 6815           idle();
// 6816         #endif
// 6817       }
// 6818 
// 6819       // Unload filament
// 6820       do_pause_e_move(unload_length, FILAMENT_CHANGE_UNLOAD_FEEDRATE);
// 6821     }
// 6822 
// 6823     if (show_lcd) {
// 6824       #if ENABLED(ULTIPANEL)
// 6825         lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INSERT);
// 6826       #endif
// 6827     }
// 6828 
// 6829     #if HAS_BUZZER
// 6830       filament_change_beep(max_beep_count, true);
// 6831     #endif
// 6832 
// 6833     idle();
// 6834 
// 6835     // Disable extruders steppers for manual filament changing (only on boards that have separate ENABLE_PINS)
// 6836     #if E0_ENABLE_PIN != X_ENABLE_PIN && E1_ENABLE_PIN != Y_ENABLE_PIN
// 6837       disable_e_steppers();
// 6838       safe_delay(100);
// 6839     #endif
// 6840 
// 6841     // Start the heater idle timers
// 6842     const millis_t nozzle_timeout = (millis_t)(PAUSE_PARK_NOZZLE_TIMEOUT) * 1000UL;
// 6843 
// 6844     HOTEND_LOOP()
// 6845       thermalManager.start_heater_idle_timer(e, nozzle_timeout);
// 6846 
// 6847     return true;
// 6848   }
// 6849 
// 6850   static void wait_for_filament_reload(const int8_t max_beep_count = 0) {
// 6851     bool nozzle_timed_out = false;
// 6852 
// 6853     // Wait for filament insert by user and press button
// 6854     KEEPALIVE_STATE(PAUSED_FOR_USER);
// 6855     wait_for_user = true;    // LCD click or M108 will clear this
// 6856     while (wait_for_user) {
// 6857       #if HAS_BUZZER
// 6858         filament_change_beep(max_beep_count);
// 6859       #endif
// 6860 
// 6861       // If the nozzle has timed out, wait for the user to press the button to re-heat the nozzle, then
// 6862       // re-heat the nozzle, re-show the insert screen, restart the idle timers, and start over
// 6863       if (!nozzle_timed_out)
// 6864         HOTEND_LOOP()
// 6865           nozzle_timed_out |= thermalManager.is_heater_idle(e);
// 6866 
// 6867       if (nozzle_timed_out) {
// 6868         #if ENABLED(ULTIPANEL)
// 6869           lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_CLICK_TO_HEAT_NOZZLE);
// 6870         #endif
// 6871 
// 6872         // Wait for LCD click or M108
// 6873         while (wait_for_user) idle(true);
// 6874 
// 6875         // Re-enable the heaters if they timed out
// 6876         HOTEND_LOOP() thermalManager.reset_heater_idle_timer(e);
// 6877 
// 6878         // Wait for the heaters to reach the target temperatures
// 6879         ensure_safe_temperature();
// 6880 
// 6881         #if ENABLED(ULTIPANEL)
// 6882           lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INSERT);
// 6883         #endif
// 6884 
// 6885         // Start the heater idle timers
// 6886         const millis_t nozzle_timeout = (millis_t)(PAUSE_PARK_NOZZLE_TIMEOUT) * 1000UL;
// 6887 
// 6888         HOTEND_LOOP()
// 6889           thermalManager.start_heater_idle_timer(e, nozzle_timeout);
// 6890 
// 6891         wait_for_user = true; /* Wait for user to load filament */
// 6892         nozzle_timed_out = false;
// 6893 
// 6894         #if HAS_BUZZER
// 6895           filament_change_beep(max_beep_count, true);
// 6896         #endif
// 6897       }
// 6898 
// 6899       idle(true);
// 6900     }
// 6901     KEEPALIVE_STATE(IN_HANDLER);
// 6902   }
// 6903 
// 6904   static void resume_print(const float &load_length = 0, const float &initial_extrude_length = 0, const int8_t max_beep_count = 0) {
// 6905     bool nozzle_timed_out = false;
// 6906 
// 6907     if (!move_away_flag) return;
// 6908 
// 6909     // Re-enable the heaters if they timed out
// 6910     HOTEND_LOOP() {
// 6911       nozzle_timed_out |= thermalManager.is_heater_idle(e);
// 6912       thermalManager.reset_heater_idle_timer(e);
// 6913     }
// 6914 
// 6915     if (nozzle_timed_out) ensure_safe_temperature();
// 6916 
// 6917     #if HAS_BUZZER
// 6918       filament_change_beep(max_beep_count, true);
// 6919     #endif
// 6920 
// 6921     set_destination_from_current();
// 6922 
// 6923     if (load_length != 0) {
// 6924       #if ENABLED(ULTIPANEL)
// 6925         // Show "insert filament"
// 6926         if (nozzle_timed_out)
// 6927           lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INSERT);
// 6928       #endif
// 6929 
// 6930       KEEPALIVE_STATE(PAUSED_FOR_USER);
// 6931       wait_for_user = true;    // LCD click or M108 will clear this
// 6932       while (wait_for_user && nozzle_timed_out) {
// 6933         #if HAS_BUZZER
// 6934           filament_change_beep(max_beep_count);
// 6935         #endif
// 6936         idle(true);
// 6937       }
// 6938       KEEPALIVE_STATE(IN_HANDLER);
// 6939 
// 6940       #if ENABLED(ULTIPANEL)
// 6941         // Show "load" message
// 6942         lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_LOAD);
// 6943       #endif
// 6944 
// 6945       // Load filament
// 6946       do_pause_e_move(load_length, FILAMENT_CHANGE_LOAD_FEEDRATE);
// 6947     }
// 6948 
// 6949     #if ENABLED(ULTIPANEL) && ADVANCED_PAUSE_EXTRUDE_LENGTH > 0
// 6950 
// 6951       if (!thermalManager.tooColdToExtrude(active_extruder)) {
// 6952         float extrude_length = initial_extrude_length;
// 6953 
// 6954         do {
// 6955           if (extrude_length > 0) {
// 6956             // "Wait for filament extrude"
// 6957             lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_EXTRUDE);
// 6958 
// 6959             // Extrude filament to get into hotend
// 6960             do_pause_e_move(extrude_length, ADVANCED_PAUSE_EXTRUDE_FEEDRATE);
// 6961           }
// 6962 
// 6963           // Show "Extrude More" / "Resume" menu and wait for reply
// 6964           KEEPALIVE_STATE(PAUSED_FOR_USER);
// 6965           wait_for_user = false;
// 6966           lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_OPTION);
// 6967           while (advanced_pause_menu_response == ADVANCED_PAUSE_RESPONSE_WAIT_FOR) idle(true);
// 6968           KEEPALIVE_STATE(IN_HANDLER);
// 6969 
// 6970           extrude_length = ADVANCED_PAUSE_EXTRUDE_LENGTH;
// 6971 
// 6972           // Keep looping if "Extrude More" was selected
// 6973         } while (advanced_pause_menu_response == ADVANCED_PAUSE_RESPONSE_EXTRUDE_MORE);
// 6974       }
// 6975 
// 6976     #endif
// 6977 
// 6978     #if ENABLED(ULTIPANEL)
// 6979       // "Wait for print to resume"
// 6980       lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_RESUME);
// 6981     #endif
// 6982 
// 6983     // Set extruder to saved position
// 6984     destination[E_AXIS] = current_position[E_AXIS] = resume_position[E_AXIS];
// 6985     planner.set_e_position_mm(current_position[E_AXIS]);
// 6986 
// 6987     // Move XY to starting position, then Z
// 6988     do_blocking_move_to_xy(resume_position[X_AXIS], resume_position[Y_AXIS], NOZZLE_PARK_XY_FEEDRATE);
// 6989     do_blocking_move_to_z(resume_position[Z_AXIS], NOZZLE_PARK_Z_FEEDRATE);
// 6990 
// 6991     #if ENABLED(FILAMENT_RUNOUT_SENSOR)
// 6992       filament_ran_out = false;
// 6993     #endif
// 6994 
// 6995     #if ENABLED(ULTIPANEL)
// 6996       // Show status screen
// 6997       lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_STATUS);
// 6998     #endif
// 6999 
// 7000     #ifdef ACTION_ON_RESUME
// 7001       SERIAL_ECHOLNPGM("//action:" ACTION_ON_RESUME);
// 7002     #endif
// 7003 
// 7004     #if ENABLED(SDSUPPORT)
// 7005       if (sd_print_paused) {
// 7006         card.startFileprint();
// 7007         sd_print_paused = false;
// 7008       }
// 7009     #endif
// 7010 
// 7011     move_away_flag = false;
// 7012   }
// 7013 #endif // ADVANCED_PAUSE_FEATURE
// 7014 
// 7015 #if ENABLED(SDSUPPORT)
// 7016 
// 7017   /**
// 7018    * M20: List SD card to serial output
// 7019    */
// 7020   inline void gcode_M20() {
// 7021     SERIAL_PROTOCOLLNPGM(MSG_BEGIN_FILE_LIST);
// 7022     card.ls();
// 7023     SERIAL_PROTOCOLLNPGM(MSG_END_FILE_LIST);
// 7024   }
// 7025 
// 7026   /**
// 7027    * M21: Init SD Card
// 7028    */
// 7029   inline void gcode_M21() { card.initsd(); }
// 7030 
// 7031   /**
// 7032    * M22: Release SD Card
// 7033    */
// 7034   inline void gcode_M22() { card.release(); }
// 7035 
// 7036   /**
// 7037    * M23: Open a file
// 7038    */
// 7039   inline void gcode_M23() {
// 7040     // Simplify3D includes the size, so zero out all spaces (#7227)
// 7041     for (char *fn = parser.string_arg; *fn; ++fn) if (*fn == ' ') *fn = '\0';
// 7042     card.openFile(parser.string_arg, true);
// 7043     strcpy(curFileName, mksReprint.filename);//(uint8_t *)&mksReprint.filename[0]
// 7044   }
// 7045 
// 7046   /**
// 7047    * M24: Start or Resume SD Print
// 7048    */
// 7049   inline void gcode_M24() {
// 7050   	mks_resumePrint();
// 7051   
// 7052     #if ENABLED(PARK_HEAD_ON_PAUSE)
// 7053       resume_print();
// 7054     #endif
// 7055 	
// 7056 	if(mksReprint.mks_printer_state != MKS_REPRINTING && mksReprint.mks_printer_state != MKS_REPRINTED)
// 7057 	{
// 7058     	card.startFileprint();
// 7059     	print_job_timer.start();
// 7060 	}
// 7061   }
// 7062 
// 7063   /**
// 7064    * M25: Pause SD Print
// 7065    */
// 7066   inline void gcode_M25() {
// 7067     card.pauseSDPrint();
// 7068     print_job_timer.pause();
// 7069 
// 7070     #if ENABLED(PARK_HEAD_ON_PAUSE)
// 7071       enqueue_and_echo_commands_P(PSTR("M125")); // Must be enqueued with pauseSDPrint set to be last in the buffer
// 7072     #endif
// 7073 	
// 7074 	mksReprint.mks_printer_state = MKS_PAUSING;
// 7075   }
// 7076 /**
// 7077 	 * M998: Stop SD Print
// 7078 */
// 7079 	inline void gcode_M998() {
// 7080 		if(mksReprint.mks_printer_state == MKS_REPRINTED)	
// 7081 		return;
// 7082 			
// 7083 		mksReprint.mks_printer_state = MKS_IDLE;
// 7084         if(gCfgItems.pwroff_save_mode != 1)
// 7085 		    epr_write_data(EPR_SAV_FLAG, (uint8_t *)&mksReprint.mks_printer_state,sizeof(mksReprint.mks_printer_state));
// 7086 
// 7087 		card.stopSDPrint();
// 7088 		clear_command_queue();
// 7089 		quickstop_stepper();
// 7090 		print_job_timer.stop();
// 7091 		thermalManager.disable_all_heaters();
// 7092 		#if FAN_COUNT > 0
// 7093 			for (uint8_t i = 0; i < FAN_COUNT; i++) 
// 7094             {         
// 7095                 fanSpeeds[i] = 0;
// 7096                 #if 1
// 7097                 MKS_FAN_TIM = 0 ;
// 7098                 #endif
// 7099              }
// 7100 		#endif
// 7101 		wait_for_heatup = false;
// 7102 	}
// 7103 
// 7104   /**
// 7105    * M26: Set SD Card file index
// 7106    */
// 7107   inline void gcode_M26() {
// 7108     if (card.cardOK && parser.seenval('S'))
// 7109       card.setIndex(parser.value_long());
// 7110   }
// 7111 
// 7112   /**
// 7113    * M27: Get SD Card status
// 7114    */
// 7115   inline void gcode_M27() { card.getStatus(); }
// 7116 
// 7117   /**
// 7118    * M28: Start SD Write
// 7119    */
// 7120   inline void gcode_M28() { card.openFile(parser.string_arg, false); }
// 7121 
// 7122   /**
// 7123    * M29: Stop SD Write
// 7124    * Processed in write to file routine above
// 7125    */
// 7126   inline void gcode_M29() {
// 7127     // card.saving = false;
// 7128   }
// 7129 
// 7130   /**
// 7131    * M30 <filename>: Delete SD Card file
// 7132    */
// 7133   inline void gcode_M30() {
// 7134     if (card.cardOK) {
// 7135       card.closefile();
// 7136       card.removeFile(parser.string_arg);
// 7137     }
// 7138   }
// 7139 
// 7140 #endif // SDSUPPORT
// 7141 
// 7142 /**
// 7143  * M31: Get the time since the start of SD Print (or last M109)
// 7144  */
// 7145 inline void gcode_M31() {
// 7146   char buffer[21];
// 7147   duration_t elapsed = print_job_timer.duration();
// 7148   elapsed.toString(buffer);
// 7149   lcd_setstatus(buffer);
// 7150 
// 7151   SERIAL_ECHO_START();
// 7152   SERIAL_ECHOLNPAIR("Print time: ", buffer);
// 7153 }
// 7154 
// 7155 #if ENABLED(SDSUPPORT)
// 7156 
// 7157   /**
// 7158    * M32: Select file and start SD Print
// 7159    *
// 7160    * Examples:
// 7161    *
// 7162    *    M32 !PATH/TO/FILE.GCO#      ; Start FILE.GCO
// 7163    *    M32 P !PATH/TO/FILE.GCO#    ; Start FILE.GCO as a procedure
// 7164    *    M32 S60 !PATH/TO/FILE.GCO#  ; Start FILE.GCO at byte 60
// 7165    *
// 7166    */
// 7167   inline void gcode_M32() {
// 7168     if (card.sdprinting) stepper.synchronize();
// 7169 
// 7170     if (card.cardOK|| card.usbOK) {
// 7171       const bool call_procedure = parser.boolval('P');
// 7172 
// 7173       card.openFile(parser.string_arg, true, call_procedure);
// 7174 
// 7175       if (parser.seenval('S')) card.setIndex(parser.value_long());
// 7176 
// 7177       card.startFileprint();
// 7178 
// 7179       // Procedure calls count as normal print time.
// 7180       if (!call_procedure) print_job_timer.start();
// 7181     }
// 7182   }
// 7183 
// 7184   #if ENABLED(LONG_FILENAME_HOST_SUPPORT)
// 7185 
// 7186     /**
// 7187      * M33: Get the long full path of a file or folder
// 7188      *
// 7189      * Parameters:
// 7190      *   <dospath> Case-insensitive DOS-style path to a file or folder
// 7191      *
// 7192      * Example:
// 7193      *   M33 miscel~1/armchair/armcha~1.gco
// 7194      *
// 7195      * Output:
// 7196      *   /Miscellaneous/Armchair/Armchair.gcode
// 7197      */
// 7198     inline void gcode_M33() {
// 7199       card.printLongPath(parser.string_arg);
// 7200     }
// 7201 
// 7202   #endif
// 7203 
// 7204   #if ENABLED(SDCARD_SORT_ALPHA) && ENABLED(SDSORT_GCODE)
// 7205     /**
// 7206      * M34: Set SD Card Sorting Options
// 7207      */
// 7208     inline void gcode_M34() {
// 7209       if (parser.seen('S')) card.setSortOn(parser.value_bool());
// 7210       if (parser.seenval('F')) {
// 7211         const int v = parser.value_long();
// 7212         card.setSortFolders(v < 0 ? -1 : v > 0 ? 1 : 0);
// 7213       }
// 7214       //if (parser.seen('R')) card.setSortReverse(parser.value_bool());
// 7215     }
// 7216   #endif // SDCARD_SORT_ALPHA && SDSORT_GCODE
// 7217 
// 7218   /**
// 7219    * M928: Start SD Write
// 7220    */
// 7221   inline void gcode_M928() {
// 7222     card.openLogFile(parser.string_arg);
// 7223   }
// 7224 
// 7225 #endif // SDSUPPORT
// 7226 
// 7227 /**
// 7228  * Sensitive pin test for M42, M226
// 7229  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock39 Using cfiCommon0
          CFI Function _Z16pin_is_protecteda
          CFI NoCalls
        THUMB
// 7230 static bool pin_is_protected(const int8_t pin) {
// 7231   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
// 7232   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
_Z16pin_is_protecteda:
        MOVS     R1,#+0
        B.N      ??pin_is_protected_0
??pin_is_protected_1:
        ADDS     R1,R1,#+1
??pin_is_protected_0:
        UXTB     R1,R1
        CMP      R1,#+40
        BCS.N    ??pin_is_protected_2
// 7233     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
        ADR.W    R2,??sensitive_pins
        LDRSB    R2,[R1, R2]
        CMP      R0,R2
        BNE.N    ??pin_is_protected_1
        MOVS     R0,#+1
        BX       LR
// 7234   return false;
??pin_is_protected_2:
        MOVS     R0,#+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock39
// 7235 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??sensitive_pins:
        DC8 0, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 0, 2, 3, 4, -1, -1
        DC8 -1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
        DC8 -1, -1, -1, -1

        SECTION `.rodata`:CONST:REORDER:NOROOT(0)
        SECTION_GROUP _ZTI5Print
// __absolute char const <Typeinfo for Print>
_ZTI5Print:
        DATA
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZNK10duration_t8toStringEPcEs
// __absolute char const <_ZZNK10duration_t8toStringEPcEs>[20]
_ZZNK10duration_t8toStringEPcEs:
        DATA
        DC8 "%iy %id %ih %im %is"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZNK10duration_t8toStringEPcEs_0
// __absolute char const <_ZZNK10duration_t8toStringEPcEs_0>[16]
_ZZNK10duration_t8toStringEPcEs_0:
        DATA
        DC8 "%id %ih %im %is"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZNK10duration_t8toStringEPcEs_1
// __absolute char const <_ZZNK10duration_t8toStringEPcEs_1>[12]
_ZZNK10duration_t8toStringEPcEs_1:
        DATA
        DC8 "%ih %im %is"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZNK10duration_t8toStringEPcEs_2
// __absolute char const <_ZZNK10duration_t8toStringEPcEs_2>[8]
_ZZNK10duration_t8toStringEPcEs_2:
        DATA
        DC8 "%im %is"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZNK10duration_t8toStringEPcEs_3
// __absolute char const <_ZZNK10duration_t8toStringEPcEs_3>[4]
_ZZNK10duration_t8toStringEPcEs_3:
        DATA
        DC8 "%is"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs
// __absolute char const <_ZZ19get_serial_commandsvEs>[5]
_ZZ19get_serial_commandsvEs:
        DATA
        DC8 "M110"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_0
// __absolute char const <_ZZ19get_serial_commandsvEs_0>[51]
_ZZ19get_serial_commandsvEs_0:
        DATA
        DC8 4CH, 69H, 6EH, 65H, 20H, 4EH, 75H, 6DH
        DC8 62H, 65H, 72H, 20H, 69H, 73H, 20H, 6EH
        DC8 6FH, 74H, 20H, 4CH, 61H, 73H, 74H, 20H
        DC8 4CH, 69H, 6EH, 65H, 20H, 4EH, 75H, 6DH
        DC8 62H, 65H, 72H, 2BH, 31H, 2CH, 20H, 4CH
        DC8 61H, 73H, 74H, 20H, 4CH, 69H, 6EH, 65H
        DC8 3AH, 20H, 0
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_1
// __absolute char const <_ZZ19get_serial_commandsvEs_1>[31]
_ZZ19get_serial_commandsvEs_1:
        DATA
        DC8 "checksum mismatch, Last Line: "
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_2
// __absolute char const <_ZZ19get_serial_commandsvEs_2>[42]
_ZZ19get_serial_commandsvEs_2:
        DATA
        DC8 "No Checksum with line number, Last Line: "
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_3
// __absolute char const <_ZZ19get_serial_commandsvEs_3>[119]
_ZZ19get_serial_commandsvEs_3:
        DATA
        DC8 50H, 72H, 69H, 6EH, 74H, 65H, 72H, 20H
        DC8 73H, 74H, 6FH, 70H, 70H, 65H, 64H, 20H
        DC8 64H, 75H, 65H, 20H, 74H, 6FH, 20H, 65H
        DC8 72H, 72H, 6FH, 72H, 73H, 2EH, 20H, 46H
        DC8 69H, 78H, 20H, 74H, 68H, 65H, 20H, 65H
        DC8 72H, 72H, 6FH, 72H, 20H, 61H, 6EH, 64H
        DC8 20H, 75H, 73H, 65H, 20H, 4DH, 39H, 39H
        DC8 39H, 20H, 74H, 6FH, 20H, 72H, 65H, 73H
        DC8 74H, 61H, 72H, 74H, 2EH, 20H, 28H, 54H
        DC8 65H, 6DH, 70H, 65H, 72H, 61H, 74H, 75H
        DC8 72H, 65H, 20H, 69H, 73H, 20H, 72H, 65H
        DC8 73H, 65H, 74H, 2EH, 20H, 53H, 65H, 74H
        DC8 20H, 69H, 74H, 20H, 61H, 66H, 74H, 65H
        DC8 72H, 20H, 72H, 65H, 73H, 74H, 61H, 72H
        DC8 74H, 69H, 6EH, 67H, 29H, 0AH, 0
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_4
// __absolute char const <_ZZ19get_serial_commandsvEs_4>[10]
_ZZ19get_serial_commandsvEs_4:
        DATA
        DC8 "STOPPED. "
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_5
// __absolute char const <_ZZ19get_serial_commandsvEs_5>[5]
_ZZ19get_serial_commandsvEs_5:
        DATA
        DC8 "M108"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_6
// __absolute char const <_ZZ19get_serial_commandsvEs_6>[5]
_ZZ19get_serial_commandsvEs_6:
        DATA
        DC8 "M112"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_7
// __absolute char const <_ZZ19get_serial_commandsvEs_7>[9]
_ZZ19get_serial_commandsvEs_7:
        DATA
        DC8 "KILLED. "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_8
// __absolute char const <_ZZ19get_serial_commandsvEs_8>[5]
_ZZ19get_serial_commandsvEs_8:
        DATA
        DC8 "M410"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ24get_homing_bump_feedrate8AxisEnumEs
// __absolute char const <_ZZ24get_homing_bump_feedrate8AxisEnumEs>[34]
_ZZ24get_homing_bump_feedrate8AxisEnumEs:
        DATA
        DC8 "Warning: Homing Bump Divisor < 1\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ11gcode_G2_G3bEs
// __absolute char const <_ZZ11gcode_G2_G3bEs>[22]
_ZZ11gcode_G2_G3bEs:
        DATA
        DC8 "G2/G3 bad parameters\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ8gcode_G4vEs
// __absolute char const <_ZZ8gcode_G4vEs>[9]
_ZZ8gcode_G4vEs:
        DATA
        DC8 "Sleep..."
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M17vEs
// __absolute char const <_ZZ9gcode_M17vEs>[9]
_ZZ9gcode_M17vEs:
        DATA
        DC8 "No move."
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M20vEs
// __absolute char const <_ZZ9gcode_M20vEs>[17]
_ZZ9gcode_M20vEs:
        DATA
        DC8 "Begin file list\012"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M20vEs_0
// __absolute char const <_ZZ9gcode_M20vEs_0>[15]
_ZZ9gcode_M20vEs_0:
        DATA
        DC8 "End file list\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M31vEs
// __absolute char const <_ZZ9gcode_M31vEs>[13]
_ZZ9gcode_M31vEs:
        DATA
        DC8 "Print time: "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M42vEs
// __absolute char const <_ZZ9gcode_M42vEs>[15]
_ZZ9gcode_M42vEs:
        DATA
        DC8 "Protected Pin\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M104vEs
// __absolute char const <_ZZ10gcode_M104vEs>[18]
_ZZ10gcode_M104vEs:
        DATA
        DC8 "3D Printer ready."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M104vEs_0
// __absolute char const <_ZZ10gcode_M104vEs_0>[14]
_ZZ10gcode_M104vEs_0:
        DATA
        DC8 "E1 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M104vEs_1
// __absolute char const <_ZZ10gcode_M104vEs_1>[14]
_ZZ10gcode_M104vEs_1:
        DATA
        DC8 "E2 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M104vEs_2
// __absolute char const <_ZZ10gcode_M104vEs_2>[14]
_ZZ10gcode_M104vEs_2:
        DATA
        DC8 "E3 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M104vEs_3
// __absolute char const <_ZZ10gcode_M104vEs_3>[14]
_ZZ10gcode_M104vEs_3:
        DATA
        DC8 "E4 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M104vEs_4
// __absolute char const <_ZZ10gcode_M104vEs_4>[14]
_ZZ10gcode_M104vEs_4:
        DATA
        DC8 "E5 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M105vEs
// __absolute char const <_ZZ10gcode_M105vEs>[33]
_ZZ10gcode_M105vEs:
        DATA
        DC8 "No thermistors - no temperature\012"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M112vEs
// __absolute char const <_ZZ10gcode_M112vEs>[9]
_ZZ10gcode_M112vEs:
        DATA
        DC8 "KILLED. "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M109vEs
// __absolute char const <_ZZ10gcode_M109vEs>[18]
_ZZ10gcode_M109vEs:
        DATA
        DC8 "3D Printer ready."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M109vEs_0
// __absolute char const <_ZZ10gcode_M109vEs_0>[14]
_ZZ10gcode_M109vEs_0:
        DATA
        DC8 "E1 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M109vEs_1
// __absolute char const <_ZZ10gcode_M109vEs_1>[14]
_ZZ10gcode_M109vEs_1:
        DATA
        DC8 "E2 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M109vEs_2
// __absolute char const <_ZZ10gcode_M109vEs_2>[14]
_ZZ10gcode_M109vEs_2:
        DATA
        DC8 "E3 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M109vEs_3
// __absolute char const <_ZZ10gcode_M109vEs_3>[14]
_ZZ10gcode_M109vEs_3:
        DATA
        DC8 "E4 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M109vEs_4
// __absolute char const <_ZZ10gcode_M109vEs_4>[14]
_ZZ10gcode_M109vEs_4:
        DATA
        DC8 "E5 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M109vEs_5
// __absolute char const <_ZZ10gcode_M109vEs_5>[4]
_ZZ10gcode_M109vEs_5:
        DATA
        DC8 " W:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M109vEs_6
// __absolute char const <_ZZ10gcode_M109vEs_6>[14]
_ZZ10gcode_M109vEs_6:
        DATA
        DC8 "Heating done."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vEs_4
// __absolute char const <_ZZ10gcode_M111vEs_4>[7]
_ZZ10gcode_M111vEs_4:
        DATA
        DC8 "DEBUG:"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vEs_5
// __absolute char const <_ZZ10gcode_M111vEs_5>[4]
_ZZ10gcode_M111vEs_5:
        DATA
        DC8 "off"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs
// __absolute char const <_ZZ10gcode_M115vEs>[198]
_ZZ10gcode_M115vEs:
        DATA
        DC8 46H, 49H, 52H, 4DH, 57H, 41H, 52H, 45H
        DC8 5FH, 4EH, 41H, 4DH, 45H, 3AH, 4DH, 61H
        DC8 72H, 6CH, 69H, 6EH, 20H, 31H, 2EH, 30H
        DC8 2EH, 30H, 20H, 28H, 47H, 69H, 74H, 68H
        DC8 75H, 62H, 29H, 20H, 53H, 4FH, 55H, 52H
        DC8 43H, 45H, 5FH, 43H, 4FH, 44H, 45H, 5FH
        DC8 55H, 52H, 4CH, 3AH, 68H, 74H, 74H, 70H
        DC8 73H, 3AH, 2FH, 2FH, 67H, 69H, 74H, 68H
        DC8 75H, 62H, 2EH, 63H, 6FH, 6DH, 2FH, 4DH
        DC8 61H, 72H, 6CH, 69H, 6EH, 46H, 69H, 72H
        DC8 6DH, 77H, 61H, 72H, 65H, 2FH, 4DH, 61H
        DC8 72H, 6CH, 69H, 6EH, 20H, 50H, 52H, 4FH
        DC8 54H, 4FH, 43H, 4FH, 4CH, 5FH, 56H, 45H
        DC8 52H, 53H, 49H, 4FH, 4EH, 3AH, 31H, 2EH
        DC8 30H, 20H, 4DH, 41H, 43H, 48H, 49H, 4EH
        DC8 45H, 5FH, 54H, 59H, 50H, 45H, 3AH, 33H
        DC8 44H, 20H, 50H, 72H, 69H, 6EH, 74H, 65H
        DC8 72H, 20H, 45H, 58H, 54H, 52H, 55H, 44H
        DC8 45H, 52H, 5FH, 43H, 4FH, 55H, 4EH, 54H
        DC8 3AH, 31H, 20H, 55H, 55H, 49H, 44H, 3AH
        DC8 63H, 65H, 64H, 65H, 32H, 61H, 32H, 66H
        DC8 2DH, 34H, 31H, 61H, 32H, 2DH, 34H, 37H
        DC8 34H, 38H, 2DH, 39H, 62H, 31H, 32H, 2DH
        DC8 63H, 35H, 35H, 63H, 36H, 32H, 66H, 33H
        DC8 36H, 37H, 66H, 66H, 0AH, 0
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_0
// __absolute char const <_ZZ10gcode_M115vEs_0>[16]
_ZZ10gcode_M115vEs_0:
        DATA
        DC8 "SERIAL_XON_XOFF"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_1
// __absolute char const <_ZZ10gcode_M115vEs_1>[7]
_ZZ10gcode_M115vEs_1:
        DATA
        DC8 "EEPROM"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_2
// __absolute char const <_ZZ10gcode_M115vEs_2>[11]
_ZZ10gcode_M115vEs_2:
        DATA
        DC8 "VOLUMETRIC"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_3
// __absolute char const <_ZZ10gcode_M115vEs_3>[16]
_ZZ10gcode_M115vEs_3:
        DATA
        DC8 "AUTOREPORT_TEMP"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_4
// __absolute char const <_ZZ10gcode_M115vEs_4>[9]
_ZZ10gcode_M115vEs_4:
        DATA
        DC8 "PROGRESS"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_5
// __absolute char const <_ZZ10gcode_M115vEs_5>[10]
_ZZ10gcode_M115vEs_5:
        DATA
        DC8 "PRINT_JOB"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_6
// __absolute char const <_ZZ10gcode_M115vEs_6>[10]
_ZZ10gcode_M115vEs_6:
        DATA
        DC8 "AUTOLEVEL"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_7
// __absolute char const <_ZZ10gcode_M115vEs_7>[8]
_ZZ10gcode_M115vEs_7:
        DATA
        DC8 "Z_PROBE"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_8
// __absolute char const <_ZZ10gcode_M115vEs_8>[14]
_ZZ10gcode_M115vEs_8:
        DATA
        DC8 "LEVELING_DATA"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_9
// __absolute char const <_ZZ10gcode_M115vEs_9>[14]
_ZZ10gcode_M115vEs_9:
        DATA
        DC8 "BUILD_PERCENT"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs__10_
// __absolute char const <_ZZ10gcode_M115vEs__10_>[15]
_ZZ10gcode_M115vEs__10_:
        DATA
        DC8 "SOFTWARE_POWER"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs__11_
// __absolute char const <_ZZ10gcode_M115vEs__11_>[14]
_ZZ10gcode_M115vEs__11_:
        DATA
        DC8 "TOGGLE_LIGHTS"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs__12_
// __absolute char const <_ZZ10gcode_M115vEs__12_>[22]
_ZZ10gcode_M115vEs__12_:
        DATA
        DC8 "CASE_LIGHT_BRIGHTNESS"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs__13_
// __absolute char const <_ZZ10gcode_M115vEs__13_>[17]
_ZZ10gcode_M115vEs__13_:
        DATA
        DC8 "EMERGENCY_PARSER"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M118vEs
// __absolute char const <_ZZ10gcode_M118vEs>[4]
_ZZ10gcode_M118vEs:
        DATA
        DC8 "// "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M204vEs
// __absolute char const <_ZZ10gcode_M204vEs>[40]
_ZZ10gcode_M204vEs:
        DATA
        DC8 "Setting Print and Travel Acceleration: "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M204vEs_0
// __absolute char const <_ZZ10gcode_M204vEs_0>[29]
_ZZ10gcode_M204vEs_0:
        DATA
        DC8 "Setting Print Acceleration: "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M204vEs_1
// __absolute char const <_ZZ10gcode_M204vEs_1>[31]
_ZZ10gcode_M204vEs_1:
        DATA
        DC8 "Setting Retract Acceleration: "
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M204vEs_2
// __absolute char const <_ZZ10gcode_M204vEs_2>[30]
_ZZ10gcode_M204vEs_2:
        DATA
        DC8 "Setting Travel Acceleration: "
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M211vEs
// __absolute char const <_ZZ10gcode_M211vEs>[16]
_ZZ10gcode_M211vEs:
        DATA
        DC8 "Soft endstops: "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M211vEs_0
// __absolute char const <_ZZ10gcode_M211vEs_0>[4]
_ZZ10gcode_M211vEs_0:
        DATA
        DC8 "On "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M211vEs_1
// __absolute char const <_ZZ10gcode_M211vEs_1>[4]
_ZZ10gcode_M211vEs_1:
        DATA
        DC8 "Off"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M211vEs_2
// __absolute char const <_ZZ10gcode_M211vEs_2>[8]
_ZZ10gcode_M211vEs_2:
        DATA
        DC8 "  Min: "

        SECTION `.rodata`:CONST:REORDER:NOROOT(1)
        SECTION_GROUP _ZZ10gcode_M211vEs_3
// __absolute char const <_ZZ10gcode_M211vEs_3>[2]
_ZZ10gcode_M211vEs_3:
        DATA
        DC8 "X"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M211vEs_4
// __absolute char const <_ZZ10gcode_M211vEs_4>[3]
_ZZ10gcode_M211vEs_4:
        DATA
        DC8 " Y"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M211vEs_5
// __absolute char const <_ZZ10gcode_M211vEs_5>[3]
_ZZ10gcode_M211vEs_5:
        DATA
        DC8 " Z"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M211vEs_6
// __absolute char const <_ZZ10gcode_M211vEs_6>[8]
_ZZ10gcode_M211vEs_6:
        DATA
        DC8 "  Max: "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M301vEs
// __absolute char const <_ZZ10gcode_M301vEs>[4]
_ZZ10gcode_M301vEs:
        DATA
        DC8 " p:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M301vEs_0
// __absolute char const <_ZZ10gcode_M301vEs_0>[4]
_ZZ10gcode_M301vEs_0:
        DATA
        DC8 " i:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M301vEs_1
// __absolute char const <_ZZ10gcode_M301vEs_1>[4]
_ZZ10gcode_M301vEs_1:
        DATA
        DC8 " d:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M301vEs_2
// __absolute char const <_ZZ10gcode_M301vEs_2>[17]
_ZZ10gcode_M301vEs_2:
        DATA
        DC8 "Invalid extruder"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M428vEs
// __absolute char const <_ZZ10gcode_M428vEs>[30]
_ZZ10gcode_M428vEs:
        DATA
        DC8 "Too far from reference point\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M428vEs_0
// __absolute char const <_ZZ10gcode_M428vEs_0>[14]
_ZZ10gcode_M428vEs_0:
        DATA
        DC8 "Err: Too far!"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M428vEs_1
// __absolute char const <_ZZ10gcode_M428vEs_1>[16]
_ZZ10gcode_M428vEs_1:
        DATA
        DC8 "Offsets applied"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M355vEs
// __absolute char const <_ZZ10gcode_M355vEs>[15]
_ZZ10gcode_M355vEs:
        DATA
        DC8 "No case light\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ22invalid_extruder_errorhEs
// __absolute char const <_ZZ22invalid_extruder_errorhEs>[17]
_ZZ22invalid_extruder_errorhEs:
        DATA
        DC8 "Invalid extruder"
        DC8 0, 0, 0
// 7236 
// 7237 /**
// 7238  * M42: Change pin status via GCode
// 7239  *
// 7240  *  P<pin>  Pin number (LED if omitted)
// 7241  *  S<byte> Pin status from 0 - 255
// 7242  */
// 7243 inline void gcode_M42() {
// 7244   if (!parser.seenval('S')) return;
// 7245   const byte pin_status = parser.value_byte();
// 7246 
// 7247   const int pin_number = parser.intval('P', LED_PIN);
// 7248   if (pin_number < 0) return;
// 7249 
// 7250   if (pin_is_protected(pin_number)) {
// 7251     SERIAL_ERROR_START();
// 7252     SERIAL_ERRORLNPGM(MSG_ERR_PROTECTED_PIN);
// 7253     return;
// 7254   }
// 7255 
// 7256   pinMode(pin_number, OUTPUT);
// 7257   digitalWrite(pin_number, pin_status);
// 7258   //analogWrite(pin_number, pin_status);
// 7259 
// 7260   #if FAN_COUNT > 0
// 7261     switch (pin_number) {
// 7262       #if HAS_FAN0
// 7263         case FAN_PIN: fanSpeeds[0] = pin_status; break;
// 7264       #endif
// 7265       #if HAS_FAN1
// 7266         case FAN1_PIN: fanSpeeds[1] = pin_status; break;
// 7267       #endif
// 7268       #if HAS_FAN2
// 7269         case FAN2_PIN: fanSpeeds[2] = pin_status; break;
// 7270       #endif
// 7271     }
// 7272   #endif
// 7273 }
// 7274 
// 7275 #if ENABLED(PINS_DEBUGGING)
// 7276 
// 7277   #include "pinsDebug.h"
// 7278 
// 7279   inline void toggle_pins() {
// 7280     const bool I_flag = parser.boolval('I');
// 7281     const int repeat = parser.intval('R', 1),
// 7282               start = parser.intval('S'),
// 7283               end = parser.intval('L', NUM_DIGITAL_PINS - 1),
// 7284               wait = parser.intval('W', 500);
// 7285 
// 7286     for (uint8_t pin = start; pin <= end; pin++) {
// 7287       //report_pin_state_extended(pin, I_flag, false);
// 7288 
// 7289       if (!I_flag && pin_is_protected(pin)) {
// 7290         report_pin_state_extended(pin, I_flag, true, "Untouched ");
// 7291         SERIAL_EOL();
// 7292       }
// 7293       else {
// 7294         report_pin_state_extended(pin, I_flag, true, "Pulsing   ");
// 7295         #if AVR_AT90USB1286_FAMILY // Teensy IDEs don't know about these pins so must use FASTIO
// 7296           if (pin == TEENSY_E2) {
// 7297             SET_OUTPUT(TEENSY_E2);
// 7298             for (int16_t j = 0; j < repeat; j++) {
// 7299               WRITE(TEENSY_E2, LOW);  safe_delay(wait);
// 7300               WRITE(TEENSY_E2, HIGH); safe_delay(wait);
// 7301               WRITE(TEENSY_E2, LOW);  safe_delay(wait);
// 7302             }
// 7303           }
// 7304           else if (pin == TEENSY_E3) {
// 7305             SET_OUTPUT(TEENSY_E3);
// 7306             for (int16_t j = 0; j < repeat; j++) {
// 7307               WRITE(TEENSY_E3, LOW);  safe_delay(wait);
// 7308               WRITE(TEENSY_E3, HIGH); safe_delay(wait);
// 7309               WRITE(TEENSY_E3, LOW);  safe_delay(wait);
// 7310             }
// 7311           }
// 7312           else
// 7313         #endif
// 7314         {
// 7315           pinMode(pin, OUTPUT);
// 7316           for (int16_t j = 0; j < repeat; j++) {
// 7317             digitalWrite(pin, 0); safe_delay(wait);
// 7318             digitalWrite(pin, 1); safe_delay(wait);
// 7319             digitalWrite(pin, 0); safe_delay(wait);
// 7320           }
// 7321         }
// 7322 
// 7323       }
// 7324       SERIAL_EOL();
// 7325     }
// 7326     SERIAL_ECHOLNPGM("Done.");
// 7327 
// 7328   } // toggle_pins
// 7329 
// 7330   inline void servo_probe_test() {
// 7331     #if !(NUM_SERVOS > 0 && HAS_SERVO_0)
// 7332 
// 7333       SERIAL_ERROR_START();
// 7334       SERIAL_ERRORLNPGM("SERVO not setup");
// 7335 
// 7336     #elif !HAS_Z_SERVO_ENDSTOP
// 7337 
// 7338       SERIAL_ERROR_START();
// 7339       SERIAL_ERRORLNPGM("Z_ENDSTOP_SERVO_NR not setup");
// 7340 
// 7341     #else // HAS_Z_SERVO_ENDSTOP
// 7342 
// 7343       const uint8_t probe_index = parser.byteval('P', Z_ENDSTOP_SERVO_NR);
// 7344 
// 7345       SERIAL_PROTOCOLLNPGM("Servo probe test");
// 7346       SERIAL_PROTOCOLLNPAIR(".  using index:  ", probe_index);
// 7347       SERIAL_PROTOCOLLNPAIR(".  deploy angle: ", z_servo_angle[0]);
// 7348       SERIAL_PROTOCOLLNPAIR(".  stow angle:   ", z_servo_angle[1]);
// 7349 
// 7350       bool probe_inverting;
// 7351 
// 7352       #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
// 7353 
// 7354         #define PROBE_TEST_PIN Z_MIN_PIN
// 7355 
// 7356         SERIAL_PROTOCOLLNPAIR(". probe uses Z_MIN pin: ", PROBE_TEST_PIN);
// 7357         SERIAL_PROTOCOLLNPGM(". uses Z_MIN_ENDSTOP_INVERTING (ignores Z_MIN_PROBE_ENDSTOP_INVERTING)");
// 7358         SERIAL_PROTOCOLPGM(". Z_MIN_ENDSTOP_INVERTING: ");
// 7359 
// 7360         #if Z_MIN_ENDSTOP_INVERTING
// 7361           SERIAL_PROTOCOLLNPGM("true");
// 7362         #else
// 7363           SERIAL_PROTOCOLLNPGM("false");
// 7364         #endif
// 7365 
// 7366         probe_inverting = Z_MIN_ENDSTOP_INVERTING;
// 7367 
// 7368       #elif ENABLED(Z_MIN_PROBE_ENDSTOP)
// 7369 
// 7370         #define PROBE_TEST_PIN Z_MIN_PROBE_PIN
// 7371         SERIAL_PROTOCOLLNPAIR(". probe uses Z_MIN_PROBE_PIN: ", PROBE_TEST_PIN);
// 7372         SERIAL_PROTOCOLLNPGM(". uses Z_MIN_PROBE_ENDSTOP_INVERTING (ignores Z_MIN_ENDSTOP_INVERTING)");
// 7373         SERIAL_PROTOCOLPGM(". Z_MIN_PROBE_ENDSTOP_INVERTING: ");
// 7374 
// 7375         #if Z_MIN_PROBE_ENDSTOP_INVERTING
// 7376           SERIAL_PROTOCOLLNPGM("true");
// 7377         #else
// 7378           SERIAL_PROTOCOLLNPGM("false");
// 7379         #endif
// 7380 
// 7381         probe_inverting = Z_MIN_PROBE_ENDSTOP_INVERTING;
// 7382 
// 7383       #endif
// 7384 
// 7385       SERIAL_PROTOCOLLNPGM(". deploy & stow 4 times");
// 7386       SET_INPUT_PULLUP(PROBE_TEST_PIN);
// 7387       bool deploy_state, stow_state;
// 7388       for (uint8_t i = 0; i < 4; i++) {
// 7389         MOVE_SERVO(probe_index, z_servo_angle[0]); //deploy
// 7390         safe_delay(500);
// 7391         deploy_state = READ(PROBE_TEST_PIN);
// 7392         MOVE_SERVO(probe_index, z_servo_angle[1]); //stow
// 7393         safe_delay(500);
// 7394         stow_state = READ(PROBE_TEST_PIN);
// 7395       }
// 7396       if (probe_inverting != deploy_state) SERIAL_PROTOCOLLNPGM("WARNING - INVERTING setting probably backwards");
// 7397 
// 7398       refresh_cmd_timeout();
// 7399 
// 7400       if (deploy_state != stow_state) {
// 7401         SERIAL_PROTOCOLLNPGM("BLTouch clone detected");
// 7402         if (deploy_state) {
// 7403           SERIAL_PROTOCOLLNPGM(".  DEPLOYED state: HIGH (logic 1)");
// 7404           SERIAL_PROTOCOLLNPGM(".  STOWED (triggered) state: LOW (logic 0)");
// 7405         }
// 7406         else {
// 7407           SERIAL_PROTOCOLLNPGM(".  DEPLOYED state: LOW (logic 0)");
// 7408           SERIAL_PROTOCOLLNPGM(".  STOWED (triggered) state: HIGH (logic 1)");
// 7409         }
// 7410         #if ENABLED(BLTOUCH)
// 7411           SERIAL_PROTOCOLLNPGM("ERROR: BLTOUCH enabled - set this device up as a Z Servo Probe with inverting as true.");
// 7412         #endif
// 7413 
// 7414       }
// 7415       else {                                           // measure active signal length
// 7416         MOVE_SERVO(probe_index, z_servo_angle[0]);     // deploy
// 7417         safe_delay(500);
// 7418         SERIAL_PROTOCOLLNPGM("please trigger probe");
// 7419         uint16_t probe_counter = 0;
// 7420 
// 7421         // Allow 30 seconds max for operator to trigger probe
// 7422         for (uint16_t j = 0; j < 500 * 30 && probe_counter == 0 ; j++) {
// 7423 
// 7424           safe_delay(2);
// 7425 
// 7426           if (0 == j % (500 * 1)) // keep cmd_timeout happy
// 7427             refresh_cmd_timeout();
// 7428 
// 7429           if (deploy_state != READ(PROBE_TEST_PIN)) { // probe triggered
// 7430 
// 7431             for (probe_counter = 1; probe_counter < 50 && deploy_state != READ(PROBE_TEST_PIN); ++probe_counter)
// 7432               safe_delay(2);
// 7433 
// 7434             if (probe_counter == 50)
// 7435               SERIAL_PROTOCOLLNPGM("Z Servo Probe detected"); // >= 100mS active time
// 7436             else if (probe_counter >= 2)
// 7437               SERIAL_PROTOCOLLNPAIR("BLTouch compatible probe detected - pulse width (+/- 4mS): ", probe_counter * 2); // allow 4 - 100mS pulse
// 7438             else
// 7439               SERIAL_PROTOCOLLNPGM("noise detected - please re-run test"); // less than 2mS pulse
// 7440 
// 7441             MOVE_SERVO(probe_index, z_servo_angle[1]); //stow
// 7442 
// 7443           }  // pulse detected
// 7444 
// 7445         } // for loop waiting for trigger
// 7446 
// 7447         if (probe_counter == 0) SERIAL_PROTOCOLLNPGM("trigger not detected");
// 7448 
// 7449       } // measure active signal length
// 7450 
// 7451     #endif
// 7452 
// 7453   } // servo_probe_test
// 7454 
// 7455   /**
// 7456    * M43: Pin debug - report pin state, watch pins, toggle pins and servo probe test/report
// 7457    *
// 7458    *  M43         - report name and state of pin(s)
// 7459    *                  P<pin>  Pin to read or watch. If omitted, reads all pins.
// 7460    *                  I       Flag to ignore Marlin's pin protection.
// 7461    *
// 7462    *  M43 W       - Watch pins -reporting changes- until reset, click, or M108.
// 7463    *                  P<pin>  Pin to read or watch. If omitted, read/watch all pins.
// 7464    *                  I       Flag to ignore Marlin's pin protection.
// 7465    *
// 7466    *  M43 E<bool> - Enable / disable background endstop monitoring
// 7467    *                  - Machine continues to operate
// 7468    *                  - Reports changes to endstops
// 7469    *                  - Toggles LED_PIN when an endstop changes
// 7470    *                  - Can not reliably catch the 5mS pulse from BLTouch type probes
// 7471    *
// 7472    *  M43 T       - Toggle pin(s) and report which pin is being toggled
// 7473    *                  S<pin>  - Start Pin number.   If not given, will default to 0
// 7474    *                  L<pin>  - End Pin number.   If not given, will default to last pin defined for this board
// 7475    *                  I<bool> - Flag to ignore Marlin's pin protection.   Use with caution!!!!
// 7476    *                  R       - Repeat pulses on each pin this number of times before continueing to next pin
// 7477    *                  W       - Wait time (in miliseconds) between pulses.  If not given will default to 500
// 7478    *
// 7479    *  M43 S       - Servo probe test
// 7480    *                  P<index> - Probe index (optional - defaults to 0
// 7481    */
// 7482   inline void gcode_M43() {
// 7483 
// 7484     if (parser.seen('T')) {   // must be first or else its "S" and "E" parameters will execute endstop or servo test
// 7485       toggle_pins();
// 7486       return;
// 7487     }
// 7488 
// 7489     // Enable or disable endstop monitoring
// 7490     if (parser.seen('E')) {
// 7491       endstop_monitor_flag = parser.value_bool();
// 7492       SERIAL_PROTOCOLPGM("endstop monitor ");
// 7493       serialprintPGM(endstop_monitor_flag ? PSTR("en") : PSTR("dis"));
// 7494       SERIAL_PROTOCOLLNPGM("abled");
// 7495       return;
// 7496     }
// 7497 
// 7498     if (parser.seen('S')) {
// 7499       servo_probe_test();
// 7500       return;
// 7501     }
// 7502 
// 7503     // Get the range of pins to test or watch
// 7504     const uint8_t first_pin = parser.byteval('P'),
// 7505                   last_pin = parser.seenval('P') ? first_pin : NUM_DIGITAL_PINS - 1;
// 7506 
// 7507     if (first_pin > last_pin) return;
// 7508 
// 7509     const bool ignore_protection = parser.boolval('I');
// 7510 
// 7511     // Watch until click, M108, or reset
// 7512     if (parser.boolval('W')) {
// 7513       SERIAL_PROTOCOLLNPGM("Watching pins");
// 7514       byte pin_state[last_pin - first_pin + 1];
// 7515       for (int8_t pin = first_pin; pin <= last_pin; pin++) {
// 7516         if (pin_is_protected(pin) && !ignore_protection) continue;
// 7517         pinMode(pin, INPUT_PULLUP);
// 7518         delay(1);
// 7519         /*
// 7520           if (IS_ANALOG(pin))
// 7521             pin_state[pin - first_pin] = analogRead(pin - analogInputToDigitalPin(0)); // int16_t pin_state[...]
// 7522           else
// 7523         //*/
// 7524             pin_state[pin - first_pin] = digitalRead(pin);
// 7525       }
// 7526 
// 7527       #if HAS_RESUME_CONTINUE
// 7528         wait_for_user = true;
// 7529         KEEPALIVE_STATE(PAUSED_FOR_USER);
// 7530       #endif
// 7531 
// 7532       for (;;) {
// 7533         for (int8_t pin = first_pin; pin <= last_pin; pin++) {
// 7534           if (pin_is_protected(pin) && !ignore_protection) continue;
// 7535           const byte val =
// 7536             /*
// 7537               IS_ANALOG(pin)
// 7538                 ? analogRead(pin - analogInputToDigitalPin(0)) : // int16_t val
// 7539                 :
// 7540             //*/
// 7541               digitalRead(pin);
// 7542           if (val != pin_state[pin - first_pin]) {
// 7543             report_pin_state_extended(pin, ignore_protection, false);
// 7544             pin_state[pin - first_pin] = val;
// 7545           }
// 7546         }
// 7547 
// 7548         #if HAS_RESUME_CONTINUE
// 7549           if (!wait_for_user) {
// 7550             KEEPALIVE_STATE(IN_HANDLER);
// 7551             break;
// 7552           }
// 7553         #endif
// 7554 
// 7555         safe_delay(200);
// 7556       }
// 7557       return;
// 7558     }
// 7559 
// 7560     // Report current state of selected pin(s)
// 7561     for (uint8_t pin = first_pin; pin <= last_pin; pin++)
// 7562       report_pin_state_extended(pin, ignore_protection, true);
// 7563   }
// 7564 
// 7565 #endif // PINS_DEBUGGING
// 7566 
// 7567 #if ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)
// 7568 
// 7569   /**
// 7570    * M48: Z probe repeatability measurement function.
// 7571    *
// 7572    * Usage:
// 7573    *   M48 <P#> <X#> <Y#> <V#> <E> <L#>
// 7574    *     P = Number of sampled points (4-50, default 10)
// 7575    *     X = Sample X position
// 7576    *     Y = Sample Y position
// 7577    *     V = Verbose level (0-4, default=1)
// 7578    *     E = Engage Z probe for each reading
// 7579    *     L = Number of legs of movement before probe
// 7580    *     S = Schizoid (Or Star if you prefer)
// 7581    *
// 7582    * This function requires the machine to be homed before invocation.
// 7583    */
// 7584   inline void gcode_M48() {
// 7585 
// 7586     if (axis_unhomed_error()) return;
// 7587 
// 7588     const int8_t verbose_level = parser.byteval('V', 1);
// 7589     if (!WITHIN(verbose_level, 0, 4)) {
// 7590       SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-4).");
// 7591       return;
// 7592     }
// 7593 
// 7594     if (verbose_level > 0)
// 7595       SERIAL_PROTOCOLLNPGM("M48 Z-Probe Repeatability Test");
// 7596 
// 7597     const int8_t n_samples = parser.byteval('P', 10);
// 7598     if (!WITHIN(n_samples, 4, 50)) {
// 7599       SERIAL_PROTOCOLLNPGM("?Sample size not plausible (4-50).");
// 7600       return;
// 7601     }
// 7602 
// 7603     const bool stow_probe_after_each = parser.boolval('E');
// 7604 
// 7605     float X_current = current_position[X_AXIS],
// 7606           Y_current = current_position[Y_AXIS];
// 7607 
// 7608     const float X_probe_location = parser.linearval('X', X_current + X_PROBE_OFFSET_FROM_EXTRUDER),
// 7609                 Y_probe_location = parser.linearval('Y', Y_current + Y_PROBE_OFFSET_FROM_EXTRUDER);
// 7610 
// 7611     #if DISABLED(DELTA)
// 7612       if (!WITHIN(X_probe_location, MIN_PROBE_X, MAX_PROBE_X)) {
// 7613         out_of_range_error(PSTR("X"));
// 7614         return;
// 7615       }
// 7616       if (!WITHIN(Y_probe_location, MIN_PROBE_Y, MAX_PROBE_Y)) {
// 7617         out_of_range_error(PSTR("Y"));
// 7618         return;
// 7619       }
// 7620     #else
// 7621       if (!position_is_reachable_by_probe(X_probe_location, Y_probe_location)) {
// 7622         SERIAL_PROTOCOLLNPGM("? (X,Y) location outside of probeable radius.");
// 7623         return;
// 7624       }
// 7625     #endif
// 7626 
// 7627     bool seen_L = parser.seen('L');
// 7628     uint8_t n_legs = seen_L ? parser.value_byte() : 0;
// 7629     if (n_legs > 15) {
// 7630       SERIAL_PROTOCOLLNPGM("?Number of legs in movement not plausible (0-15).");
// 7631       return;
// 7632     }
// 7633     if (n_legs == 1) n_legs = 2;
// 7634 
// 7635     const bool schizoid_flag = parser.boolval('S');
// 7636     if (schizoid_flag && !seen_L) n_legs = 7;
// 7637 
// 7638     /**
// 7639      * Now get everything to the specified probe point So we can safely do a
// 7640      * probe to get us close to the bed.  If the Z-Axis is far from the bed,
// 7641      * we don't want to use that as a starting point for each probe.
// 7642      */
// 7643     if (verbose_level > 2)
// 7644       SERIAL_PROTOCOLLNPGM("Positioning the probe...");
// 7645 
// 7646     // Disable bed level correction in M48 because we want the raw data when we probe
// 7647 
// 7648     #if HAS_LEVELING
// 7649       const bool was_enabled = planner.leveling_active;
// 7650       set_bed_leveling_enabled(false);
// 7651     #endif
// 7652 
// 7653     setup_for_endstop_or_probe_move();
// 7654 
// 7655     double mean = 0.0, sigma = 0.0, min = 99999.9, max = -99999.9, sample_set[n_samples];
// 7656 
// 7657     // Move to the first point, deploy, and probe
// 7658     const float t = probe_pt(X_probe_location, Y_probe_location, stow_probe_after_each, verbose_level);
// 7659     bool probing_good = !isnan(t);
// 7660 
// 7661     if (probing_good) {
// 7662       //randomSeed(millis());
// 7663 	  srand(millis());
// 7664 
// 7665       for (uint8_t n = 0; n < n_samples; n++) {
// 7666         if (n_legs) {
// 7667           const int dir = (random(0, 10) > 5.0) ? -1 : 1;  // clockwise or counter clockwise
// 7668           float angle = random(0.0, 360.0);
// 7669           const float radius = random(
// 7670             #if ENABLED(DELTA)
// 7671               0.1250000000 * (DELTA_PROBEABLE_RADIUS),
// 7672               0.3333333333 * (DELTA_PROBEABLE_RADIUS)
// 7673             #else
// 7674               5.0, 0.125 * min(X_BED_SIZE, Y_BED_SIZE)
// 7675             #endif
// 7676           );
// 7677 
// 7678           if (verbose_level > 3) {
// 7679             SERIAL_ECHOPAIR("Starting radius: ", radius);
// 7680             SERIAL_ECHOPAIR("   angle: ", angle);
// 7681             SERIAL_ECHOPGM(" Direction: ");
// 7682             if (dir > 0) SERIAL_ECHOPGM("Counter-");
// 7683             SERIAL_ECHOLNPGM("Clockwise");
// 7684           }
// 7685 
// 7686           for (uint8_t l = 0; l < n_legs - 1; l++) {
// 7687             double delta_angle;
// 7688 
// 7689             if (schizoid_flag)
// 7690               // The points of a 5 point star are 72 degrees apart.  We need to
// 7691               // skip a point and go to the next one on the star.
// 7692               delta_angle = dir * 2.0 * 72.0;
// 7693 
// 7694             else
// 7695               // If we do this line, we are just trying to move further
// 7696               // around the circle.
// 7697               delta_angle = dir * (float) random(25, 45);
// 7698 
// 7699             angle += delta_angle;
// 7700 
// 7701             while (angle > 360.0)   // We probably do not need to keep the angle between 0 and 2*PI, but the
// 7702               angle -= 360.0;       // Arduino documentation says the trig functions should not be given values
// 7703             while (angle < 0.0)     // outside of this range.   It looks like they behave correctly with
// 7704               angle += 360.0;       // numbers outside of the range, but just to be safe we clamp them.
// 7705 
// 7706             X_current = X_probe_location - (X_PROBE_OFFSET_FROM_EXTRUDER) + cos(RADIANS(angle)) * radius;
// 7707             Y_current = Y_probe_location - (Y_PROBE_OFFSET_FROM_EXTRUDER) + sin(RADIANS(angle)) * radius;
// 7708 
// 7709             #if DISABLED(DELTA)
// 7710               X_current = constrain(X_current, X_MIN_POS, X_MAX_POS);
// 7711               Y_current = constrain(Y_current, Y_MIN_POS, Y_MAX_POS);
// 7712             #else
// 7713               // If we have gone out too far, we can do a simple fix and scale the numbers
// 7714               // back in closer to the origin.
// 7715               while (!position_is_reachable_by_probe(X_current, Y_current)) {
// 7716                 X_current *= 0.8;
// 7717                 Y_current *= 0.8;
// 7718                 if (verbose_level > 3) {
// 7719                   SERIAL_ECHOPAIR("Pulling point towards center:", X_current);
// 7720                   SERIAL_ECHOLNPAIR(", ", Y_current);
// 7721                 }
// 7722               }
// 7723             #endif
// 7724             if (verbose_level > 3) {
// 7725               SERIAL_PROTOCOLPGM("Going to:");
// 7726               SERIAL_ECHOPAIR(" X", X_current);
// 7727               SERIAL_ECHOPAIR(" Y", Y_current);
// 7728               SERIAL_ECHOLNPAIR(" Z", current_position[Z_AXIS]);
// 7729             }
// 7730             do_blocking_move_to_xy(X_current, Y_current);
// 7731           } // n_legs loop
// 7732         } // n_legs
// 7733 
// 7734         // Probe a single point
// 7735         sample_set[n] = probe_pt(X_probe_location, Y_probe_location, stow_probe_after_each, 0);
// 7736 
// 7737         // Break the loop if the probe fails
// 7738         probing_good = !isnan(sample_set[n]);
// 7739         if (!probing_good) break;
// 7740 
// 7741         /**
// 7742          * Get the current mean for the data points we have so far
// 7743          */
// 7744         double sum = 0.0;
// 7745         for (uint8_t j = 0; j <= n; j++) sum += sample_set[j];
// 7746         mean = sum / (n + 1);
// 7747 
// 7748         NOMORE(min, sample_set[n]);
// 7749         NOLESS(max, sample_set[n]);
// 7750 
// 7751         /**
// 7752          * Now, use that mean to calculate the standard deviation for the
// 7753          * data points we have so far
// 7754          */
// 7755         sum = 0.0;
// 7756         for (uint8_t j = 0; j <= n; j++)
// 7757           sum += sq(sample_set[j] - mean);
// 7758 
// 7759         sigma = SQRT(sum / (n + 1));
// 7760         if (verbose_level > 0) {
// 7761           if (verbose_level > 1) {
// 7762             SERIAL_PROTOCOL(n + 1);
// 7763             SERIAL_PROTOCOLPGM(" of ");
// 7764             SERIAL_PROTOCOL((int)n_samples);
// 7765             SERIAL_PROTOCOLPGM(": z: ");
// 7766             SERIAL_PROTOCOL_F(sample_set[n], 3);
// 7767             if (verbose_level > 2) {
// 7768               SERIAL_PROTOCOLPGM(" mean: ");
// 7769               SERIAL_PROTOCOL_F(mean, 4);
// 7770               SERIAL_PROTOCOLPGM(" sigma: ");
// 7771               SERIAL_PROTOCOL_F(sigma, 6);
// 7772               SERIAL_PROTOCOLPGM(" min: ");
// 7773               SERIAL_PROTOCOL_F(min, 3);
// 7774               SERIAL_PROTOCOLPGM(" max: ");
// 7775               SERIAL_PROTOCOL_F(max, 3);
// 7776               SERIAL_PROTOCOLPGM(" range: ");
// 7777               SERIAL_PROTOCOL_F(max-min, 3);
// 7778             }
// 7779             SERIAL_EOL();
// 7780           }
// 7781         }
// 7782 
// 7783       } // n_samples loop
// 7784     }
// 7785 
// 7786     STOW_PROBE();
// 7787 
// 7788     if (probing_good) {
// 7789       SERIAL_PROTOCOLLNPGM("Finished!");
// 7790 
// 7791       if (verbose_level > 0) {
// 7792         SERIAL_PROTOCOLPGM("Mean: ");
// 7793         SERIAL_PROTOCOL_F(mean, 6);
// 7794         SERIAL_PROTOCOLPGM(" Min: ");
// 7795         SERIAL_PROTOCOL_F(min, 3);
// 7796         SERIAL_PROTOCOLPGM(" Max: ");
// 7797         SERIAL_PROTOCOL_F(max, 3);
// 7798         SERIAL_PROTOCOLPGM(" Range: ");
// 7799         SERIAL_PROTOCOL_F(max-min, 3);
// 7800         SERIAL_EOL();
// 7801       }
// 7802 
// 7803       SERIAL_PROTOCOLPGM("Standard Deviation: ");
// 7804       SERIAL_PROTOCOL_F(sigma, 6);
// 7805       SERIAL_EOL();
// 7806       SERIAL_EOL();
// 7807     }
// 7808 
// 7809     clean_up_after_endstop_or_probe_move();
// 7810 
// 7811     // Re-enable bed level correction if it had been on
// 7812     #if HAS_LEVELING
// 7813       set_bed_leveling_enabled(was_enabled);
// 7814     #endif
// 7815 
// 7816     report_current_position();
// 7817   }
// 7818 
// 7819 #endif // Z_MIN_PROBE_REPEATABILITY_TEST
// 7820 
// 7821 #if ENABLED(G26_MESH_VALIDATION)
// 7822 
// 7823   inline void gcode_M49() {
// 7824     g26_debug_flag ^= true;
// 7825     SERIAL_PROTOCOLPGM("G26 Debug ");
// 7826     serialprintPGM(g26_debug_flag ? PSTR("on.\n") : PSTR("off.\n"));
// 7827   }
// 7828 
// 7829 #endif // G26_MESH_VALIDATION
// 7830 
// 7831 #if ENABLED(ULTRA_LCD) && ENABLED(LCD_SET_PROGRESS_MANUALLY)
// 7832   /**
// 7833    * M73: Set percentage complete (for display on LCD)
// 7834    *
// 7835    * Example:
// 7836    *   M73 P25 ; Set progress to 25%
// 7837    *
// 7838    * Notes:
// 7839    *   This has no effect during an SD print job
// 7840    */
// 7841   inline void gcode_M73() {
// 7842     if (!IS_SD_PRINTING && parser.seen('P')) {
// 7843       progress_bar_percent = parser.value_byte();
// 7844       NOMORE(progress_bar_percent, 100);
// 7845     }
// 7846   }
// 7847 #endif // ULTRA_LCD && LCD_SET_PROGRESS_MANUALLY
// 7848 
// 7849 /**
// 7850  * M75: Start print timer
// 7851  */
// 7852 inline void gcode_M75() { print_job_timer.start(); }
// 7853 
// 7854 /**
// 7855  * M76: Pause print timer
// 7856  */
// 7857 inline void gcode_M76() { print_job_timer.pause(); }
// 7858 
// 7859 /**
// 7860  * M77: Stop print timer
// 7861  */
// 7862 inline void gcode_M77() { print_job_timer.stop(); }
// 7863 
// 7864 #if ENABLED(PRINTCOUNTER)
// 7865   /**
// 7866    * M78: Show print statistics
// 7867    */
// 7868   inline void gcode_M78() {
// 7869     // "M78 S78" will reset the statistics
// 7870     if (parser.intval('S') == 78)
// 7871       print_job_timer.initStats();
// 7872     else
// 7873       print_job_timer.showStats();
// 7874   }
// 7875 #endif
// 7876 
// 7877 /**
// 7878  * M104: Set hot end temperature
// 7879  */
// 7880 inline void gcode_M104() {
// 7881   if (get_target_extruder_from_command(104)) return;
// 7882   if (DEBUGGING(DRYRUN)) return;
// 7883 
// 7884   #if ENABLED(SINGLENOZZLE)
// 7885     if (target_extruder != active_extruder) return;
// 7886   #endif
// 7887 
// 7888   if (parser.seenval('S')) {
// 7889     const int16_t temp = parser.value_celsius();
// 7890     thermalManager.setTargetHotend(temp, target_extruder);
// 7891 
// 7892     #if ENABLED(DUAL_X_CARRIAGE)
// 7893       if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && target_extruder == 0)
// 7894         thermalManager.setTargetHotend(temp ? temp + duplicate_extruder_temp_offset : 0, 1);
// 7895     #endif
// 7896 
// 7897     #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
// 7898       /**
// 7899        * Stop the timer at the end of print. Start is managed by 'heat and wait' M109.
// 7900        * We use half EXTRUDE_MINTEMP here to allow nozzles to be put into hot
// 7901        * standby mode, for instance in a dual extruder setup, without affecting
// 7902        * the running print timer.
// 7903        */
// 7904       if (parser.value_celsius() <= (EXTRUDE_MINTEMP) / 2) {
// 7905         print_job_timer.stop();
// 7906         LCD_MESSAGEPGM(WELCOME_MSG);
// 7907       }
// 7908     #endif
// 7909 
// 7910     //if (parser.value_celsius() > thermalManager.degHotend(target_extruder))
// 7911     //  lcd_status_printf_P(0, PSTR("E%i %s"), target_extruder + 1, MSG_HEATING);
// 7912 		if(parser.value_celsius() > thermalManager.degHotend(target_extruder))
// 7913 		{
// 7914 		switch(target_extruder)
// 7915 			{
// 7916 			case 0:
// 7917 				LCD_MESSAGEPGM("E1 Heating...");
// 7918 				break;
// 7919 			case 1:
// 7920 				LCD_MESSAGEPGM("E2 Heating...");
// 7921 				break;
// 7922 			case 2:
// 7923 				LCD_MESSAGEPGM("E3 Heating...");
// 7924 				break;
// 7925 			case 3:
// 7926 				LCD_MESSAGEPGM("E4 Heating...");
// 7927 				break;
// 7928 			case 4:
// 7929 				LCD_MESSAGEPGM("E5 Heating...");
// 7930 				break;
// 7931 			default: break;
// 7932 				
// 7933 			}
// 7934 		}    
// 7935   }
// 7936 
// 7937   #if ENABLED(AUTOTEMP)
// 7938     planner.autotemp_M104_M109();
// 7939   #endif
// 7940 }
// 7941 
// 7942 /**
// 7943  * M105: Read hot end and bed temperature
// 7944  */
// 7945 inline void gcode_M105() {
// 7946   if (get_target_extruder_from_command(105)) return;
// 7947 
// 7948   #if HAS_TEMP_HOTEND || HAS_TEMP_BED
// 7949     SERIAL_PROTOCOLPGM(MSG_OK);
// 7950     thermalManager.print_heaterstates();
// 7951   #else // !HAS_TEMP_HOTEND && !HAS_TEMP_BED
// 7952     SERIAL_ERROR_START();
// 7953     SERIAL_ERRORLNPGM(MSG_ERR_NO_THERMISTORS);
// 7954   #endif
// 7955 
// 7956   SERIAL_EOL();
// 7957 }
// 7958 
// 7959 #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND || HAS_TEMP_BED)
// 7960 
// 7961   /**
// 7962    * M155: Set temperature auto-report interval. M155 S<seconds>
// 7963    */
// 7964   inline void gcode_M155() {
// 7965     if (parser.seenval('S'))
// 7966       thermalManager.set_auto_report_interval(parser.value_byte());
// 7967   }
// 7968 
// 7969 #endif // AUTO_REPORT_TEMPERATURES
// 7970 
// 7971 #if FAN_COUNT > 0
// 7972 
// 7973   /**
// 7974    * M106: Set Fan Speed
// 7975    *
// 7976    *  S<int>   Speed between 0-255
// 7977    *  P<index> Fan index, if more than one fan
// 7978    *
// 7979    * With EXTRA_FAN_SPEED enabled:
// 7980    *
// 7981    *  T<int>   Restore/Use/Set Temporary Speed:
// 7982    *           1     = Restore previous speed after T2
// 7983    *           2     = Use temporary speed set with T3-255
// 7984    *           3-255 = Set the speed for use with T2
// 7985    */
// 7986   inline void gcode_M106() {
// 7987     const uint8_t p = parser.byteval('P');
// 7988     if (p < FAN_COUNT) {
// 7989       #if ENABLED(EXTRA_FAN_SPEED)
// 7990         const int16_t t = parser.intval('T');
// 7991         if (t > 0) {
// 7992           switch (t) {
// 7993             case 1:
// 7994               fanSpeeds[p] = old_fanSpeeds[p];
// 7995               break;
// 7996             case 2:
// 7997               old_fanSpeeds[p] = fanSpeeds[p];
// 7998               fanSpeeds[p] = new_fanSpeeds[p];
// 7999               break;
// 8000             default:
// 8001               new_fanSpeeds[p] = min(t, 255);
// 8002               break;
// 8003           }
// 8004           return;
// 8005         }
// 8006       #endif // EXTRA_FAN_SPEED
// 8007       const uint16_t s = parser.ushortval('S', 255);
// 8008       fanSpeeds[p] = min(s, 255);
// 8009 	  MKS_FAN_TIM = s*10000/255;
// 8010     }
// 8011   }
// 8012 
// 8013   /**
// 8014    * M107: Fan Off
// 8015    */
// 8016   inline void gcode_M107() {
// 8017     const uint16_t p = parser.ushortval('P');
// 8018     if (p < FAN_COUNT) 
// 8019     {
// 8020 		fanSpeeds[p] = 0;
// 8021 		MKS_FAN_TIM = 0 ;
// 8022     }
// 8023   }
// 8024 
// 8025 #endif // FAN_COUNT > 0
// 8026 
// 8027 #if DISABLED(EMERGENCY_PARSER)
// 8028 
// 8029   /**
// 8030    * M108: Stop the waiting for heaters in M109, M190, M303. Does not affect the target temperature.
// 8031    */
// 8032   inline void gcode_M108() { wait_for_heatup = false; }
// 8033 
// 8034 
// 8035   /**
// 8036    * M112: Emergency Stop
// 8037    */
// 8038   inline void gcode_M112() { kill(PSTR(MSG_KILLED)); }
// 8039 
// 8040 
// 8041   /**
// 8042    * M410: Quickstop - Abort all planned moves
// 8043    *
// 8044    * This will stop the carriages mid-move, so most likely they
// 8045    * will be out of sync with the stepper position after this.
// 8046    */
// 8047   inline void gcode_M410() { quickstop_stepper(); }
// 8048 
// 8049 #endif
// 8050 
// 8051 /**
// 8052  * M109: Sxxx Wait for extruder(s) to reach temperature. Waits only when heating.
// 8053  *       Rxxx Wait for extruder(s) to reach temperature. Waits when heating and cooling.
// 8054  */
// 8055 
// 8056 #ifndef MIN_COOLING_SLOPE_DEG
// 8057   #define MIN_COOLING_SLOPE_DEG 1.50
// 8058 #endif
// 8059 #ifndef MIN_COOLING_SLOPE_TIME
// 8060   #define MIN_COOLING_SLOPE_TIME 60
// 8061 #endif
// 8062 
// 8063 inline void gcode_M109() {
// 8064 
// 8065   if (get_target_extruder_from_command(109)) return;
// 8066   if (DEBUGGING(DRYRUN)) return;
// 8067 
// 8068   #if ENABLED(SINGLENOZZLE)
// 8069     if (target_extruder != active_extruder) return;
// 8070   #endif
// 8071 
// 8072   const bool no_wait_for_cooling = parser.seenval('S');
// 8073   if (no_wait_for_cooling || parser.seenval('R')) {
// 8074     const int16_t temp = parser.value_celsius();
// 8075     thermalManager.setTargetHotend(temp, target_extruder);
// 8076 
// 8077     #if ENABLED(DUAL_X_CARRIAGE)
// 8078       if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && target_extruder == 0)
// 8079         thermalManager.setTargetHotend(temp ? temp + duplicate_extruder_temp_offset : 0, 1);
// 8080     #endif
// 8081 
// 8082     #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
// 8083       /**
// 8084        * Use half EXTRUDE_MINTEMP to allow nozzles to be put into hot
// 8085        * standby mode, (e.g., in a dual extruder setup) without affecting
// 8086        * the running print timer.
// 8087        */
// 8088       if (parser.value_celsius() <= (EXTRUDE_MINTEMP) / 2) {
// 8089         print_job_timer.stop();
// 8090         LCD_MESSAGEPGM(WELCOME_MSG);
// 8091       }
// 8092       else
// 8093         print_job_timer.start();
// 8094     #endif
// 8095 
// 8096     //if (thermalManager.isHeatingHotend(target_extruder)) lcd_status_printf_P(0, PSTR("E%i %s"), target_extruder + 1, MSG_HEATING);
// 8097 	if (parser.value_celsius() > thermalManager.degHotend(target_extruder))
// 8098 	{
// 8099 			switch(target_extruder)
// 8100 			{
// 8101 			case 0:
// 8102 				LCD_MESSAGEPGM("E1 Heating...");
// 8103 				break;
// 8104 			case 1:
// 8105 				LCD_MESSAGEPGM("E2 Heating...");
// 8106 				break;
// 8107 			case 2:
// 8108 				LCD_MESSAGEPGM("E3 Heating...");
// 8109 				break;
// 8110 			case 3:
// 8111 				LCD_MESSAGEPGM("E4 Heating...");
// 8112 				break;
// 8113 			case 4:
// 8114 				LCD_MESSAGEPGM("E5 Heating...");
// 8115 				break;
// 8116 			default: break;
// 8117 			}
// 8118 	}
// 8119 
// 8120   }
// 8121   else return;
// 8122 
// 8123   #if ENABLED(AUTOTEMP)
// 8124     planner.autotemp_M104_M109();
// 8125   #endif
// 8126 
// 8127   #if TEMP_RESIDENCY_TIME > 0
// 8128     millis_t residency_start_ms = 0;
// 8129     // Loop until the temperature has stabilized
// 8130     #define TEMP_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + (TEMP_RESIDENCY_TIME) * 1000UL))
// 8131   #else
// 8132     // Loop until the temperature is very close target
// 8133     #define TEMP_CONDITIONS (wants_to_cool ? thermalManager.isCoolingHotend(target_extruder) : thermalManager.isHeatingHotend(target_extruder))
// 8134   #endif
// 8135 
// 8136   float target_temp = -1.0, old_temp = 9999.0;
// 8137   bool wants_to_cool = false;
// 8138   wait_for_heatup = true;
// 8139   millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
// 8140 
// 8141   #if DISABLED(BUSY_WHILE_HEATING)
// 8142     KEEPALIVE_STATE(NOT_BUSY);
// 8143   #endif
// 8144 
// 8145   #if ENABLED(PRINTER_EVENT_LEDS)
// 8146     const float start_temp = thermalManager.degHotend(target_extruder);
// 8147     uint8_t old_blue = 0;
// 8148   #endif
// 8149   
// 8150   mks_heating_busy = 1;
// 8151 
// 8152   do {
// 8153     // Target temperature might be changed during the loop
// 8154     if (target_temp != thermalManager.degTargetHotend(target_extruder)) {
// 8155       wants_to_cool = thermalManager.isCoolingHotend(target_extruder);
// 8156       target_temp = thermalManager.degTargetHotend(target_extruder);
// 8157 
// 8158       // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
// 8159       if (no_wait_for_cooling && wants_to_cool) break;
// 8160     }
// 8161 
// 8162     now = millis();
// 8163     if (ELAPSED(now, next_temp_ms)) { //Print temp & remaining time every 1s while waiting
// 8164       next_temp_ms = now + 1000UL;
// 8165       //thermalManager.print_heaterstates();    //mks 2018-08
// 8166       #if TEMP_RESIDENCY_TIME > 0
// 8167         SERIAL_PROTOCOLPGM(" W:");
// 8168         if (residency_start_ms)
// 8169           SERIAL_PROTOCOL(long((((TEMP_RESIDENCY_TIME) * 1000UL) - (now - residency_start_ms)) / 1000UL));
// 8170         else
// 8171           SERIAL_PROTOCOLCHAR('?');
// 8172       #endif
// 8173       SERIAL_EOL();
// 8174     }
// 8175 
// 8176     idle();
// 8177     refresh_cmd_timeout(); // to prevent stepper_inactive_time from running out
// 8178 
// 8179     const float temp = thermalManager.degHotend(target_extruder);
// 8180 
// 8181     #if ENABLED(PRINTER_EVENT_LEDS)
// 8182       // Gradually change LED strip from violet to red as nozzle heats up
// 8183       if (!wants_to_cool) {
// 8184         const uint8_t blue = map(constrain(temp, start_temp, target_temp), start_temp, target_temp, 255, 0);
// 8185         if (blue != old_blue) {
// 8186           old_blue = blue;
// 8187           leds.set_color(
// 8188             MakeLEDColor(255, 0, blue, 0, pixels.getBrightness())
// 8189             #if ENABLED(NEOPIXEL_IS_SEQUENTIAL)
// 8190               , true
// 8191             #endif
// 8192           );
// 8193         }
// 8194       }
// 8195     #endif
// 8196 
// 8197     #if TEMP_RESIDENCY_TIME > 0
// 8198 
// 8199       const float temp_diff = FABS(target_temp - temp);
// 8200 
// 8201       if (!residency_start_ms) {
// 8202         // Start the TEMP_RESIDENCY_TIME timer when we reach target temp for the first time.
// 8203         if (temp_diff < TEMP_WINDOW) residency_start_ms = now;
// 8204       }
// 8205       else if (temp_diff > TEMP_HYSTERESIS) {
// 8206         // Restart the timer whenever the temperature falls outside the hysteresis.
// 8207         residency_start_ms = now;
// 8208       }
// 8209 
// 8210     #endif
// 8211 
// 8212     // Prevent a wait-forever situation if R is misused i.e. M109 R0
// 8213     if (wants_to_cool) {
// 8214       // break after MIN_COOLING_SLOPE_TIME seconds
// 8215       // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG
// 8216       if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
// 8217         if (old_temp - temp < MIN_COOLING_SLOPE_DEG) break;
// 8218         next_cool_check_ms = now + 1000UL * MIN_COOLING_SLOPE_TIME;
// 8219         old_temp = temp;
// 8220       }
// 8221     }
// 8222 
// 8223   } while (wait_for_heatup && TEMP_CONDITIONS);
// 8224   
// 8225   mks_heating_busy = 0;
// 8226 
// 8227   if (wait_for_heatup) {
// 8228     LCD_MESSAGEPGM(MSG_HEATING_COMPLETE);
// 8229     #if ENABLED(PRINTER_EVENT_LEDS)
// 8230       leds.set_white();
// 8231     #endif
// 8232   }
// 8233 
// 8234   #if DISABLED(BUSY_WHILE_HEATING)
// 8235     KEEPALIVE_STATE(IN_HANDLER);
// 8236   #endif
// 8237 }
// 8238 
// 8239 #if HAS_TEMP_BED
// 8240 
// 8241   #ifndef MIN_COOLING_SLOPE_DEG_BED
// 8242     #define MIN_COOLING_SLOPE_DEG_BED 1.50
// 8243   #endif
// 8244   #ifndef MIN_COOLING_SLOPE_TIME_BED
// 8245     #define MIN_COOLING_SLOPE_TIME_BED 60
// 8246   #endif
// 8247 
// 8248   /**
// 8249    * M190: Sxxx Wait for bed current temp to reach target temp. Waits only when heating
// 8250    *       Rxxx Wait for bed current temp to reach target temp. Waits when heating and cooling
// 8251    */
// 8252   inline void gcode_M190() {
// 8253     if (DEBUGGING(DRYRUN)) return;
// 8254 
// 8255     LCD_MESSAGEPGM(MSG_BED_HEATING);
// 8256     const bool no_wait_for_cooling = parser.seenval('S');
// 8257     if (no_wait_for_cooling || parser.seenval('R')) {
// 8258       thermalManager.setTargetBed(parser.value_celsius());
// 8259       #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
// 8260         if (parser.value_celsius() > BED_MINTEMP)
// 8261           print_job_timer.start();
// 8262       #endif
// 8263     }
// 8264     else return;
// 8265 
// 8266     #if TEMP_BED_RESIDENCY_TIME > 0
// 8267       millis_t residency_start_ms = 0;
// 8268       // Loop until the temperature has stabilized
// 8269       #define TEMP_BED_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + (TEMP_BED_RESIDENCY_TIME) * 1000UL))
// 8270     #else
// 8271       // Loop until the temperature is very close target
// 8272       #define TEMP_BED_CONDITIONS (wants_to_cool ? thermalManager.isCoolingBed() : thermalManager.isHeatingBed())
// 8273     #endif
// 8274 
// 8275     float target_temp = -1.0, old_temp = 9999.0;
// 8276     bool wants_to_cool = false;
// 8277     wait_for_heatup = true;
// 8278     millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
// 8279 
// 8280     #if DISABLED(BUSY_WHILE_HEATING)
// 8281       KEEPALIVE_STATE(NOT_BUSY);
// 8282     #endif
// 8283 
// 8284     target_extruder = active_extruder; // for print_heaterstates
// 8285 
// 8286     #if ENABLED(PRINTER_EVENT_LEDS)
// 8287       const float start_temp = thermalManager.degBed();
// 8288       uint8_t old_red = 255;
// 8289     #endif
// 8290 	mks_heating_busy = 1;
// 8291 
// 8292     do {
// 8293       // Target temperature might be changed during the loop
// 8294       if (target_temp != thermalManager.degTargetBed()) {
// 8295         wants_to_cool = thermalManager.isCoolingBed();
// 8296         target_temp = thermalManager.degTargetBed();
// 8297 
// 8298         // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
// 8299         if (no_wait_for_cooling && wants_to_cool) break;
// 8300       }
// 8301 
// 8302       now = millis();
// 8303       if (ELAPSED(now, next_temp_ms)) { //Print Temp Reading every 1 second while heating up.
// 8304         next_temp_ms = now + 1000UL;
// 8305         thermalManager.print_heaterstates();
// 8306         #if TEMP_BED_RESIDENCY_TIME > 0
// 8307           SERIAL_PROTOCOLPGM(" W:");
// 8308           if (residency_start_ms)
// 8309             SERIAL_PROTOCOL(long((((TEMP_BED_RESIDENCY_TIME) * 1000UL) - (now - residency_start_ms)) / 1000UL));
// 8310           else
// 8311             SERIAL_PROTOCOLCHAR('?');
// 8312         #endif
// 8313         SERIAL_EOL();
// 8314       }
// 8315 
// 8316       idle();
// 8317       refresh_cmd_timeout(); // to prevent stepper_inactive_time from running out
// 8318 
// 8319       const float temp = thermalManager.degBed();
// 8320 
// 8321       #if ENABLED(PRINTER_EVENT_LEDS)
// 8322         // Gradually change LED strip from blue to violet as bed heats up
// 8323         if (!wants_to_cool) {
// 8324           const uint8_t red = map(constrain(temp, start_temp, target_temp), start_temp, target_temp, 0, 255);
// 8325           if (red != old_red) {
// 8326             old_red = red;
// 8327             leds.set_color(
// 8328               MakeLEDColor(red, 0, 255, 0, pixels.getBrightness())
// 8329               #if ENABLED(NEOPIXEL_IS_SEQUENTIAL)
// 8330                 , true
// 8331               #endif
// 8332             );
// 8333           }
// 8334         }
// 8335       #endif
// 8336 
// 8337       #if TEMP_BED_RESIDENCY_TIME > 0
// 8338 
// 8339         const float temp_diff = FABS(target_temp - temp);
// 8340 
// 8341         if (!residency_start_ms) {
// 8342           // Start the TEMP_BED_RESIDENCY_TIME timer when we reach target temp for the first time.
// 8343           if (temp_diff < TEMP_BED_WINDOW) residency_start_ms = now;
// 8344         }
// 8345         else if (temp_diff > TEMP_BED_HYSTERESIS) {
// 8346           // Restart the timer whenever the temperature falls outside the hysteresis.
// 8347           residency_start_ms = now;
// 8348         }
// 8349 
// 8350       #endif // TEMP_BED_RESIDENCY_TIME > 0
// 8351 
// 8352       // Prevent a wait-forever situation if R is misused i.e. M190 R0
// 8353       if (wants_to_cool) {
// 8354         // Break after MIN_COOLING_SLOPE_TIME_BED seconds
// 8355         // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG_BED
// 8356         if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
// 8357           if (old_temp - temp < MIN_COOLING_SLOPE_DEG_BED) break;
// 8358           next_cool_check_ms = now + 1000UL * MIN_COOLING_SLOPE_TIME_BED;
// 8359           old_temp = temp;
// 8360         }
// 8361       }
// 8362 
// 8363     } while (wait_for_heatup && TEMP_BED_CONDITIONS);
// 8364 
// 8365 	mks_heating_busy = 0;
// 8366 
// 8367     if (wait_for_heatup) LCD_MESSAGEPGM(MSG_BED_DONE);
// 8368     #if DISABLED(BUSY_WHILE_HEATING)
// 8369       KEEPALIVE_STATE(IN_HANDLER);
// 8370     #endif
// 8371   }
// 8372 
// 8373 #endif // HAS_TEMP_BED
// 8374 
// 8375 /**
// 8376  * M110: Set Current Line Number
// 8377  */
// 8378 inline void gcode_M110() {
// 8379   if (parser.seenval('N')) gcode_LastN = parser.value_long();
// 8380 }
// 8381 
// 8382 /**
// 8383  * M111: Set the debug level
// 8384  */
// 8385 inline void gcode_M111() {
// 8386   if (parser.seen('S')) marlin_debug_flags = parser.byteval('S');
// 8387 

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vE11str_debug_1
// 8388   const static char str_debug_1[] PROGMEM = MSG_DEBUG_ECHO,
_ZZ10gcode_M111vE11str_debug_1:
        DATA
        DC8 "ECHO"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vE11str_debug_2
// 8389                     str_debug_2[] PROGMEM = MSG_DEBUG_INFO,
_ZZ10gcode_M111vE11str_debug_2:
        DATA
        DC8 "INFO"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vE11str_debug_4
// 8390                     str_debug_4[] PROGMEM = MSG_DEBUG_ERRORS,
_ZZ10gcode_M111vE11str_debug_4:
        DATA
        DC8 "ERRORS"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vE11str_debug_8
// 8391                     str_debug_8[] PROGMEM = MSG_DEBUG_DRYRUN,
_ZZ10gcode_M111vE11str_debug_8:
        DATA
        DC8 "DRYRUN"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vE12str_debug_16
// 8392                     str_debug_16[] PROGMEM = MSG_DEBUG_COMMUNICATION
_ZZ10gcode_M111vE12str_debug_16:
        DATA
        DC8 "COMMUNICATION"
        DC8 0, 0
// 8393                     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 8394                       , str_debug_32[] PROGMEM = MSG_DEBUG_LEVELING
// 8395                     #endif
// 8396                     ;
// 8397 

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vE13debug_strings
// 8398   const static char* const debug_strings[] PROGMEM = {
_ZZ10gcode_M111vE13debug_strings:
        DATA
        DC32 _ZZ10gcode_M111vE11str_debug_1, _ZZ10gcode_M111vE11str_debug_2
        DC32 _ZZ10gcode_M111vE11str_debug_4, _ZZ10gcode_M111vE11str_debug_8
        DC32 _ZZ10gcode_M111vE12str_debug_16

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "mks_pft.sys">`:
        DC8 "mks_pft.sys"

        SECTION `.rodata`:CONST:NOROOT(1)
        DATA
`?<Constant "Z">`:
        DC8 "Z"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant {(0.0F), (0.0F)}>`:
        DC32 0H, 0H

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant " Z:">`:
        DC8 " Z:"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "X:">`:
        DC8 "X:"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant " Y:">`:
        DC8 " Y:"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant " E:">`:
        DC8 " E:"

        SECTION `.rodata`:CONST:NOROOT(1)
        DATA
`?<Constant ":">`:
        DC8 ":"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "ok">`:
        DC8 "ok"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "M29">`:
        DC8 "M29"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "%f">`:
        DC8 "%f"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant " Y">`:
        DC8 " Y"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "G28">`:
        DC8 "G28"

        SECTION `.rodata`:CONST:NOROOT(1)
        DATA
`?<Constant "/">`:
        DC8 "/"
// 8399     str_debug_1, str_debug_2, str_debug_4, str_debug_8, str_debug_16
// 8400     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 8401       , str_debug_32
// 8402     #endif
// 8403   };
// 8404 
// 8405   SERIAL_ECHO_START();
// 8406   SERIAL_ECHOPGM(MSG_DEBUG_PREFIX);
// 8407   if (marlin_debug_flags) {
// 8408     uint8_t comma = 0;
// 8409     for (uint8_t i = 0; i < COUNT(debug_strings); i++) {
// 8410       if (TEST(marlin_debug_flags, i)) {
// 8411         if (comma++) SERIAL_CHAR(',');
// 8412         //serialprintPGM((char*)pgm_read_word(&debug_strings[i]));
// 8413         serialprintPGM((char*)&(debug_strings[i]));
// 8414       }
// 8415     }
// 8416   }
// 8417   else {
// 8418     SERIAL_ECHOPGM(MSG_DEBUG_OFF);
// 8419   }
// 8420   SERIAL_EOL();
// 8421 }
// 8422 
// 8423 #if ENABLED(HOST_KEEPALIVE_FEATURE)
// 8424 
// 8425   /**
// 8426    * M113: Get or set Host Keepalive interval (0 to disable)
// 8427    *
// 8428    *   S<seconds> Optional. Set the keepalive interval.
// 8429    */
// 8430   inline void gcode_M113() {
// 8431     if (parser.seenval('S')) {
// 8432       host_keepalive_interval = parser.value_byte();
// 8433       NOMORE(host_keepalive_interval, 60);
// 8434     }
// 8435     else {
// 8436       SERIAL_ECHO_START();
// 8437       SERIAL_ECHOLNPAIR("M113 S", (unsigned long)host_keepalive_interval);
// 8438     }
// 8439   }
// 8440 
// 8441 #endif
// 8442 
// 8443 #if ENABLED(BARICUDA)
// 8444 
// 8445   #if HAS_HEATER_1
// 8446     /**
// 8447      * M126: Heater 1 valve open
// 8448      */
// 8449     inline void gcode_M126() { baricuda_valve_pressure = parser.byteval('S', 255); }
// 8450     /**
// 8451      * M127: Heater 1 valve close
// 8452      */
// 8453     inline void gcode_M127() { baricuda_valve_pressure = 0; }
// 8454   #endif
// 8455 
// 8456   #if HAS_HEATER_2
// 8457     /**
// 8458      * M128: Heater 2 valve open
// 8459      */
// 8460     inline void gcode_M128() { baricuda_e_to_p_pressure = parser.byteval('S', 255); }
// 8461     /**
// 8462      * M129: Heater 2 valve close
// 8463      */
// 8464     inline void gcode_M129() { baricuda_e_to_p_pressure = 0; }
// 8465   #endif
// 8466 
// 8467 #endif // BARICUDA
// 8468 
// 8469 /**
// 8470  * M140: Set bed temperature
// 8471  */
// 8472 inline void gcode_M140() {
// 8473   if (DEBUGGING(DRYRUN)) return;
// 8474   if (parser.seenval('S')) thermalManager.setTargetBed(parser.value_celsius());
// 8475 }
// 8476 
// 8477 #if ENABLED(ULTIPANEL)
// 8478 
// 8479   /**
// 8480    * M145: Set the heatup state for a material in the LCD menu
// 8481    *
// 8482    *   S<material> (0=PLA, 1=ABS)
// 8483    *   H<hotend temp>
// 8484    *   B<bed temp>
// 8485    *   F<fan speed>
// 8486    */
// 8487   inline void gcode_M145() {
// 8488     const uint8_t material = (uint8_t)parser.intval('S');
// 8489     if (material >= COUNT(lcd_preheat_hotend_temp)) {
// 8490       SERIAL_ERROR_START();
// 8491       SERIAL_ERRORLNPGM(MSG_ERR_MATERIAL_INDEX);
// 8492     }
// 8493     else {
// 8494       int v;
// 8495       if (parser.seenval('H')) {
// 8496         v = parser.value_int();
// 8497         lcd_preheat_hotend_temp[material] = constrain(v, EXTRUDE_MINTEMP, HEATER_0_MAXTEMP - 15);
// 8498       }
// 8499       if (parser.seenval('F')) {
// 8500         v = parser.value_int();
// 8501         lcd_preheat_fan_speed[material] = constrain(v, 0, 255);
// 8502       }
// 8503       #if TEMP_SENSOR_BED != 0
// 8504         if (parser.seenval('B')) {
// 8505           v = parser.value_int();
// 8506           lcd_preheat_bed_temp[material] = constrain(v, BED_MINTEMP, BED_MAXTEMP - 15);
// 8507         }
// 8508       #endif
// 8509     }
// 8510   }
// 8511 
// 8512 #endif // ULTIPANEL
// 8513 
// 8514 #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
// 8515   /**
// 8516    * M149: Set temperature units
// 8517    */
// 8518   inline void gcode_M149() {
// 8519          if (parser.seenval('C')) parser.set_input_temp_units(TEMPUNIT_C);
// 8520     else if (parser.seenval('K')) parser.set_input_temp_units(TEMPUNIT_K);
// 8521     else if (parser.seenval('F')) parser.set_input_temp_units(TEMPUNIT_F);
// 8522   }
// 8523 #endif
// 8524 
// 8525 #if HAS_POWER_SWITCH
// 8526 
// 8527   /**
// 8528    * M80   : Turn on the Power Supply
// 8529    * M80 S : Report the current state and exit
// 8530    */
// 8531   inline void gcode_M80() {
// 8532 
// 8533     // S: Report the current power supply state and exit
// 8534     if (parser.seen('S')) {
// 8535       serialprintPGM(powersupply_on ? PSTR("PS:1\n") : PSTR("PS:0\n"));
// 8536       return;
// 8537     }
// 8538 
// 8539     OUT_WRITE(PS_ON_PIN, PS_ON_AWAKE); // GND
// 8540 
// 8541     /**
// 8542      * If you have a switch on suicide pin, this is useful
// 8543      * if you want to start another print with suicide feature after
// 8544      * a print without suicide...
// 8545      */
// 8546     #if HAS_SUICIDE
// 8547       OUT_WRITE(SUICIDE_PIN, HIGH);
// 8548     #endif
// 8549 
// 8550     #if ENABLED(HAVE_TMC2130)
// 8551       delay(100);
// 8552       tmc2130_init(); // Settings only stick when the driver has power
// 8553     #endif
// 8554 
// 8555     powersupply_on = true;
// 8556 
// 8557     #if ENABLED(ULTIPANEL)
// 8558       LCD_MESSAGEPGM(WELCOME_MSG);
// 8559     #endif
// 8560 
// 8561     #if ENABLED(HAVE_TMC2208)
// 8562       delay(100);
// 8563       tmc2208_init();
// 8564     #endif
// 8565   }
// 8566 
// 8567 #endif // HAS_POWER_SWITCH
// 8568 
// 8569 /**
// 8570  * M81: Turn off Power, including Power Supply, if there is one.
// 8571  *
// 8572  *      This code should ALWAYS be available for EMERGENCY SHUTDOWN!
// 8573  */
// 8574 inline void gcode_M81() {
// 8575   thermalManager.disable_all_heaters();
// 8576   stepper.finish_and_disable();
// 8577 
// 8578   #if FAN_COUNT > 0
// 8579     for (uint8_t i = 0; i < FAN_COUNT; i++) fanSpeeds[i] = 0;
// 8580     #if ENABLED(PROBING_FANS_OFF)
// 8581       fans_paused = false;
// 8582       ZERO(paused_fanSpeeds);
// 8583     #endif
// 8584   #endif
// 8585 
// 8586   safe_delay(1000); // Wait 1 second before switching off
// 8587 
// 8588   #if HAS_SUICIDE
// 8589     stepper.synchronize();
// 8590     suicide();
// 8591   #elif HAS_POWER_SWITCH
// 8592     OUT_WRITE(PS_ON_PIN, PS_ON_ASLEEP);
// 8593     powersupply_on = false;
// 8594   #endif
// 8595 
// 8596   #if ENABLED(ULTIPANEL)
// 8597     LCD_MESSAGEPGM(MACHINE_NAME " " MSG_OFF ".");
// 8598   #endif
// 8599 }
// 8600 
// 8601 /**
// 8602  * M82: Set E codes absolute (default)
// 8603  */
// 8604 inline void gcode_M82() { axis_relative_modes[E_AXIS] = false; }
// 8605 
// 8606 /**
// 8607  * M83: Set E codes relative while in Absolute Coordinates (G90) mode
// 8608  */
// 8609 inline void gcode_M83() { axis_relative_modes[E_AXIS] = true; }
// 8610 
// 8611 /**
// 8612  * M18, M84: Disable stepper motors
// 8613  */
// 8614 inline void gcode_M18_M84() {
// 8615   if (parser.seenval('S')) {
// 8616     stepper_inactive_time = parser.value_millis_from_seconds();
// 8617   }
// 8618   else {
// 8619     bool all_axis = !((parser.seen('X')) || (parser.seen('Y')) || (parser.seen('Z')) || (parser.seen('E')));
// 8620     if (all_axis) {
// 8621       stepper.finish_and_disable();
// 8622     }
// 8623     else {
// 8624       stepper.synchronize();
// 8625       if (parser.seen('X')) disable_X();
// 8626       if (parser.seen('Y')) disable_Y();
// 8627       if (parser.seen('Z')) disable_Z();
// 8628       #if E0_ENABLE_PIN != X_ENABLE_PIN && E1_ENABLE_PIN != Y_ENABLE_PIN // Only enable on boards that have separate ENABLE_PINS
// 8629         if (parser.seen('E')) disable_e_steppers();
// 8630       #endif
// 8631     }
// 8632 
// 8633     #if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(ULTIPANEL)  // Only needed with an LCD
// 8634       ubl.lcd_map_control = defer_return_to_status = false;
// 8635     #endif
// 8636   }
// 8637 }
// 8638 
// 8639 /**
// 8640  * M85: Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
// 8641  */
// 8642 inline void gcode_M85() {
// 8643   if (parser.seen('S')) max_inactive_time = parser.value_millis_from_seconds();
// 8644 }
// 8645 
// 8646 /**
// 8647  * Multi-stepper support for M92, M201, M203
// 8648  */
// 8649 #if ENABLED(DISTINCT_E_FACTORS)
// 8650   #define GET_TARGET_EXTRUDER(CMD) if (get_target_extruder_from_command(CMD)) return
// 8651   #define TARGET_EXTRUDER target_extruder
// 8652 #else
// 8653   #define GET_TARGET_EXTRUDER(CMD) NOOP
// 8654   #define TARGET_EXTRUDER 0
// 8655 #endif
// 8656 
// 8657 /**
// 8658  * M92: Set axis steps-per-unit for one or more axes, X, Y, Z, and E.
// 8659  *      (Follows the same syntax as G92)
// 8660  *
// 8661  *      With multiple extruders use T to specify which one.
// 8662  */
// 8663 inline void gcode_M92() {
// 8664 
// 8665   GET_TARGET_EXTRUDER(92);
// 8666 
// 8667   LOOP_XYZE(i) {
// 8668     if (parser.seen(axis_codes[i])) {
// 8669       if (i == E_AXIS) {
// 8670         const float value = parser.value_per_axis_unit((AxisEnum)(E_AXIS + TARGET_EXTRUDER));
// 8671         if (value < 20.0) {
// 8672           float factor = planner.axis_steps_per_mm[E_AXIS + TARGET_EXTRUDER] / value; // increase e constants if M92 E14 is given for netfab.
// 8673           planner.max_jerk[E_AXIS] *= factor;
// 8674           planner.max_feedrate_mm_s[E_AXIS + TARGET_EXTRUDER] *= factor;
// 8675           planner.max_acceleration_steps_per_s2[E_AXIS + TARGET_EXTRUDER] *= factor;
// 8676         }
// 8677         planner.axis_steps_per_mm[E_AXIS + TARGET_EXTRUDER] = value;
// 8678       }
// 8679       else {
// 8680         planner.axis_steps_per_mm[i] = parser.value_per_axis_unit((AxisEnum)i);
// 8681       }
// 8682     }
// 8683   }
// 8684   planner.refresh_positioning();
// 8685 }
// 8686 
// 8687 /**
// 8688  * Output the current position to serial
// 8689  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock40 Using cfiCommon0
          CFI Function _Z22report_mksdlp_positionv
        THUMB
// 8690 void report_mksdlp_position() {
_Z22report_mksdlp_positionv:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
// 8691 //	SERIAL_PROTOCOLPGM("X:");
// 8692 //	SERIAL_PROTOCOL(/*LOGICAL_X_POSITION*/(current_position[X_AXIS]));
// 8693 //	SERIAL_PROTOCOLPGM(" Y:");
// 8694 //	SERIAL_PROTOCOL(/*LOGICAL_Y_POSITION*/(current_position[Y_AXIS]));
// 8695 
// 8696   SERIAL_PROTOCOLPGM("Layer:");
        ADR.W    R0,`?<Constant "Layer:">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 8697   SERIAL_PROTOCOL(mksdlp.get_currentLayer());
        LDR.W    R0,??DataTable104
          CFI FunCall _ZN7MKS_DLP16get_currentLayerEv
        BL       _ZN7MKS_DLP16get_currentLayerEv
        LDR.W    R5,??DataTable97
        MOVS     R2,#+10
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEii
        BL       _ZN5Print5printEii
// 8698 	
// 8699   SERIAL_PROTOCOLPGM(" Z:");
        ADR.N    R0,??DataTable92_1  ;; " Z:"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 8700   SERIAL_PROTOCOL(/*LOGICAL_Z_POSITION*/(current_position[Z_AXIS]));
        MOVS     R1,#+2
        MOV      R4,R1
        LDR.N    R0,??DataTable92_9
        LDR      R0,[R0, #+40]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        VMOV     D0,R0,R1
        MOV      R1,R4
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
// 8701 //	SERIAL_PROTOCOLPGM(" E:");
// 8702 //	SERIAL_PROTOCOL(current_position[E_AXIS]);
// 8703 	
// 8704   stepper.report_positions();
        POP      {R0,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Stepper16report_positionsEv
        B.W      _ZN7Stepper16report_positionsEv
          CFI EndBlock cfiBlock40
// 8705 	
// 8706 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Layer:">`:
        DC8 "Layer:"
        DC8 0
// 8707 
// 8708  

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock41 Using cfiCommon0
          CFI Function _Z23report_current_positionv
        THUMB
// 8709 void report_current_position() {
_Z23report_current_positionv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
// 8710   SERIAL_PROTOCOLPGM("X:");
        ADR.N    R0,??DataTable92_2  ;; 0x58, 0x3A, 0x00, 0x00
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 8711   SERIAL_PROTOCOL(/*LOGICAL_X_POSITION*/(current_position[X_AXIS]));
        LDR.W    R5,??DataTable97
        LDR.N    R6,??DataTable92_9
        MOVS     R1,#+2
        MOV      R4,R1
        LDR      R0,[R6, #+32]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        VMOV     D0,R0,R1
        MOV      R1,R4
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
// 8712   SERIAL_PROTOCOLPGM(" Y:");
        ADR.N    R0,??DataTable92_3  ;; " Y:"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 8713   SERIAL_PROTOCOL(/*LOGICAL_Y_POSITION*/(current_position[Y_AXIS]));
        LDR      R0,[R6, #+36]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        VMOV     D0,R0,R1
        MOV      R1,R4
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
// 8714 
// 8715   SERIAL_PROTOCOLPGM(" Z:");
        ADR.N    R0,??DataTable92_1  ;; " Z:"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 8716   SERIAL_PROTOCOL(/*LOGICAL_Z_POSITION*/(current_position[Z_AXIS]));
        LDR      R0,[R6, #+40]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        VMOV     D0,R0,R1
        MOV      R1,R4
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
// 8717   SERIAL_PROTOCOLPGM(" E:");
        ADR.N    R0,??DataTable92_4  ;; " E:"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 8718   SERIAL_PROTOCOL(current_position[E_AXIS]);
        LDR      R0,[R6, #+44]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        VMOV     D0,R0,R1
        MOV      R1,R4
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
// 8719 
// 8720   stepper.report_positions();
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Stepper16report_positionsEv
        B.W      _ZN7Stepper16report_positionsEv
          CFI EndBlock cfiBlock41
// 8721 
// 8722   #if IS_SCARA
// 8723     SERIAL_PROTOCOLPAIR("SCARA Theta:", stepper.get_axis_position_degrees(A_AXIS));
// 8724     SERIAL_PROTOCOLLNPAIR("   Psi+Theta:", stepper.get_axis_position_degrees(B_AXIS));
// 8725     SERIAL_EOL();
// 8726   #endif
// 8727 }
// 8728 
// 8729 #ifdef M114_DETAIL
// 8730 
// 8731   void report_xyze(const float pos[], const uint8_t n = 4, const uint8_t precision = 3) {
// 8732     char str[12];
// 8733     for (uint8_t i = 0; i < n; i++) {
// 8734       SERIAL_CHAR(' ');
// 8735       SERIAL_CHAR(axis_codes[i]);
// 8736       SERIAL_CHAR(':');
// 8737       SERIAL_PROTOCOL(dtostrf(pos[i], 8, precision, str));
// 8738     }
// 8739     SERIAL_EOL();
// 8740   }
// 8741 
// 8742   inline void report_xyz(const float pos[]) { report_xyze(pos, 3); }
// 8743 
// 8744   void report_current_position_detail() {
// 8745 
// 8746     stepper.synchronize();
// 8747 
// 8748     SERIAL_PROTOCOLPGM("\nLogical:");
// 8749     const float logical[XYZ] = {
// 8750       LOGICAL_X_POSITION(current_position[X_AXIS]),
// 8751       LOGICAL_Y_POSITION(current_position[Y_AXIS]),
// 8752       LOGICAL_Z_POSITION(current_position[Z_AXIS])
// 8753     };
// 8754     report_xyze(logical);
// 8755 
// 8756     SERIAL_PROTOCOLPGM("Raw:    ");
// 8757     report_xyz(current_position);
// 8758 
// 8759     float leveled[XYZ] = { current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] };
// 8760 
// 8761     #if PLANNER_LEVELING
// 8762       SERIAL_PROTOCOLPGM("Leveled:");
// 8763       planner.apply_leveling(leveled);
// 8764       report_xyz(leveled);
// 8765 
// 8766       SERIAL_PROTOCOLPGM("UnLevel:");
// 8767       float unleveled[XYZ] = { leveled[X_AXIS], leveled[Y_AXIS], leveled[Z_AXIS] };
// 8768       planner.unapply_leveling(unleveled);
// 8769       report_xyz(unleveled);
// 8770     #endif
// 8771 
// 8772     #if IS_KINEMATIC
// 8773       #if IS_SCARA
// 8774         SERIAL_PROTOCOLPGM("ScaraK: ");
// 8775       #else
// 8776         SERIAL_PROTOCOLPGM("DeltaK: ");
// 8777       #endif
// 8778       inverse_kinematics(leveled);  // writes delta[]
// 8779       report_xyz(delta);
// 8780     #endif
// 8781 
// 8782     SERIAL_PROTOCOLPGM("Stepper:");
// 8783     LOOP_XYZE(i) {
// 8784       SERIAL_CHAR(' ');
// 8785       SERIAL_CHAR(axis_codes[i]);
// 8786       SERIAL_CHAR(':');
// 8787       SERIAL_PROTOCOL(stepper.position((AxisEnum)i));
// 8788     }
// 8789     SERIAL_EOL();
// 8790 
// 8791     #if IS_SCARA
// 8792       const float deg[XYZ] = {
// 8793         stepper.get_axis_position_degrees(A_AXIS),
// 8794         stepper.get_axis_position_degrees(B_AXIS)
// 8795       };
// 8796       SERIAL_PROTOCOLPGM("Degrees:");
// 8797       report_xyze(deg, 2);
// 8798     #endif
// 8799 
// 8800     SERIAL_PROTOCOLPGM("FromStp:");
// 8801     get_cartesian_from_steppers();  // writes cartes[XYZ] (with forward kinematics)
// 8802     const float from_steppers[XYZE] = { cartes[X_AXIS], cartes[Y_AXIS], cartes[Z_AXIS], stepper.get_axis_position_mm(E_AXIS) };
// 8803     report_xyze(from_steppers);
// 8804 
// 8805     const float diff[XYZE] = {
// 8806       from_steppers[X_AXIS] - leveled[X_AXIS],
// 8807       from_steppers[Y_AXIS] - leveled[Y_AXIS],
// 8808       from_steppers[Z_AXIS] - leveled[Z_AXIS],
// 8809       from_steppers[E_AXIS] - current_position[E_AXIS]
// 8810     };
// 8811     SERIAL_PROTOCOLPGM("Differ: ");
// 8812     report_xyze(diff);
// 8813   }
// 8814 #endif // M114_DETAIL
// 8815 
// 8816 /**
// 8817  * M114: Report current position to host
// 8818  */
// 8819 inline void gcode_M114() {
// 8820 
// 8821   #ifdef M114_DETAIL
// 8822     if (parser.seen('D')) {
// 8823       report_current_position_detail();
// 8824       return;
// 8825     }
// 8826   #endif
// 8827 
// 8828   stepper.synchronize();
// 8829   report_current_position();
// 8830 }
// 8831 
// 8832 /**
// 8833  * M115: Capabilities string
// 8834  */
// 8835 
// 8836 #if ENABLED(EXTENDED_CAPABILITIES_REPORT)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock42 Using cfiCommon0
          CFI Function _Z8cap_linePKcb
        THUMB
// 8837   static void cap_line(const char * const name, bool ena=false) {
_Z8cap_linePKcb:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        MOV      R5,R1
// 8838     SERIAL_PROTOCOLPGM("Cap:");
        ADR.W    R0,`?<Constant "Cap:">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 8839     serialprintPGM(name);
        MOV      R0,R4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 8840     SERIAL_PROTOCOLPGM(":");
        ADR.N    R0,??DataTable92_5  ;; ":"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 8841     SERIAL_PROTOCOLLN(int(ena ? 1 : 0));
        LDR.W    R4,??DataTable97
        MOVS     R2,#+10
        MOV      R1,R5
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEii
        BL       _ZN5Print5printEii
        MOVS     R1,#+10
        MOV      R0,R4
        POP      {R2,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
          CFI EndBlock cfiBlock42
// 8842   }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable91:
        DC8      "Z",0x0,0x0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable91_1:
        DC32     0x0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Cap:">`:
        DC8 "Cap:"
        DC8 0, 0, 0
// 8843 #endif
// 8844 
// 8845 inline void gcode_M115() {
// 8846   SERIAL_PROTOCOLLNPGM(MSG_M115_REPORT);
// 8847 
// 8848   #if ENABLED(EXTENDED_CAPABILITIES_REPORT)
// 8849 
// 8850     // SERIAL_XON_XOFF
// 8851     cap_line(PSTR("SERIAL_XON_XOFF")
// 8852       #if ENABLED(SERIAL_XON_XOFF)
// 8853         , true
// 8854       #endif
// 8855     );
// 8856 
// 8857     // EEPROM (M500, M501)
// 8858     cap_line(PSTR("EEPROM")
// 8859       #if ENABLED(EEPROM_SETTINGS)
// 8860         , true
// 8861       #endif
// 8862     );
// 8863 
// 8864     // Volumetric Extrusion (M200)
// 8865     cap_line(PSTR("VOLUMETRIC")
// 8866       #if DISABLED(NO_VOLUMETRICS)
// 8867         , true
// 8868       #endif
// 8869     );
// 8870 
// 8871     // AUTOREPORT_TEMP (M155)
// 8872     cap_line(PSTR("AUTOREPORT_TEMP")
// 8873       #if ENABLED(AUTO_REPORT_TEMPERATURES)
// 8874         , true
// 8875       #endif
// 8876     );
// 8877 
// 8878     // PROGRESS (M530 S L, M531 <file>, M532 X L)
// 8879     cap_line(PSTR("PROGRESS"));
// 8880 
// 8881     // Print Job timer M75, M76, M77
// 8882     cap_line(PSTR("PRINT_JOB"), true);
// 8883 
// 8884     // AUTOLEVEL (G29)
// 8885     cap_line(PSTR("AUTOLEVEL")
// 8886       #if HAS_AUTOLEVEL
// 8887         , true
// 8888       #endif
// 8889     );
// 8890 
// 8891     // Z_PROBE (G30)
// 8892     cap_line(PSTR("Z_PROBE")
// 8893       #if HAS_BED_PROBE
// 8894         , true
// 8895       #endif
// 8896     );
// 8897 
// 8898     // MESH_REPORT (M420 V)
// 8899     cap_line(PSTR("LEVELING_DATA")
// 8900       #if HAS_LEVELING
// 8901         , true
// 8902       #endif
// 8903     );
// 8904 
// 8905     // BUILD_PERCENT (M73)
// 8906     cap_line(PSTR("BUILD_PERCENT")
// 8907       #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
// 8908         , true
// 8909       #endif
// 8910     );
// 8911 
// 8912     // SOFTWARE_POWER (M80, M81)
// 8913     cap_line(PSTR("SOFTWARE_POWER")
// 8914       #if HAS_POWER_SWITCH
// 8915         , true
// 8916       #endif
// 8917     );
// 8918 
// 8919     // CASE LIGHTS (M355)
// 8920     cap_line(PSTR("TOGGLE_LIGHTS")
// 8921       #if HAS_CASE_LIGHT
// 8922         , true
// 8923       #endif
// 8924     );
// 8925     cap_line(PSTR("CASE_LIGHT_BRIGHTNESS")
// 8926       #if HAS_CASE_LIGHT
// 8927         , USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN)
// 8928       #endif
// 8929     );
// 8930 
// 8931     // EMERGENCY_PARSER (M108, M112, M410)
// 8932     cap_line(PSTR("EMERGENCY_PARSER")
// 8933       #if ENABLED(EMERGENCY_PARSER)
// 8934         , true
// 8935       #endif
// 8936     );
// 8937 
// 8938   #endif // EXTENDED_CAPABILITIES_REPORT
// 8939 }
// 8940 
// 8941 /**
// 8942  * M117: Set LCD Status Message
// 8943  */
// 8944 inline void gcode_M117() { lcd_setstatus(parser.string_arg); }
// 8945 
// 8946 /**
// 8947  * M118: Display a message in the host console.
// 8948  *
// 8949  *  A1  Append '// ' for an action command, as in OctoPrint
// 8950  *  E1  Have the host 'echo:' the text
// 8951  */
// 8952 inline void gcode_M118() {
// 8953   if (parser.boolval('E')) SERIAL_ECHO_START();
// 8954   if (parser.boolval('A')) SERIAL_ECHOPGM("// ");
// 8955   SERIAL_ECHOLN(parser.string_arg);
// 8956 }
// 8957 
// 8958 /**
// 8959  * M119: Output endstop states to serial output
// 8960  */
// 8961 inline void gcode_M119() { endstops.M119(); }
// 8962 
// 8963 /**
// 8964  * M120: Enable endstops and set non-homing endstop state to "enabled"
// 8965  */
// 8966 inline void gcode_M120() { endstops.enable_globally(true); }
// 8967 
// 8968 /**
// 8969  * M121: Disable endstops and set non-homing endstop state to "disabled"
// 8970  */
// 8971 inline void gcode_M121() { endstops.enable_globally(false); }
// 8972 
// 8973 #if ENABLED(PARK_HEAD_ON_PAUSE)
// 8974 
// 8975   /**
// 8976    * M125: Store current position and move to filament change position.
// 8977    *       Called on pause (by M25) to prevent material leaking onto the
// 8978    *       object. On resume (M24) the head will be moved back and the
// 8979    *       print will resume.
// 8980    *
// 8981    *       If Marlin is compiled without SD Card support, M125 can be
// 8982    *       used directly to pause the print and move to park position,
// 8983    *       resuming with a button click or M108.
// 8984    *
// 8985    *    L = override retract length
// 8986    *    X = override X
// 8987    *    Y = override Y
// 8988    *    Z = override Z raise
// 8989    */
// 8990   inline void gcode_M125() {
// 8991 
// 8992     // Initial retract before move to filament change position
// 8993     const float retract = parser.seen('L') ? parser.value_axis_units(E_AXIS) : 0
// 8994       #ifdef PAUSE_PARK_RETRACT_LENGTH
// 8995         - (PAUSE_PARK_RETRACT_LENGTH)
// 8996       #endif
// 8997     ;
// 8998 
// 8999     point_t park_point = NOZZLE_PARK_POINT;
// 9000 
// 9001     // Move XY axes to filament change position or given position
// 9002     if (parser.seenval('X')) park_point.x = parser.linearval('X');
// 9003     if (parser.seenval('Y')) park_point.y = parser.linearval('Y');
// 9004 
// 9005     // Lift Z axis
// 9006     if (parser.seenval('Z')) park_point.z = parser.linearval('Z');
// 9007 
// 9008     #if HOTENDS > 1 && DISABLED(DUAL_X_CARRIAGE)
// 9009       park_point.x += (active_extruder ? hotend_offset[X_AXIS][active_extruder] : 0);
// 9010       park_point.y += (active_extruder ? hotend_offset[Y_AXIS][active_extruder] : 0);
// 9011     #endif
// 9012 
// 9013     #if DISABLED(SDSUPPORT)
// 9014       const bool job_running = print_job_timer.isRunning();
// 9015     #endif
// 9016 
// 9017     if (pause_print(retract, park_point)) {
// 9018       #if DISABLED(SDSUPPORT)
// 9019         // Wait for lcd click or M108
// 9020         wait_for_filament_reload();
// 9021 
// 9022         // Return to print position and continue
// 9023         resume_print();
// 9024 
// 9025         if (job_running) print_job_timer.start();
// 9026       #endif
// 9027     }
// 9028   }
// 9029 
// 9030 #endif // PARK_HEAD_ON_PAUSE
// 9031 
// 9032 #if HAS_COLOR_LEDS
// 9033 
// 9034   /**
// 9035    * M150: Set Status LED Color - Use R-U-B-W for R-G-B-W
// 9036    *       and Brightness       - Use P (for NEOPIXEL only)
// 9037    *
// 9038    * Always sets all 3 or 4 components. If a component is left out, set to 0.
// 9039    *                                    If brightness is left out, no value changed
// 9040    *
// 9041    * Examples:
// 9042    *
// 9043    *   M150 R255       ; Turn LED red
// 9044    *   M150 R255 U127  ; Turn LED orange (PWM only)
// 9045    *   M150            ; Turn LED off
// 9046    *   M150 R U B      ; Turn LED white
// 9047    *   M150 W          ; Turn LED white using a white LED
// 9048    *   M150 P127       ; Set LED 50% brightness
// 9049    *   M150 P          ; Set LED full brightness
// 9050    */
// 9051   inline void gcode_M150() {
// 9052     leds.set_color(MakeLEDColor(
// 9053       parser.seen('R') ? (parser.has_value() ? parser.value_byte() : 255) : 0,
// 9054       parser.seen('U') ? (parser.has_value() ? parser.value_byte() : 255) : 0,
// 9055       parser.seen('B') ? (parser.has_value() ? parser.value_byte() : 255) : 0,
// 9056       parser.seen('W') ? (parser.has_value() ? parser.value_byte() : 255) : 0,
// 9057       parser.seen('P') ? (parser.has_value() ? parser.value_byte() : 255) : pixels.getBrightness()
// 9058     ));
// 9059   }
// 9060 
// 9061 #endif // HAS_COLOR_LEDS
// 9062 
// 9063 #if DISABLED(NO_VOLUMETRICS)
// 9064 
// 9065   /**
// 9066    * M200: Set filament diameter and set E axis units to cubic units
// 9067    *
// 9068    *    T<extruder> - Optional extruder number. Current extruder if omitted.
// 9069    *    D<linear> - Diameter of the filament. Use "D0" to switch back to linear units on the E axis.
// 9070    */
// 9071   inline void gcode_M200() {
// 9072 
// 9073     if (get_target_extruder_from_command(200)) return;
// 9074 
// 9075     if (parser.seen('D')) {
// 9076       // setting any extruder filament size disables volumetric on the assumption that
// 9077       // slicers either generate in extruder values as cubic mm or as as filament feeds
// 9078       // for all extruders
// 9079       if ( (parser.volumetric_enabled = (parser.value_linear_units() != 0.0)) )
// 9080         planner.set_filament_size(target_extruder, parser.value_linear_units());
// 9081     }
// 9082     planner.calculate_volumetric_multipliers();
// 9083   }
// 9084 
// 9085 #endif // !NO_VOLUMETRICS
// 9086 
// 9087 /**
// 9088  * M201: Set max acceleration in units/s^2 for print moves (M201 X1000 Y1000)
// 9089  *
// 9090  *       With multiple extruders use T to specify which one.
// 9091  */
// 9092 inline void gcode_M201() {
// 9093 
// 9094   GET_TARGET_EXTRUDER(201);
// 9095 
// 9096   LOOP_XYZE(i) {
// 9097     if (parser.seen(axis_codes[i])) {
// 9098       const uint8_t a = i + (i == E_AXIS ? TARGET_EXTRUDER : 0);
// 9099       planner.max_acceleration_mm_per_s2[a] = parser.value_axis_units((AxisEnum)a);
// 9100     }
// 9101   }
// 9102   // steps per sq second need to be updated to agree with the units per sq second (as they are what is used in the planner)
// 9103   planner.reset_acceleration_rates();
// 9104 }
// 9105 
// 9106 #if 0 // Not used for Sprinter/grbl gen6
// 9107   inline void gcode_M202() {
// 9108     LOOP_XYZE(i) {
// 9109       if (parser.seen(axis_codes[i])) axis_travel_steps_per_sqr_second[i] = parser.value_axis_units((AxisEnum)i) * planner.axis_steps_per_mm[i];
// 9110     }
// 9111   }
// 9112 #endif
// 9113 
// 9114 
// 9115 /**
// 9116  * M203: Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in units/sec
// 9117  *
// 9118  *       With multiple extruders use T to specify which one.
// 9119  */
// 9120 inline void gcode_M203() {
// 9121 
// 9122   GET_TARGET_EXTRUDER(203);
// 9123 
// 9124   LOOP_XYZE(i)
// 9125     if (parser.seen(axis_codes[i])) {
// 9126       const uint8_t a = i + (i == E_AXIS ? TARGET_EXTRUDER : 0);
// 9127       planner.max_feedrate_mm_s[a] = parser.value_axis_units((AxisEnum)a);
// 9128     }
// 9129 }
// 9130 
// 9131 /**
// 9132  * M204: Set Accelerations in units/sec^2 (M204 P1200 R3000 T3000)
// 9133  *
// 9134  *    P = Printing moves
// 9135  *    R = Retract only (no X, Y, Z) moves
// 9136  *    T = Travel (non printing) moves
// 9137  *
// 9138  *  Also sets minimum segment time in ms (B20000) to prevent buffer under-runs and M20 minimum feedrate
// 9139  */
// 9140 inline void gcode_M204() {
// 9141   if (parser.seen('S')) {  // Kept for legacy compatibility. Should NOT BE USED for new developments.
// 9142     planner.travel_acceleration = planner.acceleration = parser.value_linear_units();
// 9143     SERIAL_ECHOLNPAIR("Setting Print and Travel Acceleration: ", planner.acceleration);
// 9144   }
// 9145   if (parser.seen('P')) {
// 9146     planner.acceleration = parser.value_linear_units();
// 9147     SERIAL_ECHOLNPAIR("Setting Print Acceleration: ", planner.acceleration);
// 9148   }
// 9149   if (parser.seen('R')) {
// 9150     planner.retract_acceleration = parser.value_linear_units();
// 9151     SERIAL_ECHOLNPAIR("Setting Retract Acceleration: ", planner.retract_acceleration);
// 9152   }
// 9153   if (parser.seen('T')) {
// 9154     planner.travel_acceleration = parser.value_linear_units();
// 9155     SERIAL_ECHOLNPAIR("Setting Travel Acceleration: ", planner.travel_acceleration);
// 9156   }
// 9157 }
// 9158 
// 9159 /**
// 9160  * M205: Set Advanced Settings
// 9161  *
// 9162  *    S = Min Feed Rate (units/s)
// 9163  *    T = Min Travel Feed Rate (units/s)
// 9164  *    B = Min Segment Time (Âµs)
// 9165  *    X = Max X Jerk (units/sec^2)
// 9166  *    Y = Max Y Jerk (units/sec^2)
// 9167  *    Z = Max Z Jerk (units/sec^2)
// 9168  *    E = Max E Jerk (units/sec^2)
// 9169  */
// 9170 inline void gcode_M205() {
// 9171   if (parser.seen('S')) planner.min_feedrate_mm_s = parser.value_linear_units();
// 9172   if (parser.seen('T')) planner.min_travel_feedrate_mm_s = parser.value_linear_units();
// 9173   if (parser.seen('B')) planner.min_segment_time_us = parser.value_ulong();
// 9174   if (parser.seen('X')) planner.max_jerk[X_AXIS] = parser.value_linear_units();
// 9175   if (parser.seen('Y')) planner.max_jerk[Y_AXIS] = parser.value_linear_units();
// 9176   if (parser.seen('Z')) planner.max_jerk[Z_AXIS] = parser.value_linear_units();
// 9177   if (parser.seen('E')) planner.max_jerk[E_AXIS] = parser.value_linear_units();
// 9178 }
// 9179 
// 9180 #if HAS_M206_COMMAND
// 9181 
// 9182   /**
// 9183    * M206: Set Additional Homing Offset (X Y Z). SCARA aliases T=X, P=Y
// 9184    *
// 9185    * *** @thinkyhead: I recommend deprecating M206 for SCARA in favor of M665.
// 9186    * ***              M206 for SCARA will remain enabled in 1.1.x for compatibility.
// 9187    * ***              In the next 1.2 release, it will simply be disabled by default.
// 9188    */
// 9189   inline void gcode_M206() {
// 9190     LOOP_XYZ(i)
// 9191       if (parser.seen(axis_codes[i]))
// 9192         set_home_offset((AxisEnum)i, parser.value_linear_units());
// 9193 
// 9194     #if ENABLED(MORGAN_SCARA)
// 9195       if (parser.seen('T')) set_home_offset(A_AXIS, parser.value_float()); // Theta
// 9196       if (parser.seen('P')) set_home_offset(B_AXIS, parser.value_float()); // Psi
// 9197     #endif
// 9198 
// 9199     report_current_position();
// 9200   }
// 9201 
// 9202 #endif // HAS_M206_COMMAND
// 9203 
// 9204 #if ENABLED(DELTA)
// 9205   /**
// 9206    * M665: Set delta configurations
// 9207    *
// 9208    *    H = delta height
// 9209    *    L = diagonal rod
// 9210    *    R = delta radius
// 9211    *    S = segments per second
// 9212    *    B = delta calibration radius
// 9213    *    X = Alpha (Tower 1) angle trim
// 9214    *    Y = Beta (Tower 2) angle trim
// 9215    *    Z = Rotate A and B by this angle
// 9216    */
// 9217   inline void gcode_M665() {
// 9218     if (parser.seen('H')) delta_height                   = parser.value_linear_units();
// 9219     if (parser.seen('L')) delta_diagonal_rod             = parser.value_linear_units();
// 9220     if (parser.seen('R')) delta_radius                   = parser.value_linear_units();
// 9221     if (parser.seen('S')) delta_segments_per_second      = parser.value_float();
// 9222     if (parser.seen('B')) delta_calibration_radius       = parser.value_float();
// 9223     if (parser.seen('X')) delta_tower_angle_trim[A_AXIS] = parser.value_float();
// 9224     if (parser.seen('Y')) delta_tower_angle_trim[B_AXIS] = parser.value_float();
// 9225     if (parser.seen('Z')) delta_tower_angle_trim[C_AXIS] = parser.value_float();
// 9226     recalc_delta_settings();
// 9227   }
// 9228   /**
// 9229    * M666: Set delta endstop adjustment
// 9230    */
// 9231   inline void gcode_M666() {
// 9232     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 9233       if (DEBUGGING(LEVELING)) {
// 9234         SERIAL_ECHOLNPGM(">>> gcode_M666");
// 9235       }
// 9236     #endif
// 9237     LOOP_XYZ(i) {
// 9238       if (parser.seen(axis_codes[i])) {
// 9239         if (parser.value_linear_units() * Z_HOME_DIR <= 0)
// 9240           delta_endstop_adj[i] = parser.value_linear_units();
// 9241         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 9242           if (DEBUGGING(LEVELING)) {
// 9243             SERIAL_ECHOPAIR("delta_endstop_adj[", axis_codes[i]);
// 9244             SERIAL_ECHOLNPAIR("] = ", delta_endstop_adj[i]);
// 9245           }
// 9246         #endif
// 9247       }
// 9248     }
// 9249     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 9250       if (DEBUGGING(LEVELING)) {
// 9251         SERIAL_ECHOLNPGM("<<< gcode_M666");
// 9252       }
// 9253     #endif
// 9254   }
// 9255 
// 9256 #elif IS_SCARA
// 9257 
// 9258   /**
// 9259    * M665: Set SCARA settings
// 9260    *
// 9261    * Parameters:
// 9262    *
// 9263    *   S[segments-per-second] - Segments-per-second
// 9264    *   P[theta-psi-offset]    - Theta-Psi offset, added to the shoulder (A/X) angle
// 9265    *   T[theta-offset]        - Theta     offset, added to the elbow    (B/Y) angle
// 9266    *
// 9267    *   A, P, and X are all aliases for the shoulder angle
// 9268    *   B, T, and Y are all aliases for the elbow angle
// 9269    */
// 9270   inline void gcode_M665() {
// 9271     if (parser.seen('S')) delta_segments_per_second = parser.value_float();
// 9272 
// 9273     const bool hasA = parser.seen('A'), hasP = parser.seen('P'), hasX = parser.seen('X');
// 9274     const uint8_t sumAPX = hasA + hasP + hasX;
// 9275     if (sumAPX == 1)
// 9276       home_offset[A_AXIS] = parser.value_float();
// 9277     else if (sumAPX > 1) {
// 9278       SERIAL_ERROR_START();
// 9279       SERIAL_ERRORLNPGM("Only one of A, P, or X is allowed.");
// 9280       return;
// 9281     }
// 9282 
// 9283     const bool hasB = parser.seen('B'), hasT = parser.seen('T'), hasY = parser.seen('Y');
// 9284     const uint8_t sumBTY = hasB + hasT + hasY;
// 9285     if (sumBTY == 1)
// 9286       home_offset[B_AXIS] = parser.value_float();
// 9287     else if (sumBTY > 1) {
// 9288       SERIAL_ERROR_START();
// 9289       SERIAL_ERRORLNPGM("Only one of B, T, or Y is allowed.");
// 9290       return;
// 9291     }
// 9292   }
// 9293 
// 9294 
// 9295 
// 9296 #elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
// 9297 
// 9298   /**
// 9299    * M666: For Z Dual Endstop setup, set z axis offset to the z2 axis.
// 9300    */
// 9301   inline void gcode_M666() {
// 9302     SERIAL_ECHOPGM("Dual Endstop Adjustment (mm): ");
// 9303     #if ENABLED(X_DUAL_ENDSTOPS)
// 9304       if (parser.seen('X')) x_endstop_adj = parser.value_linear_units();
// 9305       SERIAL_ECHOPAIR(" X", x_endstop_adj);
// 9306     #endif
// 9307     #if ENABLED(Y_DUAL_ENDSTOPS)
// 9308       if (parser.seen('Y')) y_endstop_adj = parser.value_linear_units();
// 9309       SERIAL_ECHOPAIR(" Y", y_endstop_adj);
// 9310     #endif
// 9311     #if ENABLED(Z_DUAL_ENDSTOPS)
// 9312       if (parser.seen('Z')) z_endstop_adj = parser.value_linear_units();
// 9313       SERIAL_ECHOPAIR(" Z", z_endstop_adj);
// 9314     #endif
// 9315     SERIAL_EOL();
// 9316   }
// 9317 
// 9318 #endif // !DELTA && Z_DUAL_ENDSTOPS
// 9319 
// 9320 #if ENABLED(FWRETRACT)
// 9321 
// 9322   /**
// 9323    * M207: Set firmware retraction values
// 9324    *
// 9325    *   S[+units]    retract_length
// 9326    *   W[+units]    swap_retract_length (multi-extruder)
// 9327    *   F[units/min] retract_feedrate_mm_s
// 9328    *   Z[units]     retract_zlift
// 9329    */
// 9330   inline void gcode_M207() {
// 9331     if (parser.seen('S')) retract_length = parser.value_axis_units(E_AXIS);
// 9332     if (parser.seen('F')) retract_feedrate_mm_s = MMM_TO_MMS(parser.value_axis_units(E_AXIS));
// 9333     if (parser.seen('Z')) retract_zlift = parser.value_linear_units();
// 9334     if (parser.seen('W')) swap_retract_length = parser.value_axis_units(E_AXIS);
// 9335   }
// 9336 
// 9337   /**
// 9338    * M208: Set firmware un-retraction values
// 9339    *
// 9340    *   S[+units]    retract_recover_length (in addition to M207 S*)
// 9341    *   W[+units]    swap_retract_recover_length (multi-extruder)
// 9342    *   F[units/min] retract_recover_feedrate_mm_s
// 9343    *   R[units/min] swap_retract_recover_feedrate_mm_s
// 9344    */
// 9345   inline void gcode_M208() {
// 9346     if (parser.seen('S')) retract_recover_length = parser.value_axis_units(E_AXIS);
// 9347     if (parser.seen('F')) retract_recover_feedrate_mm_s = MMM_TO_MMS(parser.value_axis_units(E_AXIS));
// 9348     if (parser.seen('R')) swap_retract_recover_feedrate_mm_s = MMM_TO_MMS(parser.value_axis_units(E_AXIS));
// 9349     if (parser.seen('W')) swap_retract_recover_length = parser.value_axis_units(E_AXIS);
// 9350   }
// 9351 
// 9352   /**
// 9353    * M209: Enable automatic retract (M209 S1)
// 9354    *   For slicers that don't support G10/11, reversed extrude-only
// 9355    *   moves will be classified as retraction.
// 9356    */
// 9357   inline void gcode_M209() {
// 9358     if (MIN_AUTORETRACT <= MAX_AUTORETRACT) {
// 9359       if (parser.seen('S')) {
// 9360         autoretract_enabled = parser.value_bool();
// 9361         for (uint8_t i = 0; i < EXTRUDERS; i++) retracted[i] = false;
// 9362       }
// 9363     }
// 9364   }
// 9365 
// 9366 #endif // FWRETRACT
// 9367 
// 9368 /**
// 9369  * M211: Enable, Disable, and/or Report software endstops
// 9370  *
// 9371  * Usage: M211 S1 to enable, M211 S0 to disable, M211 alone for report
// 9372  */
// 9373 inline void gcode_M211() {
// 9374   SERIAL_ECHO_START();
// 9375   #if HAS_SOFTWARE_ENDSTOPS
// 9376     if (parser.seen('S')) soft_endstops_enabled = parser.value_bool();
// 9377     SERIAL_ECHOPGM(MSG_SOFT_ENDSTOPS);
// 9378     serialprintPGM(soft_endstops_enabled ? PSTR(MSG_ON) : PSTR(MSG_OFF));
// 9379   #else
// 9380     SERIAL_ECHOPGM(MSG_SOFT_ENDSTOPS);
// 9381     SERIAL_ECHOPGM(MSG_OFF);
// 9382   #endif
// 9383   SERIAL_ECHOPGM(MSG_SOFT_MIN);
// 9384   SERIAL_ECHOPAIR(    MSG_X, LOGICAL_X_POSITION(soft_endstop_min[X_AXIS]));
// 9385   SERIAL_ECHOPAIR(" " MSG_Y, LOGICAL_Y_POSITION(soft_endstop_min[Y_AXIS]));
// 9386   SERIAL_ECHOPAIR(" " MSG_Z, LOGICAL_Z_POSITION(soft_endstop_min[Z_AXIS]));
// 9387   SERIAL_ECHOPGM(MSG_SOFT_MAX);
// 9388   SERIAL_ECHOPAIR(    MSG_X, LOGICAL_X_POSITION(soft_endstop_max[X_AXIS]));
// 9389   SERIAL_ECHOPAIR(" " MSG_Y, LOGICAL_Y_POSITION(soft_endstop_max[Y_AXIS]));
// 9390   SERIAL_ECHOLNPAIR(" " MSG_Z, LOGICAL_Z_POSITION(soft_endstop_max[Z_AXIS]));
// 9391 }
// 9392 
// 9393 #if HOTENDS > 1
// 9394 
// 9395   /**
// 9396    * M218 - set hotend offset (in linear units)
// 9397    *
// 9398    *   T<tool>
// 9399    *   X<xoffset>
// 9400    *   Y<yoffset>
// 9401    *   Z<zoffset> - Available with DUAL_X_CARRIAGE and SWITCHING_NOZZLE
// 9402    */
// 9403   inline void gcode_M218() {
// 9404     if (get_target_extruder_from_command(218) || target_extruder == 0) return;
// 9405 
// 9406     if (parser.seenval('X')) hotend_offset[X_AXIS][target_extruder] = parser.value_linear_units();
// 9407     if (parser.seenval('Y')) hotend_offset[Y_AXIS][target_extruder] = parser.value_linear_units();
// 9408 
// 9409     #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER)
// 9410       if (parser.seenval('Z')) hotend_offset[Z_AXIS][target_extruder] = parser.value_linear_units();
// 9411     #endif
// 9412 
// 9413     SERIAL_ECHO_START();
// 9414     SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);
// 9415     HOTEND_LOOP() {
// 9416       SERIAL_CHAR(' ');
// 9417       SERIAL_ECHO(hotend_offset[X_AXIS][e]);
// 9418       SERIAL_CHAR(',');
// 9419       SERIAL_ECHO(hotend_offset[Y_AXIS][e]);
// 9420       #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER)
// 9421         SERIAL_CHAR(',');
// 9422         SERIAL_ECHO(hotend_offset[Z_AXIS][e]);
// 9423       #endif
// 9424     }
// 9425     SERIAL_EOL();
// 9426   }
// 9427 
// 9428 #endif // HOTENDS > 1
// 9429 
// 9430 /**
// 9431  * M220: Set speed percentage factor, aka "Feed Rate" (M220 S95)
// 9432  */
// 9433 inline void gcode_M220() {
// 9434   if (parser.seenval('S')) feedrate_percentage = parser.value_int();
// 9435 }
// 9436 
// 9437 /**
// 9438  * M221: Set extrusion percentage (M221 T0 S95)
// 9439  */
// 9440 inline void gcode_M221() {
// 9441   if (get_target_extruder_from_command(221)) return;
// 9442   if (parser.seenval('S')) {
// 9443     planner.flow_percentage[target_extruder] = parser.value_int();
// 9444     planner.refresh_e_factor(target_extruder);
// 9445   }
// 9446 }
// 9447 
// 9448 /**
// 9449  * M226: Wait until the specified pin reaches the state required (M226 P<pin> S<state>)
// 9450  */
// 9451 inline void gcode_M226() {
// 9452   if (parser.seen('P')) {
// 9453     const int pin_number = parser.value_int(),
// 9454               pin_state = parser.intval('S', -1); // required pin state - default is inverted
// 9455 
// 9456     if (WITHIN(pin_state, -1, 1) && pin_number > -1 && !pin_is_protected(pin_number)) {
// 9457 
// 9458       int target = LOW;
// 9459 
// 9460       stepper.synchronize();
// 9461 
// 9462       pinMode(pin_number, INPUT);
// 9463       switch (pin_state) {
// 9464         case 1:
// 9465           target = HIGH;
// 9466           break;
// 9467         case 0:
// 9468           target = LOW;
// 9469           break;
// 9470         case -1:
// 9471           target = !digitalRead(pin_number);
// 9472           break;
// 9473       }
// 9474 
// 9475       while (digitalRead(pin_number) != target) idle();
// 9476 
// 9477     } // pin_state -1 0 1 && pin_number > -1
// 9478   } // parser.seen('P')
// 9479 }
// 9480 
// 9481 #if ENABLED(EXPERIMENTAL_I2CBUS)
// 9482 
// 9483   /**
// 9484    * M260: Send data to a I2C slave device
// 9485    *
// 9486    * This is a PoC, the formating and arguments for the GCODE will
// 9487    * change to be more compatible, the current proposal is:
// 9488    *
// 9489    *  M260 A<slave device address base 10> ; Sets the I2C slave address the data will be sent to
// 9490    *
// 9491    *  M260 B<byte-1 value in base 10>
// 9492    *  M260 B<byte-2 value in base 10>
// 9493    *  M260 B<byte-3 value in base 10>
// 9494    *
// 9495    *  M260 S1 ; Send the buffered data and reset the buffer
// 9496    *  M260 R1 ; Reset the buffer without sending data
// 9497    *
// 9498    */
// 9499   inline void gcode_M260() {
// 9500     // Set the target address
// 9501     if (parser.seen('A')) i2c.address(parser.value_byte());
// 9502 
// 9503     // Add a new byte to the buffer
// 9504     if (parser.seen('B')) i2c.addbyte(parser.value_byte());
// 9505 
// 9506     // Flush the buffer to the bus
// 9507     if (parser.seen('S')) i2c.send();
// 9508 
// 9509     // Reset and rewind the buffer
// 9510     else if (parser.seen('R')) i2c.reset();
// 9511   }
// 9512 
// 9513   /**
// 9514    * M261: Request X bytes from I2C slave device
// 9515    *
// 9516    * Usage: M261 A<slave device address base 10> B<number of bytes>
// 9517    */
// 9518   inline void gcode_M261() {
// 9519     if (parser.seen('A')) i2c.address(parser.value_byte());
// 9520 
// 9521     uint8_t bytes = parser.byteval('B', 1);
// 9522 
// 9523     if (i2c.addr && bytes && bytes <= TWIBUS_BUFFER_SIZE) {
// 9524       i2c.relay(bytes);
// 9525     }
// 9526     else {
// 9527       SERIAL_ERROR_START();
// 9528       SERIAL_ERRORLN("Bad i2c request");
// 9529     }
// 9530   }
// 9531 
// 9532 #endif // EXPERIMENTAL_I2CBUS
// 9533 
// 9534 #if HAS_SERVOS
// 9535 
// 9536   /**
// 9537    * M280: Get or set servo position. P<index> [S<angle>]
// 9538    */
// 9539   inline void gcode_M280() {
// 9540     if (!parser.seen('P')) return;
// 9541     const int servo_index = parser.value_int();
// 9542     if (WITHIN(servo_index, 0, NUM_SERVOS - 1)) {
// 9543       if (parser.seen('S'))
// 9544         MOVE_SERVO(servo_index, parser.value_int());
// 9545       else {
// 9546         SERIAL_ECHO_START();
// 9547         SERIAL_ECHOPAIR(" Servo ", servo_index);
// 9548         SERIAL_ECHOLNPAIR(": ", servo[servo_index].read());
// 9549       }
// 9550     }
// 9551     else {
// 9552       SERIAL_ERROR_START();
// 9553       SERIAL_ECHOPAIR("Servo ", servo_index);
// 9554       SERIAL_ECHOLNPGM(" out of range");
// 9555     }
// 9556   }
// 9557 
// 9558 #endif // HAS_SERVOS
// 9559 
// 9560 #if ENABLED(BABYSTEPPING)
// 9561 
// 9562   #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
// 9563     FORCE_INLINE void mod_zprobe_zoffset(const float &offs) {
// 9564       zprobe_zoffset += offs;
// 9565       SERIAL_ECHO_START();
// 9566       SERIAL_ECHOLNPAIR(MSG_PROBE_Z_OFFSET ": ", zprobe_zoffset);
// 9567     }
// 9568   #endif
// 9569 
// 9570   /**
// 9571    * M290: Babystepping
// 9572    */
// 9573   inline void gcode_M290() {
// 9574     #if ENABLED(BABYSTEP_XY)
// 9575       for (uint8_t a = X_AXIS; a <= Z_AXIS; a++)
// 9576         if (parser.seenval(axis_codes[a]) || (a == Z_AXIS && parser.seenval('S'))) {
// 9577           const float offs = constrain(parser.value_axis_units((AxisEnum)a), -2, 2);
// 9578           thermalManager.babystep_axis((AxisEnum)a, offs * planner.axis_steps_per_mm[a]);
// 9579           #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
// 9580             if (a == Z_AXIS && (!parser.seen('P') || parser.value_bool())) mod_zprobe_zoffset(offs);
// 9581           #endif
// 9582         }
// 9583     #else
// 9584       if (parser.seenval('Z') || parser.seenval('S')) {
// 9585         const float offs = constrain(parser.value_axis_units(Z_AXIS), -2, 2);
// 9586         thermalManager.babystep_axis(Z_AXIS, offs * planner.axis_steps_per_mm[Z_AXIS]);
// 9587         #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
// 9588           if (!parser.seen('P') || parser.value_bool()) mod_zprobe_zoffset(offs);
// 9589         #endif
// 9590       }
// 9591     #endif
// 9592   }
// 9593 
// 9594 #endif // BABYSTEPPING
// 9595 
// 9596 #if HAS_BUZZER
// 9597 
// 9598   /**
// 9599    * M300: Play beep sound S<frequency Hz> P<duration ms>
// 9600    */
// 9601   inline void gcode_M300() {
// 9602     uint16_t const frequency = parser.ushortval('S', 260);
// 9603     uint16_t duration = parser.ushortval('P', 1000);
// 9604 
// 9605     // Limits the tone duration to 0-5 seconds.
// 9606     NOMORE(duration, 5000);
// 9607 
// 9608     BUZZ(duration, frequency);
// 9609   }
// 9610 
// 9611 #endif // HAS_BUZZER
// 9612 
// 9613 #if ENABLED(PIDTEMP)
// 9614 
// 9615   /**
// 9616    * M301: Set PID parameters P I D (and optionally C, L)
// 9617    *
// 9618    *   P[float] Kp term
// 9619    *   I[float] Ki term (unscaled)
// 9620    *   D[float] Kd term (unscaled)
// 9621    *
// 9622    * With PID_EXTRUSION_SCALING:
// 9623    *
// 9624    *   C[float] Kc term
// 9625    *   L[float] LPQ length
// 9626    */
// 9627   inline void gcode_M301() {
// 9628 
// 9629     // multi-extruder PID patch: M301 updates or prints a single extruder's PID values
// 9630     // default behaviour (omitting E parameter) is to update for extruder 0 only
// 9631     const uint8_t e = parser.byteval('E'); // extruder being updated
// 9632 
// 9633     if (e < HOTENDS) { // catch bad input value
// 9634       if (parser.seen('P')) PID_PARAM(Kp, e) = parser.value_float();
// 9635       if (parser.seen('I')) PID_PARAM(Ki, e) = scalePID_i(parser.value_float());
// 9636       if (parser.seen('D')) PID_PARAM(Kd, e) = scalePID_d(parser.value_float());
// 9637       #if ENABLED(PID_EXTRUSION_SCALING)
// 9638         if (parser.seen('C')) PID_PARAM(Kc, e) = parser.value_float();
// 9639         if (parser.seen('L')) lpq_len = parser.value_float();
// 9640         NOMORE(lpq_len, LPQ_MAX_LEN);
// 9641       #endif
// 9642 
// 9643       thermalManager.updatePID();
// 9644       SERIAL_ECHO_START();
// 9645       #if ENABLED(PID_PARAMS_PER_HOTEND)
// 9646         SERIAL_ECHOPAIR(" e:", e); // specify extruder in serial output
// 9647       #endif // PID_PARAMS_PER_HOTEND
// 9648       SERIAL_ECHOPAIR(" p:", PID_PARAM(Kp, e));
// 9649       SERIAL_ECHOPAIR(" i:", unscalePID_i(PID_PARAM(Ki, e)));
// 9650       SERIAL_ECHOPAIR(" d:", unscalePID_d(PID_PARAM(Kd, e)));
// 9651       #if ENABLED(PID_EXTRUSION_SCALING)
// 9652         //Kc does not have scaling applied above, or in resetting defaults
// 9653         SERIAL_ECHOPAIR(" c:", PID_PARAM(Kc, e));
// 9654       #endif
// 9655       SERIAL_EOL();
// 9656     }
// 9657     else {
// 9658       SERIAL_ERROR_START();
// 9659       SERIAL_ERRORLN(MSG_INVALID_EXTRUDER);
// 9660     }
// 9661   }
// 9662 
// 9663 #endif // PIDTEMP
// 9664 
// 9665 #if ENABLED(PIDTEMPBED)
// 9666 
// 9667   inline void gcode_M304() {
// 9668     if (parser.seen('P')) thermalManager.bedKp = parser.value_float();
// 9669     if (parser.seen('I')) thermalManager.bedKi = scalePID_i(parser.value_float());
// 9670     if (parser.seen('D')) thermalManager.bedKd = scalePID_d(parser.value_float());
// 9671 
// 9672     SERIAL_ECHO_START();
// 9673     SERIAL_ECHOPAIR(" p:", thermalManager.bedKp);
// 9674     SERIAL_ECHOPAIR(" i:", unscalePID_i(thermalManager.bedKi));
// 9675     SERIAL_ECHOLNPAIR(" d:", unscalePID_d(thermalManager.bedKd));
// 9676   }
// 9677 
// 9678 #endif // PIDTEMPBED
// 9679 
// 9680 #if defined(CHDK) || HAS_PHOTOGRAPH
// 9681 
// 9682   /**
// 9683    * M240: Trigger a camera by emulating a Canon RC-1
// 9684    *       See http://www.doc-diy.net/photo/rc-1_hacked/
// 9685    */
// 9686   inline void gcode_M240() {
// 9687     #ifdef CHDK
// 9688 
// 9689       OUT_WRITE(CHDK, HIGH);
// 9690       chdkHigh = millis();
// 9691       chdkActive = true;
// 9692 
// 9693     #elif HAS_PHOTOGRAPH
// 9694 
// 9695       const uint8_t NUM_PULSES = 16;
// 9696       const float PULSE_LENGTH = 0.01524;
// 9697       for (int i = 0; i < NUM_PULSES; i++) {
// 9698         WRITE(PHOTOGRAPH_PIN, HIGH);
// 9699         _delay_ms(PULSE_LENGTH);
// 9700         WRITE(PHOTOGRAPH_PIN, LOW);
// 9701         _delay_ms(PULSE_LENGTH);
// 9702       }
// 9703       delay(7.33);
// 9704       for (int i = 0; i < NUM_PULSES; i++) {
// 9705         WRITE(PHOTOGRAPH_PIN, HIGH);
// 9706         _delay_ms(PULSE_LENGTH);
// 9707         WRITE(PHOTOGRAPH_PIN, LOW);
// 9708         _delay_ms(PULSE_LENGTH);
// 9709       }
// 9710 
// 9711     #endif // !CHDK && HAS_PHOTOGRAPH
// 9712   }
// 9713 
// 9714 #endif // CHDK || PHOTOGRAPH_PIN
// 9715 
// 9716 #if HAS_LCD_CONTRAST
// 9717 
// 9718   /**
// 9719    * M250: Read and optionally set the LCD contrast
// 9720    */
// 9721   inline void gcode_M250() {
// 9722     if (parser.seen('C')) set_lcd_contrast(parser.value_int());
// 9723     SERIAL_PROTOCOLPGM("lcd contrast value: ");
// 9724     SERIAL_PROTOCOL(lcd_contrast);
// 9725     SERIAL_EOL();
// 9726   }
// 9727 
// 9728 #endif // HAS_LCD_CONTRAST
// 9729 
// 9730 #if ENABLED(PREVENT_COLD_EXTRUSION)
// 9731 
// 9732   /**
// 9733    * M302: Allow cold extrudes, or set the minimum extrude temperature
// 9734    *
// 9735    *       S<temperature> sets the minimum extrude temperature
// 9736    *       P<bool> enables (1) or disables (0) cold extrusion
// 9737    *
// 9738    *  Examples:
// 9739    *
// 9740    *       M302         ; report current cold extrusion state
// 9741    *       M302 P0      ; enable cold extrusion checking
// 9742    *       M302 P1      ; disables cold extrusion checking
// 9743    *       M302 S0      ; always allow extrusion (disables checking)
// 9744    *       M302 S170    ; only allow extrusion above 170
// 9745    *       M302 S170 P1 ; set min extrude temp to 170 but leave disabled
// 9746    */
// 9747   inline void gcode_M302() {
// 9748     const bool seen_S = parser.seen('S');
// 9749     if (seen_S) {
// 9750       thermalManager.extrude_min_temp = parser.value_celsius();
// 9751       thermalManager.allow_cold_extrude = (thermalManager.extrude_min_temp == 0);
// 9752     }
// 9753 
// 9754     if (parser.seen('P'))
// 9755       thermalManager.allow_cold_extrude = (thermalManager.extrude_min_temp == 0) || parser.value_bool();
// 9756     else if (!seen_S) {
// 9757       // Report current state
// 9758       SERIAL_ECHO_START();
// 9759       SERIAL_ECHOPAIR("Cold extrudes are ", (thermalManager.allow_cold_extrude ? "en" : "dis"));
// 9760       SERIAL_ECHOPAIR("abled (min temp ", thermalManager.extrude_min_temp);
// 9761       SERIAL_ECHOLNPGM("C)");
// 9762     }
// 9763   }
// 9764 
// 9765 #endif // PREVENT_COLD_EXTRUSION
// 9766 
// 9767 /**
// 9768  * M303: PID relay autotune
// 9769  *
// 9770  *       S<temperature> sets the target temperature. (default 150C)
// 9771  *       E<extruder> (-1 for the bed) (default 0)
// 9772  *       C<cycles>
// 9773  *       U<bool> with a non-zero value will apply the result to current settings
// 9774  */
// 9775 inline void gcode_M303() {
// 9776   #if HAS_PID_HEATING
// 9777     const int e = parser.intval('E'), c = parser.intval('C', 5);
// 9778     const bool u = parser.boolval('U');
// 9779 
// 9780     int16_t temp = parser.celsiusval('S', e < 0 ? 70 : 150);
// 9781 
// 9782     if (WITHIN(e, 0, HOTENDS - 1))
// 9783       target_extruder = e;
// 9784 
// 9785     #if DISABLED(BUSY_WHILE_HEATING)
// 9786       KEEPALIVE_STATE(NOT_BUSY);
// 9787     #endif
// 9788 
// 9789     thermalManager.PID_autotune(temp, e, c, u);
// 9790 
// 9791     #if DISABLED(BUSY_WHILE_HEATING)
// 9792       KEEPALIVE_STATE(IN_HANDLER);
// 9793     #endif
// 9794   #else
// 9795     SERIAL_ERROR_START();
// 9796     SERIAL_ERRORLNPGM(MSG_ERR_M303_DISABLED);
// 9797   #endif
// 9798 }
// 9799 
// 9800 #if ENABLED(MORGAN_SCARA)
// 9801 
// 9802   bool SCARA_move_to_cal(const uint8_t delta_a, const uint8_t delta_b) {
// 9803     if (IsRunning()) {
// 9804       forward_kinematics_SCARA(delta_a, delta_b);
// 9805       destination[X_AXIS] = cartes[X_AXIS];
// 9806       destination[Y_AXIS] = cartes[Y_AXIS];
// 9807       destination[Z_AXIS] = current_position[Z_AXIS];
// 9808       prepare_move_to_destination();
// 9809       return true;
// 9810     }
// 9811     return false;
// 9812   }
// 9813 
// 9814   /**
// 9815    * M360: SCARA calibration: Move to cal-position ThetaA (0 deg calibration)
// 9816    */
// 9817   inline bool gcode_M360() {
// 9818     SERIAL_ECHOLNPGM(" Cal: Theta 0");
// 9819     return SCARA_move_to_cal(0, 120);
// 9820   }
// 9821 
// 9822   /**
// 9823    * M361: SCARA calibration: Move to cal-position ThetaB (90 deg calibration - steps per degree)
// 9824    */
// 9825   inline bool gcode_M361() {
// 9826     SERIAL_ECHOLNPGM(" Cal: Theta 90");
// 9827     return SCARA_move_to_cal(90, 130);
// 9828   }
// 9829 
// 9830   /**
// 9831    * M362: SCARA calibration: Move to cal-position PsiA (0 deg calibration)
// 9832    */
// 9833   inline bool gcode_M362() {
// 9834     SERIAL_ECHOLNPGM(" Cal: Psi 0");
// 9835     return SCARA_move_to_cal(60, 180);
// 9836   }
// 9837 
// 9838   /**
// 9839    * M363: SCARA calibration: Move to cal-position PsiB (90 deg calibration - steps per degree)
// 9840    */
// 9841   inline bool gcode_M363() {
// 9842     SERIAL_ECHOLNPGM(" Cal: Psi 90");
// 9843     return SCARA_move_to_cal(50, 90);
// 9844   }
// 9845 
// 9846   /**
// 9847    * M364: SCARA calibration: Move to cal-position PsiC (90 deg to Theta calibration position)
// 9848    */
// 9849   inline bool gcode_M364() {
// 9850     SERIAL_ECHOLNPGM(" Cal: Theta-Psi 90");
// 9851     return SCARA_move_to_cal(45, 135);
// 9852   }
// 9853 
// 9854 #endif // SCARA
// 9855 
// 9856 #if ENABLED(EXT_SOLENOID)
// 9857 
// 9858   void enable_solenoid(const uint8_t num) {
// 9859     switch (num) {
// 9860       case 0:
// 9861         OUT_WRITE(SOL0_PIN, HIGH);
// 9862         break;
// 9863         #if HAS_SOLENOID_1 && EXTRUDERS > 1
// 9864           case 1:
// 9865             OUT_WRITE(SOL1_PIN, HIGH);
// 9866             break;
// 9867         #endif
// 9868         #if HAS_SOLENOID_2 && EXTRUDERS > 2
// 9869           case 2:
// 9870             OUT_WRITE(SOL2_PIN, HIGH);
// 9871             break;
// 9872         #endif
// 9873         #if HAS_SOLENOID_3 && EXTRUDERS > 3
// 9874           case 3:
// 9875             OUT_WRITE(SOL3_PIN, HIGH);
// 9876             break;
// 9877         #endif
// 9878         #if HAS_SOLENOID_4 && EXTRUDERS > 4
// 9879           case 4:
// 9880             OUT_WRITE(SOL4_PIN, HIGH);
// 9881             break;
// 9882         #endif
// 9883       default:
// 9884         SERIAL_ECHO_START();
// 9885         SERIAL_ECHOLNPGM(MSG_INVALID_SOLENOID);
// 9886         break;
// 9887     }
// 9888   }
// 9889 
// 9890   void enable_solenoid_on_active_extruder() { enable_solenoid(active_extruder); }
// 9891 
// 9892   void disable_all_solenoids() {
// 9893     OUT_WRITE(SOL0_PIN, LOW);
// 9894     #if HAS_SOLENOID_1 && EXTRUDERS > 1
// 9895       OUT_WRITE(SOL1_PIN, LOW);
// 9896     #endif
// 9897     #if HAS_SOLENOID_2 && EXTRUDERS > 2
// 9898       OUT_WRITE(SOL2_PIN, LOW);
// 9899     #endif
// 9900     #if HAS_SOLENOID_3 && EXTRUDERS > 3
// 9901       OUT_WRITE(SOL3_PIN, LOW);
// 9902     #endif
// 9903     #if HAS_SOLENOID_4 && EXTRUDERS > 4
// 9904       OUT_WRITE(SOL4_PIN, LOW);
// 9905     #endif
// 9906   }
// 9907 
// 9908   /**
// 9909    * M380: Enable solenoid on the active extruder
// 9910    */
// 9911   inline void gcode_M380() { enable_solenoid_on_active_extruder(); }
// 9912 
// 9913   /**
// 9914    * M381: Disable all solenoids
// 9915    */
// 9916   inline void gcode_M381() { disable_all_solenoids(); }
// 9917 
// 9918 #endif // EXT_SOLENOID
// 9919 
// 9920 /**
// 9921  * M400: Finish all moves
// 9922  */
// 9923 inline void gcode_M400() { stepper.synchronize(); }
// 9924 
// 9925 #if HAS_BED_PROBE
// 9926 
// 9927   /**
// 9928    * M401: Engage Z Servo endstop if available
// 9929    */
// 9930   inline void gcode_M401() { DEPLOY_PROBE(); }
// 9931 
// 9932   /**
// 9933    * M402: Retract Z Servo endstop if enabled
// 9934    */
// 9935   inline void gcode_M402() { STOW_PROBE(); }
// 9936 
// 9937 #endif // HAS_BED_PROBE
// 9938 
// 9939 #if ENABLED(FILAMENT_WIDTH_SENSOR)
// 9940 
// 9941   /**
// 9942    * M404: Display or set (in current units) the nominal filament width (3mm, 1.75mm ) W<3.0>
// 9943    */
// 9944   inline void gcode_M404() {
// 9945     if (parser.seen('W')) {
// 9946       filament_width_nominal = parser.value_linear_units();
// 9947       planner.volumetric_area_nominal = CIRCLE_AREA(filament_width_nominal * 0.5);
// 9948     }
// 9949     else {
// 9950       SERIAL_PROTOCOLPGM("Filament dia (nominal mm):");
// 9951       SERIAL_PROTOCOLLN(filament_width_nominal);
// 9952     }
// 9953   }
// 9954 
// 9955   /**
// 9956    * M405: Turn on filament sensor for control
// 9957    */
// 9958   inline void gcode_M405() {
// 9959     // This is technically a linear measurement, but since it's quantized to centimeters and is a different
// 9960     // unit than everything else, it uses parser.value_byte() instead of parser.value_linear_units().
// 9961     if (parser.seen('D')) {
// 9962       meas_delay_cm = parser.value_byte();
// 9963       NOMORE(meas_delay_cm, MAX_MEASUREMENT_DELAY);
// 9964     }
// 9965 
// 9966     if (filwidth_delay_index[1] == -1) { // Initialize the ring buffer if not done since startup
// 9967       const int8_t temp_ratio = thermalManager.widthFil_to_size_ratio();
// 9968 
// 9969       for (uint8_t i = 0; i < COUNT(measurement_delay); ++i)
// 9970         measurement_delay[i] = temp_ratio;
// 9971 
// 9972       filwidth_delay_index[0] = filwidth_delay_index[1] = 0;
// 9973     }
// 9974 
// 9975     filament_sensor = true;
// 9976   }
// 9977 
// 9978   /**
// 9979    * M406: Turn off filament sensor for control
// 9980    */
// 9981   inline void gcode_M406() {
// 9982     filament_sensor = false;
// 9983     planner.calculate_volumetric_multipliers();   // Restore correct 'volumetric_multiplier' value
// 9984   }
// 9985 
// 9986   /**
// 9987    * M407: Get measured filament diameter on serial output
// 9988    */
// 9989   inline void gcode_M407() {
// 9990     SERIAL_PROTOCOLPGM("Filament dia (measured mm):");
// 9991     SERIAL_PROTOCOLLN(filament_width_meas);
// 9992   }
// 9993 
// 9994 #endif // FILAMENT_WIDTH_SENSOR
// 9995 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock43 Using cfiCommon0
          CFI Function _Z17quickstop_stepperv
        THUMB
// 9996 void quickstop_stepper() {
_Z17quickstop_stepperv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 9997   stepper.quick_stop();
          CFI FunCall _ZN7Stepper10quick_stopEv
        BL       _ZN7Stepper10quick_stopEv
// 9998   stepper.synchronize();
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
// 9999   set_current_from_steppers_for_axis(ALL_AXES);
        MOVS     R0,#+100
          CFI FunCall _Z34set_current_from_steppers_for_axis8AxisEnum
        BL       _Z34set_current_from_steppers_for_axis8AxisEnum
// 10000   SYNC_PLAN_POSITION_KINEMATIC();
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z18sync_plan_positionv
        B.N      _Z18sync_plan_positionv
          CFI EndBlock cfiBlock43
// 10001 }
// 10002 
// 10003 #if HAS_LEVELING
// 10004   /**
// 10005    * M420: Enable/Disable Bed Leveling and/or set the Z fade height.
// 10006    *
// 10007    *   S[bool]   Turns leveling on or off
// 10008    *   Z[height] Sets the Z fade height (0 or none to disable)
// 10009    *   V[bool]   Verbose - Print the leveling grid
// 10010    *
// 10011    * With AUTO_BED_LEVELING_UBL only:
// 10012    *
// 10013    *   L[index]  Load UBL mesh from index (0 is default)
// 10014    */
// 10015   inline void gcode_M420() {
// 10016 
// 10017     const float oldpos[] = { current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] };
// 10018 
// 10019     #if ENABLED(AUTO_BED_LEVELING_UBL)
// 10020 
// 10021       // L to load a mesh from the EEPROM
// 10022       if (parser.seen('L')) {
// 10023 
// 10024         #if ENABLED(EEPROM_SETTINGS)
// 10025           const int8_t storage_slot = parser.has_value() ? parser.value_int() : ubl.storage_slot;
// 10026           const int16_t a = settings.calc_num_meshes();
// 10027 
// 10028           if (!a) {
// 10029             SERIAL_PROTOCOLLNPGM("?EEPROM storage not available.");
// 10030             return;
// 10031           }
// 10032 
// 10033           if (!WITHIN(storage_slot, 0, a - 1)) {
// 10034             SERIAL_PROTOCOLLNPGM("?Invalid storage slot.");
// 10035             SERIAL_PROTOCOLLNPAIR("?Use 0 to ", a - 1);
// 10036             return;
// 10037           }
// 10038 
// 10039           settings.load_mesh(storage_slot);
// 10040           ubl.storage_slot = storage_slot;
// 10041 
// 10042         #else
// 10043 
// 10044           SERIAL_PROTOCOLLNPGM("?EEPROM storage not available.");
// 10045           return;
// 10046 
// 10047         #endif
// 10048       }
// 10049 
// 10050       // L to load a mesh from the EEPROM
// 10051       if (parser.seen('L') || parser.seen('V')) {
// 10052         ubl.display_map(0);  // Currently only supports one map type
// 10053         SERIAL_ECHOLNPAIR("ubl.mesh_is_valid = ", ubl.mesh_is_valid());
// 10054         SERIAL_ECHOLNPAIR("ubl.storage_slot = ", ubl.storage_slot);
// 10055       }
// 10056 
// 10057     #endif // AUTO_BED_LEVELING_UBL
// 10058 
// 10059     // V to print the matrix or mesh
// 10060     if (parser.seen('V')) {
// 10061       #if ABL_PLANAR
// 10062         planner.bed_level_matrix.debug(PSTR("Bed Level Correction Matrix:"));
// 10063       #else
// 10064         if (leveling_is_valid()) {
// 10065           #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 10066             print_bilinear_leveling_grid();
// 10067             #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 10068               print_bilinear_leveling_grid_virt();
// 10069             #endif
// 10070           #elif ENABLED(MESH_BED_LEVELING)
// 10071             SERIAL_ECHOLNPGM("Mesh Bed Level data:");
// 10072             mbl_mesh_report();
// 10073           #endif
// 10074         }
// 10075       #endif
// 10076     }
// 10077 
// 10078     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
// 10079       if (parser.seen('Z')) set_z_fade_height(parser.value_linear_units(), false);
// 10080     #endif
// 10081 
// 10082     bool to_enable = false;
// 10083     if (parser.seen('S')) {
// 10084       to_enable = parser.value_bool();
// 10085       set_bed_leveling_enabled(to_enable);
// 10086     }
// 10087 
// 10088     const bool new_status = planner.leveling_active;
// 10089 
// 10090     if (to_enable && !new_status) {
// 10091       SERIAL_ERROR_START();
// 10092       SERIAL_ERRORLNPGM(MSG_ERR_M420_FAILED);
// 10093     }
// 10094 
// 10095     SERIAL_ECHO_START();
// 10096     SERIAL_ECHOLNPAIR("Bed Leveling ", new_status ? MSG_ON : MSG_OFF);
// 10097 
// 10098     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
// 10099       SERIAL_ECHO_START();
// 10100       SERIAL_ECHOPGM("Fade Height ");
// 10101       if (planner.z_fade_height > 0.0)
// 10102         SERIAL_ECHOLN(planner.z_fade_height);
// 10103       else
// 10104         SERIAL_ECHOLNPGM(MSG_OFF);
// 10105     #endif
// 10106 
// 10107     // Report change in position
// 10108     if (memcmp(oldpos, current_position, sizeof(oldpos)))
// 10109       report_current_position();
// 10110   }
// 10111 #endif
// 10112 
// 10113 #if ENABLED(MESH_BED_LEVELING)
// 10114 
// 10115   /**
// 10116    * M421: Set a single Mesh Bed Leveling Z coordinate
// 10117    *
// 10118    * Usage:
// 10119    *   M421 X<linear> Y<linear> Z<linear>
// 10120    *   M421 X<linear> Y<linear> Q<offset>
// 10121    *   M421 I<xindex> J<yindex> Z<linear>
// 10122    *   M421 I<xindex> J<yindex> Q<offset>
// 10123    */
// 10124   inline void gcode_M421() {
// 10125     const bool hasX = parser.seen('X'), hasI = parser.seen('I');
// 10126     const int8_t ix = hasI ? parser.value_int() : hasX ? mbl.probe_index_x(parser.value_linear_units()) : -1;
// 10127     const bool hasY = parser.seen('Y'), hasJ = parser.seen('J');
// 10128     const int8_t iy = hasJ ? parser.value_int() : hasY ? mbl.probe_index_y(parser.value_linear_units()) : -1;
// 10129     const bool hasZ = parser.seen('Z'), hasQ = !hasZ && parser.seen('Q');
// 10130 
// 10131     if (int(hasI && hasJ) + int(hasX && hasY) != 1 || !(hasZ || hasQ)) {
// 10132       SERIAL_ERROR_START();
// 10133       SERIAL_ERRORLNPGM(MSG_ERR_M421_PARAMETERS);
// 10134     }
// 10135     else if (ix < 0 || iy < 0) {
// 10136       SERIAL_ERROR_START();
// 10137       SERIAL_ERRORLNPGM(MSG_ERR_MESH_XY);
// 10138     }
// 10139     else
// 10140       mbl.set_z(ix, iy, parser.value_linear_units() + (hasQ ? mbl.z_values[ix][iy] : 0));
// 10141   }
// 10142 
// 10143 #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 10144 
// 10145   /**
// 10146    * M421: Set a single Mesh Bed Leveling Z coordinate
// 10147    *
// 10148    * Usage:
// 10149    *   M421 I<xindex> J<yindex> Z<linear>
// 10150    *   M421 I<xindex> J<yindex> Q<offset>
// 10151    */
// 10152   inline void gcode_M421() {
// 10153     int8_t ix = parser.intval('I', -1), iy = parser.intval('J', -1);
// 10154     const bool hasI = ix >= 0,
// 10155                hasJ = iy >= 0,
// 10156                hasZ = parser.seen('Z'),
// 10157                hasQ = !hasZ && parser.seen('Q');
// 10158 
// 10159     if (!hasI || !hasJ || !(hasZ || hasQ)) {
// 10160       SERIAL_ERROR_START();
// 10161       SERIAL_ERRORLNPGM(MSG_ERR_M421_PARAMETERS);
// 10162     }
// 10163     else if (!WITHIN(ix, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(iy, 0, GRID_MAX_POINTS_Y - 1)) {
// 10164       SERIAL_ERROR_START();
// 10165       SERIAL_ERRORLNPGM(MSG_ERR_MESH_XY);
// 10166     }
// 10167     else {
// 10168       z_values[ix][iy] = parser.value_linear_units() + (hasQ ? z_values[ix][iy] : 0);
// 10169       #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 10170         bed_level_virt_interpolate();
// 10171       #endif
// 10172     }
// 10173   }
// 10174 
// 10175 #elif ENABLED(AUTO_BED_LEVELING_UBL)
// 10176 
// 10177   /**
// 10178    * M421: Set a single Mesh Bed Leveling Z coordinate
// 10179    *
// 10180    * Usage:
// 10181    *   M421 I<xindex> J<yindex> Z<linear>
// 10182    *   M421 I<xindex> J<yindex> Q<offset>
// 10183    *   M421 C Z<linear>
// 10184    *   M421 C Q<offset>
// 10185    */
// 10186   inline void gcode_M421() {
// 10187     int8_t ix = parser.intval('I', -1), iy = parser.intval('J', -1);
// 10188     const bool hasI = ix >= 0,
// 10189                hasJ = iy >= 0,
// 10190                hasC = parser.seen('C'),
// 10191                hasZ = parser.seen('Z'),
// 10192                hasQ = !hasZ && parser.seen('Q');
// 10193 
// 10194     if (hasC) {
// 10195       const mesh_index_pair location = ubl.find_closest_mesh_point_of_type(REAL, current_position[X_AXIS], current_position[Y_AXIS], USE_NOZZLE_AS_REFERENCE, NULL);
// 10196       ix = location.x_index;
// 10197       iy = location.y_index;
// 10198     }
// 10199 
// 10200     if (int(hasC) + int(hasI && hasJ) != 1 || !(hasZ || hasQ)) {
// 10201       SERIAL_ERROR_START();
// 10202       SERIAL_ERRORLNPGM(MSG_ERR_M421_PARAMETERS);
// 10203     }
// 10204     else if (!WITHIN(ix, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(iy, 0, GRID_MAX_POINTS_Y - 1)) {
// 10205       SERIAL_ERROR_START();
// 10206       SERIAL_ERRORLNPGM(MSG_ERR_MESH_XY);
// 10207     }
// 10208     else
// 10209       ubl.z_values[ix][iy] = parser.value_linear_units() + (hasQ ? ubl.z_values[ix][iy] : 0);
// 10210   }
// 10211 
// 10212 #endif // AUTO_BED_LEVELING_UBL
// 10213 
// 10214 #if HAS_M206_COMMAND
// 10215 
// 10216   /**
// 10217    * M428: Set home_offset based on the distance between the
// 10218    *       current_position and the nearest "reference point."
// 10219    *       If an axis is past center its endstop position
// 10220    *       is the reference-point. Otherwise it uses 0. This allows
// 10221    *       the Z offset to be set near the bed when using a max endstop.
// 10222    *
// 10223    *       M428 can't be used more than 2cm away from 0 or an endstop.
// 10224    *
// 10225    *       Use M206 to set these values directly.
// 10226    */
// 10227   inline void gcode_M428() {
// 10228     if (axis_unhomed_error()) return;
// 10229 
// 10230     float diff[XYZ];
// 10231     LOOP_XYZ(i) {
// 10232       diff[i] = base_home_pos((AxisEnum)i) - current_position[i];
// 10233       diff[C_AXIS] = home_offset[C_AXIS] - current_position[C_AXIS];    //mks_dlp
// 10234       
// 10235       if (!WITHIN(diff[i], -200, 200) && home_dir((AxisEnum)i) > 0)
// 10236         diff[i] = -current_position[i];
// 10237       if (!WITHIN(diff[i], -200, 200)) {
// 10238         SERIAL_ERROR_START();
// 10239         SERIAL_ERRORLNPGM(MSG_ERR_M428_TOO_FAR);
// 10240         LCD_ALERTMESSAGEPGM("Err: Too far!");
// 10241         BUZZ(200, 40);
// 10242         return;
// 10243       }
// 10244     }
// 10245     LOOP_XYZ(i) set_home_offset((AxisEnum)i, diff[i]);
// 10246     report_current_position();
// 10247     LCD_MESSAGEPGM(MSG_HOME_OFFSETS_APPLIED);
// 10248     BUZZ(100, 659);
// 10249     BUZZ(100, 698);
// 10250   }
// 10251 
// 10252 #endif // HAS_M206_COMMAND
// 10253 
// 10254 /**
// 10255  * M500: Store settings in EEPROM
// 10256  */
// 10257 inline void gcode_M500() {
// 10258   (void)settings.save();
// 10259 }
// 10260 
// 10261 /**
// 10262  * M501: Read settings from EEPROM
// 10263  */
// 10264 inline void gcode_M501() {
// 10265   (void)settings.load();
// 10266 }
// 10267 
// 10268 /**
// 10269  * M502: Revert to default settings
// 10270  */
// 10271 inline void gcode_M502() {
// 10272   (void)settings.reset();
// 10273 }
// 10274 
// 10275 #if DISABLED(DISABLE_M503)
// 10276   /**
// 10277    * M503: print settings currently in memory
// 10278    */
// 10279   inline void gcode_M503() {
// 10280     (void)settings.report(parser.seen('S') && !parser.value_bool());
// 10281   }
// 10282 #endif
// 10283 
// 10284 #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
// 10285 
// 10286   /**
// 10287    * M540: Set whether SD card print should abort on endstop hit (M540 S<0|1>)
// 10288    */
// 10289   inline void gcode_M540() {
// 10290     if (parser.seen('S')) stepper.abort_on_endstop_hit = parser.value_bool();
// 10291   }
// 10292 
// 10293 #endif // ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED
// 10294 
// 10295 #if HAS_BED_PROBE
// 10296 
// 10297   inline void gcode_M851() {
// 10298     SERIAL_ECHO_START();
// 10299     SERIAL_ECHOPGM(MSG_PROBE_Z_OFFSET);
// 10300     if (parser.seen('Z')) {
// 10301       const float value = parser.value_linear_units();
// 10302       if (!WITHIN(value, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
// 10303         SERIAL_ECHOLNPGM(" " MSG_Z_MIN " " STRINGIFY(Z_PROBE_OFFSET_RANGE_MIN) " " MSG_Z_MAX " " STRINGIFY(Z_PROBE_OFFSET_RANGE_MAX));
// 10304         return;
// 10305       }
// 10306       zprobe_zoffset = value;
// 10307     }
// 10308     SERIAL_ECHOLNPAIR(": ", zprobe_zoffset);
// 10309   }
// 10310 
// 10311 #endif // HAS_BED_PROBE
// 10312 
// 10313 #if ENABLED(SKEW_CORRECTION_GCODE)
// 10314 
// 10315   /**
// 10316    * M852: Get or set the machine skew factors. Reports current values with no arguments.
// 10317    *
// 10318    *  S[xy_factor] - Alias for 'I'
// 10319    *  I[xy_factor] - New XY skew factor
// 10320    *  J[xz_factor] - New XZ skew factor
// 10321    *  K[yz_factor] - New YZ skew factor
// 10322    */
// 10323   inline void gcode_M852() {
// 10324     uint8_t ijk = 0, badval = 0, setval = 0;
// 10325 
// 10326     if (parser.seen('I') || parser.seen('S')) {
// 10327       ++ijk;
// 10328       const float value = parser.value_linear_units();
// 10329       if (WITHIN(value, SKEW_FACTOR_MIN, SKEW_FACTOR_MAX)) {
// 10330         if (planner.xy_skew_factor != value) {
// 10331           planner.xy_skew_factor = value;
// 10332           ++setval;
// 10333         }
// 10334       }
// 10335       else
// 10336         ++badval;
// 10337     }
// 10338 
// 10339     #if ENABLED(SKEW_CORRECTION_FOR_Z)
// 10340 
// 10341       if (parser.seen('J')) {
// 10342         ++ijk;
// 10343         const float value = parser.value_linear_units();
// 10344         if (WITHIN(value, SKEW_FACTOR_MIN, SKEW_FACTOR_MAX)) {
// 10345           if (planner.xz_skew_factor != value) {
// 10346             planner.xz_skew_factor = value;
// 10347             ++setval;
// 10348           }
// 10349         }
// 10350         else
// 10351           ++badval;
// 10352       }
// 10353 
// 10354       if (parser.seen('K')) {
// 10355         ++ijk;
// 10356         const float value = parser.value_linear_units();
// 10357         if (WITHIN(value, SKEW_FACTOR_MIN, SKEW_FACTOR_MAX)) {
// 10358           if (planner.yz_skew_factor != value) {
// 10359             planner.yz_skew_factor = value;
// 10360             ++setval;
// 10361           }
// 10362         }
// 10363         else
// 10364           ++badval;
// 10365       }
// 10366 
// 10367     #endif
// 10368 
// 10369     if (badval)
// 10370       SERIAL_ECHOLNPGM(MSG_SKEW_MIN " " STRINGIFY(SKEW_FACTOR_MIN) " " MSG_SKEW_MAX " " STRINGIFY(SKEW_FACTOR_MAX));
// 10371 
// 10372     // When skew is changed the current position changes
// 10373     if (setval) {
// 10374       set_current_from_steppers_for_axis(ALL_AXES);
// 10375       SYNC_PLAN_POSITION_KINEMATIC();
// 10376       report_current_position();
// 10377     }
// 10378 
// 10379     if (!ijk) {
// 10380       SERIAL_ECHO_START();
// 10381       SERIAL_ECHOPAIR(MSG_SKEW_FACTOR " XY: ", planner.xy_skew_factor);
// 10382       #if ENABLED(SKEW_CORRECTION_FOR_Z)
// 10383         SERIAL_ECHOPAIR(" XZ: ", planner.xz_skew_factor);
// 10384         SERIAL_ECHOLNPAIR(" YZ: ", planner.yz_skew_factor);
// 10385       #else
// 10386         SERIAL_EOL();
// 10387       #endif
// 10388     }
// 10389   }
// 10390 
// 10391 #endif // SKEW_CORRECTION_GCODE
// 10392 
// 10393 #if ENABLED(ADVANCED_PAUSE_FEATURE)
// 10394 
// 10395   /**
// 10396    * M600: Pause for filament change
// 10397    *
// 10398    *  E[distance] - Retract the filament this far (negative value)
// 10399    *  Z[distance] - Move the Z axis by this distance
// 10400    *  X[position] - Move to this X position, with Y
// 10401    *  Y[position] - Move to this Y position, with X
// 10402    *  U[distance] - Retract distance for removal (negative value) (manual reload)
// 10403    *  L[distance] - Extrude distance for insertion (positive value) (manual reload)
// 10404    *  B[count]    - Number of times to beep, -1 for indefinite (if equipped with a buzzer)
// 10405    *
// 10406    *  Default values are used for omitted arguments.
// 10407    *
// 10408    */
// 10409   inline void gcode_M600() {
// 10410     point_t park_point = NOZZLE_PARK_POINT;
// 10411 
// 10412     #if ENABLED(HOME_BEFORE_FILAMENT_CHANGE)
// 10413       // Don't allow filament change without homing first
// 10414       if (axis_unhomed_error()) home_all_axes();
// 10415     #endif
// 10416 
// 10417     // Initial retract before move to filament change position
// 10418     const float retract = parser.seen('E') ? parser.value_axis_units(E_AXIS) : 0
// 10419       #ifdef PAUSE_PARK_RETRACT_LENGTH
// 10420         - (PAUSE_PARK_RETRACT_LENGTH)
// 10421       #endif
// 10422     ;
// 10423 
// 10424     // Lift Z axis
// 10425     if (parser.seenval('Z'))
// 10426       park_point.z = parser.linearval('Z');
// 10427 
// 10428     // Move XY axes to filament change position or given position
// 10429     if (parser.seenval('X'))
// 10430       park_point.x = parser.linearval('X');
// 10431 
// 10432     if (parser.seenval('Y'))
// 10433       park_point.y = parser.linearval('Y');
// 10434 
// 10435     #if HOTENDS > 1 && DISABLED(DUAL_X_CARRIAGE)
// 10436       park_point.x += (active_extruder ? hotend_offset[X_AXIS][active_extruder] : 0);
// 10437       park_point.y += (active_extruder ? hotend_offset[Y_AXIS][active_extruder] : 0);
// 10438     #endif
// 10439 
// 10440     // Unload filament
// 10441     const float unload_length = parser.seen('U') ? parser.value_axis_units(E_AXIS) : 0
// 10442       #if defined(FILAMENT_CHANGE_UNLOAD_LENGTH) && FILAMENT_CHANGE_UNLOAD_LENGTH > 0
// 10443         - (FILAMENT_CHANGE_UNLOAD_LENGTH)
// 10444       #endif
// 10445     ;
// 10446 
// 10447     // Load filament
// 10448     const float load_length = parser.seen('L') ? parser.value_axis_units(E_AXIS) : 0
// 10449       #ifdef FILAMENT_CHANGE_LOAD_LENGTH
// 10450         + FILAMENT_CHANGE_LOAD_LENGTH
// 10451       #endif
// 10452     ;
// 10453 
// 10454     const int beep_count = parser.intval('B',
// 10455       #ifdef FILAMENT_CHANGE_NUMBER_OF_ALERT_BEEPS
// 10456         FILAMENT_CHANGE_NUMBER_OF_ALERT_BEEPS
// 10457       #else
// 10458         -1
// 10459       #endif
// 10460     );
// 10461 
// 10462     const bool job_running = print_job_timer.isRunning();
// 10463 
// 10464     if (pause_print(retract, park_point, unload_length, beep_count, true)) {
// 10465       wait_for_filament_reload(beep_count);
// 10466       resume_print(load_length, ADVANCED_PAUSE_EXTRUDE_LENGTH, beep_count);
// 10467     }
// 10468 
// 10469     // Resume the print job timer if it was running
// 10470     if (job_running) print_job_timer.start();
// 10471   }
// 10472 
// 10473 #endif // ADVANCED_PAUSE_FEATURE
// 10474 
// 10475 #if ENABLED(MK2_MULTIPLEXER)
// 10476 
// 10477   inline void select_multiplexed_stepper(const uint8_t e) {
// 10478     stepper.synchronize();
// 10479     disable_e_steppers();
// 10480     WRITE(E_MUX0_PIN, TEST(e, 0) ? HIGH : LOW);
// 10481     WRITE(E_MUX1_PIN, TEST(e, 1) ? HIGH : LOW);
// 10482     WRITE(E_MUX2_PIN, TEST(e, 2) ? HIGH : LOW);
// 10483     safe_delay(100);
// 10484   }
// 10485 
// 10486   /**
// 10487    * M702: Unload all extruders
// 10488    */
// 10489   inline void gcode_M702() {
// 10490     for (uint8_t s = 0; s < E_STEPPERS; s++) {
// 10491       select_multiplexed_stepper(e);
// 10492       // TODO: standard unload filament function
// 10493       // MK2 firmware behavior:
// 10494       //  - Make sure temperature is high enough
// 10495       //  - Raise Z to at least 15 to make room
// 10496       //  - Extrude 1cm of filament in 1 second
// 10497       //  - Under 230C quickly purge ~12mm, over 230C purge ~10mm
// 10498       //  - Change E max feedrate to 80, eject the filament from the tube. Sync.
// 10499       //  - Restore E max feedrate to 50
// 10500     }
// 10501     // Go back to the last active extruder
// 10502     select_multiplexed_stepper(active_extruder);
// 10503     disable_e_steppers();
// 10504   }
// 10505 
// 10506 #endif // MK2_MULTIPLEXER
// 10507 
// 10508 #if ENABLED(DUAL_X_CARRIAGE)
// 10509 
// 10510   /**
// 10511    * M605: Set dual x-carriage movement mode
// 10512    *
// 10513    *    M605 S0: Full control mode. The slicer has full control over x-carriage movement
// 10514    *    M605 S1: Auto-park mode. The inactive head will auto park/unpark without slicer involvement
// 10515    *    M605 S2 [Xnnn] [Rmmm]: Duplication mode. The second extruder will duplicate the first with nnn
// 10516    *                         units x-offset and an optional differential hotend temperature of
// 10517    *                         mmm degrees. E.g., with "M605 S2 X100 R2" the second extruder will duplicate
// 10518    *                         the first with a spacing of 100mm in the x direction and 2 degrees hotter.
// 10519    *
// 10520    *    Note: the X axis should be homed after changing dual x-carriage mode.
// 10521    */
// 10522   inline void gcode_M605() {
// 10523     stepper.synchronize();
// 10524     if (parser.seen('S')) dual_x_carriage_mode = (DualXMode)parser.value_byte();
// 10525     switch (dual_x_carriage_mode) {
// 10526       case DXC_FULL_CONTROL_MODE:
// 10527       case DXC_AUTO_PARK_MODE:
// 10528         break;
// 10529       case DXC_DUPLICATION_MODE:
// 10530         if (parser.seen('X')) duplicate_extruder_x_offset = max(parser.value_linear_units(), X2_MIN_POS - x_home_pos(0));
// 10531         if (parser.seen('R')) duplicate_extruder_temp_offset = parser.value_celsius_diff();
// 10532         SERIAL_ECHO_START();
// 10533         SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);
// 10534         SERIAL_CHAR(' ');
// 10535         SERIAL_ECHO(hotend_offset[X_AXIS][0]);
// 10536         SERIAL_CHAR(',');
// 10537         SERIAL_ECHO(hotend_offset[Y_AXIS][0]);
// 10538         SERIAL_CHAR(' ');
// 10539         SERIAL_ECHO(duplicate_extruder_x_offset);
// 10540         SERIAL_CHAR(',');
// 10541         SERIAL_ECHOLN(hotend_offset[Y_AXIS][1]);
// 10542         break;
// 10543       default:
// 10544         dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
// 10545         break;
// 10546     }
// 10547     active_extruder_parked = false;
// 10548     extruder_duplication_enabled = false;
// 10549     delayed_move_time = 0;
// 10550   }
// 10551 
// 10552 #elif ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
// 10553 
// 10554   inline void gcode_M605() {
// 10555     stepper.synchronize();
// 10556     extruder_duplication_enabled = parser.intval('S') == (int)DXC_DUPLICATION_MODE;
// 10557     SERIAL_ECHO_START();
// 10558     SERIAL_ECHOLNPAIR(MSG_DUPLICATION_MODE, extruder_duplication_enabled ? MSG_ON : MSG_OFF);
// 10559   }
// 10560 
// 10561 #endif // DUAL_NOZZLE_DUPLICATION_MODE
// 10562 
// 10563 #if ENABLED(LIN_ADVANCE)
// 10564   /**
// 10565    * M900: Set and/or Get advance K factor and WH/D ratio
// 10566    *
// 10567    *  K<factor>                  Set advance K factor
// 10568    *  R<ratio>                   Set ratio directly (overrides WH/D)
// 10569    *  W<width> H<height> D<diam> Set ratio from WH/D
// 10570    */
// 10571   inline void gcode_M900() {
// 10572     stepper.synchronize();
// 10573 
// 10574     const float newK = parser.floatval('K', -1);
// 10575     if (newK >= 0) planner.extruder_advance_k = newK;
// 10576 
// 10577     float newR = parser.floatval('R', -1);
// 10578     if (newR < 0) {
// 10579       const float newD = parser.floatval('D', -1),
// 10580                   newW = parser.floatval('W', -1),
// 10581                   newH = parser.floatval('H', -1);
// 10582       if (newD >= 0 && newW >= 0 && newH >= 0)
// 10583         newR = newD ? (newW * newH) / (sq(newD * 0.5) * M_PI) : 0;
// 10584     }
// 10585     if (newR >= 0) planner.advance_ed_ratio = newR;
// 10586 
// 10587     SERIAL_ECHO_START();
// 10588     SERIAL_ECHOPAIR("Advance K=", planner.extruder_advance_k);
// 10589     SERIAL_ECHOPGM(" E/D=");
// 10590     const float ratio = planner.advance_ed_ratio;
// 10591     if (ratio) SERIAL_ECHO(ratio); else SERIAL_ECHOPGM("Auto");
// 10592     SERIAL_EOL();
// 10593   }
// 10594 #endif // LIN_ADVANCE
// 10595 
// 10596 #if HAS_TRINAMIC
// 10597   static bool report_tmc_status = false;
// 10598   const char extended_axis_codes[11][3] = { "X", "X2", "Y", "Y2", "Z", "Z2", "E0", "E1", "E2", "E3", "E4" };
// 10599   enum TMC_AxisEnum {
// 10600     TMC_X,
// 10601     TMC_X2,
// 10602     TMC_Y,
// 10603     TMC_Y2,
// 10604     TMC_Z,
// 10605     TMC_Z2,
// 10606     TMC_E0,
// 10607     TMC_E1,
// 10608     TMC_E2,
// 10609     TMC_E3,
// 10610     TMC_E4
// 10611   };
// 10612   #if ENABLED(TMC_DEBUG)
// 10613     enum TMC_debug_enum {
// 10614       TMC_CODES,
// 10615       TMC_ENABLED,
// 10616       TMC_CURRENT,
// 10617       TMC_RMS_CURRENT,
// 10618       TMC_MAX_CURRENT,
// 10619       TMC_IRUN,
// 10620       TMC_IHOLD,
// 10621       TMC_CS_ACTUAL,
// 10622       TMC_PWM_SCALE,
// 10623       TMC_VSENSE,
// 10624       TMC_STEALTHCHOP,
// 10625       TMC_MICROSTEPS,
// 10626       TMC_TSTEP,
// 10627       TMC_TPWMTHRS,
// 10628       TMC_TPWMTHRS_MMS,
// 10629       TMC_OTPW,
// 10630       TMC_OTPW_TRIGGERED,
// 10631       TMC_TOFF,
// 10632       TMC_TBL,
// 10633       TMC_HEND,
// 10634       TMC_HSTRT,
// 10635       TMC_SGT
// 10636     };
// 10637     enum TMC_drv_status_enum {
// 10638       TMC_DRV_CODES,
// 10639       TMC_STST,
// 10640       TMC_OLB,
// 10641       TMC_OLA,
// 10642       TMC_S2GB,
// 10643       TMC_S2GA,
// 10644       TMC_DRV_OTPW,
// 10645       TMC_OT,
// 10646       TMC_STALLGUARD,
// 10647       TMC_DRV_CS_ACTUAL,
// 10648       TMC_FSACTIVE,
// 10649       TMC_SG_RESULT,
// 10650       TMC_DRV_STATUS_HEX,
// 10651       TMC_T157,
// 10652       TMC_T150,
// 10653       TMC_T143,
// 10654       TMC_T120,
// 10655       TMC_STEALTH,
// 10656       TMC_S2VSB,
// 10657       TMC_S2VSA
// 10658     };
// 10659     static void drv_status_print_hex(const char name[], const uint32_t drv_status) {
// 10660       SERIAL_ECHO(name);
// 10661       SERIAL_ECHOPGM(" = 0x");
// 10662       for(int B=24; B>=8; B-=8){
// 10663         MYSERIAL.print((drv_status>>(B+4))&0xF, HEX);
// 10664         MYSERIAL.print((drv_status>>B)&0xF, HEX);
// 10665         MYSERIAL.print(':');
// 10666       }
// 10667       MYSERIAL.print((drv_status>>4)&0xF, HEX);
// 10668       MYSERIAL.print((drv_status)&0xF, HEX);
// 10669       SERIAL_EOL();
// 10670     }
// 10671 
// 10672     #if ENABLED(HAVE_TMC2130)
// 10673       static void tmc_status(TMC2130Stepper &st, const TMC_debug_enum i) {
// 10674         switch(i) {
// 10675           case TMC_PWM_SCALE: MYSERIAL.print(st.PWM_SCALE(), DEC); break;
// 10676           case TMC_TSTEP: SERIAL_ECHO(st.TSTEP()); break;
// 10677           case TMC_SGT: MYSERIAL.print(st.sgt(), DEC); break;
// 10678           case TMC_STEALTHCHOP: serialprintPGM(st.stealthChop() ? PSTR("true") : PSTR("false")); break;
// 10679           default: break;
// 10680         }
// 10681       }
// 10682       static void tmc_parse_drv_status(TMC2130Stepper &st, const TMC_drv_status_enum i) {
// 10683         switch(i) {
// 10684           case TMC_STALLGUARD: if (st.stallguard()) SERIAL_ECHOPGM("X"); break;
// 10685           case TMC_SG_RESULT:  MYSERIAL.print(st.sg_result(), DEC);      break;
// 10686           case TMC_FSACTIVE:   if (st.fsactive())   SERIAL_ECHOPGM("X"); break;
// 10687           default: break;
// 10688         }
// 10689       }
// 10690     #endif
// 10691     #if ENABLED(HAVE_TMC2208)
// 10692       static void tmc_status(TMC2208Stepper &st, const TMC_debug_enum i) {
// 10693         switch(i) {
// 10694           case TMC_TSTEP:
// 10695             {
// 10696               uint32_t data = 0;
// 10697               st.TSTEP(&data);
// 10698               MYSERIAL.print(data);
// 10699               break;
// 10700             }
// 10701           case TMC_PWM_SCALE: MYSERIAL.print(st.pwm_scale_sum(), DEC); break;
// 10702           case TMC_STEALTHCHOP: serialprintPGM(st.stealth() ? PSTR("true") : PSTR("false")); break;
// 10703           case TMC_S2VSA: if (st.s2vsa()) SERIAL_ECHOPGM("X"); break;
// 10704           case TMC_S2VSB: if (st.s2vsb()) SERIAL_ECHOPGM("X"); break;
// 10705           default: break;
// 10706         }
// 10707       }
// 10708       static void tmc_parse_drv_status(TMC2208Stepper &st, const TMC_drv_status_enum i) {
// 10709         switch(i) {
// 10710           case TMC_T157: if (st.t157()) SERIAL_ECHOPGM("X"); break;
// 10711           case TMC_T150: if (st.t150()) SERIAL_ECHOPGM("X"); break;
// 10712           case TMC_T143: if (st.t143()) SERIAL_ECHOPGM("X"); break;
// 10713           case TMC_T120: if (st.t120()) SERIAL_ECHOPGM("X"); break;
// 10714           default: break;
// 10715         }
// 10716       }
// 10717     #endif
// 10718     template <typename TMC>
// 10719     static void tmc_status(TMC &st, TMC_AxisEnum axis, const TMC_debug_enum i, const float spmm) {
// 10720       SERIAL_ECHO('\t');
// 10721       switch(i) {
// 10722         case TMC_CODES: SERIAL_ECHO(extended_axis_codes[axis]); break;
// 10723         case TMC_ENABLED: serialprintPGM(st.isEnabled() ? PSTR("true") : PSTR("false")); break;
// 10724         case TMC_CURRENT: SERIAL_ECHO(st.getCurrent()); break;
// 10725         case TMC_RMS_CURRENT: MYSERIAL.print(st.rms_current()); break;
// 10726         case TMC_MAX_CURRENT: MYSERIAL.print((float)st.rms_current()*1.41, 0); break;
// 10727         case TMC_IRUN:
// 10728           MYSERIAL.print(st.irun(), DEC);
// 10729           SERIAL_ECHOPGM("/31");
// 10730           break;
// 10731         case TMC_IHOLD:
// 10732           MYSERIAL.print(st.ihold(), DEC);
// 10733           SERIAL_ECHOPGM("/31");
// 10734           break;
// 10735         case TMC_CS_ACTUAL:
// 10736           MYSERIAL.print(st.cs_actual(), DEC);
// 10737           SERIAL_ECHOPGM("/31");
// 10738           break;
// 10739 
// 10740         case TMC_VSENSE: serialprintPGM(st.vsense() ? PSTR("1=.18") : PSTR("0=.325")); break;
// 10741 
// 10742         case TMC_MICROSTEPS: SERIAL_ECHO(st.microsteps()); break;
// 10743         case TMC_TPWMTHRS:
// 10744           {
// 10745             uint32_t tpwmthrs_val = st.TPWMTHRS();
// 10746             SERIAL_ECHO(tpwmthrs_val);
// 10747           }
// 10748           break;
// 10749         case TMC_TPWMTHRS_MMS:
// 10750           {
// 10751             uint32_t tpwmthrs_val = st.TPWMTHRS();
// 10752             tpwmthrs_val ? SERIAL_ECHO(12650000UL * st.microsteps() / (256 * tpwmthrs_val * spmm)) : SERIAL_ECHO('-');
// 10753           }
// 10754           break;
// 10755         case TMC_OTPW: serialprintPGM(st.otpw() ? PSTR("true") : PSTR("false")); break;
// 10756         case TMC_OTPW_TRIGGERED: serialprintPGM(st.getOTPW() ? PSTR("true") : PSTR("false")); break;
// 10757         case TMC_TOFF: MYSERIAL.print(st.toff(), DEC); break;
// 10758         case TMC_TBL: MYSERIAL.print(st.blank_time(), DEC); break;
// 10759         case TMC_HEND: MYSERIAL.print(st.hysterisis_end(), DEC); break;
// 10760         case TMC_HSTRT: MYSERIAL.print(st.hysterisis_start(), DEC); break;
// 10761         default: tmc_status(st, i); break;
// 10762       }
// 10763     }
// 10764     template <typename TMC>
// 10765     static void tmc_parse_drv_status(TMC &st, TMC_AxisEnum axis, const TMC_drv_status_enum i) {
// 10766       SERIAL_ECHOPGM("\t");
// 10767       switch(i) {
// 10768         case TMC_DRV_CODES:     SERIAL_ECHO(extended_axis_codes[axis]);  break;
// 10769         case TMC_STST:          if (st.stst())         SERIAL_ECHOPGM("X"); break;
// 10770         case TMC_OLB:           if (st.olb())          SERIAL_ECHOPGM("X"); break;
// 10771         case TMC_OLA:           if (st.ola())          SERIAL_ECHOPGM("X"); break;
// 10772         case TMC_S2GB:          if (st.s2gb())         SERIAL_ECHOPGM("X"); break;
// 10773         case TMC_S2GA:          if (st.s2ga())         SERIAL_ECHOPGM("X"); break;
// 10774         case TMC_DRV_OTPW:      if (st.otpw())         SERIAL_ECHOPGM("X"); break;
// 10775         case TMC_OT:            if (st.ot())           SERIAL_ECHOPGM("X"); break;
// 10776         case TMC_DRV_CS_ACTUAL: MYSERIAL.print(st.cs_actual(), DEC);        break;
// 10777         case TMC_DRV_STATUS_HEX:drv_status_print_hex(extended_axis_codes[axis], st.DRV_STATUS()); break;
// 10778         default: tmc_parse_drv_status(st, i); break;
// 10779       }
// 10780     }
// 10781 
// 10782     static void tmc_debug_loop(const TMC_debug_enum i) {
// 10783       #if X_IS_TRINAMIC
// 10784         tmc_status(stepperX, TMC_X, i, planner.axis_steps_per_mm[X_AXIS]);
// 10785       #endif
// 10786       #if X2_IS_TRINAMIC
// 10787         tmc_status(stepperX2, TMC_X2, i, planner.axis_steps_per_mm[X_AXIS]);
// 10788       #endif
// 10789 
// 10790       #if Y_IS_TRINAMIC
// 10791         tmc_status(stepperY, TMC_Y, i, planner.axis_steps_per_mm[Y_AXIS]);
// 10792       #endif
// 10793       #if Y2_IS_TRINAMIC
// 10794         tmc_status(stepperY2, TMC_Y2, i, planner.axis_steps_per_mm[Y_AXIS]);
// 10795       #endif
// 10796 
// 10797       #if Z_IS_TRINAMIC
// 10798         tmc_status(stepperZ, TMC_Z, i, planner.axis_steps_per_mm[Z_AXIS]);
// 10799       #endif
// 10800       #if Z2_IS_TRINAMIC
// 10801         tmc_status(stepperZ2, TMC_Z2, i, planner.axis_steps_per_mm[Z_AXIS]);
// 10802       #endif
// 10803 
// 10804       #if E0_IS_TRINAMIC
// 10805         tmc_status(stepperE0, TMC_E0, i, planner.axis_steps_per_mm[E_AXIS]);
// 10806       #endif
// 10807       #if E1_IS_TRINAMIC
// 10808         tmc_status(stepperE1, TMC_E1, i, planner.axis_steps_per_mm[E_AXIS+1]);
// 10809       #endif
// 10810       #if E2_IS_TRINAMIC
// 10811         tmc_status(stepperE2, TMC_E2, i, planner.axis_steps_per_mm[E_AXIS+2]);
// 10812       #endif
// 10813       #if E3_IS_TRINAMIC
// 10814         tmc_status(stepperE3, TMC_E3, i, planner.axis_steps_per_mm[E_AXIS+3]);
// 10815       #endif
// 10816       #if E4_IS_TRINAMIC
// 10817         tmc_status(stepperE4, TMC_E4, i, planner.axis_steps_per_mm[E_AXIS+4]);
// 10818       #endif
// 10819 
// 10820       SERIAL_EOL();
// 10821     }
// 10822 
// 10823     static void drv_status_loop(const TMC_drv_status_enum i) {
// 10824       #if X_IS_TRINAMIC
// 10825         tmc_parse_drv_status(stepperX, TMC_X, i);
// 10826       #endif
// 10827       #if X2_IS_TRINAMIC
// 10828         tmc_parse_drv_status(stepperX2, TMC_X2, i);
// 10829       #endif
// 10830 
// 10831       #if Y_IS_TRINAMIC
// 10832         tmc_parse_drv_status(stepperY, TMC_Y, i);
// 10833       #endif
// 10834       #if Y2_IS_TRINAMIC
// 10835         tmc_parse_drv_status(stepperY2, TMC_Y2, i);
// 10836       #endif
// 10837 
// 10838       #if Z_IS_TRINAMIC
// 10839         tmc_parse_drv_status(stepperZ, TMC_Z, i);
// 10840       #endif
// 10841       #if Z2_IS_TRINAMIC
// 10842         tmc_parse_drv_status(stepperZ2, TMC_Z2, i);
// 10843       #endif
// 10844 
// 10845       #if E0_IS_TRINAMIC
// 10846         tmc_parse_drv_status(stepperE0, TMC_E0, i);
// 10847       #endif
// 10848       #if E1_IS_TRINAMIC
// 10849         tmc_parse_drv_status(stepperE1, TMC_E1, i);
// 10850       #endif
// 10851       #if E2_IS_TRINAMIC
// 10852         tmc_parse_drv_status(stepperE2, TMC_E2, i);
// 10853       #endif
// 10854       #if E3_IS_TRINAMIC
// 10855         tmc_parse_drv_status(stepperE3, TMC_E3, i);
// 10856       #endif
// 10857       #if E4_IS_TRINAMIC
// 10858         tmc_parse_drv_status(stepperE4, TMC_E4, i);
// 10859       #endif
// 10860 
// 10861       SERIAL_EOL();
// 10862     }
// 10863 
// 10864     inline void gcode_M122() {
// 10865       if (parser.seen('S')) {
// 10866         if (parser.value_bool()) {
// 10867           SERIAL_ECHOLNPGM("axis:pwm_scale |status_response|");
// 10868           report_tmc_status = true;
// 10869         } else
// 10870           report_tmc_status = false;
// 10871       } else {
// 10872         SERIAL_ECHOPGM("\t");                 tmc_debug_loop(TMC_CODES);
// 10873         SERIAL_ECHOPGM("Enabled\t");          tmc_debug_loop(TMC_ENABLED);
// 10874         SERIAL_ECHOPGM("Set current");        tmc_debug_loop(TMC_CURRENT);
// 10875         SERIAL_ECHOPGM("RMS current");        tmc_debug_loop(TMC_RMS_CURRENT);
// 10876         SERIAL_ECHOPGM("MAX current");        tmc_debug_loop(TMC_MAX_CURRENT);
// 10877         SERIAL_ECHOPGM("Run current");        tmc_debug_loop(TMC_IRUN);
// 10878         SERIAL_ECHOPGM("Hold current");       tmc_debug_loop(TMC_IHOLD);
// 10879         SERIAL_ECHOPGM("CS actual\t");        tmc_debug_loop(TMC_CS_ACTUAL);
// 10880         SERIAL_ECHOPGM("PWM scale");          tmc_debug_loop(TMC_PWM_SCALE);
// 10881         SERIAL_ECHOPGM("vsense\t");           tmc_debug_loop(TMC_VSENSE);
// 10882         SERIAL_ECHOPGM("stealthChop");        tmc_debug_loop(TMC_STEALTHCHOP);
// 10883         SERIAL_ECHOPGM("msteps\t");           tmc_debug_loop(TMC_MICROSTEPS);
// 10884         SERIAL_ECHOPGM("tstep\t");            tmc_debug_loop(TMC_TSTEP);
// 10885         SERIAL_ECHOPGM("pwm\nthreshold\t");   tmc_debug_loop(TMC_TPWMTHRS);
// 10886         SERIAL_ECHOPGM("[mm/s]\t");           tmc_debug_loop(TMC_TPWMTHRS_MMS);
// 10887         SERIAL_ECHOPGM("OT prewarn");         tmc_debug_loop(TMC_OTPW);
// 10888         SERIAL_ECHOPGM("OT prewarn has\nbeen triggered"); tmc_debug_loop(TMC_OTPW_TRIGGERED);
// 10889         SERIAL_ECHOPGM("off time\t");         tmc_debug_loop(TMC_TOFF);
// 10890         SERIAL_ECHOPGM("blank time");         tmc_debug_loop(TMC_TBL);
// 10891         SERIAL_ECHOPGM("hysterisis\n-end\t"); tmc_debug_loop(TMC_HEND);
// 10892         SERIAL_ECHOPGM("-start\t");           tmc_debug_loop(TMC_HSTRT);
// 10893         SERIAL_ECHOPGM("Stallguard thrs");    tmc_debug_loop(TMC_SGT);
// 10894 
// 10895         SERIAL_ECHOPGM("DRVSTATUS");          drv_status_loop(TMC_DRV_CODES);
// 10896         #if ENABLED(HAVE_TMC2130)
// 10897           SERIAL_ECHOPGM("stallguard\t");     drv_status_loop(TMC_STALLGUARD);
// 10898           SERIAL_ECHOPGM("sg_result\t");      drv_status_loop(TMC_SG_RESULT);
// 10899           SERIAL_ECHOPGM("fsactive\t");       drv_status_loop(TMC_FSACTIVE);
// 10900         #endif
// 10901         SERIAL_ECHOPGM("stst\t");             drv_status_loop(TMC_STST);
// 10902         SERIAL_ECHOPGM("olb\t");              drv_status_loop(TMC_OLB);
// 10903         SERIAL_ECHOPGM("ola\t");              drv_status_loop(TMC_OLA);
// 10904         SERIAL_ECHOPGM("s2gb\t");             drv_status_loop(TMC_S2GB);
// 10905         SERIAL_ECHOPGM("s2ga\t");             drv_status_loop(TMC_S2GA);
// 10906         SERIAL_ECHOPGM("otpw\t");             drv_status_loop(TMC_DRV_OTPW);
// 10907         SERIAL_ECHOPGM("ot\t");               drv_status_loop(TMC_OT);
// 10908         #if ENABLED(HAVE_TMC2208)
// 10909           SERIAL_ECHOPGM("157C\t");           drv_status_loop(TMC_T157);
// 10910           SERIAL_ECHOPGM("150C\t");           drv_status_loop(TMC_T150);
// 10911           SERIAL_ECHOPGM("143C\t");           drv_status_loop(TMC_T143);
// 10912           SERIAL_ECHOPGM("120C\t");           drv_status_loop(TMC_T120);
// 10913           SERIAL_ECHOPGM("s2vsa\t");          drv_status_loop(TMC_S2VSA);
// 10914           SERIAL_ECHOPGM("s2vsb\t");          drv_status_loop(TMC_S2VSB);
// 10915         #endif
// 10916         SERIAL_ECHOLNPGM("Driver registers:");drv_status_loop(TMC_DRV_STATUS_HEX);
// 10917       }
// 10918     }
// 10919   #endif
// 10920 
// 10921   template<typename TMC>
// 10922   static void tmc_get_current(TMC &st, const char name[]) {
// 10923     SERIAL_ECHO(name);
// 10924     SERIAL_ECHOPGM(" axis driver current: ");
// 10925     SERIAL_ECHOLN(st.getCurrent());
// 10926   }
// 10927   template<typename TMC>
// 10928   static void tmc_set_current(TMC &st, const char name[], const int mA) {
// 10929     st.setCurrent(mA, R_SENSE, HOLD_MULTIPLIER);
// 10930     tmc_get_current(st, name);
// 10931   }
// 10932 
// 10933   template<typename TMC>
// 10934   static void tmc_report_otpw(TMC &st, const char name[]) {
// 10935     SERIAL_ECHO(name);
// 10936     SERIAL_ECHOPGM(" axis temperature prewarn triggered: ");
// 10937     serialprintPGM(st.getOTPW() ? PSTR("true") : PSTR("false"));
// 10938     SERIAL_EOL();
// 10939   }
// 10940   template<typename TMC>
// 10941   static void tmc_clear_otpw(TMC &st, const char name[]) {
// 10942     st.clear_otpw();
// 10943     SERIAL_ECHO(name);
// 10944     SERIAL_ECHOLNPGM(" prewarn flag cleared");
// 10945   }
// 10946 
// 10947   template<typename TMC>
// 10948   static void tmc_get_pwmthrs(TMC &st, const char name[], const uint16_t spmm) {
// 10949     SERIAL_ECHO(name);
// 10950     SERIAL_ECHOPGM(" stealthChop max speed set to ");
// 10951     SERIAL_ECHOLN(12650000UL * st.microsteps() / (256 * st.TPWMTHRS() * spmm));
// 10952   }
// 10953   template<typename TMC>
// 10954   static void tmc_set_pwmthrs(TMC &st, const char name[], const int32_t thrs, const uint32_t spmm) {
// 10955     st.TPWMTHRS(12650000UL * st.microsteps() / (256 * thrs * spmm));
// 10956     tmc_get_pwmthrs(st, name, spmm);
// 10957   }
// 10958 
// 10959   template<typename TMC>
// 10960   static void tmc_get_sgt(TMC &st, const char name[]) {
// 10961     SERIAL_ECHO(name);
// 10962     SERIAL_ECHOPGM(" driver homing sensitivity set to ");
// 10963     MYSERIAL.println(st.sgt(), DEC);
// 10964   }
// 10965   template<typename TMC>
// 10966   static void tmc_set_sgt(TMC &st, const char name[], const int8_t sgt_val) {
// 10967     st.sgt(sgt_val);
// 10968     tmc_get_sgt(st, name);
// 10969   }
// 10970 
// 10971   /**
// 10972    * M906: Set motor current in milliamps using axis codes X, Y, Z, E
// 10973    * Report driver currents when no axis specified
// 10974    */
// 10975   inline void gcode_M906() {
// 10976     uint16_t values[XYZE];
// 10977     LOOP_XYZE(i)
// 10978       values[i] = parser.intval(axis_codes[i]);
// 10979 
// 10980     #if X_IS_TRINAMIC
// 10981       if (values[X_AXIS]) tmc_set_current(stepperX, extended_axis_codes[TMC_X], values[X_AXIS]);
// 10982       else tmc_get_current(stepperX, extended_axis_codes[TMC_X]);
// 10983     #endif
// 10984     #if X2_IS_TRINAMIC
// 10985       if (values[X_AXIS]) tmc_set_current(stepperX2, extended_axis_codes[TMC_X2], values[X_AXIS]);
// 10986       else tmc_get_current(stepperX2, extended_axis_codes[TMC_X2]);
// 10987     #endif
// 10988     #if Y_IS_TRINAMIC
// 10989       if (values[Y_AXIS]) tmc_set_current(stepperY, extended_axis_codes[TMC_Y], values[Y_AXIS]);
// 10990       else tmc_get_current(stepperY, extended_axis_codes[TMC_Y]);
// 10991     #endif
// 10992     #if Y2_IS_TRINAMIC
// 10993       if (values[Y_AXIS]) tmc_set_current(stepperY2, extended_axis_codes[TMC_Y2], values[Y_AXIS]);
// 10994       else tmc_get_current(stepperY2, extended_axis_codes[TMC_Y2]);
// 10995     #endif
// 10996     #if Z_IS_TRINAMIC
// 10997       if (values[Z_AXIS]) tmc_set_current(stepperZ, extended_axis_codes[TMC_Z], values[Z_AXIS]);
// 10998       else tmc_get_current(stepperZ, extended_axis_codes[TMC_Z]);
// 10999     #endif
// 11000     #if Z2_IS_TRINAMIC
// 11001       if (values[Z_AXIS]) tmc_set_current(stepperZ2, extended_axis_codes[TMC_Z2], values[Z_AXIS]);
// 11002       else tmc_get_current(stepperZ2, extended_axis_codes[TMC_Z2]);
// 11003     #endif
// 11004     #if E0_IS_TRINAMIC
// 11005       if (values[E_AXIS]) tmc_set_current(stepperE0, extended_axis_codes[TMC_E0], values[E_AXIS]);
// 11006       else tmc_get_current(stepperE0, extended_axis_codes[TMC_E0]);
// 11007     #endif
// 11008     #if E1_IS_TRINAMIC
// 11009       if (values[E_AXIS]) tmc_set_current(stepperE1, extended_axis_codes[TMC_E1], values[E_AXIS]);
// 11010       else tmc_get_current(stepperE1, extended_axis_codes[TMC_E1]);
// 11011     #endif
// 11012     #if E2_IS_TRINAMIC
// 11013       if (values[E_AXIS]) tmc_set_current(stepperE2, extended_axis_codes[TMC_E2], values[E_AXIS]);
// 11014       else tmc_get_current(stepperE2, extended_axis_codes[TMC_E2]);
// 11015     #endif
// 11016     #if E3_IS_TRINAMIC
// 11017       if (values[E_AXIS]) tmc_set_current(stepperE3, extended_axis_codes[TMC_E3], values[E_AXIS]);
// 11018       else tmc_get_current(stepperE3, extended_axis_codes[TMC_E3]);
// 11019     #endif
// 11020     #if E4_IS_TRINAMIC
// 11021       if (values[E_AXIS]) tmc_set_current(stepperE4, extended_axis_codes[TMC_E4], values[E_AXIS]);
// 11022       else tmc_get_current(stepperE4, extended_axis_codes[TMC_E4]);
// 11023     #endif
// 11024 
// 11025   }
// 11026 
// 11027   /**
// 11028    * M911: Report TMC stepper driver overtemperature pre-warn flag
// 11029    * The flag is held by the library and persist until manually cleared by M912
// 11030    */
// 11031   inline void gcode_M911() {
// 11032     #if ENABLED(X_IS_TMC2130) || (ENABLED(X_IS_TMC2208) && PIN_EXISTS(X_SERIAL_RX)) || ENABLED(IS_TRAMS)
// 11033       tmc_report_otpw(stepperX, extended_axis_codes[TMC_X]);
// 11034     #endif
// 11035     #if ENABLED(Y_IS_TMC2130) || (ENABLED(Y_IS_TMC2208) && PIN_EXISTS(Y_SERIAL_RX)) || ENABLED(IS_TRAMS)
// 11036       tmc_report_otpw(stepperY, extended_axis_codes[TMC_Y]);
// 11037     #endif
// 11038     #if ENABLED(Z_IS_TMC2130) || (ENABLED(Z_IS_TMC2208) && PIN_EXISTS(Z_SERIAL_RX)) || ENABLED(IS_TRAMS)
// 11039       tmc_report_otpw(stepperZ, extended_axis_codes[TMC_Z]);
// 11040     #endif
// 11041     #if ENABLED(E0_IS_TMC2130) || (ENABLED(E0_IS_TMC2208) && PIN_EXISTS(E0_SERIAL_RX)) || ENABLED(IS_TRAMS)
// 11042       tmc_report_otpw(stepperE0, extended_axis_codes[TMC_E0]);
// 11043     #endif
// 11044   }
// 11045 
// 11046   /**
// 11047    * M912: Clear TMC stepper driver overtemperature pre-warn flag held by the library
// 11048    */
// 11049   inline void gcode_M912() {
// 11050     const bool clearX = parser.seen(axis_codes[X_AXIS]), clearY = parser.seen(axis_codes[Y_AXIS]), clearZ = parser.seen(axis_codes[Z_AXIS]), clearE = parser.seen(axis_codes[E_AXIS]),
// 11051              clearAll = (!clearX && !clearY && !clearZ && !clearE) || (clearX && clearY && clearZ && clearE);
// 11052     #if ENABLED(X_IS_TMC2130) || ENABLED(IS_TRAMS) || (ENABLED(X_IS_TMC2208) && PIN_EXISTS(X_SERIAL_RX))
// 11053       if (clearX || clearAll) tmc_clear_otpw(stepperX, extended_axis_codes[TMC_X]);
// 11054     #endif
// 11055     #if ENABLED(X2_IS_TMC2130) || (ENABLED(X2_IS_TMC2208) && PIN_EXISTS(X_SERIAL_RX))
// 11056       if (clearX || clearAll) tmc_clear_otpw(stepperX, extended_axis_codes[TMC_X]);
// 11057     #endif
// 11058 
// 11059     #if ENABLED(Y_IS_TMC2130) || (ENABLED(Y_IS_TMC2208) && PIN_EXISTS(Y_SERIAL_RX))
// 11060       if (clearY || clearAll) tmc_clear_otpw(stepperY, extended_axis_codes[TMC_Y]);
// 11061     #endif
// 11062 
// 11063     #if ENABLED(Z_IS_TMC2130) || (ENABLED(Z_IS_TMC2208) && PIN_EXISTS(Z_SERIAL_RX))
// 11064       if (clearZ || clearAll) tmc_clear_otpw(stepperZ, extended_axis_codes[TMC_Z]);
// 11065     #endif
// 11066 
// 11067     #if ENABLED(E0_IS_TMC2130) || (ENABLED(E0_IS_TMC2208) && PIN_EXISTS(E0_SERIAL_RX))
// 11068       if (clearE || clearAll) tmc_clear_otpw(stepperE0, extended_axis_codes[TMC_E0]);
// 11069     #endif
// 11070   }
// 11071 
// 11072   /**
// 11073    * M913: Set HYBRID_THRESHOLD speed.
// 11074    */
// 11075   #if ENABLED(HYBRID_THRESHOLD)
// 11076     inline void gcode_M913() {
// 11077       uint16_t values[XYZE];
// 11078       LOOP_XYZE(i)
// 11079         values[i] = parser.intval(axis_codes[i]);
// 11080 
// 11081       #if X_IS_TRINAMIC
// 11082         if (values[X_AXIS]) tmc_set_pwmthrs(stepperX, extended_axis_codes[TMC_X], values[X_AXIS], planner.axis_steps_per_mm[X_AXIS]);
// 11083         else tmc_get_pwmthrs(stepperX, extended_axis_codes[TMC_X], planner.axis_steps_per_mm[X_AXIS]);
// 11084       #endif
// 11085       #if X2_IS_TRINAMIC
// 11086         if (values[X_AXIS]) tmc_set_pwmthrs(stepperX2, extended_axis_codes[TMC_X2], values[X_AXIS], planner.axis_steps_per_mm[X_AXIS]);
// 11087         else tmc_get_pwmthrs(stepperX, extended_axis_codes[TMC_X2], planner.axis_steps_per_mm[X_AXIS]);
// 11088       #endif
// 11089 
// 11090       #if Y_IS_TRINAMIC
// 11091         if (values[Y_AXIS]) tmc_set_pwmthrs(stepperY, extended_axis_codes[TMC_Y], values[Y_AXIS], planner.axis_steps_per_mm[Y_AXIS]);
// 11092         else tmc_get_pwmthrs(stepperY, extended_axis_codes[TMC_Y], planner.axis_steps_per_mm[Y_AXIS]);
// 11093       #endif
// 11094       #if Y2_IS_TRINAMIC
// 11095         if (values[Y_AXIS]) tmc_set_pwmthrs(stepperY2, extended_axis_codes[TMC_Y2], values[Y_AXIS], planner.axis_steps_per_mm[Y_AXIS]);
// 11096         else tmc_get_pwmthrs(stepperY, extended_axis_codes[TMC_Y2], planner.axis_steps_per_mm[Y_AXIS]);
// 11097       #endif
// 11098 
// 11099       #if Z_IS_TRINAMIC
// 11100         if (values[Z_AXIS]) tmc_set_pwmthrs(stepperZ, extended_axis_codes[TMC_Z], values[Z_AXIS], planner.axis_steps_per_mm[Z_AXIS]);
// 11101         else tmc_get_pwmthrs(stepperZ, extended_axis_codes[TMC_Z], planner.axis_steps_per_mm[Z_AXIS]);
// 11102       #endif
// 11103       #if Z2_IS_TRINAMIC
// 11104         if (values[Z_AXIS]) tmc_set_pwmthrs(stepperZ2, extended_axis_codes[TMC_Z2], values[Z_AXIS], planner.axis_steps_per_mm[Z_AXIS]);
// 11105         else tmc_get_pwmthrs(stepperZ, extended_axis_codes[TMC_Z2], planner.axis_steps_per_mm[Z_AXIS]);
// 11106       #endif
// 11107 
// 11108       #if E0_IS_TRINAMIC
// 11109         if (values[E_AXIS]) tmc_set_pwmthrs(stepperE0, extended_axis_codes[TMC_E0], values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
// 11110         else tmc_get_pwmthrs(stepperE0, extended_axis_codes[TMC_E0], planner.axis_steps_per_mm[E_AXIS]);
// 11111       #endif
// 11112       #if E1_IS_TRINAMIC
// 11113         if (values[E_AXIS]) tmc_set_pwmthrs(stepperE1, extended_axis_codes[TMC_E1], values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
// 11114         else tmc_get_pwmthrs(stepperE1, extended_axis_codes[TMC_E1], planner.axis_steps_per_mm[E_AXIS]);
// 11115       #endif
// 11116       #if E2_IS_TRINAMIC
// 11117         if (values[E_AXIS]) tmc_set_pwmthrs(stepperE2, extended_axis_codes[TMC_E2], values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
// 11118         else tmc_get_pwmthrs(stepperE2, extended_axis_codes[TMC_E2], planner.axis_steps_per_mm[E_AXIS]);
// 11119       #endif
// 11120       #if E3_IS_TRINAMIC
// 11121         if (values[E_AXIS]) tmc_set_pwmthrs(stepperE3, extended_axis_codes[TMC_E3], values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
// 11122         else tmc_get_pwmthrs(stepperE3, extended_axis_codes[TMC_E3], planner.axis_steps_per_mm[E_AXIS]);
// 11123       #endif
// 11124       #if E4_IS_TRINAMIC
// 11125         if (values[E_AXIS]) tmc_set_pwmthrs(stepperE4, extended_axis_codes[TMC_E4], values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
// 11126         else tmc_get_pwmthrs(stepperE4, extended_axis_codes[TMC_E4], planner.axis_steps_per_mm[E_AXIS]);
// 11127       #endif
// 11128     }
// 11129   #endif // HYBRID_THRESHOLD
// 11130 
// 11131   /**
// 11132    * M914: Set SENSORLESS_HOMING sensitivity.
// 11133    */
// 11134   #if ENABLED(SENSORLESS_HOMING)
// 11135     inline void gcode_M914() {
// 11136       #if ENABLED(X_IS_TMC2130) || ENABLED(IS_TRAMS)
// 11137         if (parser.seen(axis_codes[X_AXIS])) tmc_set_sgt(stepperX, extended_axis_codes[TMC_X], parser.value_int());
// 11138         else tmc_get_sgt(stepperX, extended_axis_codes[TMC_X]);
// 11139       #endif
// 11140       #if ENABLED(X2_IS_TMC2130)
// 11141         if (parser.seen(axis_codes[X_AXIS])) tmc_set_sgt(stepperX2, extended_axis_codes[TMC_X2], parser.value_int());
// 11142         else tmc_get_sgt(stepperX2, extended_axis_codes[TMC_X2]);
// 11143       #endif
// 11144       #if ENABLED(Y_IS_TMC2130) || ENABLED(IS_TRAMS)
// 11145         if (parser.seen(axis_codes[Y_AXIS])) tmc_set_sgt(stepperY, extended_axis_codes[TMC_Y], parser.value_int());
// 11146         else tmc_get_sgt(stepperY, extended_axis_codes[TMC_Y]);
// 11147       #endif
// 11148       #if ENABLED(Y2_IS_TMC2130)
// 11149         if (parser.seen(axis_codes[Y_AXIS])) tmc_set_sgt(stepperY2, extended_axis_codes[TMC_Y2], parser.value_int());
// 11150         else tmc_get_sgt(stepperY2, extended_axis_codes[TMC_Y2]);
// 11151       #endif
// 11152     }
// 11153   #endif // SENSORLESS_HOMING
// 11154 
// 11155   /**
// 11156    * TMC Z axis calibration routine
// 11157    */
// 11158   #if ENABLED(TMC_Z_CALIBRATION) && (Z_IS_TRINAMIC || Z2_IS_TRINAMIC)
// 11159     inline void gcode_M915() {
// 11160       uint16_t _rms = parser.seenval('S') ? parser.value_int() : CALIBRATION_CURRENT;
// 11161       uint16_t _z = parser.seenval('Z') ? parser.value_int() : CALIBRATION_EXTRA_HEIGHT;
// 11162 
// 11163       if (!axis_known_position[Z_AXIS]) {
// 11164         SERIAL_ECHOLNPGM("\nPlease home Z axis first");
// 11165         return;
// 11166       }
// 11167 
// 11168       uint16_t Z_current_1 = stepperZ.getCurrent();
// 11169       uint16_t Z2_current_1 = stepperZ.getCurrent();
// 11170 
// 11171       stepperZ.setCurrent(_rms, R_SENSE, HOLD_MULTIPLIER);
// 11172       stepperZ2.setCurrent(_rms, R_SENSE, HOLD_MULTIPLIER);
// 11173       SERIAL_ECHOPAIR("\nCalibration current: Z", _rms);
// 11174 
// 11175       soft_endstops_enabled = false;
// 11176 
// 11177       do_blocking_move_to_z(Z_MAX_POS+_z);
// 11178 
// 11179       stepperZ.setCurrent(Z_current_1, R_SENSE, HOLD_MULTIPLIER);
// 11180       stepperZ2.setCurrent(Z2_current_1, R_SENSE, HOLD_MULTIPLIER);
// 11181 
// 11182       do_blocking_move_to_z(Z_MAX_POS);
// 11183       soft_endstops_enabled = true;
// 11184 
// 11185       SERIAL_ECHOLNPGM("\nHoming Z because we lost steps");
// 11186       home_z_safely();
// 11187     }
// 11188   #endif
// 11189 
// 11190 #endif // HAS_TRINAMIC
// 11191 
// 11192 /**
// 11193  * M907: Set digital trimpot motor current using axis codes X, Y, Z, E, B, S
// 11194  */
// 11195 inline void gcode_M907() {
// 11196   #if HAS_DIGIPOTSS
// 11197 
// 11198     LOOP_XYZE(i) if (parser.seen(axis_codes[i])) stepper.digipot_current(i, parser.value_int());
// 11199     if (parser.seen('B')) stepper.digipot_current(4, parser.value_int());
// 11200     if (parser.seen('S')) for (uint8_t i = 0; i <= 4; i++) stepper.digipot_current(i, parser.value_int());
// 11201 
// 11202   #elif HAS_MOTOR_CURRENT_PWM
// 11203 
// 11204     #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
// 11205       if (parser.seen('X')) stepper.digipot_current(0, parser.value_int());
// 11206     #endif
// 11207     #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
// 11208       if (parser.seen('Z')) stepper.digipot_current(1, parser.value_int());
// 11209     #endif
// 11210     #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
// 11211       if (parser.seen('E')) stepper.digipot_current(2, parser.value_int());
// 11212     #endif
// 11213 
// 11214   #endif
// 11215 
// 11216   #if ENABLED(DIGIPOT_I2C)
// 11217     // this one uses actual amps in floating point
// 11218     LOOP_XYZE(i) if (parser.seen(axis_codes[i])) digipot_i2c_set_current(i, parser.value_float());
// 11219     // for each additional extruder (named B,C,D,E..., channels 4,5,6,7...)
// 11220     for (uint8_t i = NUM_AXIS; i < DIGIPOT_I2C_NUM_CHANNELS; i++) if (parser.seen('B' + i - (NUM_AXIS))) digipot_i2c_set_current(i, parser.value_float());
// 11221   #endif
// 11222 
// 11223   #if ENABLED(DAC_STEPPER_CURRENT)
// 11224     if (parser.seen('S')) {
// 11225       const float dac_percent = parser.value_float();
// 11226       for (uint8_t i = 0; i <= 4; i++) dac_current_percent(i, dac_percent);
// 11227     }
// 11228     LOOP_XYZE(i) if (parser.seen(axis_codes[i])) dac_current_percent(i, parser.value_float());
// 11229   #endif
// 11230 }
// 11231 
// 11232 #if HAS_DIGIPOTSS || ENABLED(DAC_STEPPER_CURRENT)
// 11233 
// 11234   /**
// 11235    * M908: Control digital trimpot directly (M908 P<pin> S<current>)
// 11236    */
// 11237   inline void gcode_M908() {
// 11238     #if HAS_DIGIPOTSS
// 11239       stepper.digitalPotWrite(
// 11240         parser.intval('P'),
// 11241         parser.intval('S')
// 11242       );
// 11243     #endif
// 11244     #ifdef DAC_STEPPER_CURRENT
// 11245       dac_current_raw(
// 11246         parser.byteval('P', -1),
// 11247         parser.ushortval('S', 0)
// 11248       );
// 11249     #endif
// 11250   }
// 11251 
// 11252   #if ENABLED(DAC_STEPPER_CURRENT) // As with Printrbot RevF
// 11253 
// 11254     inline void gcode_M909() { dac_print_values(); }
// 11255 
// 11256     inline void gcode_M910() { dac_commit_eeprom(); }
// 11257 
// 11258   #endif
// 11259 
// 11260 #endif // HAS_DIGIPOTSS || DAC_STEPPER_CURRENT
// 11261 
// 11262 #if HAS_MICROSTEPS
// 11263 
// 11264   // M350 Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.
// 11265   inline void gcode_M350() {
// 11266     if (parser.seen('S')) for (int i = 0; i <= 4; i++) stepper.microstep_mode(i, parser.value_byte());
// 11267     LOOP_XYZE(i) if (parser.seen(axis_codes[i])) stepper.microstep_mode(i, parser.value_byte());
// 11268     if (parser.seen('B')) stepper.microstep_mode(4, parser.value_byte());
// 11269     stepper.microstep_readings();
// 11270   }
// 11271 
// 11272   /**
// 11273    * M351: Toggle MS1 MS2 pins directly with axis codes X Y Z E B
// 11274    *       S# determines MS1 or MS2, X# sets the pin high/low.
// 11275    */
// 11276   inline void gcode_M351() {
// 11277     if (parser.seenval('S')) switch (parser.value_byte()) {
// 11278       case 1:
// 11279         LOOP_XYZE(i) if (parser.seenval(axis_codes[i])) stepper.microstep_ms(i, parser.value_byte(), -1);
// 11280         if (parser.seenval('B')) stepper.microstep_ms(4, parser.value_byte(), -1);
// 11281         break;
// 11282       case 2:
// 11283         LOOP_XYZE(i) if (parser.seenval(axis_codes[i])) stepper.microstep_ms(i, -1, parser.value_byte());
// 11284         if (parser.seenval('B')) stepper.microstep_ms(4, -1, parser.value_byte());
// 11285         break;
// 11286     }
// 11287     stepper.microstep_readings();
// 11288   }
// 11289 
// 11290 #endif // HAS_MICROSTEPS
// 11291 
// 11292 #if HAS_CASE_LIGHT
// 11293   #ifndef INVERT_CASE_LIGHT
// 11294     #define INVERT_CASE_LIGHT false
// 11295   #endif
// 11296   uint8_t case_light_brightness;  // LCD routine wants INT
// 11297   bool case_light_on;
// 11298 
// 11299   void update_case_light() {
// 11300     pinMode(CASE_LIGHT_PIN, OUTPUT); // digitalWrite doesn't set the port mode
// 11301     if (case_light_on) {
// 11302       if (USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN))
// 11303         analogWrite(CASE_LIGHT_PIN, INVERT_CASE_LIGHT ? 255 - case_light_brightness : case_light_brightness);
// 11304       else
// 11305         WRITE(CASE_LIGHT_PIN, INVERT_CASE_LIGHT ? LOW : HIGH);
// 11306     }
// 11307     else {
// 11308       if (USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN))
// 11309         analogWrite(CASE_LIGHT_PIN, INVERT_CASE_LIGHT ? 255 : 0);
// 11310       else
// 11311         WRITE(CASE_LIGHT_PIN, INVERT_CASE_LIGHT ? HIGH : LOW);
// 11312     }
// 11313   }
// 11314 #endif // HAS_CASE_LIGHT
// 11315 
// 11316 /**
// 11317  * M355: Turn case light on/off and set brightness
// 11318  *
// 11319  *   P<byte>  Set case light brightness (PWM pin required - ignored otherwise)
// 11320  *
// 11321  *   S<bool>  Set case light on/off
// 11322  *
// 11323  *   When S turns on the light on a PWM pin then the current brightness level is used/restored
// 11324  *
// 11325  *   M355 P200 S0 turns off the light & sets the brightness level
// 11326  *   M355 S1 turns on the light with a brightness of 200 (assuming a PWM pin)
// 11327  */
// 11328 inline void gcode_M355() {
// 11329   #if HAS_CASE_LIGHT
// 11330     uint8_t args = 0;
// 11331     if (parser.seenval('P')) ++args, case_light_brightness = parser.value_byte();
// 11332     if (parser.seenval('S')) ++args, case_light_on = parser.value_bool();
// 11333     if (args) update_case_light();
// 11334 
// 11335     // always report case light status
// 11336     SERIAL_ECHO_START();
// 11337     if (!case_light_on) {
// 11338       SERIAL_ECHOLN("Case light: off");
// 11339     }
// 11340     else {
// 11341       if (!USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN)) SERIAL_ECHOLN("Case light: on");
// 11342       else SERIAL_ECHOLNPAIR("Case light: ", (int)case_light_brightness);
// 11343     }
// 11344 
// 11345   #else
// 11346     SERIAL_ERROR_START();
// 11347     SERIAL_ERRORLNPGM(MSG_ERR_M355_NONE);
// 11348   #endif // HAS_CASE_LIGHT
// 11349 }
// 11350 
// 11351 #if ENABLED(MIXING_EXTRUDER)
// 11352 
// 11353   /**
// 11354    * M163: Set a single mix factor for a mixing extruder
// 11355    *       This is called "weight" by some systems.
// 11356    *
// 11357    *   S[index]   The channel index to set
// 11358    *   P[float]   The mix value
// 11359    *
// 11360    */
// 11361   inline void gcode_M163() {
// 11362     const int mix_index = parser.intval('S');
// 11363     if (mix_index < MIXING_STEPPERS) {
// 11364       float mix_value = parser.floatval('P');
// 11365       NOLESS(mix_value, 0.0);
// 11366       mixing_factor[mix_index] = RECIPROCAL(mix_value);
// 11367     }
// 11368   }
// 11369 
// 11370   #if MIXING_VIRTUAL_TOOLS > 1
// 11371 
// 11372     /**
// 11373      * M164: Store the current mix factors as a virtual tool.
// 11374      *
// 11375      *   S[index]   The virtual tool to store
// 11376      *
// 11377      */
// 11378     inline void gcode_M164() {
// 11379       const int tool_index = parser.intval('S');
// 11380       if (tool_index < MIXING_VIRTUAL_TOOLS) {
// 11381         normalize_mix();
// 11382         for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
// 11383           mixing_virtual_tool_mix[tool_index][i] = mixing_factor[i];
// 11384       }
// 11385     }
// 11386 
// 11387   #endif
// 11388 
// 11389   #if ENABLED(DIRECT_MIXING_IN_G1)
// 11390     /**
// 11391      * M165: Set multiple mix factors for a mixing extruder.
// 11392      *       Factors that are left out will be set to 0.
// 11393      *       All factors together must add up to 1.0.
// 11394      *
// 11395      *   A[factor] Mix factor for extruder stepper 1
// 11396      *   B[factor] Mix factor for extruder stepper 2
// 11397      *   C[factor] Mix factor for extruder stepper 3
// 11398      *   D[factor] Mix factor for extruder stepper 4
// 11399      *   H[factor] Mix factor for extruder stepper 5
// 11400      *   I[factor] Mix factor for extruder stepper 6
// 11401      *
// 11402      */
// 11403     inline void gcode_M165() { gcode_get_mix(); }
// 11404   #endif
// 11405 
// 11406 #endif // MIXING_EXTRUDER
// 11407 
// 11408 /**
// 11409  * M999: Restart after being stopped
// 11410  *
// 11411  * Default behaviour is to flush the serial buffer and request
// 11412  * a resend to the host starting on the last N line received.
// 11413  *
// 11414  * Sending "M999 S1" will resume printing without flushing the
// 11415  * existing command buffer.
// 11416  *
// 11417  */
// 11418 inline void gcode_M999() {
// 11419   Running = true;
// 11420   lcd_reset_alert_level();
// 11421 
// 11422   if (parser.boolval('S')) return;
// 11423 
// 11424   // gcode_LastN = Stopped_gcode_LastN;
// 11425   FlushSerialRequestResend();
// 11426 }
// 11427 
// 11428 #if ENABLED(SWITCHING_EXTRUDER)
// 11429   #if EXTRUDERS > 3
// 11430     #define REQ_ANGLES 4
// 11431     #define _SERVO_NR (e < 2 ? SWITCHING_EXTRUDER_SERVO_NR : SWITCHING_EXTRUDER_E23_SERVO_NR)
// 11432   #else
// 11433     #define REQ_ANGLES 2
// 11434     #define _SERVO_NR SWITCHING_EXTRUDER_SERVO_NR
// 11435   #endif
// 11436   inline void move_extruder_servo(const uint8_t e) {
// 11437     constexpr int16_t angles[] = SWITCHING_EXTRUDER_SERVO_ANGLES;
// 11438     static_assert(COUNT(angles) == REQ_ANGLES, "SWITCHING_EXTRUDER_SERVO_ANGLES needs " STRINGIFY(REQ_ANGLES) " angles.");
// 11439     stepper.synchronize();
// 11440     #if EXTRUDERS & 1
// 11441       if (e < EXTRUDERS - 1)
// 11442     #endif
// 11443     {
// 11444       MOVE_SERVO(_SERVO_NR, angles[e]);
// 11445       safe_delay(500);
// 11446     }
// 11447   }
// 11448 #endif // SWITCHING_EXTRUDER
// 11449 
// 11450 #if ENABLED(SWITCHING_NOZZLE)
// 11451   inline void move_nozzle_servo(const uint8_t e) {
// 11452     const int16_t angles[2] = SWITCHING_NOZZLE_SERVO_ANGLES;
// 11453     stepper.synchronize();
// 11454     MOVE_SERVO(SWITCHING_NOZZLE_SERVO_NR, angles[e]);
// 11455     safe_delay(500);
// 11456   }
// 11457 #endif
// 11458 
// 11459 inline void invalid_extruder_error(const uint8_t e) {
// 11460   SERIAL_ECHO_START();
// 11461   SERIAL_CHAR('T');
// 11462   SERIAL_ECHO_F(e, DEC);
// 11463   SERIAL_CHAR(' ');
// 11464   SERIAL_ECHOLN(MSG_INVALID_EXTRUDER);
// 11465 }
// 11466 
// 11467 #if ENABLED(PARKING_EXTRUDER)
// 11468 
// 11469   #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
// 11470     #define PE_MAGNET_ON_STATE !PARKING_EXTRUDER_SOLENOIDS_PINS_ACTIVE
// 11471   #else
// 11472     #define PE_MAGNET_ON_STATE PARKING_EXTRUDER_SOLENOIDS_PINS_ACTIVE
// 11473   #endif
// 11474 
// 11475   void pe_set_magnet(const uint8_t extruder_num, const uint8_t state) {
// 11476     switch (extruder_num) {
// 11477       case 1: OUT_WRITE(SOL1_PIN, state); break;
// 11478       default: OUT_WRITE(SOL0_PIN, state); break;
// 11479     }
// 11480     #if PARKING_EXTRUDER_SOLENOIDS_DELAY > 0
// 11481       dwell(PARKING_EXTRUDER_SOLENOIDS_DELAY);
// 11482     #endif
// 11483   }
// 11484 
// 11485   inline void pe_activate_magnet(const uint8_t extruder_num) { pe_set_magnet(extruder_num, PE_MAGNET_ON_STATE); }
// 11486   inline void pe_deactivate_magnet(const uint8_t extruder_num) { pe_set_magnet(extruder_num, !PE_MAGNET_ON_STATE); }
// 11487 
// 11488 #endif // PARKING_EXTRUDER
// 11489 
// 11490 #if HAS_FANMUX
// 11491 
// 11492   void fanmux_switch(const uint8_t e) {
// 11493     WRITE(FANMUX0_PIN, TEST(e, 0) ? HIGH : LOW);
// 11494     #if PIN_EXISTS(FANMUX1)
// 11495       WRITE(FANMUX1_PIN, TEST(e, 1) ? HIGH : LOW);
// 11496       #if PIN_EXISTS(FANMUX2)
// 11497         WRITE(FANMUX2, TEST(e, 2) ? HIGH : LOW);
// 11498       #endif
// 11499     #endif
// 11500   }
// 11501 
// 11502   FORCE_INLINE void fanmux_init(void) {
// 11503     SET_OUTPUT(FANMUX0_PIN);
// 11504     #if PIN_EXISTS(FANMUX1)
// 11505       SET_OUTPUT(FANMUX1_PIN);
// 11506       #if PIN_EXISTS(FANMUX2)
// 11507         SET_OUTPUT(FANMUX2_PIN);
// 11508       #endif
// 11509     #endif
// 11510     fanmux_switch(0);
// 11511   }
// 11512 
// 11513 #endif // HAS_FANMUX
// 11514 
// 11515 /**
// 11516  * Perform a tool-change, which may result in moving the
// 11517  * previous tool out of the way and the new tool into place.
// 11518  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock44 Using cfiCommon0
          CFI Function _Z11tool_changehfb
        THUMB
// 11519 void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
_Z11tool_changehfb:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 11520   #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
// 11521 
// 11522     if (tmp_extruder >= MIXING_VIRTUAL_TOOLS)
// 11523       return invalid_extruder_error(tmp_extruder);
// 11524 
// 11525     // T0-Tnnn: Switch virtual tool by changing the mix
// 11526     for (uint8_t j = 0; j < MIXING_STEPPERS; j++)
// 11527       mixing_factor[j] = mixing_virtual_tool_mix[tmp_extruder][j];
// 11528 
// 11529   #else // !MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1
// 11530 
// 11531     if (tmp_extruder >= EXTRUDERS)
        CMP      R0,#+0
        BEQ.N    ??tool_change_0
// 11532       return invalid_extruder_error(tmp_extruder);
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z22invalid_extruder_errorh
        B.W      _Z22invalid_extruder_errorh
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 11533 
// 11534     #if HOTENDS > 1
// 11535 
// 11536       const float old_feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : feedrate_mm_s;
// 11537 
// 11538       feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
// 11539 
// 11540       if (tmp_extruder != active_extruder) {
// 11541         if (!no_move && axis_unhomed_error()) {
// 11542           no_move = true;
// 11543           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11544             if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("No move on toolchange");
// 11545           #endif
// 11546         }
// 11547 
// 11548         // Save current position to destination, for use later
// 11549         set_destination_from_current();
// 11550 
// 11551         #if ENABLED(DUAL_X_CARRIAGE)
// 11552 
// 11553           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11554             if (DEBUGGING(LEVELING)) {
// 11555               SERIAL_ECHOPGM("Dual X Carriage Mode ");
// 11556               switch (dual_x_carriage_mode) {
// 11557                 case DXC_FULL_CONTROL_MODE: SERIAL_ECHOLNPGM("DXC_FULL_CONTROL_MODE"); break;
// 11558                 case DXC_AUTO_PARK_MODE: SERIAL_ECHOLNPGM("DXC_AUTO_PARK_MODE"); break;
// 11559                 case DXC_DUPLICATION_MODE: SERIAL_ECHOLNPGM("DXC_DUPLICATION_MODE"); break;
// 11560               }
// 11561             }
// 11562           #endif
// 11563 
// 11564           const float xhome = x_home_pos(active_extruder);
// 11565           if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE
// 11566               && IsRunning()
// 11567               && (delayed_move_time || current_position[X_AXIS] != xhome)
// 11568           ) {
// 11569             float raised_z = current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT;
// 11570             //#if ENABLED(MAX_SOFTWARE_ENDSTOPS)
// 11571             if(mksCfg.max_software_endstops){
// 11572               NOMORE(raised_z, soft_endstop_max[Z_AXIS]);
// 11573             }
// 11574             //#endif
// 11575             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11576               if (DEBUGGING(LEVELING)) {
// 11577                 SERIAL_ECHOLNPAIR("Raise to ", raised_z);
// 11578                 SERIAL_ECHOLNPAIR("MoveX to ", xhome);
// 11579                 SERIAL_ECHOLNPAIR("Lower to ", current_position[Z_AXIS]);
// 11580               }
// 11581             #endif
// 11582             // Park old head: 1) raise 2) move to park position 3) lower
// 11583             for (uint8_t i = 0; i < 3; i++)
// 11584               planner.buffer_line(
// 11585                 i == 0 ? current_position[X_AXIS] : xhome,
// 11586                 current_position[Y_AXIS],
// 11587                 i == 2 ? current_position[Z_AXIS] : raised_z,
// 11588                 current_position[E_AXIS],
// 11589                 planner.max_feedrate_mm_s[i == 1 ? X_AXIS : Z_AXIS],
// 11590                 active_extruder
// 11591               );
// 11592             stepper.synchronize();
// 11593           }
// 11594 
// 11595           // Apply Y & Z extruder offset (X offset is used as home pos with Dual X)
// 11596           current_position[Y_AXIS] -= hotend_offset[Y_AXIS][active_extruder] - hotend_offset[Y_AXIS][tmp_extruder];
// 11597           current_position[Z_AXIS] -= hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
// 11598 
// 11599           // Activate the new extruder ahead of calling set_axis_is_at_home!
// 11600           active_extruder = tmp_extruder;
// 11601 
// 11602           // This function resets the max/min values - the current position may be overwritten below.
// 11603           set_axis_is_at_home(X_AXIS);
// 11604 
// 11605           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11606             if (DEBUGGING(LEVELING)) DEBUG_POS("New Extruder", current_position);
// 11607           #endif
// 11608 
// 11609           // Only when auto-parking are carriages safe to move
// 11610           if (dual_x_carriage_mode != DXC_AUTO_PARK_MODE) no_move = true;
// 11611 
// 11612           switch (dual_x_carriage_mode) {
// 11613             case DXC_FULL_CONTROL_MODE:
// 11614               // New current position is the position of the activated extruder
// 11615               current_position[X_AXIS] = inactive_extruder_x_pos;
// 11616               // Save the inactive extruder's position (from the old current_position)
// 11617               inactive_extruder_x_pos = destination[X_AXIS];
// 11618               break;
// 11619             case DXC_AUTO_PARK_MODE:
// 11620               // record raised toolhead position for use by unpark
// 11621               COPY(raised_parked_position, current_position);
// 11622               raised_parked_position[Z_AXIS] += TOOLCHANGE_UNPARK_ZLIFT;
// 11623               //#if ENABLED(MAX_SOFTWARE_ENDSTOPS)
// 11624               if(mksCfg.max_software_endstops){
// 11625                 NOMORE(raised_parked_position[Z_AXIS], soft_endstop_max[Z_AXIS]);
// 11626               }
// 11627               //#endif
// 11628               active_extruder_parked = true;
// 11629               delayed_move_time = 0;
// 11630               break;
// 11631             case DXC_DUPLICATION_MODE:
// 11632               // If the new extruder is the left one, set it "parked"
// 11633               // This triggers the second extruder to move into the duplication position
// 11634               active_extruder_parked = (active_extruder == 0);
// 11635 
// 11636               if (active_extruder_parked)
// 11637                 current_position[X_AXIS] = inactive_extruder_x_pos;
// 11638               else
// 11639                 current_position[X_AXIS] = destination[X_AXIS] + duplicate_extruder_x_offset;
// 11640               inactive_extruder_x_pos = destination[X_AXIS];
// 11641               extruder_duplication_enabled = false;
// 11642               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11643                 if (DEBUGGING(LEVELING)) {
// 11644                   SERIAL_ECHOLNPAIR("Set inactive_extruder_x_pos=", inactive_extruder_x_pos);
// 11645                   SERIAL_ECHOLNPGM("Clear extruder_duplication_enabled");
// 11646                 }
// 11647               #endif
// 11648               break;
// 11649           }
// 11650 
// 11651           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11652             if (DEBUGGING(LEVELING)) {
// 11653               SERIAL_ECHOLNPAIR("Active extruder parked: ", active_extruder_parked ? "yes" : "no");
// 11654               DEBUG_POS("New extruder (parked)", current_position);
// 11655             }
// 11656           #endif
// 11657 
// 11658           // No extra case for HAS_ABL in DUAL_X_CARRIAGE. Does that mean they don't work together?
// 11659 
// 11660         #else // !DUAL_X_CARRIAGE
// 11661 
// 11662           #if ENABLED(PARKING_EXTRUDER) // Dual Parking extruder
// 11663             const float z_diff = hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
// 11664             float z_raise = PARKING_EXTRUDER_SECURITY_RAISE;
// 11665             if (!no_move) {
// 11666 
// 11667               const float parkingposx[] = PARKING_EXTRUDER_PARKING_X,
// 11668                           midpos = (parkingposx[0] + parkingposx[1]) * 0.5 + hotend_offset[X_AXIS][active_extruder],
// 11669                           grabpos = parkingposx[tmp_extruder] + hotend_offset[X_AXIS][active_extruder]
// 11670                                     + (tmp_extruder == 0 ? -(PARKING_EXTRUDER_GRAB_DISTANCE) : PARKING_EXTRUDER_GRAB_DISTANCE);
// 11671               /**
// 11672                *  Steps:
// 11673                *    1. Raise Z-Axis to give enough clearance
// 11674                *    2. Move to park position of old extruder
// 11675                *    3. Disengage magnetic field, wait for delay
// 11676                *    4. Move near new extruder
// 11677                *    5. Engage magnetic field for new extruder
// 11678                *    6. Move to parking incl. offset of new extruder
// 11679                *    7. Lower Z-Axis
// 11680                */
// 11681 
// 11682               // STEP 1
// 11683               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11684                 SERIAL_ECHOLNPGM("Starting Autopark");
// 11685                 if (DEBUGGING(LEVELING)) DEBUG_POS("current position:", current_position);
// 11686               #endif
// 11687               current_position[Z_AXIS] += z_raise;
// 11688               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11689                 SERIAL_ECHOLNPGM("(1) Raise Z-Axis ");
// 11690                 if (DEBUGGING(LEVELING)) DEBUG_POS("Moving to Raised Z-Position", current_position);
// 11691               #endif
// 11692               planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
// 11693               stepper.synchronize();
// 11694 
// 11695               // STEP 2
// 11696               current_position[X_AXIS] = parkingposx[active_extruder] + hotend_offset[X_AXIS][active_extruder];
// 11697               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11698                 SERIAL_ECHOLNPAIR("(2) Park extruder ", active_extruder);
// 11699                 if (DEBUGGING(LEVELING)) DEBUG_POS("Moving ParkPos", current_position);
// 11700               #endif
// 11701               planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
// 11702               stepper.synchronize();
// 11703 
// 11704               // STEP 3
// 11705               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11706                 SERIAL_ECHOLNPGM("(3) Disengage magnet ");
// 11707               #endif
// 11708               pe_deactivate_magnet(active_extruder);
// 11709 
// 11710               // STEP 4
// 11711               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11712                 SERIAL_ECHOLNPGM("(4) Move to position near new extruder");
// 11713               #endif
// 11714               current_position[X_AXIS] += (active_extruder == 0 ? 10 : -10); // move 10mm away from parked extruder
// 11715 
// 11716               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11717                 if (DEBUGGING(LEVELING)) DEBUG_POS("Moving away from parked extruder", current_position);
// 11718               #endif
// 11719               planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
// 11720               stepper.synchronize();
// 11721 
// 11722               // STEP 5
// 11723               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11724                 SERIAL_ECHOLNPGM("(5) Engage magnetic field");
// 11725               #endif
// 11726 
// 11727               #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
// 11728                 pe_activate_magnet(active_extruder); //just save power for inverted magnets
// 11729               #endif
// 11730               pe_activate_magnet(tmp_extruder);
// 11731 
// 11732               // STEP 6
// 11733               current_position[X_AXIS] = grabpos + (tmp_extruder == 0 ? (+10) : (-10));
// 11734               planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
// 11735               current_position[X_AXIS] = grabpos;
// 11736               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11737                 SERIAL_ECHOLNPAIR("(6) Unpark extruder ", tmp_extruder);
// 11738                 if (DEBUGGING(LEVELING)) DEBUG_POS("Move UnparkPos", current_position);
// 11739               #endif
// 11740               planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS]/2, active_extruder);
// 11741               stepper.synchronize();
// 11742 
// 11743               // Step 7
// 11744               current_position[X_AXIS] = midpos - hotend_offset[X_AXIS][tmp_extruder];
// 11745               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11746                 SERIAL_ECHOLNPGM("(7) Move midway between hotends");
// 11747                 if (DEBUGGING(LEVELING)) DEBUG_POS("Move midway to new extruder", current_position);
// 11748               #endif
// 11749               planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
// 11750               stepper.synchronize();
// 11751               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11752                 SERIAL_ECHOLNPGM("Autopark done.");
// 11753               #endif
// 11754             }
// 11755             else { // nomove == true
// 11756               // Only engage magnetic field for new extruder
// 11757               pe_activate_magnet(tmp_extruder);
// 11758               #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
// 11759                 pe_activate_magnet(active_extruder); // Just save power for inverted magnets
// 11760               #endif
// 11761             }
// 11762             current_position[Z_AXIS] -= hotend_offset[Z_AXIS][tmp_extruder] - hotend_offset[Z_AXIS][active_extruder]; // Apply Zoffset
// 11763 
// 11764             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11765               if (DEBUGGING(LEVELING)) DEBUG_POS("Applying Z-offset", current_position);
// 11766             #endif
// 11767 
// 11768           #endif // dualParking extruder
// 11769 
// 11770           #if ENABLED(SWITCHING_NOZZLE)
// 11771             #define DONT_SWITCH (SWITCHING_EXTRUDER_SERVO_NR == SWITCHING_NOZZLE_SERVO_NR)
// 11772             // <0 if the new nozzle is higher, >0 if lower. A bigger raise when lower.
// 11773             const float z_diff = hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder],
// 11774                         z_raise = 0.3 + (z_diff > 0.0 ? z_diff : 0.0);
// 11775 
// 11776             // Always raise by some amount (destination copied from current_position earlier)
// 11777             current_position[Z_AXIS] += z_raise;
// 11778             planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
// 11779             move_nozzle_servo(tmp_extruder);
// 11780           #endif
// 11781 
// 11782           /**
// 11783            * Set current_position to the position of the new nozzle.
// 11784            * Offsets are based on linear distance, so we need to get
// 11785            * the resulting position in coordinate space.
// 11786            *
// 11787            * - With grid or 3-point leveling, offset XYZ by a tilted vector
// 11788            * - With mesh leveling, update Z for the new position
// 11789            * - Otherwise, just use the raw linear distance
// 11790            *
// 11791            * Software endstops are altered here too. Consider a case where:
// 11792            *   E0 at X=0 ... E1 at X=10
// 11793            * When we switch to E1 now X=10, but E1 can't move left.
// 11794            * To express this we apply the change in XY to the software endstops.
// 11795            * E1 can move farther right than E0, so the right limit is extended.
// 11796            *
// 11797            * Note that we don't adjust the Z software endstops. Why not?
// 11798            * Consider a case where Z=0 (here) and switching to E1 makes Z=1
// 11799            * because the bed is 1mm lower at the new position. As long as
// 11800            * the first nozzle is out of the way, the carriage should be
// 11801            * allowed to move 1mm lower. This technically "breaks" the
// 11802            * Z software endstop. But this is technically correct (and
// 11803            * there is no viable alternative).
// 11804            */
// 11805           #if ABL_PLANAR
// 11806             // Offset extruder, make sure to apply the bed level rotation matrix
// 11807             vector_3 tmp_offset_vec = vector_3(hotend_offset[X_AXIS][tmp_extruder],
// 11808                                                hotend_offset[Y_AXIS][tmp_extruder],
// 11809                                                0),
// 11810                      act_offset_vec = vector_3(hotend_offset[X_AXIS][active_extruder],
// 11811                                                hotend_offset[Y_AXIS][active_extruder],
// 11812                                                0),
// 11813                      offset_vec = tmp_offset_vec - act_offset_vec;
// 11814 
// 11815             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11816               if (DEBUGGING(LEVELING)) {
// 11817                 tmp_offset_vec.debug(PSTR("tmp_offset_vec"));
// 11818                 act_offset_vec.debug(PSTR("act_offset_vec"));
// 11819                 offset_vec.debug(PSTR("offset_vec (BEFORE)"));
// 11820               }
// 11821             #endif
// 11822 
// 11823             offset_vec.apply_rotation(planner.bed_level_matrix.transpose(planner.bed_level_matrix));
// 11824 
// 11825             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11826               if (DEBUGGING(LEVELING)) offset_vec.debug(PSTR("offset_vec (AFTER)"));
// 11827             #endif
// 11828 
// 11829             // Adjustments to the current position
// 11830             const float xydiff[2] = { offset_vec.x, offset_vec.y };
// 11831             current_position[Z_AXIS] += offset_vec.z;
// 11832 
// 11833           #else // !ABL_PLANAR
// 11834 
// 11835             const float xydiff[2] = {
// 11836               hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder],
// 11837               hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder]
// 11838             };
// 11839 
// 11840             #if ENABLED(MESH_BED_LEVELING)
// 11841 
// 11842               if (planner.leveling_active) {
// 11843                 #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11844                   if (DEBUGGING(LEVELING)) SERIAL_ECHOPAIR("Z before MBL: ", current_position[Z_AXIS]);
// 11845                 #endif
// 11846                 float x2 = current_position[X_AXIS] + xydiff[X_AXIS],
// 11847                       y2 = current_position[Y_AXIS] + xydiff[Y_AXIS],
// 11848                       z1 = current_position[Z_AXIS], z2 = z1;
// 11849                 planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], z1);
// 11850                 planner.apply_leveling(x2, y2, z2);
// 11851                 current_position[Z_AXIS] += z2 - z1;
// 11852                 #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11853                   if (DEBUGGING(LEVELING))
// 11854                     SERIAL_ECHOLNPAIR(" after: ", current_position[Z_AXIS]);
// 11855                 #endif
// 11856               }
// 11857 
// 11858             #endif // MESH_BED_LEVELING
// 11859 
// 11860           #endif // !HAS_ABL
// 11861 
// 11862           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11863             if (DEBUGGING(LEVELING)) {
// 11864               SERIAL_ECHOPAIR("Offset Tool XY by { ", xydiff[X_AXIS]);
// 11865               SERIAL_ECHOPAIR(", ", xydiff[Y_AXIS]);
// 11866               SERIAL_ECHOLNPGM(" }");
// 11867             }
// 11868           #endif
// 11869 
// 11870           // The newly-selected extruder XY is actually at...
// 11871           current_position[X_AXIS] += xydiff[X_AXIS];
// 11872           current_position[Y_AXIS] += xydiff[Y_AXIS];
// 11873 
// 11874           // Set the new active extruder
// 11875           active_extruder = tmp_extruder;
// 11876 
// 11877         #endif // !DUAL_X_CARRIAGE
// 11878 
// 11879         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11880           if (DEBUGGING(LEVELING)) DEBUG_POS("Sync After Toolchange", current_position);
// 11881         #endif
// 11882 
// 11883         // Tell the planner the new "current position"
// 11884         SYNC_PLAN_POSITION_KINEMATIC();
// 11885 
// 11886         // Move to the "old position" (move the extruder into place)
// 11887         #if ENABLED(SWITCHING_NOZZLE)
// 11888           destination[Z_AXIS] += z_diff;  // Include the Z restore with the "move back"
// 11889         #endif
// 11890         if (!no_move && IsRunning()) {
// 11891           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11892             if (DEBUGGING(LEVELING)) DEBUG_POS("Move back", destination);
// 11893           #endif
// 11894           // Move back to the original (or tweaked) position
// 11895           do_blocking_move_to(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS]);
// 11896         }
// 11897         #if ENABLED(SWITCHING_NOZZLE)
// 11898           else {
// 11899             // Move back down. (Including when the new tool is higher.)
// 11900             do_blocking_move_to_z(destination[Z_AXIS], planner.max_feedrate_mm_s[Z_AXIS]);
// 11901           }
// 11902         #endif
// 11903       } // (tmp_extruder != active_extruder)
// 11904 
// 11905       stepper.synchronize();
// 11906 
// 11907       #if ENABLED(EXT_SOLENOID) && !ENABLED(PARKING_EXTRUDER)
// 11908         disable_all_solenoids();
// 11909         enable_solenoid_on_active_extruder();
// 11910       #endif // EXT_SOLENOID
// 11911 
// 11912       feedrate_mm_s = old_feedrate_mm_s;
// 11913 
// 11914     #else // HOTENDS <= 1
// 11915 
// 11916       UNUSED(fr_mm_s);
// 11917       UNUSED(no_move);
// 11918 
// 11919       #if ENABLED(MK2_MULTIPLEXER)
// 11920         if (tmp_extruder >= E_STEPPERS)
// 11921           return invalid_extruder_error(tmp_extruder);
// 11922 
// 11923         select_multiplexed_stepper(tmp_extruder);
// 11924       #endif
// 11925 
// 11926       // Set the new active extruder
// 11927       active_extruder = tmp_extruder;
??tool_change_0:
        LDR.N    R4,??DataTable92_9
        MOVS     R0,#+0
        STRB     R0,[R4, #+18]
// 11928 
// 11929     #endif // HOTENDS <= 1
// 11930 
// 11931     #if ENABLED(SWITCHING_EXTRUDER) && !DONT_SWITCH
// 11932       stepper.synchronize();
// 11933       move_extruder_servo(active_extruder);
// 11934     #endif
// 11935 
// 11936     #if HAS_FANMUX
// 11937       fanmux_switch(active_extruder);
// 11938     #endif
// 11939 
// 11940     SERIAL_ECHO_START();
        LDR.W    R0,??DataTable95_2
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 11941     SERIAL_ECHOLNPAIR(MSG_ACTIVE_EXTRUDER, (int)active_extruder);
        LDRB     R1,[R4, #+18]
        ADR.W    R0,`?<Constant "Active Extruder: ">`
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
        MOVS     R1,#+10
        LDR.W    R0,??DataTable97
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
          CFI EndBlock cfiBlock44
// 11942 
// 11943   #endif // !MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1
// 11944 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable92:
        DC32     0x42700000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable92_1:
        DC8      " Z:"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable92_2:
        DC8      0x58, 0x3A, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable92_3:
        DC8      " Y:"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable92_4:
        DC8      " E:"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable92_5:
        DC8      ":",0x0,0x0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable92_6:
        DC32     card

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable92_7:
        DC32     home_dir_P

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable92_8:
        DC32     mksCfg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable92_9:
        DC32     axis_relative_modes

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Active Extruder: ">`:
        DC8 "Active Extruder: "
        DC8 0, 0
// 11945 
// 11946 /**
// 11947  * T0-T3: Switch tool, usually switching extruders
// 11948  *
// 11949  *   F[units/min] Set the movement feedrate
// 11950  *   S1           Don't move the tool in XY after change
// 11951  */
// 11952 inline void gcode_T(const uint8_t tmp_extruder) {
// 11953 
// 11954   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11955     if (DEBUGGING(LEVELING)) {
// 11956       SERIAL_ECHOPAIR(">>> gcode_T(", tmp_extruder);
// 11957       SERIAL_CHAR(')');
// 11958       SERIAL_EOL();
// 11959       DEBUG_POS("BEFORE", current_position);
// 11960     }
// 11961   #endif
// 11962 
// 11963   #if HOTENDS == 1 || (ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1)
// 11964 
// 11965     tool_change(tmp_extruder);
// 11966 
// 11967   #elif HOTENDS > 1
// 11968 
// 11969     tool_change(
// 11970       tmp_extruder,
// 11971       MMM_TO_MMS(parser.linearval('F')),
// 11972       (tmp_extruder == active_extruder) || parser.boolval('S')
// 11973     );
// 11974 
// 11975   #endif
// 11976 
// 11977   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11978     if (DEBUGGING(LEVELING)) {
// 11979       DEBUG_POS("AFTER", current_position);
// 11980       SERIAL_ECHOLNPGM("<<< gcode_T");
// 11981     }
// 11982   #endif
// 11983 }
// 11984 
// 11985 /**
// 11986  * Process the parsed command and dispatch it to its handler
// 11987  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock45 Using cfiCommon0
          CFI Function _Z22process_parsed_commandv
        THUMB
// 11988 void process_parsed_command() {
_Z22process_parsed_commandv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 11989   KEEPALIVE_STATE(IN_HANDLER);
// 11990 
// 11991   // Handle a known G, M, or T
// 11992   switch (parser.command_letter) {
        LDR.W    R0,??DataTable107
        LDRSB    R0,[R0, #+0]
        CMP      R0,#+71
        BEQ.N    ??process_parsed_command_0
        CMP      R0,#+77
        BEQ.N    ??process_parsed_command_1
        CMP      R0,#+84
        BEQ.W    ??process_parsed_command_2
        B.N      ??process_parsed_command_3
// 11993     case 'G': switch (parser.codenum) {
??process_parsed_command_0:
        LDR.W    R0,??DataTable107_1
        LDR      R0,[R0, #+0]
        MOVS     R1,R0
        BEQ.N    ??process_parsed_command_4
        CMP      R1,#+1
        BEQ.N    ??process_parsed_command_4
        CMP      R1,#+2
        BEQ.N    ??process_parsed_command_5
        CMP      R1,#+3
        BEQ.N    ??process_parsed_command_5
        CMP      R1,#+4
        BEQ.N    ??process_parsed_command_6
        CMP      R1,#+28
        BEQ.N    ??process_parsed_command_7
        CMP      R1,#+90
        BEQ.N    ??process_parsed_command_8
        CMP      R1,#+91
        BEQ.N    ??process_parsed_command_9
        CMP      R1,#+92
        BEQ.N    ??process_parsed_command_10
        B.N      ??process_parsed_command_11
// 11994 
// 11995       // G0, G1
// 11996       case 0:
// 11997       case 1:
// 11998         #if IS_SCARA
// 11999           gcode_G0_G1(parser.codenum == 0);
// 12000         #else
// 12001           gcode_G0_G1();
??process_parsed_command_4:
          CFI FunCall _Z11gcode_G0_G1v
        BL       _Z11gcode_G0_G1v
// 12002         #endif
// 12003         break;
        B.N      ??process_parsed_command_11
// 12004 
// 12005       // G2, G3
// 12006       #if ENABLED(ARC_SUPPORT) && DISABLED(SCARA)
// 12007         case 2: // G2: CW ARC
// 12008         case 3: // G3: CCW ARC
// 12009           gcode_G2_G3(parser.codenum == 2);
??process_parsed_command_5:
        CMP      R0,#+2
        BNE.N    ??process_parsed_command_12
        MOVS     R0,#+1
        B.N      ??process_parsed_command_13
??process_parsed_command_12:
        MOVS     R0,#+0
??process_parsed_command_13:
          CFI FunCall _Z11gcode_G2_G3b
        BL       _Z11gcode_G2_G3b
// 12010           break;
        B.N      ??process_parsed_command_11
// 12011       #endif
// 12012 
// 12013       // G4 Dwell
// 12014       case 4:
// 12015         gcode_G4();
??process_parsed_command_6:
          CFI FunCall _Z8gcode_G4v
        BL       _Z8gcode_G4v
// 12016         break;
        B.N      ??process_parsed_command_11
// 12017 
// 12018       #if ENABLED(BEZIER_CURVE_SUPPORT)
// 12019         case 5: // G5: Cubic B_spline
// 12020           gcode_G5();
// 12021           break;
// 12022       #endif // BEZIER_CURVE_SUPPORT
// 12023 
// 12024       #if ENABLED(FWRETRACT)
// 12025         case 10: // G10: retract
// 12026           gcode_G10();
// 12027           break;
// 12028         case 11: // G11: retract_recover
// 12029           gcode_G11();
// 12030           break;
// 12031       #endif // FWRETRACT
// 12032 
// 12033       #if ENABLED(NOZZLE_CLEAN_FEATURE)
// 12034         case 12:
// 12035           gcode_G12(); // G12: Nozzle Clean
// 12036           break;
// 12037       #endif // NOZZLE_CLEAN_FEATURE
// 12038 
// 12039       #if ENABLED(CNC_WORKSPACE_PLANES)
// 12040         case 17: // G17: Select Plane XY
// 12041           gcode_G17();
// 12042           break;
// 12043         case 18: // G18: Select Plane ZX
// 12044           gcode_G18();
// 12045           break;
// 12046         case 19: // G19: Select Plane YZ
// 12047           gcode_G19();
// 12048           break;
// 12049       #endif // CNC_WORKSPACE_PLANES
// 12050 
// 12051       #if ENABLED(INCH_MODE_SUPPORT)
// 12052         case 20: // G20: Inch Mode
// 12053           gcode_G20();
// 12054           break;
// 12055 
// 12056         case 21: // G21: MM Mode
// 12057           gcode_G21();
// 12058           break;
// 12059       #endif // INCH_MODE_SUPPORT
// 12060 
// 12061       #if ENABLED(G26_MESH_VALIDATION)
// 12062         case 26: // G26: Mesh Validation Pattern generation
// 12063           gcode_G26();
// 12064           break;
// 12065       #endif // G26_MESH_VALIDATION
// 12066 
// 12067       #if ENABLED(NOZZLE_PARK_FEATURE)
// 12068         case 27: // G27: Nozzle Park
// 12069           gcode_G27();
// 12070           break;
// 12071       #endif // NOZZLE_PARK_FEATURE
// 12072 
// 12073       case 28: // G28: Home all axes, one at a time
// 12074         #if 1
// 12075       	if (gCfgItems.breakpoint_reprint_flg == 1) break;
??process_parsed_command_7:
        LDR.W    R0,??DataTable108
        LDRB     R0,[R0, #+296]
        CMP      R0,#+1
        BEQ.W    ??process_parsed_command_11
// 12076         #endif
// 12077         gcode_G28(false);
        MOVS     R0,#+0
          CFI FunCall _Z9gcode_G28b
        BL       _Z9gcode_G28b
// 12078         break;
        B.N      ??process_parsed_command_11
// 12079 
// 12080       #if HAS_LEVELING
// 12081         case 29: // G29 Detailed Z probe, probes the bed at 3 or more points,
// 12082                  // or provides access to the UBL System if enabled.
// 12083           gcode_G29();
// 12084           break;
// 12085       #endif // HAS_LEVELING
// 12086 
// 12087       #if HAS_BED_PROBE
// 12088 
// 12089         case 30: // G30 Single Z probe
// 12090           gcode_G30();
// 12091           break;
// 12092 
// 12093         #if ENABLED(Z_PROBE_SLED)
// 12094 
// 12095             case 31: // G31: dock the sled
// 12096               gcode_G31();
// 12097               break;
// 12098 
// 12099             case 32: // G32: undock the sled
// 12100               gcode_G32();
// 12101               break;
// 12102 
// 12103         #endif // Z_PROBE_SLED
// 12104 
// 12105       #endif // HAS_BED_PROBE
// 12106 
// 12107       #if ENABLED(DELTA_AUTO_CALIBRATION)
// 12108 
// 12109         case 33: // G33: Delta Auto-Calibration
// 12110           gcode_G33();
// 12111           break;
// 12112 
// 12113       #endif // DELTA_AUTO_CALIBRATION
// 12114 
// 12115       #if ENABLED(G38_PROBE_TARGET)
// 12116         case 38: // G38.2 & G38.3
// 12117           if (parser.subcode == 2 || parser.subcode == 3)
// 12118             gcode_G38(parser.subcode == 2);
// 12119           break;
// 12120       #endif
// 12121 
// 12122       case 90: // G90
// 12123         relative_mode = false;
??process_parsed_command_8:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable108_1
        STRB     R0,[R1, #+19]
// 12124         break;
        B.N      ??process_parsed_command_11
// 12125       case 91: // G91
// 12126         relative_mode = true;
??process_parsed_command_9:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable108_1
        STRB     R0,[R1, #+19]
// 12127         break;
        B.N      ??process_parsed_command_11
// 12128 
// 12129       case 92: // G92
// 12130         gcode_G92();
??process_parsed_command_10:
          CFI FunCall _Z9gcode_G92v
        BL       _Z9gcode_G92v
// 12131         break;
        B.N      ??process_parsed_command_11
// 12132 
// 12133       #if HAS_MESH
// 12134         case 42:
// 12135           gcode_G42();
// 12136           break;
// 12137       #endif
// 12138 
// 12139       #if ENABLED(DEBUG_GCODE_PARSER)
// 12140         case 800:
// 12141           parser.debug(); // GCode Parser Test for G
// 12142           break;
// 12143       #endif
// 12144     }
// 12145     break;
// 12146 
// 12147     case 'M': switch (parser.codenum) {
??process_parsed_command_1:
        LDR.W    R0,??DataTable107_1
        LDR      R0,[R0, #+0]
        SUBS     R0,R0,#+17
        BEQ.W    ??process_parsed_command_14
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_15
        SUBS     R0,R0,#+2
        BEQ.W    ??process_parsed_command_16
        SUBS     R0,R0,#+1
        CMP      R0,#+1
        BLS.W    ??process_parsed_command_17
        SUBS     R0,R0,#+2
        BEQ.W    ??process_parsed_command_18
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_19
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_20
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_21
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_22
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_23
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_24
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_25
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_26
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_27
        SUBS     R0,R0,#+10
        BEQ.W    ??process_parsed_command_28
        SUBS     R0,R0,#+33
        BEQ.W    ??process_parsed_command_29
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_30
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_31
        SUBS     R0,R0,#+4
        BEQ.W    ??process_parsed_command_32
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_33
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_34
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_15
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_35
        SUBS     R0,R0,#+7
        BEQ.W    ??process_parsed_command_36
        SUBS     R0,R0,#+12
        BEQ.W    ??process_parsed_command_37
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_38
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_39
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_40
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_41
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_42
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_43
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_44
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_45
        SUBS     R0,R0,#+2
        BEQ.W    ??process_parsed_command_46
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_47
        SUBS     R0,R0,#+2
        BEQ.W    ??process_parsed_command_48
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_49
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_50
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_51
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_52
        SUBS     R0,R0,#+19
        BEQ.W    ??process_parsed_command_53
        SUBS     R0,R0,#+60
        BEQ.W    ??process_parsed_command_54
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_55
        SUBS     R0,R0,#+2
        BEQ.W    ??process_parsed_command_56
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_57
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_58
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_59
        SUBS     R0,R0,#+5
        BEQ.W    ??process_parsed_command_60
        SUBS     R0,R0,#+9
        BEQ.W    ??process_parsed_command_61
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_62
        SUBS     R0,R0,#+5
        BEQ.W    ??process_parsed_command_63
        SUBS     R0,R0,#+75
        BEQ.W    ??process_parsed_command_64
        SUBS     R0,R0,#+2
        BEQ.W    ??process_parsed_command_65
        SUBS     R0,R0,#+52
        BEQ.W    ??process_parsed_command_66
        SUBS     R0,R0,#+45
        BEQ.W    ??process_parsed_command_67
        SUBS     R0,R0,#+10
        BEQ.W    ??process_parsed_command_68
        SUBS     R0,R0,#+18
        BEQ.W    ??process_parsed_command_69
        SUBS     R0,R0,#+72
        BEQ.W    ??process_parsed_command_70
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_71
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_72
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_73
        MOV      R1,#+404
        SUBS     R0,R0,R1
        BEQ.W    ??process_parsed_command_74
        SUBS     R0,R0,#+21
        BEQ.N    ??process_parsed_command_75
        SUBS     R0,R0,#+70
        BEQ.N    ??process_parsed_command_76
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_77
        B.N      ??process_parsed_command_11
// 12148       #if HAS_RESUME_CONTINUE
// 12149         case 0: // M0: Unconditional stop - Wait for user button press on LCD
// 12150         case 1: // M1: Conditional stop - Wait for user button press on LCD
// 12151           gcode_M0_M1();
// 12152           break;
// 12153       #endif // ULTIPANEL
// 12154 
// 12155       #if ENABLED(SPINDLE_LASER_ENABLE)
// 12156         case 3:
// 12157           gcode_M3_M4(true);   // M3: turn spindle/laser on, set laser/spindle power/speed, set rotation direction CW
// 12158           break;               // synchronizes with movement commands
// 12159         case 4:
// 12160           gcode_M3_M4(false);  // M4: turn spindle/laser on, set laser/spindle power/speed, set rotation direction CCW
// 12161           break;               // synchronizes with movement commands
// 12162         case 5:
// 12163           gcode_M5();     // M5 - turn spindle/laser off
// 12164           break;          // synchronizes with movement commands
// 12165       #endif
// 12166       case 17: // M17: Enable all stepper motors
// 12167         gcode_M17();
??process_parsed_command_14:
          CFI FunCall _Z9gcode_M17v
        BL       _Z9gcode_M17v
// 12168         break;
        B.N      ??process_parsed_command_11
// 12169 
// 12170       #if ENABLED(SDSUPPORT)
// 12171         case 20: // M20: list SD card
// 12172           gcode_M20(); break;
??process_parsed_command_16:
          CFI FunCall _Z9gcode_M20v
        BL       _Z9gcode_M20v
        B.N      ??process_parsed_command_11
// 12173         case 21: // M21: init SD card
// 12174           //gcode_M21(); break;
// 12175         case 22: // M22: release SD card
// 12176           gcode_M22(); break;
??process_parsed_command_17:
          CFI FunCall _Z9gcode_M22v
        BL       _Z9gcode_M22v
        B.N      ??process_parsed_command_11
// 12177         case 23: // M23: Select file
// 12178           gcode_M23(); break;
??process_parsed_command_18:
          CFI FunCall _Z9gcode_M23v
        BL       _Z9gcode_M23v
        B.N      ??process_parsed_command_11
// 12179         case 24: // M24: Start SD print
// 12180           gcode_M24(); 
??process_parsed_command_19:
          CFI FunCall _Z9gcode_M24v
        BL       _Z9gcode_M24v
// 12181 
// 12182           if(mksReprint.mks_printer_state == MKS_WORKING)
        LDR.W    R0,??DataTable109
        LDRB     R0,[R0, #+3336]
        CMP      R0,#+167
        BNE.W    ??process_parsed_command_11
// 12183           {
// 12184             clear_cur_ui();
          CFI FunCall clear_cur_ui
        BL       clear_cur_ui
// 12185             reset_file_info();
          CFI FunCall reset_file_info
        BL       reset_file_info
// 12186             reset_print_time();
          CFI FunCall reset_print_time
        BL       reset_print_time
// 12187             start_print_time();
          CFI FunCall start_print_time
        BL       start_print_time
// 12188             
// 12189             preview_gcode_prehandle(curFileName);
        LDR.W    R0,??DataTable109_1
          CFI FunCall preview_gcode_prehandle
        BL       preview_gcode_prehandle
// 12190             
// 12191             draw_printing();            
          CFI FunCall draw_printing
        BL       draw_printing
        B.N      ??process_parsed_command_11
// 12192            }
// 12193           break;
// 12194         case 25: // M25: Pause SD print
// 12195             gcode_M25(); 
??process_parsed_command_20:
          CFI FunCall _Z9gcode_M25v
        BL       _Z9gcode_M25v
// 12196             if(mksReprint.mks_printer_state == MKS_PAUSING)
        LDR.W    R4,??DataTable109
        LDRB     R0,[R4, #+3336]
        CMP      R0,#+168
        BNE.W    ??process_parsed_command_11
// 12197             {
// 12198             	stop_print_time();							
          CFI FunCall stop_print_time
        BL       stop_print_time
// 12199             	clear_cur_ui();
          CFI FunCall clear_cur_ui
        BL       clear_cur_ui
// 12200             
// 12201             	card.pauseSDPrint();
        MOV      R0,R4
          CFI FunCall _ZN10CardReader12pauseSDPrintEv
        BL       _ZN10CardReader12pauseSDPrintEv
// 12202             	print_job_timer.pause();
        ADDW     R0,R4,#+3464
          CFI FunCall _ZN9Stopwatch5pauseEv
        BL       _ZN9Stopwatch5pauseEv
// 12203 
// 12204             	if(from_flash_pic==1)
        LDR.W    R0,??DataTable110
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??process_parsed_command_78
// 12205             		flash_preview_begin = 1;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable110_1
        STRB     R0,[R1, #+0]
        B.N      ??process_parsed_command_79
// 12206             	else
// 12207             		default_preview_flg = 1;							
??process_parsed_command_78:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable110_2
        STRB     R0,[R1, #+0]
// 12208 
// 12209             	draw_printing();
??process_parsed_command_79:
          CFI FunCall draw_printing
        BL       draw_printing
        B.N      ??process_parsed_command_11
// 12210             }          
// 12211           break;
// 12212         case 998:	//M998: Stop SD print
// 12213           gcode_M998(); break;			  
??process_parsed_command_76:
          CFI FunCall _Z10gcode_M998v
        BL       _Z10gcode_M998v
        B.N      ??process_parsed_command_11
// 12214         case 26: // M26: Set SD index
// 12215           gcode_M26(); break;
??process_parsed_command_21:
          CFI FunCall _Z9gcode_M26v
        BL       _Z9gcode_M26v
        B.N      ??process_parsed_command_11
// 12216         case 27: // M27: Get SD status
// 12217           gcode_M27(); break;
??process_parsed_command_22:
          CFI FunCall _Z9gcode_M27v
        BL       _Z9gcode_M27v
        B.N      ??process_parsed_command_11
// 12218         case 28: // M28: Start SD write
// 12219           gcode_M28(); break;
??process_parsed_command_23:
          CFI FunCall _Z9gcode_M28v
        BL       _Z9gcode_M28v
        B.N      ??process_parsed_command_11
// 12220         case 29: // M29: Stop SD write
// 12221           gcode_M29(); break;
??process_parsed_command_24:
          CFI FunCall _Z9gcode_M29v
        BL       _Z9gcode_M29v
        B.N      ??process_parsed_command_11
// 12222         case 30: // M30 <filename> Delete File
// 12223           gcode_M30(); break;
??process_parsed_command_25:
          CFI FunCall _Z9gcode_M30v
        BL       _Z9gcode_M30v
        B.N      ??process_parsed_command_11
// 12224         case 32: // M32: Select file and start SD print
// 12225           gcode_M32(); break;
??process_parsed_command_27:
          CFI FunCall _Z9gcode_M32v
        BL       _Z9gcode_M32v
        B.N      ??process_parsed_command_11
// 12226 
// 12227         #if ENABLED(LONG_FILENAME_HOST_SUPPORT)
// 12228           case 33: // M33: Get the long full path to a file or folder
// 12229             gcode_M33(); break;
// 12230         #endif
// 12231 
// 12232         #if ENABLED(SDCARD_SORT_ALPHA) && ENABLED(SDSORT_GCODE)
// 12233           case 34: // M34: Set SD card sorting options
// 12234             gcode_M34(); break;
// 12235         #endif // SDCARD_SORT_ALPHA && SDSORT_GCODE
// 12236 
// 12237         case 928: // M928: Start SD write
// 12238           gcode_M928(); break;
??process_parsed_command_75:
          CFI FunCall _Z10gcode_M928v
        BL       _Z10gcode_M928v
        B.N      ??process_parsed_command_11
// 12239       #endif // SDSUPPORT
// 12240 
// 12241       case 31: // M31: Report time since the start of SD print or last M109
// 12242         gcode_M31(); break;
??process_parsed_command_26:
          CFI FunCall _Z9gcode_M31v
        BL       _Z9gcode_M31v
        B.N      ??process_parsed_command_11
// 12243 
// 12244       case 42: // M42: Change pin state
// 12245         gcode_M42(); break;
??process_parsed_command_28:
          CFI FunCall _Z9gcode_M42v
        BL       _Z9gcode_M42v
        B.N      ??process_parsed_command_11
// 12246 
// 12247       #if ENABLED(PINS_DEBUGGING)
// 12248         case 43: // M43: Read pin state
// 12249           gcode_M43(); break;
// 12250       #endif
// 12251 
// 12252 
// 12253       #if ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)
// 12254         case 48: // M48: Z probe repeatability test
// 12255           gcode_M48();
// 12256           break;
// 12257       #endif // Z_MIN_PROBE_REPEATABILITY_TEST
// 12258 
// 12259       #if ENABLED(G26_MESH_VALIDATION)
// 12260         case 49: // M49: Turn on or off G26 debug flag for verbose output
// 12261           gcode_M49();
// 12262           break;
// 12263       #endif // G26_MESH_VALIDATION
// 12264 
// 12265       #if ENABLED(ULTRA_LCD) && ENABLED(LCD_SET_PROGRESS_MANUALLY)
// 12266         case 73: // M73: Set print progress percentage
// 12267           gcode_M73(); break;
// 12268       #endif
// 12269 
// 12270       case 75: // M75: Start print timer
// 12271         gcode_M75(); break;
??process_parsed_command_29:
          CFI FunCall _Z9gcode_M75v
        BL       _Z9gcode_M75v
        B.N      ??process_parsed_command_11
// 12272       case 76: // M76: Pause print timer
// 12273         gcode_M76(); break;
??process_parsed_command_30:
          CFI FunCall _Z9gcode_M76v
        BL       _Z9gcode_M76v
        B.N      ??process_parsed_command_11
// 12274       case 77: // M77: Stop print timer
// 12275         gcode_M77(); break;
??process_parsed_command_31:
          CFI FunCall _Z9gcode_M77v
        BL       _Z9gcode_M77v
        B.N      ??process_parsed_command_11
// 12276 
// 12277       #if ENABLED(PRINTCOUNTER)
// 12278         case 78: // M78: Show print statistics
// 12279           gcode_M78(); break;
// 12280       #endif
// 12281 
// 12282       #if ENABLED(M100_FREE_MEMORY_WATCHER)
// 12283         case 100: // M100: Free Memory Report
// 12284           gcode_M100();
// 12285           break;
// 12286       #endif
// 12287 
// 12288       case 104: // M104: Set hot end temperature
// 12289         gcode_M104();
??process_parsed_command_37:
          CFI FunCall _Z10gcode_M104v
        BL       _Z10gcode_M104v
// 12290         break;
        B.N      ??process_parsed_command_11
// 12291 
// 12292       case 110: // M110: Set Current Line Number
// 12293         gcode_M110();
??process_parsed_command_43:
          CFI FunCall _Z10gcode_M110v
        BL       _Z10gcode_M110v
// 12294         break;
        B.N      ??process_parsed_command_11
// 12295 
// 12296       case 111: // M111: Set debug level
// 12297         gcode_M111();
??process_parsed_command_44:
          CFI FunCall _Z10gcode_M111v
        BL       _Z10gcode_M111v
// 12298         break;
        B.N      ??process_parsed_command_11
// 12299 
// 12300       #if DISABLED(EMERGENCY_PARSER)
// 12301 
// 12302         case 108: // M108: Cancel Waiting
// 12303           gcode_M108();
??process_parsed_command_41:
          CFI FunCall _Z10gcode_M108v
        BL       _Z10gcode_M108v
// 12304           break;
        B.N      ??process_parsed_command_11
// 12305 
// 12306         case 112: // M112: Emergency Stop
// 12307           gcode_M112();
??process_parsed_command_45:
          CFI FunCall _Z10gcode_M112v
        BL       _Z10gcode_M112v
// 12308           break;
        B.N      ??process_parsed_command_11
// 12309 
// 12310         case 410: // M410 quickstop - Abort all the planned moves.
// 12311           gcode_M410();
??process_parsed_command_68:
          CFI FunCall _Z10gcode_M410v
        BL       _Z10gcode_M410v
// 12312           break;
        B.N      ??process_parsed_command_11
// 12313 
// 12314       #endif
// 12315 
// 12316       #if ENABLED(HOST_KEEPALIVE_FEATURE)
// 12317         case 113: // M113: Set Host Keepalive interval
// 12318           gcode_M113();
// 12319           break;
// 12320       #endif
// 12321 
// 12322       case 140: // M140: Set bed temperature
// 12323         gcode_M140();
??process_parsed_command_53:
          CFI FunCall _Z10gcode_M140v
        BL       _Z10gcode_M140v
// 12324         break;
        B.N      ??process_parsed_command_11
// 12325 
// 12326       case 105: // M105: Report current temperature
// 12327       	mksdlp.buzzer_tone(500,100,2);
??process_parsed_command_38:
        MOVS     R3,#+2
        MOVS     R2,#+100
        MOV      R1,#+500
        LDR.W    R0,??DataTable104
          CFI FunCall _ZN7MKS_DLP11buzzer_toneEtth
        BL       _ZN7MKS_DLP11buzzer_toneEtth
// 12328         gcode_M105();
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z10gcode_M105v
        B.W      _Z10gcode_M105v
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 12329         KEEPALIVE_STATE(NOT_BUSY);
// 12330         return; // "ok" already printed
// 12331 
// 12332       #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND || HAS_TEMP_BED)
// 12333         case 155: // M155: Set temperature auto-report interval
// 12334           gcode_M155();
// 12335           break;
// 12336       #endif
// 12337 
// 12338       case 109: // M109: Wait for hotend temperature to reach target
// 12339         gcode_M109();
??process_parsed_command_42:
          CFI FunCall _Z10gcode_M109v
        BL       _Z10gcode_M109v
// 12340         break;
        B.N      ??process_parsed_command_11
// 12341 
// 12342       #if HAS_TEMP_BED
// 12343         case 190: // M190: Wait for bed temperature to reach target
// 12344           gcode_M190();
// 12345           break;
// 12346       #endif // HAS_TEMP_BED
// 12347 
// 12348       #if FAN_COUNT > 0
// 12349         case 106: // M106: Fan On
// 12350         mksdlp.buzzer_enable(1);
??process_parsed_command_39:
        LDR.W    R4,??DataTable109
        ADDW     R4,R4,#+2500
        MOVS     R1,#+1
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP13buzzer_enableEh
        BL       _ZN7MKS_DLP13buzzer_enableEh
// 12351 		//mksdlp.buzzer_tone(1000,1000,5);
// 12352 		mksdlp.bank2disp_enable(CLEAN_USED_BANK,0,0);
        MOVS     R3,#+0
        MOV      R2,R3
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
// 12353           gcode_M106();
          CFI FunCall _Z10gcode_M106v
        BL       _Z10gcode_M106v
// 12354           break;
        B.N      ??process_parsed_command_11
// 12355         case 107: // M107: Fan Off
// 12356         mksdlp.buzzer_enable(0);
??process_parsed_command_40:
        MOVS     R1,#+0
        LDR.W    R0,??DataTable104
          CFI FunCall _ZN7MKS_DLP13buzzer_enableEh
        BL       _ZN7MKS_DLP13buzzer_enableEh
// 12357           gcode_M107();
          CFI FunCall _Z10gcode_M107v
        BL       _Z10gcode_M107v
// 12358           break;
        B.N      ??process_parsed_command_11
// 12359       #endif // FAN_COUNT > 0
// 12360 
// 12361       #if ENABLED(PARK_HEAD_ON_PAUSE)
// 12362         case 125: // M125: Store current position and move to filament change position
// 12363           gcode_M125(); break;
// 12364       #endif
// 12365 
// 12366       #if ENABLED(BARICUDA)
// 12367         // PWM for HEATER_1_PIN
// 12368         #if HAS_HEATER_1
// 12369           case 126: // M126: valve open
// 12370             gcode_M126();
// 12371             break;
// 12372           case 127: // M127: valve closed
// 12373             gcode_M127();
// 12374             break;
// 12375         #endif // HAS_HEATER_1
// 12376 
// 12377         // PWM for HEATER_2_PIN
// 12378         #if HAS_HEATER_2
// 12379           case 128: // M128: valve open
// 12380             gcode_M128();
// 12381             break;
// 12382           case 129: // M129: valve closed
// 12383             gcode_M129();
// 12384             break;
// 12385         #endif // HAS_HEATER_2
// 12386       #endif // BARICUDA
// 12387 
// 12388       #if HAS_POWER_SWITCH
// 12389 
// 12390         case 80: // M80: Turn on Power Supply
// 12391           gcode_M80();
// 12392           break;
// 12393 
// 12394       #endif // HAS_POWER_SWITCH
// 12395 
// 12396       case 81: // M81: Turn off Power, including Power Supply, if possible
// 12397         gcode_M81();
??process_parsed_command_32:
          CFI FunCall _Z9gcode_M81v
        BL       _Z9gcode_M81v
// 12398         break;
        B.N      ??process_parsed_command_11
// 12399 
// 12400       case 82: // M82: Set E axis normal mode (same as other axes)
// 12401         gcode_M82();
??process_parsed_command_33:
          CFI FunCall _Z9gcode_M82v
        BL       _Z9gcode_M82v
// 12402         break;
        B.N      ??process_parsed_command_11
// 12403       case 83: // M83: Set E axis relative mode
// 12404         gcode_M83();
??process_parsed_command_34:
          CFI FunCall _Z9gcode_M83v
        BL       _Z9gcode_M83v
// 12405         break;
        B.N      ??process_parsed_command_11
// 12406       case 18: // M18 => M84
// 12407       case 84: // M84: Disable all steppers or set timeout
// 12408         gcode_M18_M84();
??process_parsed_command_15:
          CFI FunCall _Z13gcode_M18_M84v
        BL       _Z13gcode_M18_M84v
// 12409         break;
        B.N      ??process_parsed_command_11
// 12410       case 85: // M85: Set inactivity stepper shutdown timeout
// 12411         gcode_M85();
??process_parsed_command_35:
          CFI FunCall _Z9gcode_M85v
        BL       _Z9gcode_M85v
// 12412         break;
        B.N      ??process_parsed_command_11
// 12413       case 92: // M92: Set the steps-per-unit for one or more axes
// 12414         gcode_M92();
??process_parsed_command_36:
          CFI FunCall _Z9gcode_M92v
        BL       _Z9gcode_M92v
// 12415         break;
        B.N      ??process_parsed_command_11
// 12416       case 114: // M114: Report current position
// 12417         gcode_M114();
??process_parsed_command_46:
          CFI FunCall _Z10gcode_M114v
        BL       _Z10gcode_M114v
// 12418         break;
        B.N      ??process_parsed_command_11
// 12419       case 115: // M115: Report capabilities
// 12420         gcode_M115();
??process_parsed_command_47:
          CFI FunCall _Z10gcode_M115v
        BL       _Z10gcode_M115v
// 12421         break;
        B.N      ??process_parsed_command_11
// 12422       case 117: // M117: Set LCD message text, if possible
// 12423         gcode_M117();
??process_parsed_command_48:
          CFI FunCall _Z10gcode_M117v
        BL       _Z10gcode_M117v
// 12424         break;
        B.N      ??process_parsed_command_11
// 12425       case 118: // M118: Display a message in the host console
// 12426         gcode_M118();
??process_parsed_command_49:
          CFI FunCall _Z10gcode_M118v
        BL       _Z10gcode_M118v
// 12427         break;
        B.N      ??process_parsed_command_11
// 12428       case 119: // M119: Report endstop states
// 12429         gcode_M119();
??process_parsed_command_50:
          CFI FunCall _Z10gcode_M119v
        BL       _Z10gcode_M119v
// 12430         break;
        B.N      ??process_parsed_command_11
// 12431       case 120: // M120: Enable endstops
// 12432         gcode_M120();
??process_parsed_command_51:
          CFI FunCall _Z10gcode_M120v
        BL       _Z10gcode_M120v
// 12433         break;
        B.N      ??process_parsed_command_11
// 12434       case 121: // M121: Disable endstops
// 12435         gcode_M121();
??process_parsed_command_52:
          CFI FunCall _Z10gcode_M121v
        BL       _Z10gcode_M121v
// 12436         break;
        B.N      ??process_parsed_command_11
// 12437 
// 12438       #if ENABLED(ULTIPANEL)
// 12439 
// 12440         case 145: // M145: Set material heatup parameters
// 12441           gcode_M145();
// 12442           break;
// 12443 
// 12444       #endif
// 12445 
// 12446       #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
// 12447         case 149: // M149: Set temperature units
// 12448           gcode_M149();
// 12449           break;
// 12450       #endif
// 12451 
// 12452       #if HAS_COLOR_LEDS
// 12453 
// 12454         case 150: // M150: Set Status LED Color
// 12455           gcode_M150();
// 12456           break;
// 12457 
// 12458       #endif // HAS_COLOR_LEDS
// 12459 
// 12460       #if ENABLED(MIXING_EXTRUDER)
// 12461         case 163: // M163: Set a component weight for mixing extruder
// 12462           gcode_M163();
// 12463           break;
// 12464         #if MIXING_VIRTUAL_TOOLS > 1
// 12465           case 164: // M164: Save current mix as a virtual extruder
// 12466             gcode_M164();
// 12467             break;
// 12468         #endif
// 12469         #if ENABLED(DIRECT_MIXING_IN_G1)
// 12470           case 165: // M165: Set multiple mix weights
// 12471             gcode_M165();
// 12472             break;
// 12473         #endif
// 12474       #endif
// 12475 
// 12476       #if DISABLED(NO_VOLUMETRICS)
// 12477         case 200: // M200: Set filament diameter, E to cubic units
// 12478           gcode_M200();
??process_parsed_command_54:
          CFI FunCall _Z10gcode_M200v
        BL       _Z10gcode_M200v
// 12479           break;
        B.N      ??process_parsed_command_11
// 12480       #endif
// 12481 
// 12482       case 201: // M201: Set max acceleration for print moves (units/s^2)
// 12483         gcode_M201();
??process_parsed_command_55:
          CFI FunCall _Z10gcode_M201v
        BL       _Z10gcode_M201v
// 12484         break;
        B.N      ??process_parsed_command_11
// 12485       #if 0 // Not used for Sprinter/grbl gen6
// 12486         case 202: // M202
// 12487           gcode_M202();
// 12488           break;
// 12489       #endif
// 12490       case 203: // M203: Set max feedrate (units/sec)
// 12491         gcode_M203();
??process_parsed_command_56:
          CFI FunCall _Z10gcode_M203v
        BL       _Z10gcode_M203v
// 12492         break;
        B.N      ??process_parsed_command_11
// 12493       case 204: // M204: Set acceleration
// 12494         gcode_M204();
??process_parsed_command_57:
          CFI FunCall _Z10gcode_M204v
        BL       _Z10gcode_M204v
// 12495         break;
        B.N      ??process_parsed_command_11
// 12496       case 205: // M205: Set advanced settings
// 12497         gcode_M205();
??process_parsed_command_58:
          CFI FunCall _Z10gcode_M205v
        BL       _Z10gcode_M205v
// 12498         break;
        B.N      ??process_parsed_command_11
// 12499 
// 12500       #if HAS_M206_COMMAND
// 12501         case 206: // M206: Set home offsets
// 12502           gcode_M206();
??process_parsed_command_59:
          CFI FunCall _Z10gcode_M206v
        BL       _Z10gcode_M206v
// 12503           break;
        B.N      ??process_parsed_command_11
// 12504       #endif
// 12505 
// 12506       #if ENABLED(DELTA)
// 12507         case 665: // M665: Set delta configurations
// 12508           gcode_M665();
// 12509           break;
// 12510       #endif
// 12511 
// 12512       #if ENABLED(DELTA) || ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
// 12513         case 666: // M666: Set delta or dual endstop adjustment
// 12514           gcode_M666();
// 12515           break;
// 12516       #endif
// 12517 
// 12518       #if ENABLED(FWRETRACT)
// 12519         case 207: // M207: Set Retract Length, Feedrate, and Z lift
// 12520           gcode_M207();
// 12521           break;
// 12522         case 208: // M208: Set Recover (unretract) Additional Length and Feedrate
// 12523           gcode_M208();
// 12524           break;
// 12525         case 209: // M209: Turn Automatic Retract Detection on/off
// 12526           if (MIN_AUTORETRACT <= MAX_AUTORETRACT) gcode_M209();
// 12527           break;
// 12528       #endif // FWRETRACT
// 12529 
// 12530       case 211: // M211: Enable, Disable, and/or Report software endstops
// 12531         gcode_M211();
??process_parsed_command_60:
          CFI FunCall _Z10gcode_M211v
        BL       _Z10gcode_M211v
// 12532         break;
        B.N      ??process_parsed_command_11
// 12533 
// 12534       #if HOTENDS > 1
// 12535         case 218: // M218: Set a tool offset
// 12536           gcode_M218();
// 12537           break;
// 12538       #endif // HOTENDS > 1
// 12539 
// 12540       case 220: // M220: Set Feedrate Percentage: S<percent> ("FR" on your LCD)
// 12541         gcode_M220();
??process_parsed_command_61:
          CFI FunCall _Z10gcode_M220v
        BL       _Z10gcode_M220v
// 12542         break;
        B.N      ??process_parsed_command_11
// 12543 
// 12544       case 221: // M221: Set Flow Percentage
// 12545         gcode_M221();
??process_parsed_command_62:
          CFI FunCall _Z10gcode_M221v
        BL       _Z10gcode_M221v
// 12546         break;
        B.N      ??process_parsed_command_11
// 12547 
// 12548       case 226: // M226: Wait until a pin reaches a state
// 12549         gcode_M226();
??process_parsed_command_63:
          CFI FunCall _Z10gcode_M226v
        BL       _Z10gcode_M226v
// 12550         break;
        B.N      ??process_parsed_command_11
// 12551 
// 12552       #if HAS_SERVOS
// 12553         case 280: // M280: Set servo position absolute
// 12554           gcode_M280();
// 12555           break;
// 12556       #endif // HAS_SERVOS
// 12557 
// 12558       #if ENABLED(BABYSTEPPING)
// 12559         case 290: // M290: Babystepping
// 12560           gcode_M290();
// 12561           break;
// 12562       #endif // BABYSTEPPING
// 12563 
// 12564       #if HAS_BUZZER
// 12565         case 300: // M300: Play beep tone
// 12566           gcode_M300();
// 12567           break;
// 12568       #endif // HAS_BUZZER
// 12569 
// 12570       #if ENABLED(PIDTEMP)
// 12571         case 301: // M301: Set hotend PID parameters
// 12572           gcode_M301();
??process_parsed_command_64:
          CFI FunCall _Z10gcode_M301v
        BL       _Z10gcode_M301v
// 12573           break;
        B.N      ??process_parsed_command_11
// 12574       #endif // PIDTEMP
// 12575 
// 12576       #if ENABLED(PIDTEMPBED)
// 12577         case 304: // M304: Set bed PID parameters
// 12578           gcode_M304();
// 12579           break;
// 12580       #endif // PIDTEMPBED
// 12581 
// 12582       #if defined(CHDK) || HAS_PHOTOGRAPH
// 12583         case 240: // M240: Trigger a camera by emulating a Canon RC-1 : http://www.doc-diy.net/photo/rc-1_hacked/
// 12584           gcode_M240();
// 12585           break;
// 12586       #endif // CHDK || PHOTOGRAPH_PIN
// 12587 
// 12588       #if HAS_LCD_CONTRAST
// 12589         case 250: // M250: Set LCD contrast
// 12590           gcode_M250();
// 12591           break;
// 12592       #endif // HAS_LCD_CONTRAST
// 12593 
// 12594       #if ENABLED(EXPERIMENTAL_I2CBUS)
// 12595 
// 12596         case 260: // M260: Send data to an i2c slave
// 12597           gcode_M260();
// 12598           break;
// 12599 
// 12600         case 261: // M261: Request data from an i2c slave
// 12601           gcode_M261();
// 12602           break;
// 12603 
// 12604       #endif // EXPERIMENTAL_I2CBUS
// 12605 
// 12606       #if ENABLED(PREVENT_COLD_EXTRUSION)
// 12607         case 302: // M302: Allow cold extrudes (set the minimum extrude temperature)
// 12608           gcode_M302();
// 12609           break;
// 12610       #endif // PREVENT_COLD_EXTRUSION
// 12611 
// 12612       case 303: // M303: PID autotune
// 12613         gcode_M303();
??process_parsed_command_65:
          CFI FunCall _Z10gcode_M303v
        BL       _Z10gcode_M303v
// 12614         break;
        B.N      ??process_parsed_command_11
// 12615 
// 12616       #if ENABLED(MORGAN_SCARA)
// 12617         case 360:  // M360: SCARA Theta pos1
// 12618           if (gcode_M360()) return;
// 12619           break;
// 12620         case 361:  // M361: SCARA Theta pos2
// 12621           if (gcode_M361()) return;
// 12622           break;
// 12623         case 362:  // M362: SCARA Psi pos1
// 12624           if (gcode_M362()) return;
// 12625           break;
// 12626         case 363:  // M363: SCARA Psi pos2
// 12627           if (gcode_M363()) return;
// 12628           break;
// 12629         case 364:  // M364: SCARA Psi pos3 (90 deg to Theta)
// 12630           if (gcode_M364()) return;
// 12631           break;
// 12632       #endif // SCARA
// 12633 
// 12634       case 400: // M400: Finish all moves
// 12635         gcode_M400();
??process_parsed_command_67:
          CFI FunCall _Z10gcode_M400v
        BL       _Z10gcode_M400v
// 12636         break;
        B.N      ??process_parsed_command_11
// 12637 
// 12638       #if HAS_BED_PROBE
// 12639         case 401: // M401: Deploy probe
// 12640           gcode_M401();
// 12641           break;
// 12642         case 402: // M402: Stow probe
// 12643           gcode_M402();
// 12644           break;
// 12645       #endif // HAS_BED_PROBE
// 12646 
// 12647       #if ENABLED(FILAMENT_WIDTH_SENSOR)
// 12648         case 404:  // M404: Enter the nominal filament width (3mm, 1.75mm ) N<3.0> or display nominal filament width
// 12649           gcode_M404();
// 12650           break;
// 12651         case 405:  // M405: Turn on filament sensor for control
// 12652           gcode_M405();
// 12653           break;
// 12654         case 406:  // M406: Turn off filament sensor for control
// 12655           gcode_M406();
// 12656           break;
// 12657         case 407:   // M407: Display measured filament diameter
// 12658           gcode_M407();
// 12659           break;
// 12660       #endif // FILAMENT_WIDTH_SENSOR
// 12661 
// 12662       #if HAS_LEVELING
// 12663         case 420: // M420: Enable/Disable Bed Leveling
// 12664           gcode_M420();
// 12665           break;
// 12666       #endif
// 12667 
// 12668       #if HAS_MESH
// 12669         case 421: // M421: Set a Mesh Bed Leveling Z coordinate
// 12670           gcode_M421();
// 12671           break;
// 12672       #endif
// 12673 
// 12674       #if HAS_M206_COMMAND
// 12675         case 428: // M428: Apply current_position to home_offset
// 12676           gcode_M428();
??process_parsed_command_69:
          CFI FunCall _Z10gcode_M428v
        BL       _Z10gcode_M428v
// 12677           break;
        B.N      ??process_parsed_command_11
// 12678       #endif
// 12679 
// 12680       case 500: // M500: Store settings in EEPROM
// 12681         gcode_M500();
??process_parsed_command_70:
          CFI FunCall _Z10gcode_M500v
        BL       _Z10gcode_M500v
// 12682         break;
        B.N      ??process_parsed_command_11
// 12683       case 501: // M501: Read settings from EEPROM
// 12684         gcode_M501();
??process_parsed_command_71:
          CFI FunCall _Z10gcode_M501v
        BL       _Z10gcode_M501v
// 12685         break;
        B.N      ??process_parsed_command_11
// 12686       case 502: // M502: Revert to default settings
// 12687         gcode_M502();
??process_parsed_command_72:
          CFI FunCall _Z10gcode_M502v
        BL       _Z10gcode_M502v
// 12688         break;
        B.N      ??process_parsed_command_11
// 12689 
// 12690       #if DISABLED(DISABLE_M503)
// 12691         case 503: // M503: print settings currently in memory
// 12692           gcode_M503();
??process_parsed_command_73:
          CFI FunCall _Z10gcode_M503v
        BL       _Z10gcode_M503v
// 12693           break;
        B.N      ??process_parsed_command_11
// 12694       #endif
// 12695 
// 12696       #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
// 12697         case 540: // M540: Set abort on endstop hit for SD printing
// 12698           gcode_M540();
// 12699           break;
// 12700       #endif
// 12701 
// 12702       #if HAS_BED_PROBE
// 12703         case 851: // M851: Set Z Probe Z Offset
// 12704           gcode_M851();
// 12705           break;
// 12706       #endif // HAS_BED_PROBE
// 12707 
// 12708       #if ENABLED(SKEW_CORRECTION_GCODE)
// 12709         case 852: // M852: Set Skew factors
// 12710           gcode_M852();
// 12711           break;
// 12712       #endif
// 12713 
// 12714       #if ENABLED(ADVANCED_PAUSE_FEATURE)
// 12715         case 600: // M600: Pause for filament change
// 12716           gcode_M600();
// 12717           break;
// 12718       #endif // ADVANCED_PAUSE_FEATURE
// 12719 
// 12720       #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
// 12721         case 605: // M605: Set Dual X Carriage movement mode
// 12722           gcode_M605();
// 12723           break;
// 12724       #endif // DUAL_X_CARRIAGE
// 12725 
// 12726       #if ENABLED(MK2_MULTIPLEXER)
// 12727         case 702: // M702: Unload all extruders
// 12728           gcode_M702();
// 12729           break;
// 12730       #endif
// 12731 
// 12732       #if ENABLED(LIN_ADVANCE)
// 12733         case 900: // M900: Set advance K factor.
// 12734           gcode_M900();
// 12735           break;
// 12736       #endif
// 12737 
// 12738       case 907: // M907: Set digital trimpot motor current using axis codes.
// 12739         gcode_M907();
??process_parsed_command_74:
          CFI FunCall _Z10gcode_M907v
        BL       _Z10gcode_M907v
// 12740         break;
        B.N      ??process_parsed_command_11
// 12741 
// 12742       #if HAS_DIGIPOTSS || ENABLED(DAC_STEPPER_CURRENT)
// 12743 
// 12744         case 908: // M908: Control digital trimpot directly.
// 12745           gcode_M908();
// 12746           break;
// 12747 
// 12748         #if ENABLED(DAC_STEPPER_CURRENT) // As with Printrbot RevF
// 12749 
// 12750           case 909: // M909: Print digipot/DAC current value
// 12751             gcode_M909();
// 12752             break;
// 12753 
// 12754           case 910: // M910: Commit digipot/DAC value to external EEPROM
// 12755             gcode_M910();
// 12756             break;
// 12757 
// 12758         #endif
// 12759 
// 12760       #endif // HAS_DIGIPOTSS || DAC_STEPPER_CURRENT
// 12761 
// 12762       #if ENABLED(HAVE_TMC2130) || ENABLED(HAVE_TMC2208)
// 12763         case 906: // M906: Set motor current in milliamps using axis codes X, Y, Z, E
// 12764           gcode_M906();
// 12765           break;
// 12766 
// 12767         case 911: // M911: Report TMC prewarn triggered flags
// 12768           gcode_M911();
// 12769           break;
// 12770 
// 12771         case 912: // M911: Clear TMC prewarn triggered flags
// 12772           gcode_M912();
// 12773           break;
// 12774 
// 12775         #if ENABLED(TMC_DEBUG)
// 12776           case 122:  // Debug TMC steppers
// 12777             gcode_M122();
// 12778             break;
// 12779         #endif
// 12780 
// 12781         #if ENABLED(HYBRID_THRESHOLD)
// 12782           case 913: // M913: Set HYBRID_THRESHOLD speed.
// 12783             gcode_M913();
// 12784             break;
// 12785         #endif
// 12786 
// 12787         #if ENABLED(SENSORLESS_HOMING)
// 12788           case 914: // M914: Set SENSORLESS_HOMING sensitivity.
// 12789             gcode_M914();
// 12790             break;
// 12791         #endif
// 12792 
// 12793         #if ENABLED(TMC_Z_CALIBRATION) && (Z_IS_TRINAMIC || Z2_IS_TRINAMIC)
// 12794           case 915: // M915: TMC Z axis calibration routine
// 12795             gcode_M915();
// 12796             break;
// 12797         #endif
// 12798       #endif
// 12799 
// 12800       #if HAS_MICROSTEPS
// 12801 
// 12802         case 350: // M350: Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.
// 12803           gcode_M350();
// 12804           break;
// 12805 
// 12806         case 351: // M351: Toggle MS1 MS2 pins directly, S# determines MS1 or MS2, X# sets the pin high/low.
// 12807           gcode_M351();
// 12808           break;
// 12809 
// 12810       #endif // HAS_MICROSTEPS
// 12811 
// 12812       case 355: // M355 set case light brightness
// 12813         gcode_M355();
??process_parsed_command_66:
          CFI FunCall _Z10gcode_M355v
        BL       _Z10gcode_M355v
// 12814         break;
        B.N      ??process_parsed_command_11
// 12815 
// 12816       #if ENABLED(DEBUG_GCODE_PARSER)
// 12817         case 800:
// 12818           parser.debug(); // GCode Parser Test for M
// 12819           break;
// 12820       #endif
// 12821 
// 12822       #if ENABLED(I2C_POSITION_ENCODERS)
// 12823 
// 12824         case 860: // M860 Report encoder module position
// 12825           gcode_M860();
// 12826           break;
// 12827 
// 12828         case 861: // M861 Report encoder module status
// 12829           gcode_M861();
// 12830           break;
// 12831 
// 12832         case 862: // M862 Perform axis test
// 12833           gcode_M862();
// 12834           break;
// 12835 
// 12836         case 863: // M863 Calibrate steps/mm
// 12837           gcode_M863();
// 12838           break;
// 12839 
// 12840         case 864: // M864 Change module address
// 12841           gcode_M864();
// 12842           break;
// 12843 
// 12844         case 865: // M865 Check module firmware version
// 12845           gcode_M865();
// 12846           break;
// 12847 
// 12848         case 866: // M866 Report axis error count
// 12849           gcode_M866();
// 12850           break;
// 12851 
// 12852         case 867: // M867 Toggle error correction
// 12853           gcode_M867();
// 12854           break;
// 12855 
// 12856         case 868: // M868 Set error correction threshold
// 12857           gcode_M868();
// 12858           break;
// 12859 
// 12860         case 869: // M869 Report axis error
// 12861           gcode_M869();
// 12862           break;
// 12863 
// 12864       #endif // I2C_POSITION_ENCODERS
// 12865 
// 12866       case 999: // M999: Restart after being Stopped
// 12867         gcode_M999();
??process_parsed_command_77:
          CFI FunCall _Z10gcode_M999v
        BL       _Z10gcode_M999v
// 12868         break;
        B.N      ??process_parsed_command_11
// 12869     }
// 12870     break;
// 12871 
// 12872     case 'T':
// 12873       gcode_T(parser.codenum);
??process_parsed_command_2:
        LDR.W    R0,??DataTable107_1
        LDR      R0,[R0, #+0]
        UXTB     R0,R0
          CFI FunCall _Z7gcode_Th
        BL       _Z7gcode_Th
// 12874       break;
        B.N      ??process_parsed_command_11
// 12875 
// 12876     default: parser.unknown_command_error();
??process_parsed_command_3:
        LDR.W    R0,??DataTable112
          CFI FunCall _ZN11GCodeParser21unknown_command_errorEv
        BL       _ZN11GCodeParser21unknown_command_errorEv
// 12877   }
// 12878 
// 12879   KEEPALIVE_STATE(NOT_BUSY);
// 12880 
// 12881   ok_to_send();
??process_parsed_command_11:
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z10ok_to_sendv
        B.N      _Z10ok_to_sendv
          CFI EndBlock cfiBlock45
// 12882 }
// 12883 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock46 Using cfiCommon0
          CFI Function _Z20process_next_commandv
        THUMB
// 12884 void process_next_command() {
_Z20process_next_commandv:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
// 12885   char * const current_command = command_queue[cmd_queue_index_r];
        LDR.W    R0,??DataTable108_1
        LDRB     R1,[R0, #+15]
        ADD      R2,R1,R1, LSL #+1
        ADD      R1,R0,R2, LSL #+5
        ADD      R4,R1,#+140
// 12886 
// 12887   if (DEBUGGING(ECHO)) {
        LDRB     R0,[R0, #+13]
        LSLS     R0,R0,#+31
        BPL.N    ??process_next_command_0
// 12888     SERIAL_ECHO_START();
        LDR.N    R0,??DataTable95_2
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 12889     SERIAL_ECHOLN(current_command);
        LDR.N    R5,??DataTable97
        MOV      R1,R4
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEPKc
        BL       _ZN5Print5printEPKc
        MOVS     R1,#+10
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 12890     #if ENABLED(M100_FREE_MEMORY_WATCHER)
// 12891       SERIAL_ECHOPAIR("slot:", cmd_queue_index_r);
// 12892       M100_dump_routine("   Command Queue:", (const char*)command_queue, (const char*)(command_queue + sizeof(command_queue)));
// 12893     #endif
// 12894   }
// 12895 
// 12896   // Parse the next command in the queue
// 12897   parser.parse(current_command);
??process_next_command_0:
        MOV      R0,R4
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
// 12898   process_parsed_command();
        POP      {R0,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z22process_parsed_commandv
        B.N      _Z22process_parsed_commandv
          CFI EndBlock cfiBlock46
// 12899 }
// 12900 
// 12901 /**
// 12902  * Send a "Resend: nnn" message to the host to
// 12903  * indicate that a command needs to be re-sent.
// 12904  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock47 Using cfiCommon0
          CFI Function _Z24FlushSerialRequestResendv
          CFI FunCall _Z10ok_to_sendv
        THUMB
// 12905 void FlushSerialRequestResend() {
_Z24FlushSerialRequestResendv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 12906   //char command_queue[cmd_queue_index_r][100]="Resend:";
// 12907   MYSERIAL.flush();
        LDR.N    R4,??DataTable97
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5flushEv
        BL       _ZN10USARTClass5flushEv
// 12908   SERIAL_PROTOCOLPGM(MSG_RESEND);
        ADR.W    R0,`?<Constant "Resend: ">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 12909   SERIAL_PROTOCOLLN(gcode_LastN + 1);
        MOVS     R2,#+10
        LDR.N    R0,??DataTable98
        LDR      R0,[R0, #+4]
        ADDS     R1,R0,#+1
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEli
        BL       _ZN5Print5printEli
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 12910   ok_to_send();
        POP      {R4,LR}
          CFI EndBlock cfiBlock47
        REQUIRE _Z10ok_to_sendv
        ;; // Fall through to label ok_to_send()
// 12911 }
// 12912 
// 12913 /**
// 12914  * Send an "ok" message to the host, indicating
// 12915  * that a command was successfully processed.
// 12916  *
// 12917  * If ADVANCED_OK is enabled also include:
// 12918  *   N<int>  Line number of the command, if any
// 12919  *   P<int>  Planner space remaining
// 12920  *   B<int>  Block queue space remaining
// 12921  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock48 Using cfiCommon0
          CFI Function _Z10ok_to_sendv
        THUMB
// 12922 void ok_to_send() {
_Z10ok_to_sendv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 12923   refresh_cmd_timeout();
          CFI FunCall _Z19refresh_cmd_timeoutv
        BL       _Z19refresh_cmd_timeoutv
// 12924   if (!send_ok[cmd_queue_index_r]) return;
        LDR.W    R0,??DataTable108_1
        LDRB     R1,[R0, #+15]
        ADDS     R0,R1,R0
        LDRB     R0,[R0, #+24]
        CMP      R0,#+0
        BEQ.N    ??ok_to_send_0
// 12925   SERIAL_PROTOCOLPGM(MSG_OK);
        ADR.N    R0,??DataTable99_2  ;; 0x6F, 0x6B, 0x00, 0x00
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 12926   #if ENABLED(ADVANCED_OK)
// 12927     char* p = command_queue[cmd_queue_index_r];
// 12928     if (*p == 'N') {
// 12929       SERIAL_PROTOCOL(' ');
// 12930       SERIAL_ECHO(*p++);
// 12931       while (NUMERIC_SIGNED(*p))
// 12932         SERIAL_ECHO(*p++);
// 12933     }
// 12934     SERIAL_PROTOCOLPGM(" P"); SERIAL_PROTOCOL(int(BLOCK_BUFFER_SIZE - planner.movesplanned() - 1));
// 12935     SERIAL_PROTOCOLPGM(" B"); SERIAL_PROTOCOL(BUFSIZE - commands_in_queue);
// 12936   #endif
// 12937   SERIAL_EOL();
        MOVS     R1,#+10
        LDR.N    R0,??DataTable97
        POP      {R2,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??ok_to_send_0:
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock48
// 12938 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable95:
        DC32     home_bump_mm_P

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable95_1:
        DC32     injected_commands_P

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable95_2:
        DC32     echomagic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable95_3:
        DC32     errormagic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Resend: ">`:
        DC8 "Resend: "
        DC8 0, 0, 0
// 12939 
// 12940 #if HAS_SOFTWARE_ENDSTOPS
// 12941 
// 12942   /**
// 12943    * Constrain the given coordinates to the software endstops.
// 12944    *
// 12945    * For DELTA/SCARA the XY constraint is based on the smallest
// 12946    * radius within the set software endstops.
// 12947    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock49 Using cfiCommon0
          CFI Function _Z26clamp_to_software_endstopsPf
          CFI NoCalls
        THUMB
// 12948   void clamp_to_software_endstops(float target[XYZ]) {
// 12949     if (!soft_endstops_enabled) return;
_Z26clamp_to_software_endstopsPf:
        LDR.W    R1,??DataTable108_1
        LDRB     R2,[R1, #+17]
        CMP      R2,#+0
        BEQ.N    ??clamp_to_software_endstops_0
// 12950     #if IS_KINEMATIC
// 12951       const float dist_2 = HYPOT2(target[X_AXIS], target[Y_AXIS]);
// 12952       if (dist_2 > soft_endstop_radius_2) {
// 12953         const float ratio = soft_endstop_radius / SQRT(dist_2); // 200 / 300 = 0.66
// 12954         target[X_AXIS] *= ratio;
// 12955         target[Y_AXIS] *= ratio;
// 12956       }
// 12957     #else
// 12958 		if(mksCfg.min_software_endstops)
        LDR.W    R2,??DataTable116
        LDRB     R3,[R2, #+12]
        CMP      R3,#+0
        BEQ.N    ??clamp_to_software_endstops_1
// 12959 		{
// 12960       		//#if ENABLED(MIN_SOFTWARE_ENDSTOP_X)
// 12961        	 	NOLESS(target[X_AXIS], soft_endstop_min[X_AXIS]);
        VLDR     S0,[R1, #+92]
        VLDR     S1,[R0, #0]
        VCMP.F32 S1,S0
        FMSTAT   
        BPL.N    ??clamp_to_software_endstops_2
        VSTR     S0,[R0, #0]
// 12962       		//#endif
// 12963       		//#if ENABLED(MIN_SOFTWARE_ENDSTOP_Y)
// 12964         	NOLESS(target[Y_AXIS], soft_endstop_min[Y_AXIS]);
??clamp_to_software_endstops_2:
        VLDR     S0,[R1, #+96]
        VLDR     S1,[R0, #+4]
        VCMP.F32 S1,S0
        FMSTAT   
        BPL.N    ??clamp_to_software_endstops_1
        VSTR     S0,[R0, #+4]
// 12965       		//#endif
// 12966 		}
// 12967 		if(mksCfg.max_software_endstops)
??clamp_to_software_endstops_1:
        LDRB     R3,[R2, #+13]
        CMP      R3,#+0
        BEQ.N    ??clamp_to_software_endstops_3
// 12968 		{	
// 12969       		//#if ENABLED(MAX_SOFTWARE_ENDSTOP_X)
// 12970         	NOMORE(target[X_AXIS], soft_endstop_max[X_AXIS]);
        VLDR     S0,[R1, #+104]
        VLDR     S1,[R0, #0]
        VCMP.F32 S0,S1
        FMSTAT   
        BPL.N    ??clamp_to_software_endstops_4
        VSTR     S0,[R0, #0]
// 12971       		//#endif
// 12972       		//#if ENABLED(MAX_SOFTWARE_ENDSTOP_Y)
// 12973         	NOMORE(target[Y_AXIS], soft_endstop_max[Y_AXIS]);
??clamp_to_software_endstops_4:
        VLDR     S0,[R1, #+108]
        VLDR     S1,[R0, #+4]
        VCMP.F32 S0,S1
        FMSTAT   
        BPL.N    ??clamp_to_software_endstops_3
        VSTR     S0,[R0, #+4]
// 12974       		//#endif
// 12975 		}
// 12976     #endif
// 12977 	if(mksCfg.min_software_endstops)
??clamp_to_software_endstops_3:
        LDRB     R3,[R2, #+12]
        CMP      R3,#+0
        BEQ.N    ??clamp_to_software_endstops_5
// 12978 	{
// 12979     //#if ENABLED(MIN_SOFTWARE_ENDSTOP_Z)
// 12980       NOLESS(target[Z_AXIS], soft_endstop_min[Z_AXIS]);
        VLDR     S0,[R1, #+100]
        VLDR     S1,[R0, #+8]
        VCMP.F32 S1,S0
        FMSTAT   
        BPL.N    ??clamp_to_software_endstops_5
        VSTR     S0,[R0, #+8]
// 12981     //#endif
// 12982 	}
// 12983 	if(mksCfg.max_software_endstops)
??clamp_to_software_endstops_5:
        LDRB     R2,[R2, #+13]
        CMP      R2,#+0
        BEQ.N    ??clamp_to_software_endstops_0
// 12984 	{
// 12985     //#if ENABLED(MAX_SOFTWARE_ENDSTOP_Z)
// 12986       NOMORE(target[Z_AXIS], soft_endstop_max[Z_AXIS]);
        VLDR     S0,[R1, #+112]
        VLDR     S1,[R0, #+8]
        VCMP.F32 S0,S1
        FMSTAT   
        BPL.N    ??clamp_to_software_endstops_0
        VSTR     S0,[R0, #+8]
// 12987     //#endif
// 12988 	}
// 12989 }  
??clamp_to_software_endstops_0:
        BX       LR               ;; return
          CFI EndBlock cfiBlock49
// 12990 
// 12991 #endif
// 12992 
// 12993 #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 12994 
// 12995   #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 12996     #define ABL_BG_SPACING(A) bilinear_grid_spacing_virt[A]
// 12997     #define ABL_BG_FACTOR(A)  bilinear_grid_factor_virt[A]
// 12998     #define ABL_BG_POINTS_X   ABL_GRID_POINTS_VIRT_X
// 12999     #define ABL_BG_POINTS_Y   ABL_GRID_POINTS_VIRT_Y
// 13000     #define ABL_BG_GRID(X,Y)  z_values_virt[X][Y]
// 13001   #else
// 13002     #define ABL_BG_SPACING(A) bilinear_grid_spacing[A]
// 13003     #define ABL_BG_FACTOR(A)  bilinear_grid_factor[A]
// 13004     #define ABL_BG_POINTS_X   GRID_MAX_POINTS_X
// 13005     #define ABL_BG_POINTS_Y   GRID_MAX_POINTS_Y
// 13006     #define ABL_BG_GRID(X,Y)  z_values[X][Y]
// 13007   #endif
// 13008 
// 13009   // Get the Z adjustment for non-linear bed leveling
// 13010   float bilinear_z_offset(const float raw[XYZ]) {
// 13011 
// 13012     static float z1, d2, z3, d4, L, D, ratio_x, ratio_y,
// 13013                  last_x = -999.999, last_y = -999.999;
// 13014 
// 13015     // Whole units for the grid line indices. Constrained within bounds.
// 13016     static int8_t gridx, gridy, nextx, nexty,
// 13017                   last_gridx = -99, last_gridy = -99;
// 13018 
// 13019     // XY relative to the probed area
// 13020     const float rx = raw[X_AXIS] - bilinear_start[X_AXIS],
// 13021                 ry = raw[Y_AXIS] - bilinear_start[Y_AXIS];
// 13022 
// 13023     #if ENABLED(EXTRAPOLATE_BEYOND_GRID)
// 13024       // Keep using the last grid box
// 13025       #define FAR_EDGE_OR_BOX 2
// 13026     #else
// 13027       // Just use the grid far edge
// 13028       #define FAR_EDGE_OR_BOX 1
// 13029     #endif
// 13030 
// 13031     if (last_x != rx) {
// 13032       last_x = rx;
// 13033       ratio_x = rx * ABL_BG_FACTOR(X_AXIS);
// 13034       const float gx = constrain(FLOOR(ratio_x), 0, ABL_BG_POINTS_X - FAR_EDGE_OR_BOX);
// 13035       ratio_x -= gx;      // Subtract whole to get the ratio within the grid box
// 13036 
// 13037       #if DISABLED(EXTRAPOLATE_BEYOND_GRID)
// 13038         // Beyond the grid maintain height at grid edges
// 13039         NOLESS(ratio_x, 0); // Never < 0.0. (> 1.0 is ok when nextx==gridx.)
// 13040       #endif
// 13041 
// 13042       gridx = gx;
// 13043       nextx = min(gridx + 1, ABL_BG_POINTS_X - 1);
// 13044     }
// 13045 
// 13046     if (last_y != ry || last_gridx != gridx) {
// 13047 
// 13048       if (last_y != ry) {
// 13049         last_y = ry;
// 13050         ratio_y = ry * ABL_BG_FACTOR(Y_AXIS);
// 13051         const float gy = constrain(FLOOR(ratio_y), 0, ABL_BG_POINTS_Y - FAR_EDGE_OR_BOX);
// 13052         ratio_y -= gy;
// 13053 
// 13054         #if DISABLED(EXTRAPOLATE_BEYOND_GRID)
// 13055           // Beyond the grid maintain height at grid edges
// 13056           NOLESS(ratio_y, 0); // Never < 0.0. (> 1.0 is ok when nexty==gridy.)
// 13057         #endif
// 13058 
// 13059         gridy = gy;
// 13060         nexty = min(gridy + 1, ABL_BG_POINTS_Y - 1);
// 13061       }
// 13062 
// 13063       if (last_gridx != gridx || last_gridy != gridy) {
// 13064         last_gridx = gridx;
// 13065         last_gridy = gridy;
// 13066         // Z at the box corners
// 13067         z1 = ABL_BG_GRID(gridx, gridy);       // left-front
// 13068         d2 = ABL_BG_GRID(gridx, nexty) - z1;  // left-back (delta)
// 13069         z3 = ABL_BG_GRID(nextx, gridy);       // right-front
// 13070         d4 = ABL_BG_GRID(nextx, nexty) - z3;  // right-back (delta)
// 13071       }
// 13072 
// 13073       // Bilinear interpolate. Needed since ry or gridx has changed.
// 13074                   L = z1 + d2 * ratio_y;   // Linear interp. LF -> LB
// 13075       const float R = z3 + d4 * ratio_y;   // Linear interp. RF -> RB
// 13076 
// 13077       D = R - L;
// 13078     }
// 13079 
// 13080     const float offset = L + ratio_x * D;   // the offset almost always changes
// 13081 
// 13082     /*
// 13083     static float last_offset = 0;
// 13084     if (FABS(last_offset - offset) > 0.2) {
// 13085       SERIAL_ECHOPGM("Sudden Shift at ");
// 13086       SERIAL_ECHOPAIR("x=", rx);
// 13087       SERIAL_ECHOPAIR(" / ", bilinear_grid_spacing[X_AXIS]);
// 13088       SERIAL_ECHOLNPAIR(" -> gridx=", gridx);
// 13089       SERIAL_ECHOPAIR(" y=", ry);
// 13090       SERIAL_ECHOPAIR(" / ", bilinear_grid_spacing[Y_AXIS]);
// 13091       SERIAL_ECHOLNPAIR(" -> gridy=", gridy);
// 13092       SERIAL_ECHOPAIR(" ratio_x=", ratio_x);
// 13093       SERIAL_ECHOLNPAIR(" ratio_y=", ratio_y);
// 13094       SERIAL_ECHOPAIR(" z1=", z1);
// 13095       SERIAL_ECHOPAIR(" z2=", z2);
// 13096       SERIAL_ECHOPAIR(" z3=", z3);
// 13097       SERIAL_ECHOLNPAIR(" z4=", z4);
// 13098       SERIAL_ECHOPAIR(" L=", L);
// 13099       SERIAL_ECHOPAIR(" R=", R);
// 13100       SERIAL_ECHOLNPAIR(" offset=", offset);
// 13101     }
// 13102     last_offset = offset;
// 13103     //*/
// 13104 
// 13105     return offset;
// 13106   }
// 13107 
// 13108 #endif // AUTO_BED_LEVELING_BILINEAR
// 13109 
// 13110 #if ENABLED(DELTA)
// 13111 
// 13112   /**
// 13113    * Recalculate factors used for delta kinematics whenever
// 13114    * settings have been changed (e.g., by M665).
// 13115    */
// 13116   void recalc_delta_settings() {
// 13117     const float trt[ABC] = DELTA_RADIUS_TRIM_TOWER,
// 13118                 drt[ABC] = DELTA_DIAGONAL_ROD_TRIM_TOWER;
// 13119     delta_tower[A_AXIS][X_AXIS] = cos(RADIANS(210 + delta_tower_angle_trim[A_AXIS])) * (delta_radius + trt[A_AXIS]); // front left tower
// 13120     delta_tower[A_AXIS][Y_AXIS] = sin(RADIANS(210 + delta_tower_angle_trim[A_AXIS])) * (delta_radius + trt[A_AXIS]);
// 13121     delta_tower[B_AXIS][X_AXIS] = cos(RADIANS(330 + delta_tower_angle_trim[B_AXIS])) * (delta_radius + trt[B_AXIS]); // front right tower
// 13122     delta_tower[B_AXIS][Y_AXIS] = sin(RADIANS(330 + delta_tower_angle_trim[B_AXIS])) * (delta_radius + trt[B_AXIS]);
// 13123     delta_tower[C_AXIS][X_AXIS] = cos(RADIANS( 90 + delta_tower_angle_trim[C_AXIS])) * (delta_radius + trt[C_AXIS]); // back middle tower
// 13124     delta_tower[C_AXIS][Y_AXIS] = sin(RADIANS( 90 + delta_tower_angle_trim[C_AXIS])) * (delta_radius + trt[C_AXIS]);
// 13125     delta_diagonal_rod_2_tower[A_AXIS] = sq(delta_diagonal_rod + drt[A_AXIS]);
// 13126     delta_diagonal_rod_2_tower[B_AXIS] = sq(delta_diagonal_rod + drt[B_AXIS]);
// 13127     delta_diagonal_rod_2_tower[C_AXIS] = sq(delta_diagonal_rod + drt[C_AXIS]);
// 13128     update_software_endstops(Z_AXIS);
// 13129     axis_homed[X_AXIS] = axis_homed[Y_AXIS] = axis_homed[Z_AXIS] = false;
// 13130   }
// 13131 
// 13132   #if ENABLED(DELTA_FAST_SQRT)
// 13133     /**
// 13134      * Fast inverse sqrt from Quake III Arena
// 13135      * See: https://en.wikipedia.org/wiki/Fast_inverse_square_root
// 13136      */
// 13137     float Q_rsqrt(const float number) {
// 13138       long i;
// 13139       float x2, y;
// 13140       const float threehalfs = 1.5f;
// 13141       x2 = number * 0.5f;
// 13142       y  = number;
// 13143       i  = * ( long * ) &y;                       // evil floating point bit level hacking
// 13144       i  = 0x5F3759DF - ( i >> 1 );               // what the f***?
// 13145       y  = * ( float * ) &i;
// 13146       y  = y * ( threehalfs - ( x2 * y * y ) );   // 1st iteration
// 13147       // y  = y * ( threehalfs - ( x2 * y * y ) );   // 2nd iteration, this can be removed
// 13148       return y;
// 13149     }
// 13150 
// 13151   #endif
// 13152 
// 13153   /**
// 13154    * Delta Inverse Kinematics
// 13155    *
// 13156    * Calculate the tower positions for a given machine
// 13157    * position, storing the result in the delta[] array.
// 13158    *
// 13159    * This is an expensive calculation, requiring 3 square
// 13160    * roots per segmented linear move, and strains the limits
// 13161    * of a Mega2560 with a Graphical Display.
// 13162    *
// 13163    * Suggested optimizations include:
// 13164    *
// 13165    * - Disable the home_offset (M206) and/or position_shift (G92)
// 13166    *   features to remove up to 12 float additions.
// 13167    *
// 13168    * - Use a fast-inverse-sqrt function and add the reciprocal.
// 13169    *   (see above)
// 13170    */
// 13171 
// 13172   #define DELTA_DEBUG() do { \ 
// 13173       SERIAL_ECHOPAIR("cartesian X:", raw[X_AXIS]); \ 
// 13174       SERIAL_ECHOPAIR(" Y:", raw[Y_AXIS]);          \ 
// 13175       SERIAL_ECHOLNPAIR(" Z:", raw[Z_AXIS]);        \ 
// 13176       SERIAL_ECHOPAIR("delta A:", delta[A_AXIS]);   \ 
// 13177       SERIAL_ECHOPAIR(" B:", delta[B_AXIS]);        \ 
// 13178       SERIAL_ECHOLNPAIR(" C:", delta[C_AXIS]);      \ 
// 13179     }while(0)
// 13180 
// 13181   void inverse_kinematics(const float raw[XYZ]) {
// 13182     DELTA_IK(raw);
// 13183     // DELTA_DEBUG();
// 13184   }
// 13185 
// 13186   /**
// 13187    * Calculate the highest Z position where the
// 13188    * effector has the full range of XY motion.
// 13189    */
// 13190   float delta_safe_distance_from_top() {
// 13191     float cartesian[XYZ] = { 0, 0, 0 };
// 13192     inverse_kinematics(cartesian);
// 13193     float distance = delta[A_AXIS];
// 13194     cartesian[Y_AXIS] = DELTA_PRINTABLE_RADIUS;
// 13195     inverse_kinematics(cartesian);
// 13196     return FABS(distance - delta[A_AXIS]);
// 13197   }
// 13198 
// 13199   /**
// 13200    * Delta Forward Kinematics
// 13201    *
// 13202    * See the Wikipedia article "Trilateration"
// 13203    * https://en.wikipedia.org/wiki/Trilateration
// 13204    *
// 13205    * Establish a new coordinate system in the plane of the
// 13206    * three carriage points. This system has its origin at
// 13207    * tower1, with tower2 on the X axis. Tower3 is in the X-Y
// 13208    * plane with a Z component of zero.
// 13209    * We will define unit vectors in this coordinate system
// 13210    * in our original coordinate system. Then when we calculate
// 13211    * the Xnew, Ynew and Znew values, we can translate back into
// 13212    * the original system by moving along those unit vectors
// 13213    * by the corresponding values.
// 13214    *
// 13215    * Variable names matched to Marlin, c-version, and avoid the
// 13216    * use of any vector library.
// 13217    *
// 13218    * by Andreas Hardtung 2016-06-07
// 13219    * based on a Java function from "Delta Robot Kinematics V3"
// 13220    * by Steve Graves
// 13221    *
// 13222    * The result is stored in the cartes[] array.
// 13223    */
// 13224   void forward_kinematics_DELTA(float z1, float z2, float z3) {
// 13225     // Create a vector in old coordinates along x axis of new coordinate
// 13226     const float p12[] = {
// 13227       delta_tower[B_AXIS][X_AXIS] - delta_tower[A_AXIS][X_AXIS],
// 13228       delta_tower[B_AXIS][Y_AXIS] - delta_tower[A_AXIS][Y_AXIS],
// 13229       z2 - z1
// 13230     },
// 13231 
// 13232     // Get the Magnitude of vector.
// 13233     d = SQRT(sq(p12[0]) + sq(p12[1]) + sq(p12[2])),
// 13234 
// 13235     // Create unit vector by dividing by magnitude.
// 13236     ex[3] = { p12[0] / d, p12[1] / d, p12[2] / d },
// 13237 
// 13238     // Get the vector from the origin of the new system to the third point.
// 13239     p13[3] = {
// 13240       delta_tower[C_AXIS][X_AXIS] - delta_tower[A_AXIS][X_AXIS],
// 13241       delta_tower[C_AXIS][Y_AXIS] - delta_tower[A_AXIS][Y_AXIS],
// 13242       z3 - z1
// 13243     },
// 13244 
// 13245     // Use the dot product to find the component of this vector on the X axis.
// 13246     i = ex[0] * p13[0] + ex[1] * p13[1] + ex[2] * p13[2],
// 13247 
// 13248     // Create a vector along the x axis that represents the x component of p13.
// 13249     iex[] = { ex[0] * i, ex[1] * i, ex[2] * i };
// 13250 
// 13251     // Subtract the X component from the original vector leaving only Y. We use the
// 13252     // variable that will be the unit vector after we scale it.
// 13253     float ey[3] = { p13[0] - iex[0], p13[1] - iex[1], p13[2] - iex[2] };
// 13254 
// 13255     // The magnitude of Y component
// 13256     const float j = SQRT(sq(ey[0]) + sq(ey[1]) + sq(ey[2]));
// 13257 
// 13258     // Convert to a unit vector
// 13259     ey[0] /= j; ey[1] /= j;  ey[2] /= j;
// 13260 
// 13261     // The cross product of the unit x and y is the unit z
// 13262     // float[] ez = vectorCrossProd(ex, ey);
// 13263     const float ez[3] = {
// 13264       ex[1] * ey[2] - ex[2] * ey[1],
// 13265       ex[2] * ey[0] - ex[0] * ey[2],
// 13266       ex[0] * ey[1] - ex[1] * ey[0]
// 13267     },
// 13268     // We now have the d, i and j values defined in Wikipedia.
// 13269     // Plug them into the equations defined in Wikipedia for Xnew, Ynew and Znew
// 13270     Xnew = (delta_diagonal_rod_2_tower[A_AXIS] - delta_diagonal_rod_2_tower[B_AXIS] + sq(d)) / (d * 2),
// 13271     Ynew = ((delta_diagonal_rod_2_tower[A_AXIS] - delta_diagonal_rod_2_tower[C_AXIS] + HYPOT2(i, j)) / 2 - i * Xnew) / j,
// 13272     Znew = SQRT(delta_diagonal_rod_2_tower[A_AXIS] - HYPOT2(Xnew, Ynew));
// 13273 
// 13274     // Start from the origin of the old coordinates and add vectors in the
// 13275     // old coords that represent the Xnew, Ynew and Znew to find the point
// 13276     // in the old system.
// 13277     cartes[X_AXIS] = delta_tower[A_AXIS][X_AXIS] + ex[0] * Xnew + ey[0] * Ynew - ez[0] * Znew;
// 13278     cartes[Y_AXIS] = delta_tower[A_AXIS][Y_AXIS] + ex[1] * Xnew + ey[1] * Ynew - ez[1] * Znew;
// 13279     cartes[Z_AXIS] =             z1 + ex[2] * Xnew + ey[2] * Ynew - ez[2] * Znew;
// 13280   }
// 13281 
// 13282   void forward_kinematics_DELTA(float point[ABC]) {
// 13283     forward_kinematics_DELTA(point[A_AXIS], point[B_AXIS], point[C_AXIS]);
// 13284   }
// 13285 
// 13286 #endif // DELTA
// 13287 
// 13288 /**
// 13289  * Get the stepper positions in the cartes[] array.
// 13290  * Forward kinematics are applied for DELTA and SCARA.
// 13291  *
// 13292  * The result is in the current coordinate space with
// 13293  * leveling applied. The coordinates need to be run through
// 13294  * unapply_leveling to obtain machine coordinates suitable
// 13295  * for current_position, etc.
// 13296  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock50 Using cfiCommon0
          CFI Function _Z27get_cartesian_from_steppersv
        THUMB
// 13297 void get_cartesian_from_steppers() {
_Z27get_cartesian_from_steppersv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 13298   #if ENABLED(DELTA)
// 13299     forward_kinematics_DELTA(
// 13300       stepper.get_axis_position_mm(A_AXIS),
// 13301       stepper.get_axis_position_mm(B_AXIS),
// 13302       stepper.get_axis_position_mm(C_AXIS)
// 13303     );
// 13304   #else
// 13305     #if IS_SCARA
// 13306       forward_kinematics_SCARA(
// 13307         stepper.get_axis_position_degrees(A_AXIS),
// 13308         stepper.get_axis_position_degrees(B_AXIS)
// 13309       );
// 13310     #else
// 13311       cartes[X_AXIS] = stepper.get_axis_position_mm(X_AXIS);
        LDR.W    R4,??DataTable117
        MOVS     R0,#+0
          CFI FunCall _ZN7Stepper20get_axis_position_mmE8AxisEnum
        BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
        VSTR     S0,[R4, #0]
// 13312       cartes[Y_AXIS] = stepper.get_axis_position_mm(Y_AXIS);
        MOVS     R0,#+1
          CFI FunCall _ZN7Stepper20get_axis_position_mmE8AxisEnum
        BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
        VSTR     S0,[R4, #+4]
// 13313     #endif
// 13314     cartes[Z_AXIS] = stepper.get_axis_position_mm(Z_AXIS);
        MOVS     R0,#+2
          CFI FunCall _ZN7Stepper20get_axis_position_mmE8AxisEnum
        BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
        VSTR     S0,[R4, #+8]
// 13315   #endif
// 13316 }
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock50

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable97:
        DC32     Serial6
// 13317 
// 13318 /**
// 13319  * Set the current_position for an axis based on
// 13320  * the stepper positions, removing any leveling that
// 13321  * may have been applied.
// 13322  *
// 13323  * To prevent small shifts in axis position always call
// 13324  * SYNC_PLAN_POSITION_KINEMATIC after updating axes with this.
// 13325  *
// 13326  * To keep hosts in sync, always call report_current_position
// 13327  * after updating the current_position.
// 13328  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock51 Using cfiCommon0
          CFI Function _Z34set_current_from_steppers_for_axis8AxisEnum
        THUMB
// 13329 void set_current_from_steppers_for_axis(const AxisEnum axis) {
_Z34set_current_from_steppers_for_axis8AxisEnum:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
// 13330   get_cartesian_from_steppers();
          CFI FunCall _Z27get_cartesian_from_steppersv
        BL       _Z27get_cartesian_from_steppersv
// 13331   #if PLANNER_LEVELING
// 13332     planner.unapply_leveling(cartes);
// 13333   #endif
// 13334   if (axis == ALL_AXES)
        LDR.W    R0,??DataTable108_1
        LDR.W    R1,??DataTable117
        CMP      R4,#+100
        BNE.N    ??set_current_from_steppers_for_axis_0
// 13335     COPY(current_position, cartes);
        MOVS     R2,#+12
        ADDS     R0,R0,#+32
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall memcpy
        B.W      memcpy
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 13336   else
// 13337     current_position[axis] = cartes[axis];
??set_current_from_steppers_for_axis_0:
        ADD      R0,R0,R4, LSL #+2
        LDR      R1,[R1, R4, LSL #+2]
        STR      R1,[R0, #+32]
// 13338 }
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock51

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable98:
        DC32     Running
// 13339 
// 13340 #if IS_CARTESIAN
// 13341 #if ENABLED(SEGMENT_LEVELED_MOVES)
// 13342 
// 13343   /**
// 13344    * Prepare a segmented move on a CARTESIAN setup.
// 13345    *
// 13346    * This calls planner.buffer_line several times, adding
// 13347    * small incremental moves. This allows the planner to
// 13348    * apply more detailed bed leveling to the full move.
// 13349    */
// 13350   inline void segmented_line_to_destination(const float &fr_mm_s, const float segment_size=LEVELED_SEGMENT_LENGTH) {
// 13351 
// 13352     const float xdiff = destination[X_AXIS] - current_position[X_AXIS],
// 13353                 ydiff = destination[Y_AXIS] - current_position[Y_AXIS];
// 13354 
// 13355     // If the move is only in Z/E don't split up the move
// 13356     if (!xdiff && !ydiff) {
// 13357       planner.buffer_line_kinematic(destination, fr_mm_s, active_extruder);
// 13358       return;
// 13359     }
// 13360 
// 13361     // Remaining cartesian distances
// 13362     const float zdiff = destination[Z_AXIS] - current_position[Z_AXIS],
// 13363                 ediff = destination[E_AXIS] - current_position[E_AXIS];
// 13364 
// 13365     // Get the linear distance in XYZ
// 13366     // If the move is very short, check the E move distance
// 13367     // No E move either? Game over.
// 13368     float cartesian_mm = SQRT(sq(xdiff) + sq(ydiff) + sq(zdiff));
// 13369     if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = FABS(ediff);
// 13370     if (UNEAR_ZERO(cartesian_mm)) return;
// 13371 
// 13372     // The length divided by the segment size
// 13373     // At least one segment is required
// 13374     uint16_t segments = cartesian_mm / segment_size;
// 13375     NOLESS(segments, 1);
// 13376 
// 13377     // The approximate length of each segment
// 13378     const float inv_segments = 1.0 / float(segments),
// 13379                 segment_distance[XYZE] = {
// 13380                   xdiff * inv_segments,
// 13381                   ydiff * inv_segments,
// 13382                   zdiff * inv_segments,
// 13383                   ediff * inv_segments
// 13384                 };
// 13385 
// 13386     // SERIAL_ECHOPAIR("mm=", cartesian_mm);
// 13387     // SERIAL_ECHOLNPAIR(" segments=", segments);
// 13388 
// 13389     // Get the raw current position as starting point
// 13390     float raw[XYZE];
// 13391     COPY(raw, current_position);
// 13392 
// 13393     // Calculate and execute the segments
// 13394     while (--segments) {
// 13395       static millis_t next_idle_ms = millis() + 200UL;
// 13396       thermalManager.manage_heater();  // This returns immediately if not really needed.
// 13397       if (ELAPSED(millis(), next_idle_ms)) {
// 13398         next_idle_ms = millis() + 200UL;
// 13399         idle();
// 13400       }
// 13401       LOOP_XYZE(i) raw[i] += segment_distance[i];
// 13402       planner.buffer_line_kinematic(raw, fr_mm_s, active_extruder);
// 13403     }
// 13404 
// 13405     // Since segment_distance is only approximate,
// 13406     // the final move must be to the exact destination.
// 13407     planner.buffer_line_kinematic(destination, fr_mm_s, active_extruder);
// 13408   }
// 13409 
// 13410 #elif ENABLED(MESH_BED_LEVELING)
// 13411 
// 13412   /**
// 13413    * Prepare a mesh-leveled linear move in a Cartesian setup,
// 13414    * splitting the move where it crosses mesh borders.
// 13415    */
// 13416   void mesh_line_to_destination(const float fr_mm_s, uint8_t x_splits=0xFF, uint8_t y_splits=0xFF) {
// 13417     // Get current and destination cells for this line
// 13418     int cx1 = mbl.cell_index_x(current_position[X_AXIS]),
// 13419         cy1 = mbl.cell_index_y(current_position[Y_AXIS]),
// 13420         cx2 = mbl.cell_index_x(destination[X_AXIS]),
// 13421         cy2 = mbl.cell_index_y(destination[Y_AXIS]);
// 13422     NOMORE(cx1, GRID_MAX_POINTS_X - 2);
// 13423     NOMORE(cy1, GRID_MAX_POINTS_Y - 2);
// 13424     NOMORE(cx2, GRID_MAX_POINTS_X - 2);
// 13425     NOMORE(cy2, GRID_MAX_POINTS_Y - 2);
// 13426 
// 13427     // Start and end in the same cell? No split needed.
// 13428     if (cx1 == cx2 && cy1 == cy2) {
// 13429       buffer_line_to_destination(fr_mm_s);
// 13430       set_current_from_destination();
// 13431       return;
// 13432     }
// 13433 
// 13434     #define MBL_SEGMENT_END(A) (current_position[A ##_AXIS] + (destination[A ##_AXIS] - current_position[A ##_AXIS]) * normalized_dist)
// 13435 
// 13436     float normalized_dist, end[XYZE];
// 13437     const int8_t gcx = max(cx1, cx2), gcy = max(cy1, cy2);
// 13438 
// 13439     // Crosses on the X and not already split on this X?
// 13440     // The x_splits flags are insurance against rounding errors.
// 13441     if (cx2 != cx1 && TEST(x_splits, gcx)) {
// 13442       // Split on the X grid line
// 13443       CBI(x_splits, gcx);
// 13444       COPY(end, destination);
// 13445       destination[X_AXIS] = mbl.index_to_xpos[gcx];
// 13446       normalized_dist = (destination[X_AXIS] - current_position[X_AXIS]) / (end[X_AXIS] - current_position[X_AXIS]);
// 13447       destination[Y_AXIS] = MBL_SEGMENT_END(Y);
// 13448     }
// 13449     // Crosses on the Y and not already split on this Y?
// 13450     else if (cy2 != cy1 && TEST(y_splits, gcy)) {
// 13451       // Split on the Y grid line
// 13452       CBI(y_splits, gcy);
// 13453       COPY(end, destination);
// 13454       destination[Y_AXIS] = mbl.index_to_ypos[gcy];
// 13455       normalized_dist = (destination[Y_AXIS] - current_position[Y_AXIS]) / (end[Y_AXIS] - current_position[Y_AXIS]);
// 13456       destination[X_AXIS] = MBL_SEGMENT_END(X);
// 13457     }
// 13458     else {
// 13459       // Must already have been split on these border(s)
// 13460       buffer_line_to_destination(fr_mm_s);
// 13461       set_current_from_destination();
// 13462       return;
// 13463     }
// 13464 
// 13465     destination[Z_AXIS] = MBL_SEGMENT_END(Z);
// 13466     destination[E_AXIS] = MBL_SEGMENT_END(E);
// 13467 
// 13468     // Do the split and look for more borders
// 13469     mesh_line_to_destination(fr_mm_s, x_splits, y_splits);
// 13470 
// 13471     // Restore destination from stack
// 13472     COPY(destination, end);
// 13473     mesh_line_to_destination(fr_mm_s, x_splits, y_splits);
// 13474   }
// 13475 
// 13476 #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 13477 
// 13478   #define CELL_INDEX(A,V) ((V - bilinear_start[A##_AXIS]) * ABL_BG_FACTOR(A##_AXIS))
// 13479 
// 13480   /**
// 13481    * Prepare a bilinear-leveled linear move on Cartesian,
// 13482    * splitting the move where it crosses grid borders.
// 13483    */
// 13484   void bilinear_line_to_destination(const float fr_mm_s, uint16_t x_splits=0xFFFF, uint16_t y_splits=0xFFFF) {
// 13485     // Get current and destination cells for this line
// 13486     int cx1 = CELL_INDEX(X, current_position[X_AXIS]),
// 13487         cy1 = CELL_INDEX(Y, current_position[Y_AXIS]),
// 13488         cx2 = CELL_INDEX(X, destination[X_AXIS]),
// 13489         cy2 = CELL_INDEX(Y, destination[Y_AXIS]);
// 13490     cx1 = constrain(cx1, 0, ABL_BG_POINTS_X - 2);
// 13491     cy1 = constrain(cy1, 0, ABL_BG_POINTS_Y - 2);
// 13492     cx2 = constrain(cx2, 0, ABL_BG_POINTS_X - 2);
// 13493     cy2 = constrain(cy2, 0, ABL_BG_POINTS_Y - 2);
// 13494 
// 13495     // Start and end in the same cell? No split needed.
// 13496     if (cx1 == cx2 && cy1 == cy2) {
// 13497       buffer_line_to_destination(fr_mm_s);
// 13498       set_current_from_destination();
// 13499       return;
// 13500     }
// 13501 
// 13502     #define LINE_SEGMENT_END(A) (current_position[A ##_AXIS] + (destination[A ##_AXIS] - current_position[A ##_AXIS]) * normalized_dist)
// 13503 
// 13504     float normalized_dist, end[XYZE];
// 13505     const int8_t gcx = max(cx1, cx2), gcy = max(cy1, cy2);
// 13506 
// 13507     // Crosses on the X and not already split on this X?
// 13508     // The x_splits flags are insurance against rounding errors.
// 13509     if (cx2 != cx1 && TEST(x_splits, gcx)) {
// 13510       // Split on the X grid line
// 13511       CBI(x_splits, gcx);
// 13512       COPY(end, destination);
// 13513       destination[X_AXIS] = bilinear_start[X_AXIS] + ABL_BG_SPACING(X_AXIS) * gcx;
// 13514       normalized_dist = (destination[X_AXIS] - current_position[X_AXIS]) / (end[X_AXIS] - current_position[X_AXIS]);
// 13515       destination[Y_AXIS] = LINE_SEGMENT_END(Y);
// 13516     }
// 13517     // Crosses on the Y and not already split on this Y?
// 13518     else if (cy2 != cy1 && TEST(y_splits, gcy)) {
// 13519       // Split on the Y grid line
// 13520       CBI(y_splits, gcy);
// 13521       COPY(end, destination);
// 13522       destination[Y_AXIS] = bilinear_start[Y_AXIS] + ABL_BG_SPACING(Y_AXIS) * gcy;
// 13523       normalized_dist = (destination[Y_AXIS] - current_position[Y_AXIS]) / (end[Y_AXIS] - current_position[Y_AXIS]);
// 13524       destination[X_AXIS] = LINE_SEGMENT_END(X);
// 13525     }
// 13526     else {
// 13527       // Must already have been split on these border(s)
// 13528       buffer_line_to_destination(fr_mm_s);
// 13529       set_current_from_destination();
// 13530       return;
// 13531     }
// 13532 
// 13533     destination[Z_AXIS] = LINE_SEGMENT_END(Z);
// 13534     destination[E_AXIS] = LINE_SEGMENT_END(E);
// 13535 
// 13536     // Do the split and look for more borders
// 13537     bilinear_line_to_destination(fr_mm_s, x_splits, y_splits);
// 13538 
// 13539     // Restore destination from stack
// 13540     COPY(destination, end);
// 13541     bilinear_line_to_destination(fr_mm_s, x_splits, y_splits);
// 13542   }
// 13543 
// 13544 #endif // AUTO_BED_LEVELING_BILINEAR
// 13545 #endif // IS_CARTESIAN
// 13546 
// 13547 #if !UBL_SEGMENTED
// 13548 #if IS_KINEMATIC
// 13549 
// 13550   /**
// 13551    * Prepare a linear move in a DELTA or SCARA setup.
// 13552    *
// 13553    * This calls planner.buffer_line several times, adding
// 13554    * small incremental moves for DELTA or SCARA.
// 13555    *
// 13556    * For Unified Bed Leveling (Delta or Segmented Cartesian)
// 13557    * the ubl.prepare_segmented_line_to method replaces this.
// 13558    */
// 13559   inline bool prepare_kinematic_move_to(const float (&rtarget)[XYZE]) {
// 13560 
// 13561     // Get the top feedrate of the move in the XY plane
// 13562     const float _feedrate_mm_s = MMS_SCALED(feedrate_mm_s);
// 13563 
// 13564     const float xdiff = rtarget[X_AXIS] - current_position[X_AXIS],
// 13565                 ydiff = rtarget[Y_AXIS] - current_position[Y_AXIS];
// 13566 
// 13567     // If the move is only in Z/E don't split up the move
// 13568     if (!xdiff && !ydiff) {
// 13569       planner.buffer_line_kinematic(rtarget, _feedrate_mm_s, active_extruder);
// 13570       return false; // caller will update current_position
// 13571     }
// 13572 
// 13573     // Fail if attempting move outside printable radius
// 13574     if (!position_is_reachable(rtarget[X_AXIS], rtarget[Y_AXIS])) return true;
// 13575 
// 13576     // Remaining cartesian distances
// 13577     const float zdiff = rtarget[Z_AXIS] - current_position[Z_AXIS],
// 13578                 ediff = rtarget[E_AXIS] - current_position[E_AXIS];
// 13579 
// 13580     // Get the linear distance in XYZ
// 13581     // If the move is very short, check the E move distance
// 13582     // No E move either? Game over.
// 13583     float cartesian_mm = SQRT(sq(xdiff) + sq(ydiff) + sq(zdiff));
// 13584     if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = FABS(ediff);
// 13585     if (UNEAR_ZERO(cartesian_mm)) return true;
// 13586 
// 13587     // Minimum number of seconds to move the given distance
// 13588     const float seconds = cartesian_mm / _feedrate_mm_s;
// 13589 
// 13590     // The number of segments-per-second times the duration
// 13591     // gives the number of segments
// 13592     uint16_t segments = delta_segments_per_second * seconds;
// 13593 
// 13594     // For SCARA minimum segment size is 0.25mm
// 13595     #if IS_SCARA
// 13596       NOMORE(segments, cartesian_mm * 4);
// 13597     #endif
// 13598 
// 13599     // At least one segment is required
// 13600     NOLESS(segments, 1);
// 13601 
// 13602     // The approximate length of each segment
// 13603     const float inv_segments = 1.0 / float(segments),
// 13604                 segment_distance[XYZE] = {
// 13605                   xdiff * inv_segments,
// 13606                   ydiff * inv_segments,
// 13607                   zdiff * inv_segments,
// 13608                   ediff * inv_segments
// 13609                 };
// 13610 
// 13611     // SERIAL_ECHOPAIR("mm=", cartesian_mm);
// 13612     // SERIAL_ECHOPAIR(" seconds=", seconds);
// 13613     // SERIAL_ECHOLNPAIR(" segments=", segments);
// 13614 
// 13615     #if ENABLED(SCARA_FEEDRATE_SCALING)
// 13616       // SCARA needs to scale the feed rate from mm/s to degrees/s
// 13617       // i.e., Complete the angular vector in the given time.
// 13618       const float inv_segment_length = min(10.0, float(segments) / cartesian_mm), // 1/mm/segs
// 13619                   inverse_secs = inv_segment_length * _feedrate_mm_s;
// 13620       float oldA = stepper.get_axis_position_degrees(A_AXIS),
// 13621             oldB = stepper.get_axis_position_degrees(B_AXIS);
// 13622     #endif
// 13623 
// 13624     // Get the current position as starting point
// 13625     float raw[XYZE];
// 13626     COPY(raw, current_position);
// 13627 
// 13628 
// 13629     // Calculate and execute the segments
// 13630     while (--segments) {
// 13631 
// 13632       static millis_t next_idle_ms = millis() + 200UL;
// 13633       thermalManager.manage_heater();  // This returns immediately if not really needed.
// 13634       if (ELAPSED(millis(), next_idle_ms)) {
// 13635         next_idle_ms = millis() + 200UL;
// 13636         idle();
// 13637       }
// 13638 
// 13639       LOOP_XYZE(i) raw[i] += segment_distance[i];
// 13640       #if ENABLED(DELTA)
// 13641         DELTA_IK(raw); // Delta can inline its kinematics
// 13642       #else
// 13643         inverse_kinematics(raw);
// 13644       #endif
// 13645 
// 13646       ADJUST_DELTA(raw); // Adjust Z if bed leveling is enabled
// 13647 
// 13648       #if ENABLED(SCARA_FEEDRATE_SCALING)
// 13649         // For SCARA scale the feed rate from mm/s to degrees/s
// 13650         // i.e., Complete the angular vector in the given time.
// 13651         planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], raw[Z_AXIS], raw[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
// 13652         oldA = delta[A_AXIS]; oldB = delta[B_AXIS];
// 13653       #else
// 13654           if (gCfgItems.breakpoint_reprint_flg == 1) 
// 13655           {
// 13656               if (rtarget[Z_AXIS] < gCfgItems.breakpoint_z_pos) 
// 13657               {
// 13658                   current_position[Z_AXIS] = rtarget[Z_AXIS];
// 13659                   current_position[E_AXIS] = destination[E_AXIS];
// 13660                   return;
// 13661               }
// 13662           }
// 13663         //gCfgItems.breakpoint_reprint_flg = 0;
// 13664         planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], _feedrate_mm_s, active_extruder);
// 13665       #endif
// 13666     }
// 13667 
// 13668     // Ensure last segment arrives at target location.
// 13669     #if ENABLED(SCARA_FEEDRATE_SCALING)
// 13670       inverse_kinematics(rtarget);
// 13671       ADJUST_DELTA(rtarget);
// 13672       planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], rtarget[Z_AXIS], rtarget[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
// 13673     #else
// 13674       planner.buffer_line_kinematic(rtarget, _feedrate_mm_s, active_extruder);
// 13675     #endif
// 13676 
// 13677     return false; // caller will update current_position
// 13678   }
// 13679 
// 13680 #else // !IS_KINEMATIC
// 13681 
// 13682   /**
// 13683    * Prepare a linear move in a Cartesian setup.
// 13684    *
// 13685    * When a mesh-based leveling system is active, moves are segmented
// 13686    * according to the configuration of the leveling system.
// 13687    *
// 13688    * Returns true if current_position[] was set to destination[]
// 13689    */
// 13690   inline bool prepare_move_to_destination_cartesian() {
// 13691     #if HAS_MESH
// 13692       if (planner.leveling_active && planner.leveling_active_at_z(destination[Z_AXIS])) {
// 13693         #if ENABLED(AUTO_BED_LEVELING_UBL)
// 13694           ubl.line_to_destination_cartesian(MMS_SCALED(feedrate_mm_s), active_extruder);  // UBL's motion routine needs to know about
// 13695           return true;                                                                    // all moves, including Z-only moves.
// 13696         #elif ENABLED(SEGMENT_LEVELED_MOVES)
// 13697           segmented_line_to_destination(MMS_SCALED(feedrate_mm_s));
// 13698           return false; // caller will update current_position
// 13699         #else
// 13700           /**
// 13701            * For MBL and ABL-BILINEAR only segment moves when X or Y are involved.
// 13702            * Otherwise fall through to do a direct single move.
// 13703            */
// 13704           if (current_position[X_AXIS] != destination[X_AXIS] || current_position[Y_AXIS] != destination[Y_AXIS]) {
// 13705             #if ENABLED(MESH_BED_LEVELING)
// 13706               mesh_line_to_destination(MMS_SCALED(feedrate_mm_s));
// 13707             #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 13708               bilinear_line_to_destination(MMS_SCALED(feedrate_mm_s));
// 13709             #endif
// 13710             return true;
// 13711           }
// 13712         #endif
// 13713       }
// 13714     #endif // HAS_MESH
// 13715 
// 13716     buffer_line_to_destination(MMS_SCALED(feedrate_mm_s));
// 13717     return false; // caller will update current_position
// 13718   }
// 13719 
// 13720 #endif // !IS_KINEMATIC
// 13721 #endif // !UBL_SEGMENTED
// 13722 
// 13723 #if ENABLED(DUAL_X_CARRIAGE)
// 13724 
// 13725   /**
// 13726    * Unpark the carriage, if needed
// 13727    */
// 13728   inline bool dual_x_carriage_unpark() {
// 13729     if (active_extruder_parked)
// 13730       switch (dual_x_carriage_mode) {
// 13731 
// 13732         case DXC_FULL_CONTROL_MODE: break;
// 13733 
// 13734         case DXC_AUTO_PARK_MODE:
// 13735           if (current_position[E_AXIS] == destination[E_AXIS]) {
// 13736             // This is a travel move (with no extrusion)
// 13737             // Skip it, but keep track of the current position
// 13738             // (so it can be used as the start of the next non-travel move)
// 13739             if (delayed_move_time != 0xFFFFFFFFUL) {
// 13740               set_current_from_destination();
// 13741               NOLESS(raised_parked_position[Z_AXIS], destination[Z_AXIS]);
// 13742               delayed_move_time = millis();
// 13743               return true;
// 13744             }
// 13745           }
// 13746           // unpark extruder: 1) raise, 2) move into starting XY position, 3) lower
// 13747           for (uint8_t i = 0; i < 3; i++)
// 13748             planner.buffer_line(
// 13749               i == 0 ? raised_parked_position[X_AXIS] : current_position[X_AXIS],
// 13750               i == 0 ? raised_parked_position[Y_AXIS] : current_position[Y_AXIS],
// 13751               i == 2 ? current_position[Z_AXIS] : raised_parked_position[Z_AXIS],
// 13752               current_position[E_AXIS],
// 13753               i == 1 ? PLANNER_XY_FEEDRATE() : planner.max_feedrate_mm_s[Z_AXIS],
// 13754               active_extruder
// 13755             );
// 13756           delayed_move_time = 0;
// 13757           active_extruder_parked = false;
// 13758           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 13759             if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Clear active_extruder_parked");
// 13760           #endif
// 13761           break;
// 13762 
// 13763         case DXC_DUPLICATION_MODE:
// 13764           if (active_extruder == 0) {
// 13765             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 13766               if (DEBUGGING(LEVELING)) {
// 13767                 SERIAL_ECHOPAIR("Set planner X", inactive_extruder_x_pos);
// 13768                 SERIAL_ECHOLNPAIR(" ... Line to X", current_position[X_AXIS] + duplicate_extruder_x_offset);
// 13769               }
// 13770             #endif
// 13771             // move duplicate extruder into correct duplication position.
// 13772             planner.set_position_mm(
// 13773               inactive_extruder_x_pos,
// 13774               current_position[Y_AXIS],
// 13775               current_position[Z_AXIS],
// 13776               current_position[E_AXIS]
// 13777             );
// 13778             planner.buffer_line(
// 13779               current_position[X_AXIS] + duplicate_extruder_x_offset,
// 13780               current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS],
// 13781               planner.max_feedrate_mm_s[X_AXIS], 1
// 13782             );
// 13783             SYNC_PLAN_POSITION_KINEMATIC();
// 13784             stepper.synchronize();
// 13785             extruder_duplication_enabled = true;
// 13786             active_extruder_parked = false;
// 13787             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 13788               if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Set extruder_duplication_enabled\nClear active_extruder_parked");
// 13789             #endif
// 13790           }
// 13791           else {
// 13792             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 13793               if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Active extruder not 0");
// 13794             #endif
// 13795           }
// 13796           break;
// 13797       }
// 13798     return false;
// 13799   }
// 13800 
// 13801 #endif // DUAL_X_CARRIAGE
// 13802 
// 13803 /**
// 13804  * Prepare a single move and get ready for the next one
// 13805  *
// 13806  * This may result in several calls to planner.buffer_line to
// 13807  * do smaller moves for DELTA, SCARA, mesh moves, etc.
// 13808  *
// 13809  * Make sure current_position[E] and destination[E] are good
// 13810  * before calling or cold/lengthy extrusion may get missed.
// 13811  */

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock52 Using cfiCommon0
          CFI Function _Z27prepare_move_to_destinationv
        THUMB
// 13812 void prepare_move_to_destination() {
_Z27prepare_move_to_destinationv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 13813   clamp_to_software_endstops(destination);
        LDR.W    R4,??DataTable108_1
        ADD      R0,R4,#+48
          CFI FunCall _Z26clamp_to_software_endstopsPf
        BL       _Z26clamp_to_software_endstopsPf
// 13814   refresh_cmd_timeout();
          CFI FunCall _Z19refresh_cmd_timeoutv
        BL       _Z19refresh_cmd_timeoutv
// 13815 
// 13816   #if ENABLED(PREVENT_COLD_EXTRUSION) || ENABLED(PREVENT_LENGTHY_EXTRUDE)
// 13817 
// 13818     if (!DEBUGGING(DRYRUN)) {
        LDRB     R0,[R4, #+13]
        LSLS     R0,R0,#+28
        BMI.N    ??prepare_move_to_destination_0
// 13819       if (destination[E_AXIS] != current_position[E_AXIS]) {
        VLDR     S0,[R4, #+44]
        VLDR     S1,[R4, #+60]
        VCMP.F32 S1,S0
        FMSTAT   
        BEQ.N    ??prepare_move_to_destination_0
// 13820         #if ENABLED(PREVENT_COLD_EXTRUSION)
// 13821           if (thermalManager.tooColdToExtrude(active_extruder)) {
// 13822             current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
// 13823             SERIAL_ECHO_START();
// 13824             SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
// 13825           }
// 13826         #endif // PREVENT_COLD_EXTRUSION
// 13827         #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
// 13828           if (FABS(destination[E_AXIS] - current_position[E_AXIS]) * planner.e_factor[active_extruder] > (EXTRUDE_MAXLENGTH)) {
        VSUB.F32 S0,S1,S0
        VABS.F32 S0,S0
        LDRB     R0,[R4, #+18]
        LDR.W    R1,??DataTable116_1
        ADD      R0,R1,R0, LSL #+2
        VLDR     S1,[R0, #0]
        VMUL.F32 S0,S0,S1
        VLDR.W   S1,??DataTable99_4  ;; 0x43480001
        VCMP.F32 S0,S1
        FMSTAT   
        BLT.N    ??prepare_move_to_destination_0
// 13829             current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
        LDR      R0,[R4, #+60]
        STR      R0,[R4, #+44]
// 13830             SERIAL_ECHO_START();
        LDR.W    R0,??DataTable117_1
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 13831             SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
        ADR.W    R0,`?<Constant " too long extrusion p...">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 13832           }
// 13833         #endif // PREVENT_LENGTHY_EXTRUDE
// 13834       }
// 13835     }
// 13836 
// 13837   #endif
// 13838 
// 13839   #if ENABLED(DUAL_X_CARRIAGE)
// 13840     if (dual_x_carriage_unpark()) return;
// 13841   #endif
// 13842 
// 13843   if (
// 13844     #if UBL_SEGMENTED
// 13845       ubl.prepare_segmented_line_to(destination, MMS_SCALED(feedrate_mm_s))
// 13846     #elif IS_KINEMATIC
// 13847       prepare_kinematic_move_to(destination)
// 13848     #else
// 13849       prepare_move_to_destination_cartesian()
// 13850     #endif
// 13851   ) return;
??prepare_move_to_destination_0:
          CFI FunCall _Z37prepare_move_to_destination_cartesianv
        BL       _Z37prepare_move_to_destination_cartesianv
        CMP      R0,#+0
        BNE.N    ??prepare_move_to_destination_1
// 13852 
// 13853   set_current_from_destination();
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z28set_current_from_destinationv
        B.W      _Z28set_current_from_destinationv
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??prepare_move_to_destination_1:
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock52
// 13854 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable99:
        DC32     workspace_offset

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable99_1:
        DC32     0x43055555

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable99_2:
        DC8      0x6F, 0x6B, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable99_3:
        DC32     axis_relative_modes+0x28

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable99_4:
        DC32     0x43480001

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable99_5:
        DC32     0x3ff80000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant " too long extrusion p...">`:
        DC8 " too long extrusion prevented\012"
        DC8 0
// 13855 
// 13856 #if ENABLED(ARC_SUPPORT)
// 13857 
// 13858   #if N_ARC_CORRECTION < 1
// 13859     #undef N_ARC_CORRECTION
// 13860     #define N_ARC_CORRECTION 1
// 13861   #endif
// 13862 
// 13863   /**
// 13864    * Plan an arc in 2 dimensions
// 13865    *
// 13866    * The arc is approximated by generating many small linear segments.
// 13867    * The length of each segment is configured in MM_PER_ARC_SEGMENT (Default 1mm)
// 13868    * Arcs should only be made relatively large (over 5mm), as larger arcs with
// 13869    * larger segments will tend to be more efficient. Your slicer should have
// 13870    * options for G2/G3 arc generation. In future these options may be GCode tunable.
// 13871    */

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock53 Using cfiCommon0
          CFI Function _Z8plan_arcRA4_KfRA2_S_b
        THUMB
// 13872   void plan_arc(
// 13873     const float (&cart)[XYZE], // Destination position
// 13874     const float (&offset)[2], // Center of rotation relative to current_position
// 13875     const bool clockwise      // Clockwise?
// 13876   ) {
_Z8plan_arcRA4_KfRA2_S_b:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        VPUSH    {D8-D12}
          CFI D12 Frame(CFA, -48)
          CFI D11 Frame(CFA, -56)
          CFI D10 Frame(CFA, -64)
          CFI D9 Frame(CFA, -72)
          CFI D8 Frame(CFA, -80)
          CFI CFA R13+80
        SUB      SP,SP,#+24
          CFI CFA R13+104
        MOV      R4,R0
        MOV      R8,R1
        MOV      R6,R2
// 13877     #if ENABLED(CNC_WORKSPACE_PLANES)
// 13878       AxisEnum p_axis, q_axis, l_axis;
// 13879       switch (workspace_plane) {
// 13880         default:
// 13881         case PLANE_XY: p_axis = X_AXIS; q_axis = Y_AXIS; l_axis = Z_AXIS; break;
// 13882         case PLANE_ZX: p_axis = Z_AXIS; q_axis = X_AXIS; l_axis = Y_AXIS; break;
// 13883         case PLANE_YZ: p_axis = Y_AXIS; q_axis = Z_AXIS; l_axis = X_AXIS; break;
// 13884       }
// 13885     #else
// 13886       constexpr AxisEnum p_axis = X_AXIS, q_axis = Y_AXIS, l_axis = Z_AXIS;
// 13887     #endif
// 13888 
// 13889     // Radius vector from center to current location
// 13890     float r_P = -offset[0], r_Q = -offset[1];
        VLDR     S0,[R8, #0]
        VNEG.F32 S16,S0
        VLDR     S0,[R8, #+4]
        VNEG.F32 S17,S0
// 13891 
// 13892     const float radius = HYPOT(r_P, r_Q),
        VMOV.F32 S0,S16
        MOVS     R0,#+2
        VMOV.F32 S18,#1.0
        VMOV.F32 S1,S18
        B.N      ??plan_arc_0
??plan_arc_1:
        VMUL.F32 S0,S0,S0
??plan_arc_0:
        LSLS     R1,R0,#+31
        BPL.N    ??plan_arc_2
        VMUL.F32 S1,S1,S0
??plan_arc_2:
        LSRS     R0,R0,#+1
        BNE.N    ??plan_arc_1
        VMOV.F32 S0,S17
        MOVS     R0,#+2
        VMOV.F32 S2,S18
        B.N      ??plan_arc_3
??plan_arc_4:
        VMUL.F32 S0,S0,S0
??plan_arc_3:
        LSLS     R1,R0,#+31
        BPL.N    ??plan_arc_5
        VMUL.F32 S2,S2,S0
??plan_arc_5:
        LSRS     R0,R0,#+1
        BNE.N    ??plan_arc_4
        VADD.F32 S0,S1,S2
          CFI FunCall sqrtf
        BL       sqrtf
        VMOV.F32 S23,S0
// 13893                 center_P = current_position[p_axis] - r_P,
        LDR.W    R5,??DataTable108_1
        VLDR     S0,[R5, #+32]
        VSUB.F32 S19,S0,S16
// 13894                 center_Q = current_position[q_axis] - r_Q,
        VLDR     S0,[R5, #+36]
        VSUB.F32 S20,S0,S17
// 13895                 rt_X = cart[p_axis] - center_P,
        VLDR     S0,[R4, #0]
        VSUB.F32 S2,S0,S19
// 13896                 rt_Y = cart[q_axis] - center_Q,
        VLDR     S0,[R4, #+4]
        VSUB.F32 S0,S0,S20
// 13897                 linear_travel = cart[l_axis] - current_position[l_axis],
        VLDR     S1,[R4, #+8]
        VLDR     S3,[R5, #+40]
        VSUB.F32 S22,S1,S3
// 13898                 extruder_travel = cart[E_AXIS] - current_position[E_AXIS];
        VLDR     S1,[R4, #+12]
        VLDR     S3,[R5, #+44]
        VSUB.F32 S21,S1,S3
// 13899 
// 13900     // CCW angle of rotation between position and target from the circle center. Only one atan2() trig computation required.
// 13901     float angular_travel = ATAN2(r_P * rt_Y - r_Q * rt_X, r_P * rt_X + r_Q * rt_Y);
        VMUL.F32 S1,S16,S2
        VMLA.F32 S1,S17,S0
        VMUL.F32 S0,S16,S0
        VMLS.F32 S0,S17,S2
          CFI FunCall atan2f
        BL       atan2f
        VMOV.F32 S24,S0
// 13902     if (angular_travel < 0) angular_travel += RADIANS(360);
        VCMP.F32 S24,#0.0
        FMSTAT   
        BPL.N    ??plan_arc_6
        VMOV     R0,S24
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable117_2  ;; 0x54442d18
        LDR.W    R3,??DataTable117_3  ;; 0x401921fb
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        VMOV     S24,R0
// 13903     if (clockwise) angular_travel -= RADIANS(360);
??plan_arc_6:
        CMP      R6,#+0
        BEQ.N    ??plan_arc_7
        VMOV     R0,S24
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable117_2  ;; 0x54442d18
        LDR.W    R3,??DataTable117_4  ;; 0xc01921fb
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        VMOV     S24,R0
// 13904 
// 13905     // Make a circle if the angular rotation is 0 and the target is current position
// 13906     if (angular_travel == 0 && current_position[p_axis] == cart[p_axis] && current_position[q_axis] == cart[q_axis])
??plan_arc_7:
        VCMP.F32 S24,#0.0
        FMSTAT   
        BNE.N    ??plan_arc_8
        VLDR     S0,[R5, #+32]
        VLDR     S1,[R4, #0]
        VCMP.F32 S0,S1
        FMSTAT   
        BNE.N    ??plan_arc_8
        VLDR     S0,[R5, #+36]
        VLDR     S1,[R4, #+4]
        VCMP.F32 S0,S1
        FMSTAT   
        BNE.N    ??plan_arc_8
// 13907       angular_travel = RADIANS(360);
        VLDR.W   S24,??DataTable103  ;; 0x40c90fdb
// 13908 
// 13909     const float mm_of_travel = HYPOT(angular_travel * radius, FABS(linear_travel));
??plan_arc_8:
        VMUL.F32 S0,S24,S23
        MOVS     R0,#+2
        VMOV.F32 S1,S18
        B.N      ??plan_arc_9
??plan_arc_10:
        VMUL.F32 S0,S0,S0
??plan_arc_9:
        LSLS     R1,R0,#+31
        BPL.N    ??plan_arc_11
        VMUL.F32 S1,S1,S0
??plan_arc_11:
        LSRS     R0,R0,#+1
        BNE.N    ??plan_arc_10
        VABS.F32 S0,S22
        MOVS     R0,#+2
        VMOV.F32 S2,S18
        B.N      ??plan_arc_12
??plan_arc_13:
        VMUL.F32 S0,S0,S0
??plan_arc_12:
        LSLS     R1,R0,#+31
        BPL.N    ??plan_arc_14
        VMUL.F32 S2,S2,S0
??plan_arc_14:
        LSRS     R0,R0,#+1
        BNE.N    ??plan_arc_13
        VADD.F32 S0,S1,S2
          CFI FunCall sqrtf
        BL       sqrtf
// 13910     if (mm_of_travel < 0.001) return;
        VLDR.W   S1,??DataTable105  ;; 0x3a83126f
        VCMP.F32 S0,S1
        FMSTAT   
        BMI.W    ??plan_arc_15
// 13911 
// 13912     uint16_t segments = FLOOR(mm_of_travel / (MM_PER_ARC_SEGMENT));
          CFI FunCall floorf
        BL       floorf
        VCVT.S32.F32 S0,S0
        VMOV     R6,S0
        UXTH     R6,R6
// 13913     NOLESS(segments, 1);
        CMP      R6,#+0
        BNE.N    ??plan_arc_16
        MOVS     R6,#+1
// 13914 
// 13915     /**
// 13916      * Vector rotation by transformation matrix: r is the original vector, r_T is the rotated vector,
// 13917      * and phi is the angle of rotation. Based on the solution approach by Jens Geisler.
// 13918      *     r_T = [cos(phi) -sin(phi);
// 13919      *            sin(phi)  cos(phi)] * r ;
// 13920      *
// 13921      * For arc generation, the center of the circle is the axis of rotation and the radius vector is
// 13922      * defined from the circle center to the initial position. Each line segment is formed by successive
// 13923      * vector rotations. This requires only two cos() and sin() computations to form the rotation
// 13924      * matrix for the duration of the entire arc. Error may accumulate from numerical round-off, since
// 13925      * all double numbers are single precision on the Arduino. (True double precision will not have
// 13926      * round off issues for CNC applications.) Single precision error can accumulate to be greater than
// 13927      * tool precision in some cases. Therefore, arc path correction is implemented.
// 13928      *
// 13929      * Small angle approximation may be used to reduce computation overhead further. This approximation
// 13930      * holds for everything, but very small circles and large MM_PER_ARC_SEGMENT values. In other words,
// 13931      * theta_per_segment would need to be greater than 0.1 rad and N_ARC_CORRECTION would need to be large
// 13932      * to cause an appreciable drift error. N_ARC_CORRECTION~=25 is more than small enough to correct for
// 13933      * numerical drift error. N_ARC_CORRECTION may be on the order a hundred(s) before error becomes an
// 13934      * issue for CNC machines with the single precision Arduino calculations.
// 13935      *
// 13936      * This approximation also allows plan_arc to immediately insert a line segment into the planner
// 13937      * without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied
// 13938      * a correction, the planner should have caught up to the lag caused by the initial plan_arc overhead.
// 13939      * This is important when there are successive arc motions.
// 13940      */
// 13941     // Vector rotation matrix values
// 13942     float raw[XYZE];
// 13943     const float theta_per_segment = angular_travel / segments,
??plan_arc_16:
        MOV      R0,R6
        VMOV     S0,R0
        VCVT.F32.U32 S0,S0
        VDIV.F32 S23,S24,S0
// 13944                 linear_per_segment = linear_travel / segments,
        VDIV.F32 S22,S22,S0
// 13945                 extruder_per_segment = extruder_travel / segments,
        VDIV.F32 S21,S21,S0
// 13946                 sin_T = theta_per_segment,
// 13947                 cos_T = 1 - 0.5 * sq(theta_per_segment); // Small angle approximation
        VMOV.F32 S0,S23
        MOVS     R0,#+2
        B.N      ??plan_arc_17
??plan_arc_18:
        VMUL.F32 S0,S0,S0
??plan_arc_17:
        LSLS     R1,R0,#+31
        BPL.N    ??plan_arc_19
        VMUL.F32 S18,S18,S0
??plan_arc_19:
        LSRS     R0,R0,#+1
        BNE.N    ??plan_arc_18
        VMOV     R0,S18
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOVS     R2,#+0
        LDR.W    R3,??DataTable120  ;; 0x3fe00000
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R0
        MOV      R3,R1
        MOVS     R0,#+0
        LDR.W    R1,??DataTable120_1  ;; 0x3ff00000
          CFI FunCall __aeabi_dsub
        BL       __aeabi_dsub
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        VMOV     S18,R0
// 13948 
// 13949     // Initialize the linear axis
// 13950     raw[l_axis] = current_position[l_axis];
        ADD      R7,SP,#+4
        LDR      R0,[R5, #+40]
        STR      R0,[R7, #+8]
// 13951 
// 13952     // Initialize the extruder axis
// 13953     raw[E_AXIS] = current_position[E_AXIS];
        LDR      R0,[R5, #+44]
        STR      R0,[R7, #+12]
// 13954 
// 13955     const float fr_mm_s = MMS_SCALED(feedrate_mm_s);
        LDRSH    R0,[R5, #+28]
        VMOV     S0,R0
        VCVT.F32.S32 S0,S0
        VLDR     S1,[R5, #+120]
        VMUL.F32 S0,S0,S1
        VMOV     R0,S0
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable120_2  ;; 0x47ae147b
        LDR.W    R3,??DataTable123  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+0]
// 13956 
// 13957     millis_t next_idle_ms = millis() + 200UL;
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        ADD      R9,R0,#+200
// 13958 
// 13959     #if N_ARC_CORRECTION > 1
// 13960       int8_t arc_recalc_count = N_ARC_CORRECTION;
        MOV      R10,#+25
// 13961     #endif
// 13962 
// 13963     #if ENABLED(SCARA_FEEDRATE_SCALING)
// 13964       // SCARA needs to scale the feed rate from mm/s to degrees/s
// 13965       const float inv_segment_length = 1.0 / (MM_PER_ARC_SEGMENT),
// 13966                   inverse_secs = inv_segment_length * fr_mm_s;
// 13967       float oldA = stepper.get_axis_position_degrees(A_AXIS),
// 13968             oldB = stepper.get_axis_position_degrees(B_AXIS);
// 13969     #endif
// 13970 
// 13971     for (uint16_t i = 1; i < segments; i++) { // Iterate (segments-1) times
        MOV      R11,#+1
        B.N      ??plan_arc_20
// 13972 
// 13973       thermalManager.manage_heater();
// 13974       if (ELAPSED(millis(), next_idle_ms)) {
// 13975         next_idle_ms = millis() + 200UL;
// 13976         idle();
// 13977       }
// 13978 
// 13979       #if N_ARC_CORRECTION > 1
// 13980         if (--arc_recalc_count) {
// 13981           // Apply vector rotation matrix to previous r_P / 1
// 13982           const float r_new_Y = r_P * sin_T + r_Q * cos_T;
// 13983           r_P = r_P * cos_T - r_Q * sin_T;
// 13984           r_Q = r_new_Y;
// 13985         }
// 13986         else
// 13987       #endif
// 13988       {
// 13989         #if N_ARC_CORRECTION > 1
// 13990           arc_recalc_count = N_ARC_CORRECTION;
??plan_arc_21:
        MOV      R10,#+25
// 13991         #endif
// 13992 
// 13993         // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments.
// 13994         // Compute exact location by applying transformation matrix from initial radius vector(=-offset).
// 13995         // To reduce stuttering, the sin and cos could be computed at different times.
// 13996         // For now, compute both at the same time.
// 13997         const float cos_Ti = cos(i * theta_per_segment), sin_Ti = sin(i * theta_per_segment);
        MOV      R0,R11
        VMOV     S0,R0
        VCVT.F32.U32 S0,S0
        VMUL.F32 S16,S0,S23
        VMOV.F32 S0,S16
          CFI FunCall cosf
        BL       cosf
        VMOV.F32 S24,S0
        VMOV.F32 S0,S16
          CFI FunCall sinf
        BL       sinf
// 13998         r_P = -offset[0] * cos_Ti + offset[1] * sin_Ti;
        VLDR     S1,[R8, #+4]
        VLDR     S2,[R8, #0]
        VMUL.F32 S16,S1,S0
        VMLS.F32 S16,S2,S24
// 13999         r_Q = -offset[0] * sin_Ti - offset[1] * cos_Ti;
        VNMUL.F32 S17,S2,S0
        VMLS.F32 S17,S1,S24
// 14000       }
// 14001 
// 14002       // Update raw location
// 14003       raw[p_axis] = center_P + r_P;
??plan_arc_22:
        VADD.F32 S0,S19,S16
        VSTR     S0,[SP, #+4]
// 14004       raw[q_axis] = center_Q + r_Q;
        VADD.F32 S0,S20,S17
        VSTR     S0,[R7, #+4]
// 14005       raw[l_axis] += linear_per_segment;
        VLDR     S0,[R7, #+8]
        VADD.F32 S0,S0,S22
        VSTR     S0,[R7, #+8]
// 14006       raw[E_AXIS] += extruder_per_segment;
        VLDR     S0,[R7, #+12]
        VADD.F32 S0,S0,S21
        VSTR     S0,[R7, #+12]
// 14007 
// 14008       clamp_to_software_endstops(raw);
        ADD      R0,SP,#+4
          CFI FunCall _Z26clamp_to_software_endstopsPf
        BL       _Z26clamp_to_software_endstopsPf
// 14009 
// 14010       #if ENABLED(SCARA_FEEDRATE_SCALING)
// 14011         // For SCARA scale the feed rate from mm/s to degrees/s
// 14012         // i.e., Complete the angular vector in the given time.
// 14013         inverse_kinematics(raw);
// 14014         ADJUST_DELTA(raw);
// 14015         planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], raw[Z_AXIS], raw[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
// 14016         oldA = delta[A_AXIS]; oldB = delta[B_AXIS];
// 14017       #else
// 14018         planner.buffer_line_kinematic(raw, fr_mm_s, active_extruder);
        LDRB     R2,[R5, #+18]
        ADD      R1,SP,#+0
        ADD      R0,SP,#+4
          CFI FunCall _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
        BL       _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
        ADD      R11,R11,#+1
        UXTH     R11,R11
??plan_arc_20:
        CMP      R11,R6
        BGE.N    ??plan_arc_23
          CFI FunCall _ZN11Temperature13manage_heaterEv
        BL       _ZN11Temperature13manage_heaterEv
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        SUBS     R0,R0,R9
        BMI.N    ??plan_arc_24
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        ADD      R9,R0,#+200
          CFI FunCall _Z4idlev
        BL       _Z4idlev
??plan_arc_24:
        SUB      R10,R10,#+1
        SXTB     R10,R10
        CMP      R10,#+0
        BEQ.N    ??plan_arc_21
        VMUL.F32 S0,S16,S23
        VMLA.F32 S0,S17,S18
        VMUL.F32 S16,S16,S18
        VMLS.F32 S16,S17,S23
        VMOV.F32 S17,S0
        B.N      ??plan_arc_22
// 14019       #endif
// 14020     }
// 14021 
// 14022     // Ensure last segment arrives at target location.
// 14023     #if ENABLED(SCARA_FEEDRATE_SCALING)
// 14024       inverse_kinematics(cart);
// 14025       ADJUST_DELTA(cart);
// 14026       planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], cart[Z_AXIS], cart[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
// 14027     #else
// 14028       planner.buffer_line_kinematic(cart, fr_mm_s, active_extruder);
??plan_arc_23:
        LDRB     R2,[R5, #+18]
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
        BL       _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
// 14029     #endif
// 14030 
// 14031     // As far as the parser is concerned, the position is now == target. In reality the
// 14032     // motion control system might still be processing the action and the real tool position
// 14033     // in any intermediate location.
// 14034     set_current_from_destination();
          CFI FunCall _Z28set_current_from_destinationv
        BL       _Z28set_current_from_destinationv
// 14035   } // plan_arc
??plan_arc_15:
        ADD      SP,SP,#+24
          CFI CFA R13+80
        VPOP     {D8-D12}
          CFI D8 SameValue
          CFI D9 SameValue
          CFI D10 SameValue
          CFI D11 SameValue
          CFI D12 SameValue
          CFI CFA R13+40
        POP      {R0,R4-R11,PC}   ;; return
          CFI EndBlock cfiBlock53
// 14036 
// 14037 #endif // ARC_SUPPORT
// 14038 
// 14039 #if ENABLED(BEZIER_CURVE_SUPPORT)
// 14040 
// 14041   void plan_cubic_move(const float (&offset)[4]) {
// 14042     cubic_b_spline(current_position, destination, offset, MMS_SCALED(feedrate_mm_s), active_extruder);
// 14043 
// 14044     // As far as the parser is concerned, the position is now == destination. In reality the
// 14045     // motion control system might still be processing the action and the real tool position
// 14046     // in any intermediate location.
// 14047     set_current_from_destination();
// 14048   }
// 14049 
// 14050 #endif // BEZIER_CURVE_SUPPORT
// 14051 
// 14052 #if ENABLED(USE_CONTROLLER_FAN)
// 14053 
// 14054   void controllerFan() {
// 14055     static millis_t lastMotorOn = 0, // Last time a motor was turned on
// 14056                     nextMotorCheck = 0; // Last time the state was checked
// 14057     const millis_t ms = millis();
// 14058     if (ELAPSED(ms, nextMotorCheck)) {
// 14059       nextMotorCheck = ms + 2500UL; // Not a time critical function, so only check every 2.5s
// 14060       if (X_ENABLE_READ == X_ENABLE_ON || Y_ENABLE_READ == Y_ENABLE_ON || Z_ENABLE_READ == Z_ENABLE_ON || thermalManager.soft_pwm_amount_bed > 0
// 14061           || E0_ENABLE_READ == E_ENABLE_ON // If any of the drivers are enabled...
// 14062           #if E_STEPPERS > 1
// 14063             || E1_ENABLE_READ == E_ENABLE_ON
// 14064             #if HAS_X2_ENABLE
// 14065               || X2_ENABLE_READ == X_ENABLE_ON
// 14066             #endif
// 14067             #if E_STEPPERS > 2
// 14068               || E2_ENABLE_READ == E_ENABLE_ON
// 14069               #if E_STEPPERS > 3
// 14070                 || E3_ENABLE_READ == E_ENABLE_ON
// 14071                 #if E_STEPPERS > 4
// 14072                   || E4_ENABLE_READ == E_ENABLE_ON
// 14073                 #endif // E_STEPPERS > 4
// 14074               #endif // E_STEPPERS > 3
// 14075             #endif // E_STEPPERS > 2
// 14076           #endif // E_STEPPERS > 1
// 14077       ) {
// 14078         lastMotorOn = ms; //... set time to NOW so the fan will turn on
// 14079       }
// 14080 
// 14081       // Fan off if no steppers have been enabled for CONTROLLERFAN_SECS seconds
// 14082       uint8_t speed = (!lastMotorOn || ELAPSED(ms, lastMotorOn + (CONTROLLERFAN_SECS) * 1000UL)) ? 0 : CONTROLLERFAN_SPEED;
// 14083 
// 14084       // allows digital or PWM fan output to be used (see M42 handling)
// 14085       WRITE(CONTROLLER_FAN_PIN, speed);
// 14086       analogWrite(CONTROLLER_FAN_PIN, speed);
// 14087     }
// 14088   }
// 14089 
// 14090 #endif // USE_CONTROLLER_FAN
// 14091 
// 14092 #if ENABLED(MORGAN_SCARA)
// 14093 
// 14094   /**
// 14095    * Morgan SCARA Forward Kinematics. Results in cartes[].
// 14096    * Maths and first version by QHARLEY.
// 14097    * Integrated into Marlin and slightly restructured by Joachim Cerny.
// 14098    */
// 14099   void forward_kinematics_SCARA(const float &a, const float &b) {
// 14100 
// 14101     float a_sin = sin(RADIANS(a)) * L1,
// 14102           a_cos = cos(RADIANS(a)) * L1,
// 14103           b_sin = sin(RADIANS(b)) * L2,
// 14104           b_cos = cos(RADIANS(b)) * L2;
// 14105 
// 14106     cartes[X_AXIS] = a_cos + b_cos + SCARA_OFFSET_X;  //theta
// 14107     cartes[Y_AXIS] = a_sin + b_sin + SCARA_OFFSET_Y;  //theta+phi
// 14108 
// 14109     /*
// 14110       SERIAL_ECHOPAIR("SCARA FK Angle a=", a);
// 14111       SERIAL_ECHOPAIR(" b=", b);
// 14112       SERIAL_ECHOPAIR(" a_sin=", a_sin);
// 14113       SERIAL_ECHOPAIR(" a_cos=", a_cos);
// 14114       SERIAL_ECHOPAIR(" b_sin=", b_sin);
// 14115       SERIAL_ECHOLNPAIR(" b_cos=", b_cos);
// 14116       SERIAL_ECHOPAIR(" cartes[X_AXIS]=", cartes[X_AXIS]);
// 14117       SERIAL_ECHOLNPAIR(" cartes[Y_AXIS]=", cartes[Y_AXIS]);
// 14118     //*/
// 14119   }
// 14120 
// 14121   /**
// 14122    * Morgan SCARA Inverse Kinematics. Results in delta[].
// 14123    *
// 14124    * See http://forums.reprap.org/read.php?185,283327
// 14125    *
// 14126    * Maths and first version by QHARLEY.
// 14127    * Integrated into Marlin and slightly restructured by Joachim Cerny.
// 14128    */
// 14129   void inverse_kinematics(const float raw[XYZ]) {
// 14130 
// 14131     static float C2, S2, SK1, SK2, THETA, PSI;
// 14132 
// 14133     float sx = raw[X_AXIS] - SCARA_OFFSET_X,  // Translate SCARA to standard X Y
// 14134           sy = raw[Y_AXIS] - SCARA_OFFSET_Y;  // With scaling factor.
// 14135 
// 14136     if (L1 == L2)
// 14137       C2 = HYPOT2(sx, sy) / L1_2_2 - 1;
// 14138     else
// 14139       C2 = (HYPOT2(sx, sy) - (L1_2 + L2_2)) / (2.0 * L1 * L2);
// 14140 
// 14141     S2 = SQRT(1 - sq(C2));
// 14142 
// 14143     // Unrotated Arm1 plus rotated Arm2 gives the distance from Center to End
// 14144     SK1 = L1 + L2 * C2;
// 14145 
// 14146     // Rotated Arm2 gives the distance from Arm1 to Arm2
// 14147     SK2 = L2 * S2;
// 14148 
// 14149     // Angle of Arm1 is the difference between Center-to-End angle and the Center-to-Elbow
// 14150     THETA = ATAN2(SK1, SK2) - ATAN2(sx, sy);
// 14151 
// 14152     // Angle of Arm2
// 14153     PSI = ATAN2(S2, C2);
// 14154 
// 14155     delta[A_AXIS] = DEGREES(THETA);        // theta is support arm angle
// 14156     delta[B_AXIS] = DEGREES(THETA + PSI);  // equal to sub arm angle (inverted motor)
// 14157     delta[C_AXIS] = raw[Z_AXIS];
// 14158 
// 14159     /*
// 14160       DEBUG_POS("SCARA IK", raw);
// 14161       DEBUG_POS("SCARA IK", delta);
// 14162       SERIAL_ECHOPAIR("  SCARA (x,y) ", sx);
// 14163       SERIAL_ECHOPAIR(",", sy);
// 14164       SERIAL_ECHOPAIR(" C2=", C2);
// 14165       SERIAL_ECHOPAIR(" S2=", S2);
// 14166       SERIAL_ECHOPAIR(" Theta=", THETA);
// 14167       SERIAL_ECHOLNPAIR(" Phi=", PHI);
// 14168     //*/
// 14169   }
// 14170 
// 14171 #endif // MORGAN_SCARA
// 14172 
// 14173 #if ENABLED(TEMP_STAT_LEDS)
// 14174 
// 14175   static bool red_led = false;
// 14176   static millis_t next_status_led_update_ms = 0;
// 14177 
// 14178   void handle_status_leds(void) {
// 14179     if (ELAPSED(millis(), next_status_led_update_ms)) {
// 14180       next_status_led_update_ms += 500; // Update every 0.5s
// 14181       float max_temp = 0.0;
// 14182       #if HAS_TEMP_BED
// 14183         max_temp = MAX3(max_temp, thermalManager.degTargetBed(), thermalManager.degBed());
// 14184       #endif
// 14185       HOTEND_LOOP()
// 14186         max_temp = MAX3(max_temp, thermalManager.degHotend(e), thermalManager.degTargetHotend(e));
// 14187       const bool new_led = (max_temp > 55.0) ? true : (max_temp < 54.0) ? false : red_led;
// 14188       if (new_led != red_led) {
// 14189         red_led = new_led;
// 14190         #if PIN_EXISTS(STAT_LED_RED)
// 14191           WRITE(STAT_LED_RED_PIN, new_led ? HIGH : LOW);
// 14192           #if PIN_EXISTS(STAT_LED_BLUE)
// 14193             WRITE(STAT_LED_BLUE_PIN, new_led ? LOW : HIGH);
// 14194           #endif
// 14195         #else
// 14196           WRITE(STAT_LED_BLUE_PIN, new_led ? HIGH : LOW);
// 14197         #endif
// 14198       }
// 14199     }
// 14200   }
// 14201 
// 14202 #endif
// 14203 
// 14204 #if ENABLED(FILAMENT_RUNOUT_SENSOR)
// 14205 
// 14206   void handle_filament_runout() {
// 14207     if (!filament_ran_out) {
// 14208       filament_ran_out = true;
// 14209       enqueue_and_echo_commands_P(PSTR(FILAMENT_RUNOUT_SCRIPT));
// 14210       stepper.synchronize();
// 14211     }
// 14212   }
// 14213 
// 14214 #endif // FILAMENT_RUNOUT_SENSOR
// 14215 
// 14216 #if ENABLED(FAST_PWM_FAN)
// 14217 
// 14218   void setPwmFrequency(uint8_t pin, int val) {
// 14219     val &= 0x07;
// 14220     switch (digitalPinToTimer(pin)) {
// 14221       #ifdef TCCR0A
// 14222         #if !AVR_AT90USB1286_FAMILY
// 14223           case TIMER0A:
// 14224         #endif
// 14225         case TIMER0B:                           //_SET_CS(0, val);
// 14226                                                   break;
// 14227       #endif
// 14228       #ifdef TCCR1A
// 14229         case TIMER1A: case TIMER1B:             //_SET_CS(1, val);
// 14230                                                   break;
// 14231       #endif
// 14232       #if defined(TCCR2) || defined(TCCR2A)
// 14233         #ifdef TCCR2
// 14234           case TIMER2:
// 14235         #endif
// 14236         #ifdef TCCR2A
// 14237           case TIMER2A: case TIMER2B:
// 14238         #endif
// 14239                                                   _SET_CS(2, val); break;
// 14240       #endif
// 14241       #ifdef TCCR3A
// 14242         case TIMER3A: case TIMER3B: case TIMER3C: _SET_CS(3, val); break;
// 14243       #endif
// 14244       #ifdef TCCR4A
// 14245         case TIMER4A: case TIMER4B: case TIMER4C: _SET_CS(4, val); break;
// 14246       #endif
// 14247       #ifdef TCCR5A
// 14248         case TIMER5A: case TIMER5B: case TIMER5C: _SET_CS(5, val); break;
// 14249       #endif
// 14250     }
// 14251   }
// 14252 
// 14253 #endif // FAST_PWM_FAN
// 14254 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock54 Using cfiCommon0
          CFI Function _Z19enable_all_steppersv
        THUMB
// 14255 void enable_all_steppers() {
// 14256   enable_X();
// 14257   enable_Y();
// 14258   enable_Z();
_Z19enable_all_steppersv:
        MOVS     R2,#+0
        LDR.W    R0,??DataTable122
        LDRH     R1,[R0, #+4]
        LDR.W    R0,??DataTable123_1
        LDR      R0,[R0, #+8]
          CFI FunCall HAL_GPIO_WritePin
        B.W      HAL_GPIO_WritePin
          CFI EndBlock cfiBlock54
// 14259   enable_E0();
// 14260   enable_E1();
// 14261   enable_E2();
// 14262   enable_E3();
// 14263   enable_E4();
// 14264 }
// 14265 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock55 Using cfiCommon0
          CFI Function _Z18disable_e_steppersv
          CFI NoCalls
        THUMB
// 14266 void disable_e_steppers() {
// 14267   disable_E0();
// 14268   disable_E1();
// 14269   disable_E2();
// 14270   disable_E3();
// 14271   disable_E4();
// 14272 }
_Z18disable_e_steppersv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock55
// 14273 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock56 Using cfiCommon0
          CFI Function _Z20disable_all_steppersv
        THUMB
// 14274 void disable_all_steppers() {
_Z20disable_all_steppersv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 14275   disable_X();
// 14276   disable_Y();
// 14277   disable_Z();
        MOVS     R2,#+1
        LDR.W    R0,??DataTable122
        LDRH     R1,[R0, #+4]
        LDR.W    R0,??DataTable123_1
        LDR      R0,[R0, #+8]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        MOVS     R0,#+0
        LDR.N    R1,??DataTable108_1
        STRB     R0,[R1, #+10]
// 14278   disable_e_steppers();
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z18disable_e_steppersv
        B.N      _Z18disable_e_steppersv
          CFI EndBlock cfiBlock56
// 14279 }
// 14280 
// 14281 #if ENABLED(MONITOR_DRIVER_STATUS)
// 14282   /*
// 14283    * Check for over temperature or short to ground error flags.
// 14284    * Report and log warning of overtemperature condition.
// 14285    * Reduce driver current in a persistent otpw condition.
// 14286    * Keep track of otpw counter so we don't reduce current on a single instance,
// 14287    * and so we don't repeatedly report warning before the condition is cleared.
// 14288    */
// 14289 
// 14290   struct TMC_driver_data {
// 14291     uint32_t drv_status;
// 14292     bool is_otpw;
// 14293     bool is_ot;
// 14294     bool is_error;
// 14295   };
// 14296   #if ENABLED(HAVE_TMC2130)
// 14297     static uint32_t get_pwm_scale(TMC2130Stepper &st) { return st.PWM_SCALE(); }
// 14298     static uint8_t get_status_response(TMC2130Stepper &st) { return st.status_response&0xF; }
// 14299     static TMC_driver_data get_driver_data(TMC2130Stepper &st) {
// 14300       constexpr uint32_t OTPW_bm = 0x4000000UL;
// 14301       constexpr uint8_t OTPW_bp = 26;
// 14302       constexpr uint32_t OT_bm = 0x2000000UL;
// 14303       constexpr uint8_t OT_bp = 25;
// 14304       constexpr uint8_t DRIVER_ERROR_bm = 0x2UL;
// 14305       constexpr uint8_t DRIVER_ERROR_bp = 1;
// 14306       TMC_driver_data data;
// 14307       data.drv_status = st.DRV_STATUS();
// 14308       data.is_otpw = (data.drv_status & OTPW_bm)>>OTPW_bp;
// 14309       data.is_ot = (data.drv_status & OT_bm)>>OT_bp;
// 14310       data.is_error = (st.status_response & DRIVER_ERROR_bm)>>DRIVER_ERROR_bp;
// 14311       return data;
// 14312     }
// 14313   #endif
// 14314   #if ENABLED(HAVE_TMC2208)
// 14315     static uint32_t get_pwm_scale(TMC2208Stepper &st) { return st.pwm_scale_sum(); }
// 14316     static uint8_t get_status_response(TMC2208Stepper &st) {
// 14317       uint32_t drv_status = st.DRV_STATUS();
// 14318       uint8_t gstat = st.GSTAT();
// 14319       uint8_t response = 0;
// 14320       response |= (drv_status >> (31-3)) & 0b1000;
// 14321       response |= gstat & 0b11;
// 14322       return response;
// 14323     }
// 14324     static TMC_driver_data get_driver_data(TMC2208Stepper &st) {
// 14325       constexpr uint32_t OTPW_bm = 0b1ul;
// 14326       constexpr uint8_t OTPW_bp = 0;
// 14327       constexpr uint32_t OT_bm = 0b10ul;
// 14328       constexpr uint8_t OT_bp = 1;
// 14329       TMC_driver_data data;
// 14330       data.drv_status = st.DRV_STATUS();
// 14331       data.is_otpw = (data.drv_status & OTPW_bm)>>OTPW_bp;
// 14332       data.is_ot = (data.drv_status & OT_bm)>>OT_bp;
// 14333       data.is_error = st.drv_err();
// 14334       return data;
// 14335     }
// 14336   #endif
// 14337 
// 14338   template<typename TMC>
// 14339   uint8_t monitor_tmc_driver(TMC &st, const char axisID, uint8_t otpw_cnt) {
// 14340     TMC_driver_data data = get_driver_data(st);
// 14341 
// 14342     #if ENABLED(STOP_ON_ERROR)
// 14343       if (data.is_error) {
// 14344         SERIAL_EOL();
// 14345         SERIAL_ECHO(axisID);
// 14346         SERIAL_ECHO(" driver error detected:");
// 14347         if (data.is_ot) SERIAL_ECHO("\novertemperature");
// 14348         if (st.s2ga()) SERIAL_ECHO("\nshort to ground (coil A)");
// 14349         if (st.s2gb()) SERIAL_ECHO("\nshort to ground (coil B)");
// 14350         SERIAL_EOL();
// 14351         #if ENABLED(TMC_DEBUG)
// 14352           gcode_M122();
// 14353         #endif
// 14354         kill(PSTR("Driver error"));
// 14355       }
// 14356     #endif
// 14357 
// 14358     // Report if a warning was triggered
// 14359     if (data.is_otpw && otpw_cnt==0) {
// 14360       char timestamp[10];
// 14361       duration_t elapsed = print_job_timer.duration();
// 14362       const bool has_days = (elapsed.value > 60*60*24L);
// 14363       (void)elapsed.toDigital(timestamp, has_days);
// 14364       SERIAL_EOL();
// 14365       SERIAL_ECHO(timestamp);
// 14366       SERIAL_ECHOPGM(": ");
// 14367       SERIAL_ECHO(axisID);
// 14368       SERIAL_ECHOPGM(" driver overtemperature warning! (");
// 14369       SERIAL_ECHO(st.getCurrent());
// 14370       SERIAL_ECHOLN("mA)");
// 14371     }
// 14372     #if CURRENT_STEP_DOWN > 0
// 14373       // Decrease current if is_otpw is true and driver is enabled and there's been more then 4 warnings
// 14374       if (data.is_otpw && !st.isEnabled() && otpw_cnt > 4) {
// 14375         st.setCurrent(st.getCurrent() - CURRENT_STEP_DOWN, R_SENSE, HOLD_MULTIPLIER);
// 14376         #if ENABLED(REPORT_CURRENT_CHANGE)
// 14377           SERIAL_ECHO(axisID);
// 14378           SERIAL_ECHOLNPAIR(" current decreased to ", st.getCurrent());
// 14379         #endif
// 14380       }
// 14381     #endif
// 14382 
// 14383     if (data.is_otpw) {
// 14384       otpw_cnt++;
// 14385       st.flag_otpw = true;
// 14386     }
// 14387     else if (otpw_cnt>0) otpw_cnt--;
// 14388 
// 14389     if (report_tmc_status) {
// 14390       const uint32_t pwm_scale = get_pwm_scale(st);
// 14391       SERIAL_ECHO(axisID);
// 14392       SERIAL_ECHOPAIR(":", pwm_scale);
// 14393       SERIAL_ECHO(" |0b"); MYSERIAL.print(get_status_response(st), BIN);
// 14394       SERIAL_ECHO("| ");
// 14395       if (data.is_error) SERIAL_ECHO('E');
// 14396       else if (data.is_ot) SERIAL_ECHO('O');
// 14397       else if (data.is_otpw) SERIAL_ECHO('W');
// 14398       else if (otpw_cnt>0) MYSERIAL.print(otpw_cnt, DEC);
// 14399       else if (st.flag_otpw) SERIAL_ECHO('F');
// 14400       SERIAL_ECHO("\t");
// 14401     }
// 14402 
// 14403     return otpw_cnt;
// 14404   }
// 14405 
// 14406   void monitor_tmc_driver() {
// 14407     static millis_t next_cOT = 0;
// 14408     if (ELAPSED(millis(), next_cOT)) {
// 14409       next_cOT = millis() + 500;
// 14410       #if ENABLED(X_IS_TMC2130)|| (ENABLED(X_IS_TMC2208) && defined(X_HARDWARE_SERIAL)) || ENABLED(IS_TRAMS)
// 14411         static uint8_t x_otpw_cnt = 0;
// 14412         x_otpw_cnt = monitor_tmc_driver(stepperX, axis_codes[X_AXIS], x_otpw_cnt);
// 14413       #endif
// 14414       #if ENABLED(Y_IS_TMC2130)|| (ENABLED(Y_IS_TMC2208) && defined(Y_HARDWARE_SERIAL)) || ENABLED(IS_TRAMS)
// 14415         static uint8_t y_otpw_cnt = 0;
// 14416         y_otpw_cnt = monitor_tmc_driver(stepperY, axis_codes[Y_AXIS], y_otpw_cnt);
// 14417       #endif
// 14418       #if ENABLED(Z_IS_TMC2130)|| (ENABLED(Z_IS_TMC2208) && defined(Z_HARDWARE_SERIAL)) || ENABLED(IS_TRAMS)
// 14419         static uint8_t z_otpw_cnt = 0;
// 14420         z_otpw_cnt = monitor_tmc_driver(stepperZ, axis_codes[Z_AXIS], z_otpw_cnt);
// 14421       #endif
// 14422       #if ENABLED(X2_IS_TMC2130) || (ENABLED(X2_IS_TMC2208) && defined(X2_HARDWARE_SERIAL))
// 14423         static uint8_t x2_otpw_cnt = 0;
// 14424         x2_otpw_cnt = monitor_tmc_driver(stepperX2, axis_codes[X_AXIS], x2_otpw_cnt);
// 14425       #endif
// 14426       #if ENABLED(Y2_IS_TMC2130) || (ENABLED(Y2_IS_TMC2208) && defined(Y2_HARDWARE_SERIAL))
// 14427         static uint8_t y2_otpw_cnt = 0;
// 14428         y2_otpw_cnt = monitor_tmc_driver(stepperY2, axis_codes[Y_AXIS], y2_otpw_cnt);
// 14429       #endif
// 14430       #if ENABLED(Z2_IS_TMC2130) || (ENABLED(Z2_IS_TMC2208) && defined(Z2_HARDWARE_SERIAL))
// 14431         static uint8_t z2_otpw_cnt = 0;
// 14432         z2_otpw_cnt = monitor_tmc_driver(stepperZ2, axis_codes[Z_AXIS], z2_otpw_cnt);
// 14433       #endif
// 14434       #if ENABLED(E0_IS_TMC2130)|| (ENABLED(E0_IS_TMC2208) && defined(E0_HARDWARE_SERIAL)) || ENABLED(IS_TRAMS)
// 14435         static uint8_t e0_otpw_cnt = 0;
// 14436         e0_otpw_cnt = monitor_tmc_driver(stepperE0, axis_codes[E_AXIS], e0_otpw_cnt);
// 14437       #endif
// 14438       #if ENABLED(E1_IS_TMC2130) || (ENABLED(E1_IS_TMC2208) && defined(E1_HARDWARE_SERIAL))
// 14439         static uint8_t e1_otpw_cnt = 0;
// 14440         e1_otpw_cnt = monitor_tmc_driver(stepperE1, axis_codes[E_AXIS], e1_otpw_cnt);
// 14441       #endif
// 14442       #if ENABLED(E2_IS_TMC2130) || (ENABLED(E2_IS_TMC2208) && defined(E2_HARDWARE_SERIAL))
// 14443         static uint8_t e2_otpw_cnt = 0;
// 14444         e2_otpw_cnt = monitor_tmc_driver(stepperE2, axis_codes[E_AXIS], e2_otpw_cnt);
// 14445       #endif
// 14446       #if ENABLED(E3_IS_TMC2130) || (ENABLED(E3_IS_TMC2208) && defined(E3_HARDWARE_SERIAL))
// 14447         static uint8_t e3_otpw_cnt = 0;
// 14448         e3_otpw_cnt = monitor_tmc_driver(stepperE3, axis_codes[E_AXIS], e3_otpw_cnt);
// 14449       #endif
// 14450       #if ENABLED(E4_IS_TMC2130) || (ENABLED(E4_IS_TMC2208) && defined(E4_HARDWARE_SERIAL))
// 14451         static uint8_t e4_otpw_cnt = 0;
// 14452         e4_otpw_cnt = monitor_tmc_driver(stepperE4, axis_codes[E_AXIS], e4_otpw_cnt);
// 14453       #endif
// 14454 
// 14455       if (report_tmc_status) SERIAL_EOL();
// 14456     }
// 14457   }
// 14458 
// 14459 #endif // MONITOR_DRIVER_STATUS
// 14460 
// 14461 /**
// 14462  * Manage several activities:
// 14463  *  - Check for Filament Runout
// 14464  *  - Keep the command buffer full
// 14465  *  - Check for maximum inactive time between commands
// 14466  *  - Check for maximum inactive time between stepper commands
// 14467  *  - Check if pin CHDK needs to go LOW
// 14468  *  - Check for KILL button held down
// 14469  *  - Check for HOME button held down
// 14470  *  - Check if cooling fan needs to be switched on
// 14471  *  - Check if an idle but hot extruder needs filament extruded (EXTRUDER_RUNOUT_PREVENT)
// 14472  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock57 Using cfiCommon0
          CFI Function _Z17manage_inactivityb
        THUMB
// 14473 void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
_Z17manage_inactivityb:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        MOV      R4,R0
// 14474 
// 14475   #if ENABLED(FILAMENT_RUNOUT_SENSOR)
// 14476     if ((IS_SD_PRINTING || print_job_timer.isRunning()) && (READ(FIL_RUNOUT_PIN) == FIL_RUNOUT_INVERTING))
// 14477       handle_filament_runout();
// 14478   #endif
// 14479 
// 14480   if (commands_in_queue < BUFSIZE) get_available_commands();
        LDR.N    R5,??DataTable108_1
        LDRB     R0,[R5, #+14]
        CMP      R0,#+4
        BGE.N    ??manage_inactivity_0
          CFI FunCall _Z22get_available_commandsv
        BL       _Z22get_available_commandsv
// 14481 
// 14482   const millis_t ms = millis();
??manage_inactivity_0:
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        MOV      R6,R0
// 14483 
// 14484   if (max_inactive_time && ELAPSED(ms, previous_cmd_ms + max_inactive_time)) {
        LDR.N    R7,??DataTable106
        LDR      R0,[R7, #+4]
        CMP      R0,#+0
        BEQ.N    ??manage_inactivity_1
        LDR      R1,[R7, #+0]
        SUBS     R1,R6,R1
        SUBS     R0,R1,R0
        BMI.N    ??manage_inactivity_1
// 14485     SERIAL_ERROR_START();
        LDR.W    R0,??DataTable127
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 14486     SERIAL_ECHOLNPAIR(MSG_KILL_INACTIVE_TIME, parser.command_ptr);
        LDR.W    R0,??DataTable124
        LDR      R1,[R0, #+0]
        ADR.W    R0,`?<Constant "KILL caused by too mu...">`
          CFI FunCall _Z17serial_echopair_PPKcS0_
        BL       _Z17serial_echopair_PPKcS0_
        MOVS     R1,#+10
        LDR.W    R0,??DataTable124_1
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 14487     kill(PSTR(MSG_KILLED));
        ADR.W    R0,`?<Constant "KILLED. ">`
          CFI FunCall _Z4killPKc
        BL       _Z4killPKc
// 14488   }
// 14489 
// 14490   // Prevent steppers timing-out in the middle of M600
// 14491   #if ENABLED(ADVANCED_PAUSE_FEATURE) && ENABLED(PAUSE_PARK_NO_STEPPER_TIMEOUT)
// 14492     #define MOVE_AWAY_TEST !move_away_flag
// 14493   #else
// 14494     #define MOVE_AWAY_TEST true
// 14495   #endif
// 14496 
// 14497   if (MOVE_AWAY_TEST && stepper_inactive_time && ELAPSED(ms, previous_cmd_ms + stepper_inactive_time)
// 14498       && !ignore_stepper_queue && !planner.blocks_queued()) {
??manage_inactivity_1:
        LDR      R0,[R7, #+8]
        CMP      R0,#+0
        BEQ.N    ??manage_inactivity_2
        LDR      R1,[R7, #+0]
        SUBS     R1,R6,R1
        SUBS     R0,R1,R0
        BMI.N    ??manage_inactivity_2
        CMP      R4,#+0
        BNE.N    ??manage_inactivity_2
          CFI FunCall _ZN7Planner13blocks_queuedEv
        BL       _ZN7Planner13blocks_queuedEv
        CMP      R0,#+0
        BNE.N    ??manage_inactivity_2
// 14499     #if ENABLED(DISABLE_INACTIVE_X)
// 14500       disable_X();
// 14501     #endif
// 14502     #if ENABLED(DISABLE_INACTIVE_Y)
// 14503       disable_Y();
// 14504     #endif
// 14505     #if ENABLED(DISABLE_INACTIVE_Z)
// 14506       disable_Z();
        MOVS     R2,#+1
        LDR.W    R0,??DataTable122
        LDRH     R1,[R0, #+4]
        LDR.W    R0,??DataTable123_1
        LDR      R0,[R0, #+8]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        MOVS     R0,#+0
        STRB     R0,[R5, #+10]
// 14507     #endif
// 14508     #if ENABLED(DISABLE_INACTIVE_E)
// 14509       disable_e_steppers();
          CFI FunCall _Z18disable_e_steppersv
        BL       _Z18disable_e_steppersv
// 14510     #endif
// 14511     #if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(ULTIPANEL)  // Only needed with an LCD
// 14512       ubl.lcd_map_control = defer_return_to_status = false;
// 14513     #endif
// 14514   }
// 14515 
// 14516   #ifdef CHDK // Check if pin should be set to LOW after M240 set it to HIGH
// 14517     if (chdkActive && ELAPSED(ms, chdkHigh + CHDK_DELAY)) {
// 14518       chdkActive = false;
// 14519       WRITE(CHDK, LOW);
// 14520     }
// 14521   #endif
// 14522 
// 14523   #if HAS_KILL
// 14524 
// 14525     // Check if the kill button was pressed and wait just in case it was an accidental
// 14526     // key kill key press
// 14527     // -------------------------------------------------------------------------------
// 14528     static int killCount = 0;   // make the inactivity button a bit less responsive
// 14529     const int KILL_DELAY = 750;
// 14530     if (!READ(KILL_PIN))
// 14531       killCount++;
// 14532     else if (killCount > 0)
// 14533       killCount--;
// 14534 
// 14535     // Exceeded threshold and we can confirm that it was not accidental
// 14536     // KILL the machine
// 14537     // ----------------------------------------------------------------
// 14538     if (killCount >= KILL_DELAY) {
// 14539       SERIAL_ERROR_START();
// 14540       SERIAL_ERRORLNPGM(MSG_KILL_BUTTON);
// 14541       kill(PSTR(MSG_KILLED));
// 14542     }
// 14543   #endif
// 14544 
// 14545   #if HAS_HOME
// 14546     // Check to see if we have to home, use poor man's debouncer
// 14547     // ---------------------------------------------------------
// 14548     static int homeDebounceCount = 0;   // poor man's debouncing count
// 14549     const int HOME_DEBOUNCE_DELAY = 2500;
// 14550     if (!IS_SD_PRINTING && !READ(HOME_PIN)) {
// 14551       if (!homeDebounceCount) {
// 14552         enqueue_and_echo_commands_P(PSTR("G28"));
// 14553         LCD_MESSAGEPGM(MSG_AUTO_HOME);
// 14554       }
// 14555       if (homeDebounceCount < HOME_DEBOUNCE_DELAY)
// 14556         homeDebounceCount++;
// 14557       else
// 14558         homeDebounceCount = 0;
// 14559     }
// 14560   #endif
// 14561 
// 14562   #if ENABLED(USE_CONTROLLER_FAN)
// 14563     controllerFan(); // Check if fan should be turned on to cool stepper drivers down
// 14564   #endif
// 14565 
// 14566   #if ENABLED(EXTRUDER_RUNOUT_PREVENT)
// 14567     if (ELAPSED(ms, previous_cmd_ms + (EXTRUDER_RUNOUT_SECONDS) * 1000UL)
// 14568       && thermalManager.degHotend(active_extruder) > EXTRUDER_RUNOUT_MINTEMP) {
// 14569       #if ENABLED(SWITCHING_EXTRUDER)
// 14570         const bool oldstatus = E0_ENABLE_READ;
// 14571         enable_E0();
// 14572       #else // !SWITCHING_EXTRUDER
// 14573         bool oldstatus;
// 14574         switch (active_extruder) {
// 14575           default: oldstatus = E0_ENABLE_READ; enable_E0(); break;
// 14576           #if E_STEPPERS > 1
// 14577             case 1: oldstatus = E1_ENABLE_READ; enable_E1(); break;
// 14578             #if E_STEPPERS > 2
// 14579               case 2: oldstatus = E2_ENABLE_READ; enable_E2(); break;
// 14580               #if E_STEPPERS > 3
// 14581                 case 3: oldstatus = E3_ENABLE_READ; enable_E3(); break;
// 14582                 #if E_STEPPERS > 4
// 14583                   case 4: oldstatus = E4_ENABLE_READ; enable_E4(); break;
// 14584                 #endif // E_STEPPERS > 4
// 14585               #endif // E_STEPPERS > 3
// 14586             #endif // E_STEPPERS > 2
// 14587           #endif // E_STEPPERS > 1
// 14588         }
// 14589       #endif // !SWITCHING_EXTRUDER
// 14590 
// 14591       previous_cmd_ms = ms; // refresh_cmd_timeout()
// 14592 
// 14593       const float olde = current_position[E_AXIS];
// 14594       current_position[E_AXIS] += EXTRUDER_RUNOUT_EXTRUDE;
// 14595       planner.buffer_line_kinematic(current_position, MMM_TO_MMS(EXTRUDER_RUNOUT_SPEED), active_extruder);
// 14596       current_position[E_AXIS] = olde;
// 14597       planner.set_e_position_mm(olde);
// 14598       stepper.synchronize();
// 14599       #if ENABLED(SWITCHING_EXTRUDER)
// 14600         E0_ENABLE_WRITE(oldstatus);
// 14601       #else
// 14602         switch (active_extruder) {
// 14603           case 0: E0_ENABLE_WRITE(oldstatus); break;
// 14604           #if E_STEPPERS > 1
// 14605             case 1: E1_ENABLE_WRITE(oldstatus); break;
// 14606             #if E_STEPPERS > 2
// 14607               case 2: E2_ENABLE_WRITE(oldstatus); break;
// 14608               #if E_STEPPERS > 3
// 14609                 case 3: E3_ENABLE_WRITE(oldstatus); break;
// 14610                 #if E_STEPPERS > 4
// 14611                   case 4: E4_ENABLE_WRITE(oldstatus); break;
// 14612                 #endif // E_STEPPERS > 4
// 14613               #endif // E_STEPPERS > 3
// 14614             #endif // E_STEPPERS > 2
// 14615           #endif // E_STEPPERS > 1
// 14616         }
// 14617       #endif // !SWITCHING_EXTRUDER
// 14618     }
// 14619   #endif // EXTRUDER_RUNOUT_PREVENT
// 14620 
// 14621   #if ENABLED(DUAL_X_CARRIAGE)
// 14622     // handle delayed move timeout
// 14623     if (delayed_move_time && ELAPSED(ms, delayed_move_time + 1000UL) && IsRunning()) {
// 14624       // travel moves have been received so enact them
// 14625       delayed_move_time = 0xFFFFFFFFUL; // force moves to be done
// 14626       set_destination_from_current();
// 14627       prepare_move_to_destination();
// 14628     }
// 14629   #endif
// 14630 
// 14631   #if ENABLED(TEMP_STAT_LEDS)
// 14632     handle_status_leds();
// 14633   #endif
// 14634 
// 14635   #if ENABLED(MONITOR_DRIVER_STATUS)
// 14636     monitor_tmc_driver();
// 14637   #endif
// 14638 
// 14639   planner.check_axes_activity();
??manage_inactivity_2:
        POP      {R0,R4-R7,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Planner19check_axes_activityEv
        B.W      _ZN7Planner19check_axes_activityEv
          CFI EndBlock cfiBlock57
// 14640 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable103:
        DC32     0x40c90fdb

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "KILL caused by too mu...">`:
        DC8 4BH, 49H, 4CH, 4CH, 20H, 63H, 61H, 75H
        DC8 73H, 65H, 64H, 20H, 62H, 79H, 20H, 74H
        DC8 6FH, 6FH, 20H, 6DH, 75H, 63H, 68H, 20H
        DC8 69H, 6EH, 61H, 63H, 74H, 69H, 76H, 65H
        DC8 20H, 74H, 69H, 6DH, 65H, 20H, 2DH, 20H
        DC8 63H, 75H, 72H, 72H, 65H, 6EH, 74H, 20H
        DC8 63H, 6FH, 6DH, 6DH, 61H, 6EH, 64H, 3AH
        DC8 20H, 0
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "KILLED. ">`:
        DC8 "KILLED. "
        DC8 0, 0, 0
// 14641 
// 14642 /**
// 14643  * Standard idle routine keeps the machine alive
// 14644  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock58 Using cfiCommon0
          CFI Function _Z4idlev
        THUMB
// 14645 void idle(
// 14646   #if ENABLED(ADVANCED_PAUSE_FEATURE)
// 14647     bool no_stepper_sleep/*=false*/
// 14648   #endif
// 14649 ) {
_Z4idlev:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 14650   #if ENABLED(MAX7219_DEBUG)
// 14651     Max7219_idle_tasks();
// 14652   #endif  // MAX7219_DEBUG
// 14653 
// 14654   host_keepalive();
// 14655 
// 14656   #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND || HAS_TEMP_BED)
// 14657     thermalManager.auto_report_temperatures();
// 14658   #endif
// 14659 
// 14660   manage_inactivity(
// 14661     #if ENABLED(ADVANCED_PAUSE_FEATURE)
// 14662       no_stepper_sleep
// 14663     #endif
// 14664   );
        MOVS     R0,#+0
          CFI FunCall _Z17manage_inactivityb
        BL       _Z17manage_inactivityb
// 14665 
// 14666   #if ENABLED(PRINTCOUNTER)
// 14667     print_job_timer.tick();
// 14668   #endif
// 14669 
// 14670   #if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
// 14671     buzzer.tick();
// 14672   #endif
// 14673 
// 14674   GUI_RefreshPage();
          CFI FunCall GUI_RefreshPage
        BL       GUI_RefreshPage
// 14675 
// 14676   if(preview_no_display != 1)
        LDR.W    R0,??DataTable127_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BEQ.N    ??idle_0
// 14677   {
// 14678 	  disp_pre_gcode(25,15);
        MOVS     R1,#+15
        MOVS     R0,#+25
          CFI FunCall disp_pre_gcode
        BL       disp_pre_gcode
// 14679   }
// 14680 
// 14681   GUI_TOUCH_Exec(); 	  
??idle_0:
          CFI FunCall GUI_TOUCH_Exec
        BL       GUI_TOUCH_Exec
// 14682   GUI_Exec(); 
          CFI FunCall GUI_Exec
        BL       GUI_Exec
// 14683 
// 14684   mksdlp.PrintStatePolling();
        LDR.N    R0,??DataTable104
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7MKS_DLP17PrintStatePollingEv
        B.W      _ZN7MKS_DLP17PrintStatePollingEv
          CFI EndBlock cfiBlock58
// 14685   
// 14686   #if ENABLED(I2C_POSITION_ENCODERS)
// 14687     if (planner.blocks_queued() &&
// 14688         ( (blockBufferIndexRef != planner.block_buffer_head) ||
// 14689           ((lastUpdateMillis + I2CPE_MIN_UPD_TIME_MS) < millis())) ) {
// 14690       blockBufferIndexRef = planner.block_buffer_head;
// 14691       I2CPEM.update();
// 14692       lastUpdateMillis = millis();
// 14693     }
// 14694   #endif
// 14695 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable104:
        DC32     card+0x9C4
// 14696 
// 14697 extern "C" void kill_c(const char* lcd_msg);

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock59 Using cfiCommon0
          CFI Function kill_c
        THUMB
// 14698 void kill_c(const char* lcd_msg) {
kill_c:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 14699   SERIAL_ERROR_START();
        LDR.W    R0,??DataTable127
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 14700   SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
        ADR.W    R0,`?<Constant "Printer halted. kill(...">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 14701 
// 14702   thermalManager.disable_all_heaters();
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
// 14703   disable_all_steppers();
          CFI FunCall _Z20disable_all_steppersv
        BL       _Z20disable_all_steppersv
// 14704 
// 14705   #if ENABLED(ULTRA_LCD)
// 14706     kill_screen(lcd_msg);
// 14707   #else
// 14708     UNUSED(lcd_msg);
// 14709   #endif
// 14710 
// 14711   _delay_ms(600); // Wait a short time (allows messages to get out before shutting down.
        MOV      R0,#+600
          CFI FunCall HAL_Delay
        BL       HAL_Delay
// 14712   cli(); // Stop interrupts
        cpsid i
// 14713 
// 14714   _delay_ms(250); //Wait to ensure all interrupts routines stopped
        MOVS     R0,#+250
          CFI FunCall HAL_Delay
        BL       HAL_Delay
// 14715   thermalManager.disable_all_heaters(); //turn off heaters again
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
// 14716 
// 14717   #if HAS_POWER_SWITCH
// 14718     SET_INPUT(PS_ON_PIN);
// 14719   #endif
// 14720 
// 14721   suicide();
          CFI FunCall _Z7suicidev
        BL       _Z7suicidev
// 14722   while (1) {
??kill_c_0:
        B.N      ??kill_c_0
          CFI EndBlock cfiBlock59
// 14723     #if ENABLED(USE_WATCHDOG)
// 14724       watchdog_reset();
// 14725     #endif
// 14726   } // Wait for reset
// 14727 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable105:
        DC32     0x3a83126f
// 14728 
// 14729 /**
// 14730  * Kill all activity and lock the machine.
// 14731  * After this the machine will need to be reset.
// 14732  */

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock60 Using cfiCommon0
          CFI Function _Z4killPKc
        THUMB
// 14733 void kill(const char* lcd_msg) {
_Z4killPKc:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 14734   SERIAL_ERROR_START();
        LDR.W    R0,??DataTable127
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 14735   SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
        ADR.W    R0,`?<Constant "Printer halted. kill(...">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 14736 
// 14737   thermalManager.disable_all_heaters();
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
// 14738   disable_all_steppers();
          CFI FunCall _Z20disable_all_steppersv
        BL       _Z20disable_all_steppersv
// 14739 
// 14740   #if ENABLED(ULTRA_LCD)
// 14741     kill_screen(lcd_msg);
// 14742   #else
// 14743     UNUSED(lcd_msg);
// 14744   #endif
// 14745 
// 14746   _delay_ms(600); // Wait a short time (allows messages to get out before shutting down.
        MOV      R0,#+600
          CFI FunCall HAL_Delay
        BL       HAL_Delay
// 14747  
// 14748 
// 14749   _delay_ms(250); //Wait to ensure all interrupts routines stopped
        MOVS     R0,#+250
          CFI FunCall HAL_Delay
        BL       HAL_Delay
// 14750    cli(); // Stop interrupts
        cpsid i
// 14751   thermalManager.disable_all_heaters(); //turn off heaters again
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
// 14752 
// 14753   #ifdef ACTION_ON_KILL
// 14754     SERIAL_ECHOLNPGM("//action:" ACTION_ON_KILL);
// 14755   #endif
// 14756 
// 14757   #if HAS_POWER_SWITCH
// 14758     SET_INPUT(PS_ON_PIN);
// 14759   #endif
// 14760 
// 14761   suicide();
          CFI FunCall _Z7suicidev
        BL       _Z7suicidev
// 14762   while (1) {
??kill_0:
        B.N      ??kill_0
          CFI EndBlock cfiBlock60
// 14763     #if ENABLED(USE_WATCHDOG)
// 14764       watchdog_reset();
// 14765     #endif
// 14766   } // Wait for reset
// 14767 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable106:
        DC32     previous_cmd_ms

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Printer halted. kill(...">`:
        DC8 "Printer halted. kill() called!\012"
// 14768 
// 14769 /**
// 14770  * Turn off heaters and stop the print in progress
// 14771  * After a stop the machine may be resumed with M999
// 14772  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock61 Using cfiCommon0
          CFI Function _Z4stopv
        THUMB
// 14773 void stop() {
_Z4stopv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 14774   thermalManager.disable_all_heaters(); // 'unpause' taken care of in here
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
// 14775 
// 14776   #if ENABLED(PROBING_FANS_OFF)
// 14777     if (fans_paused) fans_pause(false); // put things back the way they were
// 14778   #endif
// 14779 
// 14780   if (IsRunning()) {
          CFI FunCall _Z9IsRunningv
        BL       _Z9IsRunningv
        CMP      R0,#+0
        BEQ.N    ??stop_0
// 14781     Stopped_gcode_LastN = gcode_LastN; // Save last g_code for restart
        LDR.W    R4,??DataTable112_1
        LDR      R0,[R4, #+4]
        STR      R0,[R4, #+8]
// 14782     SERIAL_ERROR_START();
        LDR.W    R0,??DataTable128_1
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 14783     SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
        ADR.W    R0,`?<Constant "Printer stopped due t...">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 14784     LCD_MESSAGEPGM(MSG_STOPPED);
        MOVS     R1,#+0
        ADR.W    R0,`?<Constant "STOPPED. ">`
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
// 14785     safe_delay(350);       // allow enough time for messages to get out before stopping
        MOV      R0,#+350
          CFI FunCall _Z10safe_delaym
        BL       _Z10safe_delaym
// 14786     Running = false;
        MOVS     R0,#+0
        STRB     R0,[R4, #+0]
// 14787   }
// 14788 }
??stop_0:
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock61

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable107:
        DC32     _ZN11GCodeParser14command_letterE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable107_1:
        DC32     _ZN11GCodeParser7codenumE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Printer stopped due t...">`:
        DC8 50H, 72H, 69H, 6EH, 74H, 65H, 72H, 20H
        DC8 73H, 74H, 6FH, 70H, 70H, 65H, 64H, 20H
        DC8 64H, 75H, 65H, 20H, 74H, 6FH, 20H, 65H
        DC8 72H, 72H, 6FH, 72H, 73H, 2EH, 20H, 46H
        DC8 69H, 78H, 20H, 74H, 68H, 65H, 20H, 65H
        DC8 72H, 72H, 6FH, 72H, 20H, 61H, 6EH, 64H
        DC8 20H, 75H, 73H, 65H, 20H, 4DH, 39H, 39H
        DC8 39H, 20H, 74H, 6FH, 20H, 72H, 65H, 73H
        DC8 74H, 61H, 72H, 74H, 2EH, 20H, 28H, 54H
        DC8 65H, 6DH, 70H, 65H, 72H, 61H, 74H, 75H
        DC8 72H, 65H, 20H, 69H, 73H, 20H, 72H, 65H
        DC8 73H, 65H, 74H, 2EH, 20H, 53H, 65H, 74H
        DC8 20H, 69H, 74H, 20H, 61H, 66H, 74H, 65H
        DC8 72H, 20H, 72H, 65H, 73H, 74H, 61H, 72H
        DC8 74H, 69H, 6EH, 67H, 29H, 0AH, 0
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "STOPPED. ">`:
        DC8 "STOPPED. "
        DC8 0, 0
// 14789 
// 14790 /**
// 14791  * Marlin entry-point: Set up before the program loop
// 14792  *  - Set up the kill pin, filament runout, power hold
// 14793  *  - Start the serial port
// 14794  *  - Print startup messages and diagnostics
// 14795  *  - Get EEPROM or default settings
// 14796  *  - Initialize managers for:
// 14797  *    â¢ temperature
// 14798  *    â¢ planner
// 14799  *    â¢ watchdog
// 14800  *    â¢ stepper
// 14801  *    â¢ photo pin
// 14802  *    â¢ servos
// 14803  *    â¢ LCD controller
// 14804  *    â¢ Digipot I2C
// 14805  *    â¢ Z probe sled
// 14806  *    â¢ status LEDs
// 14807  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock62 Using cfiCommon0
          CFI Function setup
        THUMB
// 14808 void setup() {
setup:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
// 14809 
// 14810   #if ENABLED(MAX7219_DEBUG)
// 14811     Max7219_init();
// 14812   #endif
// 14813 /*
// 14814   #if ENABLED(DISABLE_JTAG)
// 14815     // Disable JTAG on AT90USB chips to free up pins for IO
// 14816     MCUCR = 0x80;
// 14817     MCUCR = 0x80;
// 14818   #endif
// 14819   */
// 14820 
// 14821   #if ENABLED(FILAMENT_RUNOUT_SENSOR)
// 14822     setup_filrunoutpin();
// 14823   #endif
// 14824 
// 14825   setup_killpin();
          CFI FunCall _Z13setup_killpinv
        BL       _Z13setup_killpinv
// 14826 
// 14827   //setup_powerhold();
// 14828 
// 14829   #if HAS_STEPPER_RESET
// 14830     disableStepperDrivers();
// 14831   #endif
// 14832 
// 14833   //MYSERIAL.begin(BAUDRATE);
// 14834   //SERIAL_PROTOCOLLNPGM("start");
// 14835   //SERIAL_ECHO_START();
// 14836 
// 14837   #if ENABLED(HAVE_TMC2208)
// 14838     tmc2208_serial_begin();
// 14839   #endif
// 14840 
// 14841   // Check startup - does nothing if bootloader sets MCUSR to 0
// 14842   byte mcu = MCUSR;
// 14843   if (mcu &  1) SERIAL_ECHOLNPGM(MSG_POWERUP);
// 14844   if (mcu &  2) SERIAL_ECHOLNPGM(MSG_EXTERNAL_RESET);
// 14845   if (mcu &  4) SERIAL_ECHOLNPGM(MSG_BROWNOUT_RESET);
// 14846   if (mcu &  8) SERIAL_ECHOLNPGM(MSG_WATCHDOG_RESET);
// 14847   if (mcu & 32) SERIAL_ECHOLNPGM(MSG_SOFTWARE_RESET);
// 14848   //MCUSR = 0;
// 14849 
// 14850   SERIAL_ECHOPGM(MSG_MARLIN);
        ADR.W    R0,`?<Constant "MKS DLP">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 14851   SERIAL_CHAR(' ');
        LDR.W    R4,??DataTable124_1
        MOVS     R1,#+32
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 14852   SERIAL_ECHOLNPGM(SHORT_BUILD_VERSION);
        ADR.W    R0,`?<Constant "1.0.0\\n">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 14853   SERIAL_EOL();
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 14854 
// 14855   #if defined(STRING_DISTRIBUTION_DATE) && defined(STRING_CONFIG_H_AUTHOR)
// 14856     SERIAL_ECHO_START();
        LDR.W    R5,??DataTable117_1
        MOV      R0,R5
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 14857     SERIAL_ECHOPGM(MSG_CONFIGURATION_VER);
        ADR.W    R0,`?<Constant " Last Updated: ">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 14858     SERIAL_ECHOPGM(STRING_DISTRIBUTION_DATE);
        ADR.W    R0,`?<Constant "2017-12-25 12:00">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 14859     SERIAL_ECHOLNPGM(MSG_AUTHOR STRING_CONFIG_H_AUTHOR);
        ADR.W    R0,`?<Constant " | Author: (none, def...">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 14860     SERIAL_ECHO_START();
        MOV      R0,R5
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 14861     SERIAL_ECHOLNPGM("Compiled: " __DATE__);
        ADR.W    R0,`?<Constant "Compiled: Jul 18 2019\\n">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 14862   #endif
// 14863 
// 14864   SERIAL_ECHO_START();
        MOV      R0,R5
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 14865   SERIAL_ECHOPAIR(MSG_FREE_MEMORY, freeMemory());
          CFI FunCall _Z10freeMemoryv
        BL       _Z10freeMemoryv
        MOV      R1,R0
        ADR.W    R0,`?<Constant " Free Memory: ">`
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
// 14866   SERIAL_ECHOLNPAIR(MSG_PLANNER_BUFFER_BYTES, (int)sizeof(block_t)*BLOCK_BUFFER_SIZE);
        MOV      R1,#+1344
        ADR.W    R0,`?<Constant "  PlannerBufferBytes: ">`
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 14867 
// 14868   // Send "ok" after commands by default
// 14869   for (int8_t i = 0; i < BUFSIZE; i++) send_ok[i] = true;
        MOVS     R0,#+0
        MOVS     R2,#+1
        LDR.N    R4,??DataTable108_1
        B.N      ??setup_0
??setup_1:
        ADDS     R1,R1,R4
        STRB     R2,[R1, #+24]
        ADDS     R0,R0,#+1
??setup_0:
        SXTB     R0,R0
        MOV      R1,R0
        CMP      R1,#+4
        BLT.N    ??setup_1
// 14870 
// 14871   // Load data from EEPROM if available (or use defaults)
// 14872   // This also updates variables in the planner, elsewhere
// 14873   (void)settings.load();
          CFI FunCall _ZN14MarlinSettings4loadEv
        BL       _ZN14MarlinSettings4loadEv
// 14874 
// 14875   #if HAS_M206_COMMAND
// 14876     // Initialize current position based on home_offset
// 14877     COPY(current_position, home_offset);
        MOVS     R2,#+12
        ADD      R1,R4,#+80
        ADD      R0,R4,#+32
          CFI FunCall memcpy
        BL       memcpy
// 14878   #else
// 14879     ZERO(current_position);
// 14880   #endif
// 14881 
// 14882   // Vital to init stepper/planner equivalent for current_position
// 14883   SYNC_PLAN_POSITION_KINEMATIC();
          CFI FunCall _Z18sync_plan_positionv
        BL       _Z18sync_plan_positionv
// 14884 
// 14885   thermalManager.init();    // Initialize temperature loop
        LDR.W    R0,??DataTable131_1
          CFI FunCall _ZN11Temperature4initEv
        BL       _ZN11Temperature4initEv
// 14886 
// 14887   #if ENABLED(USE_WATCHDOG)
// 14888     watchdog_init();
// 14889   #endif
// 14890   //
// 14891   soft_endstop_min_init();
          CFI FunCall _Z21soft_endstop_min_initv
        BL       _Z21soft_endstop_min_initv
// 14892 
// 14893   stepper.init();    // Initialize stepper, this enables interrupts!
          CFI FunCall _ZN7Stepper4initEv
        BL       _ZN7Stepper4initEv
// 14894   servo_init();
          CFI FunCall _Z10servo_initv
        BL       _Z10servo_initv
// 14895 
// 14896   #if HAS_PHOTOGRAPH
// 14897     OUT_WRITE(PHOTOGRAPH_PIN, LOW);
// 14898   #endif
// 14899 
// 14900   #if HAS_CASE_LIGHT
// 14901     case_light_on = CASE_LIGHT_DEFAULT_ON;
// 14902     case_light_brightness = CASE_LIGHT_DEFAULT_BRIGHTNESS;
// 14903     update_case_light();
// 14904   #endif
// 14905 
// 14906   #if ENABLED(SPINDLE_LASER_ENABLE)
// 14907     OUT_WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);  // init spindle to off
// 14908     #if SPINDLE_DIR_CHANGE
// 14909       OUT_WRITE(SPINDLE_DIR_PIN, SPINDLE_INVERT_DIR ? 255 : 0);  // init rotation to clockwise (M3)
// 14910     #endif
// 14911     #if ENABLED(SPINDLE_LASER_PWM)
// 14912       SET_OUTPUT(SPINDLE_LASER_PWM_PIN);
// 14913       analogWrite(SPINDLE_LASER_PWM_PIN, SPINDLE_LASER_PWM_INVERT ? 255 : 0);  // set to lowest speed
// 14914     #endif
// 14915   #endif
// 14916 
// 14917   #if HAS_BED_PROBE
// 14918     endstops.enable_z_probe(false);
// 14919   #endif
// 14920 
// 14921   #if ENABLED(USE_CONTROLLER_FAN)
// 14922     SET_OUTPUT(CONTROLLER_FAN_PIN); //Set pin used for driver cooling fan
// 14923   #endif
// 14924 
// 14925   #if HAS_STEPPER_RESET
// 14926     enableStepperDrivers();
// 14927   #endif
// 14928 
// 14929   #if ENABLED(DIGIPOT_I2C)
// 14930     digipot_i2c_init();
// 14931   #endif
// 14932 
// 14933   #if ENABLED(DAC_STEPPER_CURRENT)
// 14934     dac_init();
// 14935   #endif
// 14936 
// 14937   #if (ENABLED(Z_PROBE_SLED) || ENABLED(SOLENOID_PROBE)) && HAS_SOLENOID_1
// 14938     OUT_WRITE(SOL1_PIN, LOW); // turn it off
// 14939   #endif
// 14940 
// 14941   #if HAS_HOME
// 14942     SET_INPUT_PULLUP(HOME_PIN);
// 14943   #endif
// 14944 
// 14945   #if PIN_EXISTS(STAT_LED_RED)
// 14946     OUT_WRITE(STAT_LED_RED_PIN, LOW); // turn it off
// 14947   #endif
// 14948 
// 14949   #if PIN_EXISTS(STAT_LED_BLUE)
// 14950     OUT_WRITE(STAT_LED_BLUE_PIN, LOW); // turn it off
// 14951   #endif
// 14952 
// 14953   #if HAS_COLOR_LEDS
// 14954     leds.setup();
// 14955   #endif
// 14956 
// 14957   #if ENABLED(RGB_LED) || ENABLED(RGBW_LED)
// 14958     SET_OUTPUT(RGB_LED_R_PIN);
// 14959     SET_OUTPUT(RGB_LED_G_PIN);
// 14960     SET_OUTPUT(RGB_LED_B_PIN);
// 14961     #if ENABLED(RGBW_LED)
// 14962       SET_OUTPUT(RGB_LED_W_PIN);
// 14963     #endif
// 14964   #endif
// 14965 
// 14966   #if ENABLED(MK2_MULTIPLEXER)
// 14967     SET_OUTPUT(E_MUX0_PIN);
// 14968     SET_OUTPUT(E_MUX1_PIN);
// 14969     SET_OUTPUT(E_MUX2_PIN);
// 14970   #endif
// 14971 
// 14972   #if HAS_FANMUX
// 14973     fanmux_init();
// 14974   #endif
// 14975 
// 14976   lcd_init();
        POP      {R0,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z8lcd_initv
        B.W      _Z8lcd_initv
          CFI EndBlock cfiBlock62
// 14977 
// 14978   #if ENABLED(SHOW_BOOTSCREEN)
// 14979     lcd_bootscreen();
// 14980   #endif
// 14981 
// 14982   #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
// 14983     // Virtual Tools 0, 1, 2, 3 = Filament 1, 2, 3, 4, etc.
// 14984     for (uint8_t t = 0; t < MIXING_VIRTUAL_TOOLS && t < MIXING_STEPPERS; t++)
// 14985       for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
// 14986         mixing_virtual_tool_mix[t][i] = (t == i) ? 1.0 : 0.0;
// 14987 
// 14988     // Remaining virtual tools are 100% filament 1
// 14989     #if MIXING_STEPPERS < MIXING_VIRTUAL_TOOLS
// 14990       for (uint8_t t = MIXING_STEPPERS; t < MIXING_VIRTUAL_TOOLS; t++)
// 14991         for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
// 14992           mixing_virtual_tool_mix[t][i] = (i == 0) ? 1.0 : 0.0;
// 14993     #endif
// 14994 
// 14995     // Initialize mixing to tool 0 color
// 14996     for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
// 14997       mixing_factor[i] = mixing_virtual_tool_mix[0][i];
// 14998   #endif
// 14999 
// 15000   #if ENABLED(BLTOUCH)
// 15001     // Make sure any BLTouch error condition is cleared
// 15002     bltouch_command(BLTOUCH_RESET);
// 15003     set_bltouch_deployed(true);
// 15004     set_bltouch_deployed(false);
// 15005   #endif
// 15006 
// 15007   #if ENABLED(I2C_POSITION_ENCODERS)
// 15008     I2CPEM.init();
// 15009   #endif
// 15010 
// 15011   #if ENABLED(EXPERIMENTAL_I2CBUS) && I2C_SLAVE_ADDRESS > 0
// 15012     i2c.onReceive(i2c_on_receive);
// 15013     i2c.onRequest(i2c_on_request);
// 15014   #endif
// 15015 
// 15016   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
// 15017     setup_endstop_interrupts();
// 15018   #endif
// 15019 
// 15020   #if ENABLED(SWITCHING_EXTRUDER) && !DONT_SWITCH
// 15021     move_extruder_servo(0);  // Initialize extruder servo
// 15022   #endif
// 15023 
// 15024   #if ENABLED(SWITCHING_NOZZLE)
// 15025     move_nozzle_servo(0);  // Initialize nozzle servo
// 15026   #endif
// 15027 
// 15028   #if ENABLED(PARKING_EXTRUDER)
// 15029     #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
// 15030       pe_activate_magnet(0);
// 15031       pe_activate_magnet(1);
// 15032     #else
// 15033       pe_deactivate_magnet(0);
// 15034       pe_deactivate_magnet(1);
// 15035     #endif
// 15036   #endif
// 15037   #if ENABLED(MKS_12864OLED) || ENABLED(MKS_12864OLED_SSD1306)
// 15038     SET_OUTPUT(LCD_PINS_DC);
// 15039     OUT_WRITE(LCD_PINS_RS, LOW);
// 15040     delay(1000);
// 15041     WRITE(LCD_PINS_RS, HIGH);
// 15042   #endif
// 15043 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable108:
        DC32     gCfgItems

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable108_1:
        DC32     axis_relative_modes

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "MKS DLP">`:
        DC8 "MKS DLP"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "1.0.0\\n">`:
        DC8 "1.0.0\012"
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant " Last Updated: ">`:
        DC8 " Last Updated: "

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "2017-12-25 12:00">`:
        DC8 "2017-12-25 12:00"
        DC8 0, 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant " | Author: (none, def...">`:
        DC8 " | Author: (none, default config)\012"
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Compiled: Jul 18 2019\\n">`:
        DC8 "Compiled: Jul 18 2019\012"
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant " Free Memory: ">`:
        DC8 " Free Memory: "
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "  PlannerBufferBytes: ">`:
        DC8 "  PlannerBufferBytes: "
        DC8 0
// 15044 
// 15045 /**
// 15046  * The main Marlin program loop
// 15047  *
// 15048  *  - Save or log commands to SD
// 15049  *  - Process available commands (if not saving)
// 15050  *  - Call heater manager
// 15051  *  - Call inactivity manager
// 15052  *  - Call endstop manager
// 15053  *  - Call LCD update
// 15054  */
// 15055 
// 15056 
// 15057 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock63 Using cfiCommon0
          CFI Function loop
        THUMB
// 15058 void loop() 
// 15059 {
loop:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
// 15060   if (commands_in_queue < BUFSIZE) get_available_commands();
        LDR.W    R4,??DataTable112_2
        LDRB     R0,[R4, #+14]
        CMP      R0,#+4
        BGE.N    ??loop_0
          CFI FunCall _Z22get_available_commandsv
        BL       _Z22get_available_commandsv
// 15061 
// 15062   mksdlp.get_available_bmps();
??loop_0:
        LDR.N    R5,??DataTable109
        ADDW     R0,R5,#+2500
          CFI FunCall _ZN7MKS_DLP18get_available_bmpsEv
        BL       _ZN7MKS_DLP18get_available_bmpsEv
// 15063 
// 15064   card.checkFilesys(gCfgItems.fileSysType);
        LDR.W    R0,??DataTable131_2
        LDRB     R1,[R0, #+218]
        MOV      R0,R5
          CFI FunCall _ZN10CardReader12checkFilesysEh
        BL       _ZN10CardReader12checkFilesysEh
// 15065 
// 15066   if (commands_in_queue) {
        LDRB     R0,[R4, #+14]
        CMP      R0,#+0
        BEQ.N    ??loop_1
// 15067 
// 15068     #if ENABLED(SDSUPPORT)
// 15069 
// 15070       if (card.saving) {
        LDRB     R0,[R5, #+2489]
        CMP      R0,#+0
        BEQ.N    ??loop_2
// 15071         char* command = command_queue[cmd_queue_index_r];
        LDRB     R0,[R4, #+15]
        ADD      R1,R0,R0, LSL #+1
        ADD      R0,R4,R1, LSL #+5
        ADD      R6,R0,#+140
// 15072         if (strstr_P(command, PSTR("M29"))) {
        ADR.N    R1,??DataTable111  ;; "M29"
        MOV      R0,R6
          CFI FunCall _Z6strstrPcPKc
        BL       _Z6strstrPcPKc
        CMP      R0,#+0
        BEQ.N    ??loop_3
// 15073           // M29 closes the file
// 15074           card.closefile();
        MOVS     R1,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader9closefileEb
        BL       _ZN10CardReader9closefileEb
// 15075           SERIAL_PROTOCOLLNPGM(MSG_FILE_SAVED);
        ADR.W    R0,`?<Constant "Done saving file.\\n">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15076 
// 15077           #if ENABLED(SERIAL_STATS_DROPPED_RX)
// 15078             SERIAL_ECHOLNPAIR("Dropped bytes: ", customizedSerial.dropped());
// 15079           #endif
// 15080 
// 15081           #if ENABLED(SERIAL_STATS_MAX_RX_QUEUED)
// 15082             SERIAL_ECHOLNPAIR("Max RX Queue Size: ", customizedSerial.rxMaxEnqueued());
// 15083           #endif
// 15084 
// 15085           ok_to_send();
          CFI FunCall _Z10ok_to_sendv
        BL       _Z10ok_to_sendv
        B.N      ??loop_4
// 15086         }
// 15087         else {
// 15088           // Write the string from the read buffer to SD
// 15089           card.write_command(command);
??loop_3:
        MOV      R1,R6
        MOV      R0,R5
          CFI FunCall _ZN10CardReader13write_commandEPc
        BL       _ZN10CardReader13write_commandEPc
// 15090           if (card.logging)
        LDRB     R0,[R5, #+2490]
        CMP      R0,#+0
        BEQ.N    ??loop_5
// 15091             process_next_command(); // The card is saving because it's logging
          CFI FunCall _Z20process_next_commandv
        BL       _Z20process_next_commandv
        B.N      ??loop_4
// 15092           else
// 15093             ok_to_send();
??loop_5:
          CFI FunCall _Z10ok_to_sendv
        BL       _Z10ok_to_sendv
        B.N      ??loop_4
// 15094         }
// 15095       }
// 15096       else
// 15097         process_next_command();
??loop_2:
          CFI FunCall _Z20process_next_commandv
        BL       _Z20process_next_commandv
// 15098 
// 15099     #else
// 15100 
// 15101       process_next_command();
// 15102 
// 15103     #endif // SDSUPPORT
// 15104 
// 15105     // The queue may be reset by a command handler or by code invoked by idle() within a handler
// 15106     if (commands_in_queue) {
??loop_4:
        LDRB     R0,[R4, #+14]
        CMP      R0,#+0
        BEQ.N    ??loop_1
// 15107       --commands_in_queue;
        SUBS     R0,R0,#+1
        STRB     R0,[R4, #+14]
// 15108       if (++cmd_queue_index_r >= BUFSIZE) cmd_queue_index_r = 0;
        LDRB     R0,[R4, #+15]
        ADDS     R0,R0,#+1
        STRB     R0,[R4, #+15]
        UXTB     R0,R0
        CMP      R0,#+4
        BLT.N    ??loop_1
        MOVS     R0,#+0
        STRB     R0,[R4, #+15]
// 15109     }
// 15110   }
// 15111   endstops.report_state();
??loop_1:
          CFI FunCall _ZN8Endstops12report_stateEv
        BL       _ZN8Endstops12report_stateEv
// 15112   idle();
          CFI FunCall _Z4idlev
        BL       _Z4idlev
// 15113   
// 15114   mks_PrintStatePolling();
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall mks_PrintStatePolling
        B.N      mks_PrintStatePolling
          CFI EndBlock cfiBlock63
// 15115 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable109:
        DC32     card

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable109_1:
        DC32     curFileName

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Done saving file.\\n">`:
        DC8 "Done saving file.\012"
        DC8 0

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
printing_rate_update_flag:
        DS8 1
// 15116 #if 1
// 15117 uint16_t z_high_count;
// 15118 
// 15119 
// 15120 
// 15121 uint8_t btn_flg;
btn_flg:
        DS8 1
z_high_count:
        DS8 2
        DS8 4
TimeIncrease:
        DS8 4
// 15122 uint32_t btn_beep_cnt;
btn_beep_cnt:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
preview_no_display:
        DS8 1
// 15123 
// 15124 extern void mksBeeperAlarm(void);
// 15125 
// 15126 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock64 Using cfiCommon0
          CFI Function _Z20SysTick_Handler_Userv
        THUMB
// 15127 void SysTick_Handler_User()
// 15128 {
_Z20SysTick_Handler_Userv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 15129 		TimeIncrease++;
        LDR.W    R4,??DataTable133
        LDR      R0,[R4, #+8]
        ADDS     R0,R0,#+1
        STR      R0,[R4, #+8]
// 15130 
// 15131 
// 15132 	
// 15133 		temperature_change_frequency_cnt++;
        LDR      R0,[R4, #+4]
        ADDS     R0,R0,#+1
        STR      R0,[R4, #+4]
// 15134 		if((temperature_change_frequency_cnt>=2000)&&(temperature_change_frequency!=1))
        CMP      R0,#+2000
        BCC.N    ??SysTick_Handler_User_0
        LDR.W    R0,??DataTable134
        LDRB     R1,[R0, #+0]
        CMP      R1,#+1
        BEQ.N    ??SysTick_Handler_User_0
// 15135 		{
// 15136 			temperature_change_frequency_cnt = 0;
        MOVS     R1,#+0
        STR      R1,[R4, #+4]
// 15137 			temperature_change_frequency = 1;
        MOVS     R1,#+1
        STRB     R1,[R0, #+0]
// 15138 		}
// 15139 		
// 15140 		if(!(TimeIncrease * TICK_CYCLE % 3000))	// 3s
??SysTick_Handler_User_0:
        LDR      R0,[R4, #+8]
        MOVW     R1,#+3000
        UDIV     R1,R0,R1
        MOVW     R2,#+3000
        MLS      R0,R2,R1,R0
        CMP      R0,#+0
        BNE.N    ??SysTick_Handler_User_1
// 15141 		{		
// 15142 			printing_rate_update_flag = 1;
        MOVS     R0,#+1
        STRB     R0,[R4, #+0]
// 15143 		}	
// 15144 
// 15145 		if((TimeIncrease * TICK_CYCLE % 1000) == 0) 
??SysTick_Handler_User_1:
        LDR      R0,[R4, #+8]
        MOV      R1,#+1000
        MOV      R2,R1
        UDIV     R2,R0,R2
        MLS      R0,R1,R2,R0
        CMP      R0,#+0
        BNE.N    ??SysTick_Handler_User_2
// 15146 		{		
// 15147 			if(print_time.start == 1)
        LDR.W    R0,??DataTable134_1
        LDRSB    R2,[R0, #+7]
        CMP      R2,#+1
        BNE.N    ??SysTick_Handler_User_2
// 15148 			{
// 15149 				print_time.seconds++;
        LDRB     R2,[R0, #+5]
        ADDS     R2,R2,#+1
        STRB     R2,[R0, #+5]
// 15150 			}
// 15151 		}
// 15152 		if((TimeIncrease * TICK_CYCLE % 1000) == 0)
??SysTick_Handler_User_2:
        LDR      R0,[R4, #+8]
        MOV      R2,R1
        UDIV     R2,R0,R2
        MLS      R0,R1,R2,R0
        CMP      R0,#+0
        BNE.N    ??SysTick_Handler_User_3
// 15153 		{
// 15154 			z_high_count=1;
        MOVS     R0,#+1
        STRH     R0,[R4, #+2]
// 15155 		}
// 15156 
// 15157 	mksBeeperAlarm();
??SysTick_Handler_User_3:
          CFI FunCall _Z14mksBeeperAlarmv
        BL       _Z14mksBeeperAlarmv
// 15158 
// 15159     if(btn_flg==1)
        LDRB     R0,[R4, #+1]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_4
// 15160     {
// 15161         btn_beep_cnt--;
        LDR      R0,[R4, #+12]
        SUBS     R0,R0,#+1
        STR      R0,[R4, #+12]
// 15162         if(btn_beep_cnt==0)
        BNE.N    ??SysTick_Handler_User_4
// 15163         {
// 15164             btn_beep_cnt=0;
// 15165             BEEPER_OP=0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable136  ;; 0x42430288
        STR      R0,[R1, #+0]
// 15166         }
// 15167     }
// 15168 }
??SysTick_Handler_User_4:
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock64

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable110:
        DC32     from_flash_pic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable110_1:
        DC32     flash_preview_begin

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable110_2:
        DC32     default_preview_flg
// 15169 #endif
// 15170 
// 15171 #include "mks_reprint.cpp"

        SECTION `.data`:DATA:REORDER:NOROOT(2)
// __absolute char *mks_pft_name
mks_pft_name:
        DATA
        DC32 `?<Constant "mks_pft.sys">`

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock65 Using cfiCommon0
          CFI Function mkstft_ui_load
        THUMB
// __interwork __softfp void mkstft_ui_load()
mkstft_ui_load:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.W    R4,??DataTable131_2
        MOVS     R2,#+4
        ADDS     R1,R4,#+4
        MOVW     R0,#+1479
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+8
        MOVW     R0,#+1503
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+12
        MOVW     R0,#+1595
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+16
        MOVW     R0,#+1507
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+104
        MOVW     R0,#+1495
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+100
        MOVW     R0,#+1499
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+20
        MOVW     R0,#+1599
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+24
        MOVW     R0,#+1603
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+28
        MOVW     R0,#+1607
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+32
        MOVW     R0,#+1527
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+36
        MOVW     R0,#+1611
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+40
        MOVW     R0,#+1531
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+60
        MOVW     R0,#+1615
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+64
        MOVW     R0,#+1619
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+68
        MOVW     R0,#+1535
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+72
        MOVW     R0,#+1539
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+76
        MOVW     R0,#+1623
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R4,#+80
        MOVW     R0,#+1627
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R4,#+84
        MOVW     R0,#+1631
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDW     R1,R4,#+411
        MOVW     R0,#+1543
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADD      R1,R4,#+216
        MOV      R0,#+1544
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall epr_read_data
        B.W      epr_read_data
          CFI EndBlock cfiBlock65

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable111:
        DC8      "M29"

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock66 Using cfiCommon0
          CFI Function _Z17mkstft_ui_set_eprv
        THUMB
// __interwork __softfp void mkstft_ui_set_epr()
_Z17mkstft_ui_set_eprv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+8
          CFI CFA R13+24
        MOVW     R4,#+1450
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDR.W    R5,??DataTable136_1  ;; 0x76313030
        LDR      R0,[SP, #+0]
        CMP      R0,R5
        BEQ.W    ??mkstft_ui_set_epr_0
        LDR.W    R6,??DataTable131_2
        MOVS     R2,#+4
        ADDS     R1,R6,#+4
        MOVW     R0,#+1479
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+8
        MOVW     R0,#+1503
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+16
        MOVW     R0,#+1595
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+16
        MOVW     R0,#+1507
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+104
        MOVW     R0,#+1495
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+100
        MOVW     R0,#+1499
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+20
        MOVW     R0,#+1599
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+24
        MOVW     R0,#+1603
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+28
        MOVW     R0,#+1607
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+32
        MOVW     R0,#+1527
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+36
        MOVW     R0,#+1611
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+40
        MOVW     R0,#+1531
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+60
        MOVW     R0,#+1615
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+64
        MOVW     R0,#+1619
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+68
        MOVW     R0,#+1535
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+72
        MOVW     R0,#+1539
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+76
        MOVW     R0,#+1623
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+80
        MOVW     R0,#+1627
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+84
        MOVW     R0,#+1631
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDW     R1,R6,#+411
        MOVW     R0,#+1543
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,R6,#+216
        MOV      R0,#+1544
          CFI FunCall epr_write_data
        BL       epr_write_data
        STR      R5,[SP, #+0]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall epr_write_data
        BL       epr_write_data
??mkstft_ui_set_epr_0:
        POP      {R0,R1,R4-R6,PC}  ;; return
          CFI EndBlock cfiBlock66

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable112:
        DC32     parser

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable112_1:
        DC32     Running

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable112_2:
        DC32     axis_relative_modes

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock67 Using cfiCommon0
          CFI Function mkstft_ui_init
        THUMB
// __interwork __softfp void mkstft_ui_init()
mkstft_ui_init:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        LDR.W    R4,??DataTable131_2
        ADDS     R0,R4,#+4
        MVN      R1,#-16777216
        STR      R1,[R0, #+84]
        STR      R1,[R4, #+4]
        LDR.W    R2,??DataTable137  ;; 0x8db937
        STR      R2,[R0, #+4]
        MOVS     R3,#+0
        STR      R3,[R0, #+8]
        STR      R2,[R0, #+12]
        STR      R3,[R0, #+100]
        STR      R1,[R0, #+96]
        STR      R2,[R0, #+16]
        STR      R1,[R0, #+20]
        STR      R2,[R0, #+24]
        STR      R1,[R0, #+28]
        STR      R1,[R0, #+32]
        LDR.W    R3,??DataTable137_1  ;; 0x43cdff
        STR      R3,[R0, #+36]
        MOV      R3,#+65280
        STR      R3,[R0, #+40]
        LDR.W    R3,??DataTable137_2  ;; 0xaaaaaa
        STR      R3,[R0, #+44]
        MOVS     R3,#+0
        STR      R3,[R0, #+48]
        STR      R3,[R0, #+52]
        STR      R3,[R0, #+56]
        STR      R1,[R0, #+60]
        MOV      R3,#+16711680
        STR      R3,[R0, #+64]
        STR      R1,[R0, #+68]
        STR      R2,[R0, #+72]
        STR      R1,[R0, #+76]
        STR      R2,[R0, #+80]
        MOVS     R0,#+1
        STRB     R0,[R4, #+411]
        ADD      R0,R4,#+188
        MOVS     R1,#+3
        STRB     R1,[R0, #+28]
        MOVW     R1,#+3919
        STR      R1,[R0, #+32]
        MOVS     R1,#+201
        STR      R1,[R0, #+36]
        MOVS     R1,#+164
        STR      R1,[R0, #+40]
        MOV      R1,#+3776
        STR      R1,[R0, #+44]
        MOVS     R1,#+1
        STRB     R1,[R0, #+30]
        MOVS     R1,#+5
        STRB     R1,[R0, #+3]
        MOVS     R1,#+0
        STRB     R1,[R4, #+188]
        MOV      R1,#+1065353216
        STR      R1,[R0, #+24]
        MOVW     R1,#+3000
        STRH     R1,[R0, #+18]
        MOVS     R1,#+1
        STRB     R1,[R0, #+16]
        MOVS     R1,#+5
        STRB     R1,[R0, #+15]
        STRB     R1,[R0, #+14]
        MOVS     R1,#+100
        STRH     R1,[R0, #+8]
        STRH     R1,[R0, #+10]
        ADDW     R0,R4,#+379
        MOVS     R1,#+0
        STRB     R1,[R0, #+29]
        STRB     R1,[R4, #+237]
        STRB     R1,[R0, #+30]
        STRB     R1,[R0, #+31]
        ADDW     R5,R4,#+411
        MOV      R0,R1
        STRB     R0,[R5, #+11]
        ADDW     R6,R4,#+237
        STRB     R0,[R6, #+12]
        MOVS     R2,#+6
        ADR.W    R1,`?<Constant "0.000">`
        ADD      R0,R4,#+316
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R0,#+1
        STRB     R0,[R6, #+26]
        MOVS     R0,#+0
        STRB     R0,[R6, #+7]
        MOVS     R0,#+1
        STRB     R0,[R6, #+8]
        MOVS     R0,#+23
        STRB     R0,[R5, #+12]
        MOVS     R0,#+1
        STRB     R0,[R5, #+13]
        MOVS     R0,#+0
        STRB     R0,[R4, #+379]
        STRB     R0,[R4, #+296]
          CFI FunCall _Z17mkstft_ui_set_eprv
        BL       _Z17mkstft_ui_set_eprv
        MOVS     R0,#+0
        LDR.W    R1,??DataTable139
        STRB     R0,[R1, #+0]
        LDR.W    R1,??DataTable141
        STRB     R0,[R1, #+0]
        STRB     R0,[R5, #+12]
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock67

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "0.000">`:
        DC8 "0.000"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock68 Using cfiCommon0
          CFI Function mks_initPrint
        THUMB
// __interwork __softfp void mks_initPrint()
mks_initPrint:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        LDR.W    R4,??DataTable139_1
        LDR.W    R0,??DataTable141_1
        LDR      R0,[R0, #+24]
        STR      R0,[R4, #+3300]
        MOVS     R0,#+166
        STRB     R0,[R4, #+3336]
        ADDW     R5,R4,#+3336
        MOVS     R0,#+0
        STR      R0,[R5, #+4]
        MOVS     R2,#+20
        MOV      R1,R0
        ADD      R0,R4,#+3248
          CFI FunCall memset
        BL       memset
        MOVS     R2,#+30
        MOVS     R1,#+0
        ADDW     R0,R4,#+3268
          CFI FunCall memset
        BL       memset
        MOVS     R0,#+0
        STRH     R0,[R5, #+26]
        STRB     R0,[R4, #+3460]
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock68

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock69 Using cfiCommon0
          CFI Function _Z14mks_WriteToEprv
          CFI NoCalls
        THUMB
// __interwork __softfp void mks_WriteToEpr()
_Z14mks_WriteToEprv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock69

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock70 Using cfiCommon0
          CFI Function mks_ReadFromEpr
        THUMB
// __interwork __softfp void mks_ReadFromEpr()
mks_ReadFromEpr:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.W    R4,??DataTable139_1
        MOVS     R2,#+30
        ADDW     R1,R4,#+3268
        MOVW     R0,#+1001
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADDW     R1,R4,#+3340
        MOVW     R0,#+1053
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall epr_read_data
        B.W      epr_read_data
          CFI EndBlock cfiBlock70

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock71 Using cfiCommon0
          CFI Function mks_resumePrint
        THUMB
// __interwork __softfp void mks_resumePrint()
mks_resumePrint:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.W    R4,??DataTable139_1
        LDRB     R0,[R4, #+3336]
        CMP      R0,#+169
        BNE.N    ??mks_resumePrint_0
        MOVS     R0,#+167
        STRB     R0,[R4, #+3336]
        ADDW     R0,R4,#+2500
          CFI FunCall _ZN7MKS_DLP11resumePrintEv
        BL       _ZN7MKS_DLP11resumePrintEv
        MOVS     R1,#+0
        ADDW     R0,R4,#+3268
          CFI FunCall _Z13lcd_setstatusPKcb
        BL       _Z13lcd_setstatusPKcb
??mks_resumePrint_0:
        LDRB     R0,[R4, #+3336]
        CMP      R0,#+170
        BNE.N    ??mks_resumePrint_1
        MOVS     R0,#+171
        STRB     R0,[R4, #+3336]
??mks_resumePrint_1:
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock71

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable116:
        DC32     mksCfg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable116_1:
        DC32     _ZN7Planner8e_factorE

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock72 Using cfiCommon0
          CFI Function mks_pausePrint
        THUMB
// __interwork __softfp void mks_pausePrint()
mks_pausePrint:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        MOVS     R0,#+166
        STRB     R0,[SP, #+0]
        MOVW     R4,#+1059
        MOVS     R2,#+1
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall epr_write_data
        BL       epr_write_data
        LDR.W    R5,??DataTable139_1
        LDR.W    R0,??DataTable141_1
        VLDR     S0,[R0, #+16]
        VLDR.W   S1,??DataTable121  ;; 0x42f00000
        VDIV.F32 S1,S0,S1
        LDR      R0,[R5, #+3300]
        VMOV     S0,R0
        ADDW     R0,R5,#+2500
          CFI FunCall _ZN7MKS_DLP14moveRelative_ZEff
        BL       _ZN7MKS_DLP14moveRelative_ZEff
        LDR.W    R0,??DataTable143
        LDR      R0,[R0, #+40]
        STR      R0,[R5, #+3312]
        MOVS     R0,#+167
        STRB     R0,[SP, #+0]
        MOVS     R2,#+1
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall epr_write_data
        BL       epr_write_data
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock72

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable117:
        DC32     cartes

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable117_1:
        DC32     echomagic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable117_2:
        DC32     0x54442d18

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable117_3:
        DC32     0x401921fb

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable117_4:
        DC32     0xc01921fb

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock73 Using cfiCommon0
          CFI Function mks_PrintStatePolling
        THUMB
// __interwork __softfp void mks_PrintStatePolling()
mks_PrintStatePolling:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        LDR.W    R4,??DataTable139_1
        LDRB     R0,[R4, #+3336]
        CMP      R0,#+168
        BNE.N    ??mks_PrintStatePolling_0
        ADDW     R5,R4,#+2500
        MOV      R0,R5
          CFI FunCall _ZN7MKS_DLP10pausePrintEv
        BL       _ZN7MKS_DLP10pausePrintEv
        CMP      R0,#+0
        BNE.N    ??mks_PrintStatePolling_0
        ADR.W    R0,`?<Constant "paused:">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
        MOVS     R0,#+169
        STRB     R0,[R4, #+3336]
        MOVS     R2,#+1
        ADDW     R1,R4,#+3336
        MOV      R0,#+1000
          CFI FunCall epr_write_data
        BL       epr_write_data
          CFI FunCall mks_pausePrint
        BL       mks_pausePrint
        MOV      R0,R5
          CFI FunCall _ZN7MKS_DLP24write_Information_pausedEv
        BL       _ZN7MKS_DLP24write_Information_pausedEv
        MOVS     R3,#+2
        MOV      R2,#+1000
        MOV      R1,R2
        MOV      R0,R5
          CFI FunCall _ZN7MKS_DLP11buzzer_toneEtth
        BL       _ZN7MKS_DLP11buzzer_toneEtth
??mks_PrintStatePolling_0:
        LDRB     R0,[R4, #+3336]
        CMP      R0,#+167
        BNE.N    ??mks_PrintStatePolling_1
        LDR.W    R0,??DataTable142
        LDRB     R1,[R0, #+0]
        CMP      R1,#+1
        BNE.N    ??mks_PrintStatePolling_2
        MOVS     R1,#+0
        STRB     R1,[R0, #+0]
        ADDW     R0,R4,#+2500
          CFI FunCall _ZN7MKS_DLP11resumePrintEv
        BL       _ZN7MKS_DLP11resumePrintEv
        MOV      R0,R4
          CFI FunCall _ZN10CardReader14startFileprintEv
        BL       _ZN10CardReader14startFileprintEv
        ADDW     R0,R4,#+3464
          CFI FunCall _ZN9Stopwatch5startEv
        BL       _ZN9Stopwatch5startEv
??mks_PrintStatePolling_2:
        ADDW     R1,R4,#+3336
        LDRB     R0,[R4, #+2488]
        CMP      R0,#+0
        BNE.N    ??mks_PrintStatePolling_3
        LDRH     R0,[R1, #+26]
        ADDS     R0,R0,#+1
        STRH     R0,[R1, #+26]
        B.N      ??mks_PrintStatePolling_4
??mks_PrintStatePolling_3:
        MOVS     R0,#+0
        STRH     R0,[R1, #+26]
??mks_PrintStatePolling_4:
        LDRH     R0,[R1, #+26]
        CMP      R0,#+21
        BLT.N    ??mks_PrintStatePolling_1
        MOVS     R0,#+0
        STRH     R0,[R1, #+26]
        MOVS     R0,#+166
        STRB     R0,[R4, #+3336]
        MOVS     R2,#+1
        MOV      R0,#+1000
          CFI FunCall epr_write_data
        BL       epr_write_data
??mks_PrintStatePolling_1:
        LDRB     R0,[R4, #+3336]
        CMP      R0,#+172
        BNE.N    ??mks_PrintStatePolling_5
        MOVS     R0,#+166
        STRB     R0,[R4, #+3336]
        MOVS     R2,#+1
        ADDW     R1,R4,#+3336
        MOV      R0,#+1000
          CFI FunCall epr_write_data
        BL       epr_write_data
          CFI FunCall _Z19clear_command_queuev
        BL       _Z19clear_command_queuev
        ADDW     R5,R4,#+2500
        MOV      R0,R5
          CFI FunCall _ZN7MKS_DLP9stopPrintEv
        BL       _ZN7MKS_DLP9stopPrintEv
        LDR.W    R0,??DataTable141_1
        VLDR     S0,[R0, #+16]
        VLDR.W   S1,??DataTable121  ;; 0x42f00000
        VDIV.F32 S1,S0,S1
        LDR      R0,[R4, #+3300]
        VMOV     S0,R0
        MOV      R0,R5
          CFI FunCall _ZN7MKS_DLP14moveRelative_ZEff
        BL       _ZN7MKS_DLP14moveRelative_ZEff
        MOVS     R2,#+1
        LDR.N    R0,??DataTable122
        LDRH     R1,[R0, #+4]
        LDR.N    R0,??DataTable123_1
        LDR      R0,[R0, #+8]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        MOVS     R0,#+0
        LDR.W    R1,??DataTable143
        STRB     R0,[R1, #+10]
        MOVS     R3,#+2
        MOV      R2,#+1000
        MOV      R1,R2
        MOV      R0,R5
          CFI FunCall _ZN7MKS_DLP11buzzer_toneEtth
        BL       _ZN7MKS_DLP11buzzer_toneEtth
        ADDW     R0,R4,#+3464
          CFI FunCall _ZN9Stopwatch4stopEv
        BL       _ZN9Stopwatch4stopEv
??mks_PrintStatePolling_5:
        LDRB     R0,[R4, #+3336]
        CMP      R0,#+171
        BNE.N    ??mks_PrintStatePolling_6
        LDRSB    R0,[R4, #+3460]
        CMP      R0,#+1
        BNE.N    ??mks_PrintStatePolling_7
        ADDW     R0,R4,#+2500
        POP      {R1,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7MKS_DLP19contiuePrint_pausedEv
        B.W      _ZN7MKS_DLP19contiuePrint_pausedEv
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??mks_PrintStatePolling_7:
        CMP      R0,#+2
        BNE.N    ??mks_PrintStatePolling_6
        ADDW     R0,R4,#+2500
        POP      {R1,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7MKS_DLP18contiuePrint_PwdwnEv
        B.W      _ZN7MKS_DLP18contiuePrint_PwdwnEv
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??mks_PrintStatePolling_6:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock73

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "paused:">`:
        DC8 "paused:"

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock74 Using cfiCommon0
          CFI Function _Z18mks_setTemperaturev
          CFI NoCalls
        THUMB
// __interwork __softfp void mks_setTemperature()
_Z18mks_setTemperaturev:
        BX       LR               ;; return
          CFI EndBlock cfiBlock74

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock75 Using cfiCommon0
          CFI Function mks_setPositionZ
        THUMB
// __interwork __softfp void mks_setPositionZ()
mks_setPositionZ:
        PUSH     {R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        SUB      SP,SP,#+20
          CFI CFA R13+32
        LDR.W    R4,??DataTable139_1
        MOVS     R2,#+96
        MOVS     R1,#+0
        ADDW     R0,R4,#+3364
          CFI FunCall memset
        BL       memset
        ADDW     R5,R4,#+3364
        MOVS     R2,#+6
        ADR.W    R1,`?<Constant "G92 Z">`
        MOV      R0,R5
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        LDR      R0,[R4, #+3312]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        ADR.N    R1,??DataTable127_1  ;; 0x25, 0x66, 0x00, 0x00
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R5
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z9gcode_G92v
        BL       _Z9gcode_G92v
        LDR.W    R0,??DataTable143
        MOVS     R1,#+0
        STR      R1,[R0, #+100]
        ADD      SP,SP,#+20
          CFI CFA R13+12
        POP      {R4,R5,PC}       ;; return
          CFI EndBlock cfiBlock75

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "G92 Z">`:
        DC8 "G92 Z"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock76 Using cfiCommon0
          CFI Function _Z15mks_setFeedratev
          CFI NoCalls
        THUMB
// __interwork __softfp void mks_setFeedrate()
_Z15mks_setFeedratev:
        LDR.W    R0,??DataTable143
        LDR.W    R1,??DataTable139_1
        LDR      R1,[R1, #+3356]
        STR      R1,[R0, #+120]
        BX       LR               ;; return
          CFI EndBlock cfiBlock76

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable120:
        DC32     0x3fe00000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable120_1:
        DC32     0x3ff00000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable120_2:
        DC32     0x47ae147b

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock77 Using cfiCommon0
          CFI Function mks_preExtrude
          CFI NoCalls
        THUMB
// __interwork __vfp void mks_preExtrude(float)
mks_preExtrude:
        BX       LR               ;; return
          CFI EndBlock cfiBlock77

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock78 Using cfiCommon0
          CFI Function mks_moveXY
        THUMB
// __interwork __vfp void mks_moveXY(float, float)
mks_moveXY:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        VPUSH    {D8}
          CFI D8 Frame(CFA, -24)
          CFI CFA R13+24
        SUB      SP,SP,#+24
          CFI CFA R13+48
        VMOV.F32 S16,S0
        VMOV.F32 S17,S1
        LDR.W    R4,??DataTable139_1
        MOVS     R2,#+96
        MOVS     R1,#+0
        ADDW     R0,R4,#+3364
          CFI FunCall memset
        BL       memset
        ADDW     R4,R4,#+3364
        MOVS     R2,#+5
        ADR.W    R1,`?<Constant "G1 X">`
        MOV      R0,R4
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        ADR.N    R5,??DataTable127_1  ;; 0x25, 0x66, 0x00, 0x00
        VMOV     R0,S16
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R1,R5
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall strcat
        BL       strcat
        ADR.N    R1,??DataTable128  ;; 0x20, 0x59, 0x00, 0x00
        MOV      R0,R4
          CFI FunCall strcat
        BL       strcat
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        VMOV     R0,S17
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R1,R5
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R4
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z11gcode_G0_G1v
        BL       _Z11gcode_G0_G1v
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        ADD      SP,SP,#+24
          CFI CFA R13+24
        VPOP     {D8}
          CFI D8 SameValue
          CFI CFA R13+16
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock78

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable121:
        DC32     0x42f00000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "G1 X">`:
        DC8 "G1 X"
        DC8 0, 0, 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock79 Using cfiCommon0
          CFI Function mks_moveZ
        THUMB
// __interwork __vfp void mks_moveZ(float)
mks_moveZ:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        VPUSH    {D8}
          CFI D8 Frame(CFA, -24)
          CFI CFA R13+24
        SUB      SP,SP,#+24
          CFI CFA R13+48
        VMOV.F32 S16,S0
        LDR.W    R4,??DataTable139_1
        MOVS     R2,#+96
        MOVS     R1,#+0
        ADDW     R0,R4,#+3364
          CFI FunCall memset
        BL       memset
        ADDW     R5,R4,#+3364
        MOVS     R2,#+5
        ADR.W    R1,`?<Constant "G1 Z">`
        MOV      R0,R5
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        LDR      R0,[R4, #+3328]
        VMOV     S0,R0
        VADD.F32 S0,S0,S16
        VMOV     R0,S0
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        ADR.N    R1,??DataTable127_1  ;; 0x25, 0x66, 0x00, 0x00
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R5
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z11gcode_G0_G1v
        BL       _Z11gcode_G0_G1v
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        ADD      SP,SP,#+24
          CFI CFA R13+24
        VPOP     {D8}
          CFI D8 SameValue
          CFI CFA R13+16
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock79

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable122:
        DC32     gArrayGpioPin

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "G1 Z">`:
        DC8 "G1 Z"
        DC8 0, 0, 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock80 Using cfiCommon0
          CFI Function _Z7mks_G28Pc
        THUMB
// __interwork __softfp void mks_G28(char *)
_Z7mks_G28Pc:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        LDR.W    R5,??DataTable139_1
        MOVS     R2,#+96
        MOVS     R1,#+0
        ADDW     R0,R5,#+3364
          CFI FunCall memset
        BL       memset
        ADDW     R5,R5,#+3364
        MOV      R1,R4
        MOV      R0,R5
          CFI FunCall strcpy
        BL       strcpy
        MOV      R0,R5
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
        MOVS     R0,#+0
        POP      {R1,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z9gcode_G28b
        B.W      _Z9gcode_G28b
          CFI EndBlock cfiBlock80

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable123:
        DC32     0x3f847ae1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable123_1:
        DC32     gArrayGpioPort

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock81 Using cfiCommon0
          CFI Function mks_manual_leveling
        THUMB
// __interwork __softfp void mks_manual_leveling(int16_t, int16_t)
mks_manual_leveling:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        MOV      R5,R1
        LDR.W    R0,??DataTable146
        LDRB     R1,[R0, #+0]
        CMP      R1,#+1
        BNE.N    ??mks_manual_leveling_0
        MOVS     R1,#+0
        STRB     R1,[R0, #+0]
        ADR.N    R0,??DataTable130  ;; "G28"
          CFI FunCall _Z7mks_G28Pc
        BL       _Z7mks_G28Pc
??mks_manual_leveling_0:
        LDR.W    R0,??DataTable139_1
        LDR.W    R1,??DataTable143
        LDR      R1,[R1, #+40]
        STR      R1,[R0, #+3328]
        VMOV.F32 S0,#10.0
          CFI FunCall mks_moveZ
        BL       mks_moveZ
        VMOV     S0,R5
        VCVT.F32.S32 S1,S0
        VMOV     S0,R4
        VCVT.F32.S32 S0,S0
          CFI FunCall mks_moveXY
        BL       mks_moveXY
        ADR.W    R0,`?<Constant "G1 Z0">`
        POP      {R1,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z27enqueue_and_echo_commands_PPKc
        B.W      _Z27enqueue_and_echo_commands_PPKc
          CFI EndBlock cfiBlock81

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable124:
        DC32     _ZN11GCodeParser11command_ptrE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable124_1:
        DC32     Serial6

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "G1 Z0">`:
        DC8 "G1 Z0"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock82 Using cfiCommon0
          CFI Function mks_contiuePrintPause
        THUMB
// __interwork __softfp void mks_contiuePrintPause()
mks_contiuePrintPause:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.W    R4,??DataTable139_1
        MOVS     R0,#+1
        STRB     R0,[R4, #+2488]
          CFI FunCall mks_setPositionZ
        BL       mks_setPositionZ
        VLDR.W   S0,??DataTable131  ;; 0x0
          CFI FunCall mks_moveZ
        BL       mks_moveZ
        MOVS     R0,#+167
        STRB     R0,[R4, #+3336]
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z9gcode_M24v
        B.W      _Z9gcode_M24v
          CFI EndBlock cfiBlock82

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock83 Using cfiCommon0
          CFI Function mks_contiuePrintPwdwn
          CFI NoCalls
        THUMB
// __interwork __softfp void mks_contiuePrintPwdwn()
mks_contiuePrintPwdwn:
        BX       LR               ;; return
          CFI EndBlock cfiBlock83

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock84 Using cfiCommon0
          CFI Function mks_contiuePrintDelta
        THUMB
// __interwork __softfp void mks_contiuePrintDelta()
mks_contiuePrintDelta:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.W    R4,??DataTable139_1
        MOVS     R0,#+1
        STRB     R0,[R4, #+2488]
        LDR      R0,[R4, #+3300]
        VMOV     S0,R0
          CFI FunCall mks_moveZ
        BL       mks_moveZ
        VLDR.W   S0,??DataTable131  ;; 0x0
          CFI FunCall mks_moveZ
        BL       mks_moveZ
        MOVS     R0,#+167
        STRB     R0,[R4, #+3336]
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z9gcode_M24v
        B.W      _Z9gcode_M24v
          CFI EndBlock cfiBlock84

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock85 Using cfiCommon0
          CFI Function mks_getPositionXYZE
          CFI NoCalls
        THUMB
// __interwork __softfp void mks_getPositionXYZE()
mks_getPositionXYZE:
        SUB      SP,SP,#+4
          CFI CFA R13+4
        MOVS     R0,#+0
        STRB     R0,[SP, #+0]
        ADD      SP,SP,#+4
          CFI CFA R13+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock85

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock86 Using cfiCommon0
          CFI Function mks_clearDir
        THUMB
// __interwork __softfp void mks_clearDir()
mks_clearDir:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        SUB      SP,SP,#+32
          CFI CFA R13+40
        LDR.W    R4,??DataTable146_1
        B.N      ??mks_clearDir_0
??mks_clearDir_1:
        ADDS     R1,R0,#+1
        ADD      R0,SP,#+0
          CFI FunCall strcpy
        BL       strcpy
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall strcpy
        BL       strcpy
??mks_clearDir_0:
        ADR.N    R1,??DataTable132  ;; "/"
        MOV      R0,R4
          CFI FunCall _Z6strstrPcPKc
        BL       _Z6strstrPcPKc
        CMP      R0,#+0
        BNE.N    ??mks_clearDir_1
        ADD      SP,SP,#+32
          CFI CFA R13+8
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock86

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable127:
        DC32     errormagic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable127_1:
        DC8      0x25, 0x66, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable127_2:
        DC32     preview_no_display

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock87 Using cfiCommon0
          CFI Function mks_contiuePrint_UI
        THUMB
// __interwork __softfp void mks_contiuePrint_UI()
mks_contiuePrint_UI:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R1,#+0
        ADR.W    R0,`?<Constant "Resume print?">`
          CFI FunCall _Z13lcd_setstatusPKcb
        BL       _Z13lcd_setstatusPKcb
        LDR.W    R4,??DataTable139_1
        ADDW     R5,R4,#+3268
        MOVS     R3,#+1
        MOV      R2,R3
        MOV      R1,R5
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8openFileEPcbb
        BL       _ZN10CardReader8openFileEPcbb
        MOV      R1,R5
        LDR.W    R0,??DataTable146_2
          CFI FunCall strcpy
        BL       strcpy
        MOV      R0,R4
          CFI FunCall _ZN10CardReader10isFileOpenEv
        BL       _ZN10CardReader10isFileOpenEv
        CMP      R0,#+0
        BNE.N    ??mks_contiuePrint_UI_0
        MOVS     R0,#+2
        POP      {R1,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall draw_dialog
        B.W      draw_dialog
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??mks_contiuePrint_UI_0:
        MOVS     R2,#+30
        ADDW     R1,R4,#+3268
        MOVW     R0,#+1001
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R0,#+0
        STRB     R0,[R4, #+2488]
          CFI FunCall mks_clearDir
        BL       mks_clearDir
??mks_contiuePrint_UI_1:
          CFI FunCall getTick
        BL       getTick
        LDR.W    R1,??DataTable146_3
        STR      R0,[R1, #+0]
        LDR.W    R1,??DataTable146_4
        LDR      R1,[R1, #+0]
          CFI FunCall getTickDiff
        BL       getTickDiff
        MOVW     R1,#+3000
        CMP      R0,R1
        BCS.N    ??mks_contiuePrint_UI_2
        LDR.N    R0,??DataTable131_2
        LDRSB    R0,[R0, #+218]
        CMP      R0,#+0
        BNE.N    ??mks_contiuePrint_UI_1
??mks_contiuePrint_UI_2:
        LDR.W    R5,??DataTable147
        MOVS     R2,#+1
        MOV      R1,R5
        MOVW     R0,#+1577
          CFI FunCall AT24CXX_Read
        BL       AT24CXX_Read
        LDRB     R0,[R5, #+0]
        CMP      R0,#+0
        BEQ.N    ??mks_contiuePrint_UI_3
        MOVS     R0,#+1
        LDR.W    R1,??DataTable147_1
        STRB     R0,[R1, #+0]
        B.N      ??mks_contiuePrint_UI_4
??mks_contiuePrint_UI_3:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable147_2
        STRB     R0,[R1, #+0]
??mks_contiuePrint_UI_4:
          CFI FunCall draw_printing
        BL       draw_printing
        ADDW     R0,R4,#+2500
        POP      {R1,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7MKS_DLP13draw_printingEv
        B.W      _ZN7MKS_DLP13draw_printingEv
          CFI EndBlock cfiBlock87

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable128:
        DC8      0x20, 0x59, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable128_1:
        DC32     errormagic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Resume print?">`:
        DC8 "Resume print?"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock88 Using cfiCommon0
          CFI Function mks_rePrintCheck
        THUMB
// __interwork __softfp void mks_rePrintCheck()
mks_rePrintCheck:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        LDR.W    R5,??DataTable139_1
        ADDW     R6,R5,#+3336
        MOVS     R2,#+1
        MOV      R1,R6
        MOV      R0,#+1000
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDR.W    R4,??DataTable147_3
        LDRB     R0,[R5, #+3336]
        STRB     R0,[R4, #+1]
        CMP      R0,#+169
        BNE.N    ??mks_rePrintCheck_0
        ADDW     R7,R5,#+2500
        MOV      R0,R7
          CFI FunCall _ZN7MKS_DLP18Is_Paused_FinishedEv
        BL       _ZN7MKS_DLP18Is_Paused_FinishedEv
        CMP      R0,#+0
        BEQ.N    ??mks_rePrintCheck_0
        MOVS     R0,#+170
        STRB     R0,[R5, #+3336]
        MOV      R0,R7
          CFI FunCall _ZN7MKS_DLP23read_Information_pausedEv
        BL       _ZN7MKS_DLP23read_Information_pausedEv
        MOVS     R0,#+1
        STRB     R0,[R5, #+3460]
          CFI FunCall mks_contiuePrint_UI
        BL       mks_contiuePrint_UI
        B.N      ??mks_rePrintCheck_1
??mks_rePrintCheck_0:
        LDRB     R0,[R5, #+3336]
        CMP      R0,#+167
        BNE.N    ??mks_rePrintCheck_2
        ADDW     R0,R5,#+2500
          CFI FunCall _ZN7MKS_DLP22read_Information_layerEv
        BL       _ZN7MKS_DLP22read_Information_layerEv
        CMP      R0,#+0
        BEQ.N    ??mks_rePrintCheck_2
        MOVS     R0,#+170
        STRB     R0,[R5, #+3336]
        MOVS     R0,#+2
        STRB     R0,[R5, #+3460]
          CFI FunCall mks_contiuePrint_UI
        BL       mks_contiuePrint_UI
        B.N      ??mks_rePrintCheck_1
??mks_rePrintCheck_2:
        MOVS     R0,#+166
        STRB     R0,[R5, #+3336]
        MOVS     R2,#+1
        MOV      R1,R6
        MOV      R0,#+1000
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R0,#+1
        STRB     R0,[R4, #+0]
??mks_rePrintCheck_1:
        LDRB     R0,[R4, #+0]
        CMP      R0,#+1
        BNE.N    ??mks_rePrintCheck_3
        MOVS     R0,#+0
        STRB     R0,[R4, #+0]
??mks_rePrintCheck_4:
          CFI FunCall getTick
        BL       getTick
        LDR.W    R1,??DataTable146_3
        STR      R0,[R1, #+0]
        LDR.W    R1,??DataTable146_4
        LDR      R1,[R1, #+0]
          CFI FunCall getTickDiff
        BL       getTickDiff
        MOVW     R1,#+3000
        CMP      R0,R1
        BCC.N    ??mks_rePrintCheck_4
        POP      {R0,R4-R7,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall draw_ready_print
        B.W      draw_ready_print
          CFI R4 Frame(CFA, -20)
          CFI R5 Frame(CFA, -16)
          CFI R6 Frame(CFA, -12)
          CFI R7 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+24
??mks_rePrintCheck_3:
        POP      {R0,R4-R7,PC}    ;; return
          CFI EndBlock cfiBlock88

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock89 Using cfiCommon0
          CFI Function mks_WriteToFile
          CFI NoCalls
        THUMB
// __interwork __softfp void mks_WriteToFile()
mks_WriteToFile:
        BX       LR               ;; return
          CFI EndBlock cfiBlock89

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock90 Using cfiCommon0
          CFI Function _Z21mks_WriteToEpr_pwroffv
          CFI NoCalls
        THUMB
// __interwork __softfp void mks_WriteToEpr_pwroff()
_Z21mks_WriteToEpr_pwroffv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock90

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock91 Using cfiCommon0
          CFI Function _Z22mks_ReadFromEpr_pwroffv
          CFI NoCalls
        THUMB
// __interwork __softfp void mks_ReadFromEpr_pwroff()
_Z22mks_ReadFromEpr_pwroffv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock91

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock92 Using cfiCommon0
          CFI Function _Z7pft_getv
          CFI NoCalls
        THUMB
// __interwork __softfp int16_t pft_get()
_Z7pft_getv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock92

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock93 Using cfiCommon0
          CFI Function _Z16mks_get_commandsv
          CFI NoCalls
        THUMB
// __interwork __softfp bool mks_get_commands()
_Z16mks_get_commandsv:
        MOVS     R0,#+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock93

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock94 Using cfiCommon0
          CFI Function mks_ReadFromFile
          CFI NoCalls
        THUMB
// __interwork __softfp bool mks_ReadFromFile()
mks_ReadFromFile:
        BX       LR               ;; return
          CFI EndBlock cfiBlock94

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock95 Using cfiCommon0
          CFI Function mks_clearFile
          CFI NoCalls
        THUMB
// __interwork __softfp void mks_clearFile()
mks_clearFile:
        BX       LR               ;; return
          CFI EndBlock cfiBlock95

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock96 Using cfiCommon0
          CFI Function mks_saveFileName
        THUMB
// __interwork __softfp void mks_saveFileName(char *)
mks_saveFileName:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        LDR.W    R5,??DataTable139_1
        MOVS     R2,#+30
        MOVS     R1,#+0
        ADDW     R0,R5,#+3268
          CFI FunCall memset
        BL       memset
        MOV      R1,R4
        ADDW     R0,R5,#+3268
          CFI FunCall strcpy
        BL       strcpy
        MOVS     R2,#+30
        ADDW     R1,R5,#+3268
        MOVW     R0,#+1001
        POP      {R3-R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall epr_write_data
        B.W      epr_write_data
          CFI EndBlock cfiBlock96

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable130:
        DC8      "G28"

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock97 Using cfiCommon0
          CFI Function EXTI9_5_IRQHandler
          CFI NoCalls
        THUMB
// __interwork __softfp void EXTI9_5_IRQHandler()
EXTI9_5_IRQHandler:
        BX       LR               ;; return
          CFI EndBlock cfiBlock97

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
card:
        DS8 2500
// 15172 #include "mks_dlp_main.cpp"
// __absolute MKS_DLP mksdlp
mksdlp:
        DS8 748
// __absolute DATA_REPRINT_ITMES mksReprint
mksReprint:
        DS8 216
print_job_timer:
        DS8 16
// __absolute uint8_t Line_Pixel[1536]
Line_Pixel:
        DS8 1536

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
injected_commands_P:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
workspace_offset:
        DS8 12

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
fanSpeeds:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
previous_cmd_ms:
        DS8 4
        DS8 4
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
cartes:
        DS8 12

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvE18serial_line_buffer
_ZZ19get_serial_commandsvE18serial_line_buffer:
        DS8 96

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
        SECTION_GROUP _ZZ19get_serial_commandsvE19serial_comment_mode
_ZZ19get_serial_commandsvE19serial_comment_mode:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvE14last_wait_time
_ZZ19get_serial_commandsvE14last_wait_time:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
// __absolute uint8_t continue_print_error_flg
continue_print_error_flg:
        DS8 1
// __absolute MKS_PRINTER_STATE volatile ctemp
ctemp:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
// __absolute uint32_t t1
t1:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
// __absolute uint32_t t2
t2:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
// __absolute char t12[10]
t12:
        DS8 12

        SECTION `.data`:DATA:REORDER:NOROOT(2)
// __absolute uint32_t volatile reTransmission_zero_cnt
reTransmission_zero_cnt:
        DATA
        DC32 0
// __absolute uint32_t volatile reTransmission_data_cnt
reTransmission_data_cnt:
        DC32 0
// __absolute uint32_t volatile reTransmission_all_cnt
reTransmission_all_cnt:
        DC32 0
// __absolute uint32_t volatile *spi1_hdmatx_CR
spi1_hdmatx_CR:
        DC32 40026488H

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
// __absolute uint8_t Line_Pixel_TFT[180]
Line_Pixel_TFT:
        DS8 180

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock98 Using cfiCommon0
          CFI Function _Z13strting2floatPhh
        THUMB
// __interwork __vfp float strting2float(BYTE *, BYTE)
_Z13strting2floatPhh:
        PUSH     {R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        SUB      SP,SP,#+20
          CFI CFA R13+32
        MOV      R4,R0
        MOV      R5,R1
        MOVS     R2,#+16
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        MOVS     R0,#+0
        ADD      R2,SP,#+0
        B.N      ??strting2float_0
??strting2float_1:
        ADD      R1,R4,R0, LSL #+1
        LDRSB    R1,[R1, #+1]
        STRB     R1,[R0, R2]
        ADDS     R0,R0,#+1
??strting2float_0:
        CMP      R0,R5, LSR #+1
        BLT.N    ??strting2float_1
        ADD      R0,SP,#+0
          CFI FunCall atof
        BL       atof
        VMOV     R0,R1,D0
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        VMOV     S0,R0
        ADD      SP,SP,#+20
          CFI CFA R13+12
        POP      {R4,R5,PC}       ;; return
          CFI EndBlock cfiBlock98

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock99 Using cfiCommon0
          CFI Function _Z13find_next_bmpv
        THUMB
// __interwork __softfp void find_next_bmp()
_Z13find_next_bmpv:
        PUSH     {R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        SUB      SP,SP,#+36
          CFI CFA R13+48
        MOVS     R0,#+0
        STRH     R0,[SP, #+0]
        ADD      R4,SP,#+0
        LDR.W    R5,??DataTable139_1
        B.N      ??find_next_bmp_0
??find_next_bmp_1:
        LDRB     R0,[SP, #+0]
        STRB     R0,[R4, #+1]
??find_next_bmp_0:
        MOV      R0,R5
          CFI FunCall _ZN10CardReader3eofEv
        BL       _ZN10CardReader3eofEv
        CMP      R0,#+0
        BNE.N    ??find_next_bmp_2
        MOVS     R2,#+1
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R0,[SP, #+0]
        CMP      R0,#+10
        BNE.N    ??find_next_bmp_1
        LDRB     R0,[R4, #+1]
        CMP      R0,#+13
        BNE.N    ??find_next_bmp_1
??find_next_bmp_2:
        ADD      SP,SP,#+36
          CFI CFA R13+12
        POP      {R4,R5,PC}       ;; return
          CFI EndBlock cfiBlock99

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable131:
        DC32     0x0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable131_1:
        DC32     thermalManager

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable131_2:
        DC32     gCfgItems

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock100 Using cfiCommon0
          CFI Function _Z11InvertUint8PhS_
          CFI NoCalls
        THUMB
// __interwork __softfp void InvertUint8(unsigned char *, unsigned char *)
_Z11InvertUint8PhS_:
        PUSH     {R4-R6}
          CFI R6 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        MOVS     R2,#+0
        MOV      R3,R2
        B.N      ??InvertUint8_0
??InvertUint8_1:
        MOVS     R4,#+1
        LDRB     R5,[R1, #+0]
        LSL      R6,R4,R3
        TST      R5,R6
        BEQ.N    ??InvertUint8_2
        RSB      R5,R3,#+7
        LSLS     R4,R4,R5
        ORRS     R2,R4,R2
        UXTB     R2,R2
??InvertUint8_2:
        ADDS     R3,R3,#+1
??InvertUint8_0:
        CMP      R3,#+8
        BLT.N    ??InvertUint8_1
        STRB     R2,[R0, #+0]
        POP      {R4-R6}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI CFA R13+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock100

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock101 Using cfiCommon0
          CFI Function _Z12InvertUint16PtS_
          CFI NoCalls
        THUMB
// __interwork __softfp void InvertUint16(unsigned short *, unsigned short *)
_Z12InvertUint16PtS_:
        PUSH     {R4-R6}
          CFI R6 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        MOVS     R2,#+0
        MOV      R3,R2
        B.N      ??InvertUint16_0
??InvertUint16_1:
        MOVS     R4,#+1
        LDRH     R5,[R1, #+0]
        LSL      R6,R4,R3
        TST      R5,R6
        BEQ.N    ??InvertUint16_2
        RSB      R5,R3,#+15
        LSLS     R4,R4,R5
        ORRS     R2,R4,R2
        UXTH     R2,R2
??InvertUint16_2:
        ADDS     R3,R3,#+1
??InvertUint16_0:
        CMP      R3,#+16
        BLT.N    ??InvertUint16_1
        STRH     R2,[R0, #+0]
        POP      {R4-R6}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI CFA R13+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock101

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock102 Using cfiCommon0
          CFI Function _ZN7MKS_DLPC1Ev
        THUMB
// __code __interwork __softfp MKS_DLP::MKS_DLP()
_ZN7MKS_DLPC1Ev:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
        ADDW     R0,R4,#+746
          CFI FunCall _ZN7SSD2828C1Ev
        BL       _ZN7SSD2828C1Ev
        ADD      R0,R4,#+468
        MOVS     R1,#+0
        STRB     R1,[R0, #+23]
        STRH     R1,[R4, #+468]
        STRB     R1,[R0, #+2]
        STRB     R1,[R0, #+3]
        STRB     R1,[R0, #+12]
        STRB     R1,[R0, #+4]
        STR      R1,[R4, #+720]
        MOVW     R1,#+5000
        STR      R1,[R0, #+8]
        MOVS     R1,#+0
        STRB     R1,[R0, #+13]
        STR      R1,[R0, #+16]
        MOV      R0,R1
        B.N      ??MKS_DLP_0
??MKS_DLP_1:
        ADD      R1,R4,R0, LSL #+2
        MOVS     R2,#+0
        STR      R2,[R1, #+496]
        ADD      R3,R4,R0, LSL #+1
        STRH     R2,[R3, #+576]
        MOVS     R2,#+166
        ADDS     R3,R0,R4
        STRB     R2,[R3, #+616]
        MOVS     R2,#+0
        STR      R2,[R1, #+636]
        ADDS     R0,R0,#+1
??MKS_DLP_0:
        CMP      R0,#+20
        BLT.N    ??MKS_DLP_1
        MOV      R0,R4
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock102

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock103 Using cfiCommon0
          CFI Function _ZN7MKS_DLP11status_initEv
        THUMB
// __interwork __softfp void MKS_DLP::status_init()
_ZN7MKS_DLP11status_initEv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
        MOVS     R0,#+0
        STRH     R0,[R4, #+468]
        ADD      R0,R4,#+468
        MOVS     R1,#+0
        STRB     R1,[R0, #+2]
        STRB     R1,[R0, #+3]
        STRB     R1,[R0, #+4]
        STRB     R1,[R0, #+13]
          CFI FunCall _Z10clr_ticketv
        BL       _Z10clr_ticketv
        LDR.W    R0,??DataTable150
          CFI FunCall _ZN9Stopwatch5startEv
        BL       _ZN9Stopwatch5startEv
        ADR.W    R0,`?<Constant "totalTime(s):">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP18get_totalPrintTimeEv
        BL       _ZN7MKS_DLP18get_totalPrintTimeEv
        MOVS     R2,#+10
        MOV      R1,R0
        LDR.W    R0,??DataTable151_1
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN5Print5printEji
        B.W      _ZN5Print5printEji
          CFI EndBlock cfiBlock103

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable132:
        DC8      "/",0x0,0x0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "totalTime(s):">`:
        DC8 "totalTime(s):"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock104 Using cfiCommon0
          CFI Function _ZN7MKS_DLP14moveRelative_ZEff
        THUMB
// __interwork __vfp void MKS_DLP::moveRelative_Z(float, float)
_ZN7MKS_DLP14moveRelative_ZEff:
        PUSH     {LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+4
        VPUSH    {S1}
          CFI CFA R13+8
        MOVS     R1,#+0
        STRB     R1,[R0, #+482]
        LDR.W    R0,??DataTable143
        VLDR     S1,[R0, #+56]
        VADD.F32 S0,S1,S0
        VSTR     S0,[R0, #+56]
        ADD      R1,SP,#+0
        ADDS     R0,R0,#+56
          CFI FunCall _Z21do_blocking_move_to_zRKfS0_
        BL       _Z21do_blocking_move_to_zRKfS0_
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock104

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable133:
        DC32     printing_rate_update_flag

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock105 Using cfiCommon0
          CFI Function _ZN7MKS_DLP22moveRelativeZandGetBmpEff
        THUMB
// __interwork __vfp void MKS_DLP::moveRelativeZandGetBmp(float, float)
_ZN7MKS_DLP22moveRelativeZandGetBmpEff:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        VPUSH    {S1}
          CFI CFA R13+12
        SUB      SP,SP,#+4
          CFI CFA R13+16
        MOV      R4,R0
        MOVS     R0,#+0
        STRB     R0,[R4, #+482]
        LDR.W    R0,??DataTable152
        VLDR     S1,[R0, #+56]
        VADD.F32 S0,S1,S0
        VSTR     S0,[R0, #+56]
        ADD      R1,SP,#+4
        ADDS     R0,R0,#+56
          CFI FunCall _Z28do_blocking_move_to_z_nowaitRKfS0_
        BL       _Z28do_blocking_move_to_z_nowaitRKfS0_
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP15get_sdcard_bmpsEv
        BL       _ZN7MKS_DLP15get_sdcard_bmpsEv
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        POP      {R0,R1,R4,PC}    ;; return
          CFI EndBlock cfiBlock105

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable134:
        DC32     temperature_change_frequency

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable134_1:
        DC32     print_time

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock106 Using cfiCommon0
          CFI Function _ZN7MKS_DLP15moveFistLayer_ZEv
        THUMB
// __interwork __softfp void MKS_DLP::moveFistLayer_Z()
_ZN7MKS_DLP15moveFistLayer_ZEv:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        MOV      R5,R0
        LDR.W    R6,??DataTable143
        VLDR     S0,[R5, #+36]
        VLDR     S1,[R6, #+88]
        VSUB.F32 S0,S0,S1
        VSTR     S0,[R6, #+56]
        LDR.W    R0,??DataTable141_1
        VLDR     S0,[R0, #+16]
        VLDR.W   S1,??DataTable138  ;; 0x42f00000
        VDIV.F32 S0,S0,S1
        VSTR     S0,[SP, #+0]
        ADD      R1,SP,#+0
        ADD      R0,R6,#+56
          CFI FunCall _Z21do_blocking_move_to_zRKfS0_
        BL       _Z21do_blocking_move_to_zRKfS0_
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        ADR.W    R0,`?<Constant "Move Z offset:">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.W    R7,??DataTable151_1
        MOVS     R1,#+2
        MOV      R4,R1
        LDR      R0,[R6, #+88]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        VMOV     D0,R0,R1
        MOV      R1,R4
        MOV      R0,R7
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
          CFI FunCall _ZN7Stepper16report_positionsEv
        BL       _ZN7Stepper16report_positionsEv
        VLDR     S0,[R5, #+36]
        VSTR     S0,[R6, #+40]
        VSTR     S0,[R6, #+56]
        ADR.W    R0,`?<Constant "Reset Z:">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR      R0,[R6, #+40]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        VMOV     D0,R0,R1
        MOV      R1,R4
        MOV      R0,R7
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
          CFI FunCall _ZN7Stepper16report_positionsEv
        BL       _ZN7Stepper16report_positionsEv
        POP      {R0,R4-R7,PC}    ;; return
          CFI EndBlock cfiBlock106

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Move Z offset:">`:
        DC8 "Move Z offset:"
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Reset Z:">`:
        DC8 "Reset Z:"
        DC8 0, 0, 0

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock107 Using cfiCommon0
          CFI Function _ZN7MKS_DLP9moveMax_ZEv
        THUMB
// __interwork __softfp void MKS_DLP::moveMax_Z()
_ZN7MKS_DLP9moveMax_ZEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.W    R0,??DataTable143
        LDR.W    R1,??DataTable141_1
        LDR      R2,[R1, #+8]
        STR      R2,[R0, #+56]
        VLDR     S0,[R1, #+16]
        VLDR.W   S1,??DataTable138  ;; 0x42f00000
        VDIV.F32 S0,S0,S1
        VMOV.F32 S1,#2.0
        VMUL.F32 S0,S0,S1
        VSTR     S0,[SP, #+0]
        ADD      R1,SP,#+0
        ADDS     R0,R0,#+56
          CFI FunCall _Z21do_blocking_move_to_zRKfS0_
        BL       _Z21do_blocking_move_to_zRKfS0_
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
        ADR.W    R0,`?<Constant "print end.\\n">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock107

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable136:
        DC32     0x42430288

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable136_1:
        DC32     0x76313030

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "print end.\\n">`:
        DC8 "print end.\012"

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock108 Using cfiCommon0
          CFI Function _ZN7MKS_DLP7getHeadEv
        THUMB
// __interwork __softfp void MKS_DLP::getHead()
_ZN7MKS_DLP7getHeadEv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+32
          CFI CFA R13+48
        MOV      R4,R0
        LDR.N    R5,??DataTable139_1
        MOVS     R2,#+3
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        MOVS     R2,#+3
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall memcpy
        BL       memcpy
        MOVS     R2,#+8
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        MOVS     R2,#+8
        ADD      R1,SP,#+0
        ADDS     R0,R4,#+3
          CFI FunCall memcpy
        BL       memcpy
        MOVS     R0,#+0
        STRB     R0,[R4, #+10]
        ADR.W    R1,`?<Constant "MKSDLP">`
        ADDS     R0,R4,#+3
          CFI FunCall _Z6strstrPcPKc
        BL       _Z6strstrPcPKc
        CMP      R0,#+0
        BNE.N    ??getHead_0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader19printingHasFinishedEv
        BL       _ZN10CardReader19printingHasFinishedEv
        B.N      ??getHead_1
??getHead_0:
        LDR.W    R1,??DataTable152_1  ;; 0x186af
        MOV      R0,R5
          CFI FunCall _ZN10CardReader8setIndexEl
        BL       _ZN10CardReader8setIndexEl
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        ADD      R6,SP,#+0
        LDRB     R0,[SP, #+0]
        LDRB     R1,[R6, #+1]
        ORR      R0,R1,R0, LSL #+8
        STRH     R0,[R4, #+12]
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R0,[SP, #+0]
        LDRB     R1,[R6, #+1]
        ORR      R0,R1,R0, LSL #+8
        STRH     R0,[R4, #+14]
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R0,[SP, #+0]
        LDRB     R1,[R6, #+1]
        ORR      R0,R1,R0, LSL #+8
        STRH     R0,[R4, #+16]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R2,[R6, #+3]
        STRB     R2,[R4, #+18]
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R1,[R4, #+18]
        ADD      R0,SP,#+0
          CFI FunCall _Z13strting2floatPhh
        BL       _Z13strting2floatPhh
        VSTR     S0,[R4, #+20]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R2,[R6, #+3]
        STRB     R2,[R4, #+24]
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R1,[R4, #+24]
        ADD      R0,SP,#+0
          CFI FunCall _Z13strting2floatPhh
        BL       _Z13strting2floatPhh
        VSTR     S0,[R4, #+28]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R2,[R6, #+3]
        STRB     R2,[R4, #+32]
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R1,[R4, #+32]
        ADD      R0,SP,#+0
          CFI FunCall _Z13strting2floatPhh
        BL       _Z13strting2floatPhh
        VSTR     S0,[R4, #+36]
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R0,[SP, #+0]
        LDRB     R1,[R6, #+1]
        ORR      R1,R1,R0, LSL #+8
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP13set_LedOnTimeEt
        BL       _ZN7MKS_DLP13set_LedOnTimeEt
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R0,[SP, #+0]
        LDRB     R1,[R6, #+1]
        ORR      R1,R1,R0, LSL #+8
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP14set_LedOffTimeEt
        BL       _ZN7MKS_DLP14set_LedOffTimeEt
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R0,[SP, #+0]
        LDRB     R1,[R6, #+1]
        ORR      R1,R1,R0, LSL #+8
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP19set_BottomLedOnTimeEt
        BL       _ZN7MKS_DLP19set_BottomLedOnTimeEt
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R0,[SP, #+0]
        LDRB     R1,[R6, #+1]
        ORR      R1,R1,R0, LSL #+8
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16set_BottomlayersEt
        BL       _ZN7MKS_DLP16set_BottomlayersEt
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP11status_initEv
        BL       _ZN7MKS_DLP11status_initEv
??getHead_1:
        ADD      SP,SP,#+32
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock108

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable137:
        DC32     0x8db937

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable137_1:
        DC32     0x43cdff

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable137_2:
        DC32     0xaaaaaa

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock109 Using cfiCommon0
          CFI Function _ZN7MKS_DLP8getHead1Ev
        THUMB
// __interwork __softfp void MKS_DLP::getHead1()
_ZN7MKS_DLP8getHead1Ev:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+32
          CFI CFA R13+48
        MOV      R4,R0
        LDR.N    R5,??DataTable139_1
        MOVS     R2,#+3
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        MOVS     R2,#+3
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall memcpy
        BL       memcpy
        MOVS     R2,#+8
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        MOVS     R2,#+8
        ADD      R1,SP,#+0
        ADDS     R0,R4,#+3
          CFI FunCall memcpy
        BL       memcpy
        MOVS     R0,#+0
        STRB     R0,[R4, #+10]
        ADR.W    R1,`?<Constant "MKSDLP">`
        ADDS     R0,R4,#+3
          CFI FunCall _Z6strstrPcPKc
        BL       _Z6strstrPcPKc
        CMP      R0,#+0
        BNE.N    ??getHead1_0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader19printingHasFinishedEv
        BL       _ZN10CardReader19printingHasFinishedEv
        B.N      ??getHead1_1
??getHead1_0:
        LDR.W    R1,??DataTable152_2  ;; 0x2fa37
        MOV      R0,R5
          CFI FunCall _ZN10CardReader8setIndexEl
        BL       _ZN10CardReader8setIndexEl
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        ADD      R6,SP,#+0
        LDRB     R0,[SP, #+0]
        LDRB     R1,[R6, #+1]
        ORR      R0,R1,R0, LSL #+8
        STRH     R0,[R4, #+12]
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R0,[SP, #+0]
        LDRB     R1,[R6, #+1]
        ORR      R0,R1,R0, LSL #+8
        STRH     R0,[R4, #+14]
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R0,[SP, #+0]
        LDRB     R1,[R6, #+1]
        ORR      R0,R1,R0, LSL #+8
        STRH     R0,[R4, #+16]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R2,[R6, #+3]
        STRB     R2,[R4, #+18]
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R1,[R4, #+18]
        ADD      R0,SP,#+0
          CFI FunCall _Z13strting2floatPhh
        BL       _Z13strting2floatPhh
        VSTR     S0,[R4, #+20]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R2,[R6, #+3]
        STRB     R2,[R4, #+24]
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R1,[R4, #+24]
        ADD      R0,SP,#+0
          CFI FunCall _Z13strting2floatPhh
        BL       _Z13strting2floatPhh
        VSTR     S0,[R4, #+28]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R2,[R6, #+3]
        STRB     R2,[R4, #+32]
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R1,[R4, #+32]
        ADD      R0,SP,#+0
          CFI FunCall _Z13strting2floatPhh
        BL       _Z13strting2floatPhh
        VSTR     S0,[R4, #+36]
??getHead1_1:
        ADD      SP,SP,#+32
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock109

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable138:
        DC32     0x42f00000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "MKSDLP">`:
        DC8 "MKSDLP"
        DC8 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock110 Using cfiCommon0
          CFI Function _ZN7MKS_DLP8getHead2Ev
        THUMB
// __interwork __softfp void MKS_DLP::getHead2()
_ZN7MKS_DLP8getHead2Ev:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+32
          CFI CFA R13+48
        MOV      R4,R0
        LDR.W    R5,??DataTable152_3
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        ADD      R6,SP,#+0
        LDRB     R0,[SP, #+0]
        LDRB     R1,[R6, #+1]
        ORR      R1,R1,R0, LSL #+8
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP13set_LedOnTimeEt
        BL       _ZN7MKS_DLP13set_LedOnTimeEt
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R0,[SP, #+0]
        LDRB     R1,[R6, #+1]
        ORR      R1,R1,R0, LSL #+8
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP14set_LedOffTimeEt
        BL       _ZN7MKS_DLP14set_LedOffTimeEt
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R0,[SP, #+0]
        LDRB     R1,[R6, #+1]
        ORR      R1,R1,R0, LSL #+8
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP19set_BottomLedOnTimeEt
        BL       _ZN7MKS_DLP19set_BottomLedOnTimeEt
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R0,[SP, #+0]
        LDRB     R1,[R6, #+1]
        ORR      R1,R1,R0, LSL #+8
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16set_BottomlayersEt
        BL       _ZN7MKS_DLP16set_BottomlayersEt
        ADD      SP,SP,#+32
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock110

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable139:
        DC32     BMP_PIC_X

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable139_1:
        DC32     card

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock111 Using cfiCommon0
          CFI Function _ZN7MKS_DLP14startFileprintEv
        THUMB
// __interwork __softfp void MKS_DLP::startFileprint()
_ZN7MKS_DLP14startFileprintEv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
          CFI FunCall _ZN7MKS_DLP8getHead1Ev
        BL       _ZN7MKS_DLP8getHead1Ev
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP8getHead2Ev
        BL       _ZN7MKS_DLP8getHead2Ev
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP23clean_Information_layerEv
        BL       _ZN7MKS_DLP23clean_Information_layerEv
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP11status_initEv
        BL       _ZN7MKS_DLP11status_initEv
          CFI FunCall draw_status_clear
        BL       draw_status_clear
          CFI FunCall display_print_statue
        BL       display_print_statue
          CFI FunCall GUI_Exec
        BL       GUI_Exec
        ADR.W    R0,`?<Constant "G28 Z0">`
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z7mks_G28Pc
        B.W      _Z7mks_G28Pc
          CFI EndBlock cfiBlock111

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "G28 Z0">`:
        DC8 "G28 Z0"
        DC8 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock112 Using cfiCommon0
          CFI Function _ZN7MKS_DLP14bank2disp_readEv
        THUMB
// __interwork __softfp uint8_t MKS_DLP::bank2disp_read()
_ZN7MKS_DLP14bank2disp_readEv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.W    R4,??DataTable152_4  ;; 0x424282b4
        MOVS     R0,#+0
        STR      R0,[R4, #+0]
        MOVS     R0,#+128
          CFI FunCall SPI1_ReadWriteByte
        BL       SPI1_ReadWriteByte
        MOVS     R0,#+255
          CFI FunCall SPI1_ReadWriteByte
        BL       SPI1_ReadWriteByte
        MOVS     R0,#+255
          CFI FunCall SPI1_ReadWriteByte
        BL       SPI1_ReadWriteByte
        MOVS     R1,#+1
        STR      R1,[R4, #+0]
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock112

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock113 Using cfiCommon0
          CFI Function _ZN7MKS_DLP16bank2disp_enableEhhh
        THUMB
// __interwork __softfp uint8_t MKS_DLP::bank2disp_enable(uint8_t, uint8_t, uint8_t)
_ZN7MKS_DLP16bank2disp_enableEhhh:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        MOV      R4,R0
        MOVS     R0,#+0
        STRB     R0,[R4, #+488]
        ADD      R5,R4,#+488
        STRB     R0,[R5, #+1]
        LSLS     R0,R3,#+6
        ORR      R0,R0,R2, LSL #+7
        ORR      R0,R0,R1, LSL #+4
        STRB     R0,[R5, #+2]
        MOVS     R6,#+0
        B.N      ??bank2disp_enable_0
??bank2disp_enable_1:
        ADDS     R6,R6,#+1
??bank2disp_enable_0:
        UXTB     R6,R6
        CMP      R6,#+5
        BGE.N    ??bank2disp_enable_2
        LDR.W    R7,??DataTable152_4  ;; 0x424282b4
        MOVS     R0,#+0
        STR      R0,[R7, #+0]
        LDRB     R0,[R4, #+488]
          CFI FunCall SPI1_ReadWriteByte
        BL       SPI1_ReadWriteByte
        LDRB     R0,[R5, #+1]
          CFI FunCall SPI1_ReadWriteByte
        BL       SPI1_ReadWriteByte
        LDRB     R0,[R5, #+2]
          CFI FunCall SPI1_ReadWriteByte
        BL       SPI1_ReadWriteByte
        MOVS     R0,#+1
        STR      R0,[R7, #+0]
        LDRB     R7,[R5, #+2]
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP14bank2disp_readEv
        BL       _ZN7MKS_DLP14bank2disp_readEv
        AND      R0,R0,#0xF0
        CMP      R7,R0
        BNE.N    ??bank2disp_enable_1
        MOVS     R0,#+1
        POP      {R1,R4-R7,PC}
??bank2disp_enable_2:
        MOVS     R0,#+0
        POP      {R1,R4-R7,PC}    ;; return
          CFI EndBlock cfiBlock113

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable141:
        DC32     BMP_PIC_Y

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable141_1:
        DC32     mksCfg

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock114 Using cfiCommon0
          CFI Function _ZN7MKS_DLP14reTransmissionEv
        THUMB
// __interwork __softfp uint8_t MKS_DLP::reTransmission()
_ZN7MKS_DLP14reTransmissionEv:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        MOV      R4,R0
        MOVS     R5,#+0
        LDR.W    R6,??DataTable152_4  ;; 0x424282b4
        LDR.W    R7,??DataTable152_5
        B.N      ??reTransmission_0
??reTransmission_1:
        ADDS     R5,R5,#+1
??reTransmission_0:
        UXTB     R5,R5
        CMP      R5,#+5
        BGE.N    ??reTransmission_2
        LDR      R0,[R7, #+8]
        ADDS     R0,R0,#+1
        STR      R0,[R7, #+8]
        MOVS     R0,#+0
        STR      R0,[R6, #+0]
        MOVS     R2,#+196
        ADD      R1,R4,#+268
        LDR.W    R0,??DataTable152_6
          CFI FunCall HAL_SPI_Transmit_DMA
        BL       HAL_SPI_Transmit_DMA
        LDR      R0,[R7, #+12]
        LDR      R1,[R0, #+0]
        BIC      R1,R1,#0x8
        STR      R1,[R0, #+0]
??reTransmission_3:
        LDR.W    R0,??DataTable152_7
        LDRSB    R0,[R0, #+53]
        CMP      R0,#+2
        BEQ.N    ??reTransmission_3
        MOVS     R0,#+1
        STR      R0,[R6, #+0]
        MOVS     R0,#+0
        STRB     R0,[SP, #+0]
        B.N      ??reTransmission_4
??reTransmission_5:
        LDRB     R0,[SP, #+0]
        ADDS     R0,R0,#+1
        STRB     R0,[SP, #+0]
??reTransmission_4:
        LDRB     R0,[SP, #+0]
        CMP      R0,#+10
        BLT.N    ??reTransmission_5
        LDR.W    R0,??DataTable152_8  ;; 0x42430200
        LDR      R0,[R0, #+0]
        STRB     R0,[R4, #+464]
        LDRB     R0,[R4, #+464]
        CMP      R0,#+1
        BNE.N    ??reTransmission_1
        MOVS     R0,#+1
        POP      {R1,R4-R7,PC}
??reTransmission_2:
        MOVS     R0,#+0
        POP      {R1,R4-R7,PC}    ;; return
          CFI EndBlock cfiBlock114

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable142:
        DC32     pause_resum

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock115 Using cfiCommon0
          CFI Function _ZN7MKS_DLP18line_fill_all_zeroEcth
        THUMB
// __interwork __softfp void MKS_DLP::line_fill_all_zero(char, uint16_t, uint8_t)
_ZN7MKS_DLP18line_fill_all_zeroEcth:
        PUSH     {R4-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
        MOV      R4,R0
        MOV      R7,R2
        MOV      R5,R3
        CMP      R1,#+0
        BNE.N    ??line_fill_all_zero_0
        MOVS     R6,#+0
        B.N      ??line_fill_all_zero_1
??line_fill_all_zero_0:
        MOV      R6,R7
        MOV      R7,#+2560
        B.N      ??line_fill_all_zero_1
??line_fill_all_zero_2:
        ASRS     R0,R6,#+8
        AND      R0,R0,#0xF
        ORR      R0,R0,R5, LSL #+4
        ORR      R0,R0,#0x40
        STRB     R0,[R4, #+72]
        ADD      R9,R4,#+72
        STRB     R6,[R9, #+1]
        MOVS     R2,#+192
        MOVS     R1,#+0
        ADD      R0,R4,#+74
          CFI FunCall memset
        BL       memset
        MOVS     R1,#+194
        MOV      R0,R9
          CFI FunCall _Z12CRC16_XMODEMPhj
        BL       _Z12CRC16_XMODEMPhj
        STRH     R0,[R4, #+266]
??line_fill_all_zero_3:
        LDRSB    R0,[R8, #+53]
        CMP      R0,#+2
        BEQ.N    ??line_fill_all_zero_3
        LDR.W    R0,??DataTable152_8  ;; 0x42430200
        LDR      R0,[R0, #+0]
        STRB     R0,[R4, #+464]
        LDR.W    R8,??DataTable152_5
        LDRB     R0,[R4, #+464]
        CMP      R0,#+0
        BNE.N    ??line_fill_all_zero_4
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP14reTransmissionEv
        BL       _ZN7MKS_DLP14reTransmissionEv
        LDR      R0,[R8, #+0]
        ADDS     R0,R0,#+1
        STR      R0,[R8, #+0]
??line_fill_all_zero_4:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable152_4  ;; 0x424282b4
        STR      R0,[R1, #+0]
        ADD      R10,R4,#+268
        MOVS     R2,#+196
        MOV      R1,R9
        MOV      R0,R10
          CFI FunCall memcpy
        BL       memcpy
        MOVS     R2,#+196
        MOV      R1,R10
        LDR.W    R0,??DataTable152_6
          CFI FunCall HAL_SPI_Transmit_DMA
        BL       HAL_SPI_Transmit_DMA
        LDR      R0,[R8, #+12]
        LDR      R1,[R0, #+0]
        BIC      R1,R1,#0x8
        STR      R1,[R0, #+0]
        ADDS     R6,R6,#+1
        UXTH     R6,R6
??line_fill_all_zero_1:
        LDR.W    R8,??DataTable152_7
        CMP      R6,R7
        BLT.N    ??line_fill_all_zero_2
??line_fill_all_zero_5:
        LDRSB    R0,[R8, #+53]
        CMP      R0,#+2
        BEQ.N    ??line_fill_all_zero_5
        MOVS     R0,#+1
        LDR.W    R1,??DataTable152_4  ;; 0x424282b4
        STR      R0,[R1, #+0]
        POP      {R4-R10,PC}      ;; return
          CFI EndBlock cfiBlock115

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable143:
        DC32     axis_relative_modes

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock116 Using cfiCommon0
          CFI Function _ZN7MKS_DLP14line_fill_zeroEth
        THUMB
// __interwork __softfp void MKS_DLP::line_fill_zero(uint16_t, uint8_t)
_ZN7MKS_DLP14line_fill_zeroEth:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R4,R0
        ASRS     R0,R1,#+8
        AND      R0,R0,#0xF
        ORR      R0,R0,R2, LSL #+4
        ORR      R0,R0,#0x40
        STRB     R0,[R4, #+72]
        ADD      R5,R4,#+72
        STRB     R1,[R5, #+1]
        MOVS     R2,#+192
        MOVS     R1,#+0
        ADD      R0,R4,#+74
          CFI FunCall memset
        BL       memset
        MOVS     R1,#+194
        MOV      R0,R5
          CFI FunCall _Z12CRC16_XMODEMPhj
        BL       _Z12CRC16_XMODEMPhj
        STRH     R0,[R4, #+266]
??line_fill_zero_0:
        LDR.W    R0,??DataTable152_7
        LDRSB    R0,[R0, #+53]
        CMP      R0,#+2
        BEQ.N    ??line_fill_zero_0
        LDR.W    R0,??DataTable152_8  ;; 0x42430200
        LDR      R0,[R0, #+0]
        STRB     R0,[R4, #+464]
        LDR.W    R6,??DataTable152_5
        LDRB     R0,[R4, #+464]
        CMP      R0,#+0
        BNE.N    ??line_fill_zero_1
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP14reTransmissionEv
        BL       _ZN7MKS_DLP14reTransmissionEv
        LDR      R0,[R6, #+0]
        ADDS     R0,R0,#+1
        STR      R0,[R6, #+0]
??line_fill_zero_1:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable152_4  ;; 0x424282b4
        STR      R0,[R1, #+0]
        ADD      R4,R4,#+268
        MOVS     R2,#+196
        MOV      R1,R5
        MOV      R0,R4
          CFI FunCall memcpy
        BL       memcpy
        MOVS     R2,#+196
        MOV      R1,R4
        LDR.W    R0,??DataTable152_6
          CFI FunCall HAL_SPI_Transmit_DMA
        BL       HAL_SPI_Transmit_DMA
        LDR      R0,[R6, #+12]
        LDR      R1,[R0, #+0]
        BIC      R1,R1,#0x8
        STR      R1,[R0, #+0]
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock116

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock117 Using cfiCommon0
          CFI Function _ZN7MKS_DLP13line_gen_dataEth
        THUMB
// __interwork __softfp void MKS_DLP::line_gen_data(uint16_t, uint8_t)
_ZN7MKS_DLP13line_gen_dataEth:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        MOV      R5,R0
        LSRS     R0,R1,#+8
        AND      R0,R0,#0xF
        ORR      R0,R0,R2, LSL #+4
        ORR      R0,R0,#0x40
        STRB     R0,[R5, #+72]
        ADD      R4,R5,#+72
        STRB     R1,[R4, #+1]
        MOVS     R2,#+192
        MOVS     R1,#+0
        ADD      R0,R5,#+74
          CFI FunCall memset
        BL       memset
        ADDW     R0,R5,#+74
        LDR.W    R1,??DataTable152_9
        MOVS     R2,#+0
        B.N      ??line_gen_data_0
??line_gen_data_1:
        LDRB     R3,[R0, #+0]
        LSLS     R3,R3,#+1
        STRB     R3,[R0, #+0]
        LDRB     R7,[R1], #+1
        CMP      R7,#+1
        BNE.N    ??line_gen_data_2
        ORR      R3,R3,#0x1
        STRB     R3,[R0, #+0]
??line_gen_data_2:
        ADDS     R6,R6,#+1
??line_gen_data_3:
        CMP      R6,#+8
        BLT.N    ??line_gen_data_1
        ADDS     R0,R0,#+1
        ADDS     R2,R2,#+1
??line_gen_data_0:
        CMP      R2,#+192
        BGE.N    ??line_gen_data_4
        MOVS     R6,#+0
        B.N      ??line_gen_data_3
??line_gen_data_4:
        MOVS     R1,#+194
        MOV      R0,R4
          CFI FunCall _Z12CRC16_XMODEMPhj
        BL       _Z12CRC16_XMODEMPhj
        STRH     R0,[R5, #+266]
??line_gen_data_5:
        LDR.W    R0,??DataTable152_7
        LDRSB    R0,[R0, #+53]
        CMP      R0,#+2
        BEQ.N    ??line_gen_data_5
        LDR.W    R0,??DataTable152_8  ;; 0x42430200
        LDR      R0,[R0, #+0]
        STRB     R0,[R5, #+464]
        LDR.W    R6,??DataTable152_5
        LDRB     R0,[R5, #+464]
        CMP      R0,#+0
        BNE.N    ??line_gen_data_6
        MOV      R0,R5
          CFI FunCall _ZN7MKS_DLP14reTransmissionEv
        BL       _ZN7MKS_DLP14reTransmissionEv
        LDR      R0,[R6, #+4]
        ADDS     R0,R0,#+1
        STR      R0,[R6, #+4]
??line_gen_data_6:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable152_4  ;; 0x424282b4
        STR      R0,[R1, #+0]
        ADD      R5,R5,#+268
        MOVS     R2,#+196
        MOV      R1,R4
        MOV      R0,R5
          CFI FunCall memcpy
        BL       memcpy
        MOVS     R2,#+196
        MOV      R1,R5
        LDR.W    R0,??DataTable152_6
          CFI FunCall HAL_SPI_Transmit_DMA
        BL       HAL_SPI_Transmit_DMA
        LDR      R0,[R6, #+12]
        LDR      R1,[R0, #+0]
        BIC      R1,R1,#0x8
        STR      R1,[R0, #+0]
        POP      {R0,R4-R7,PC}    ;; return
          CFI EndBlock cfiBlock117

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock118 Using cfiCommon0
          CFI Function _ZN7MKS_DLP17line_gen_data_TFTEt
          CFI NoCalls
        THUMB
// __interwork __softfp void MKS_DLP::line_gen_data_TFT(uint16_t)
_ZN7MKS_DLP17line_gen_data_TFTEt:
        MOVS     R0,#+7
        TST      R1,R0
        BEQ.N    ??line_gen_data_TFT_0
        BX       LR
??line_gen_data_TFT_0:
        PUSH     {R4-R6}
          CFI R6 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        CMP      R1,#+0
        BEQ.N    ??line_gen_data_TFT_1
        ASRS     R0,R1,#+3
        SUBS     R0,R0,#+1
        UXTH     R0,R0
        MOVS     R1,#+23
        LDR.W    R2,??DataTable152_10
        MLA      R0,R1,R0,R2
        LDR.W    R1,??DataTable152_9
        MOV      R2,R1
        MOVS     R3,#+0
        B.N      ??line_gen_data_TFT_2
??line_gen_data_TFT_3:
        LDRB     R4,[R0, #+0]
        LSLS     R4,R4,#+1
        STRB     R4,[R0, #+0]
        LDRB     R6,[R2, #+0]
        CMP      R6,#+1
        BNE.N    ??line_gen_data_TFT_4
        ORR      R4,R4,#0x1
        STRB     R4,[R0, #+0]
??line_gen_data_TFT_4:
        ADDS     R2,R2,#+8
        SUBS     R4,R2,R1
        SUB      R4,R4,#+720
        CMP      R4,#+49
        BCS.N    ??line_gen_data_TFT_5
        ADDS     R2,R2,#+48
??line_gen_data_TFT_5:
        ADDS     R5,R5,#+1
??line_gen_data_TFT_6:
        CMP      R5,#+8
        BLT.N    ??line_gen_data_TFT_3
        ADDS     R0,R0,#+1
        ADDS     R3,R3,#+1
??line_gen_data_TFT_2:
        CMP      R3,#+23
        BGE.N    ??line_gen_data_TFT_1
        MOVS     R5,#+0
        B.N      ??line_gen_data_TFT_6
??line_gen_data_TFT_1:
        POP      {R4-R6}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI CFA R13+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock118

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable146:
        DC32     leveling_first_time

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable146_1:
        DC32     card+0xCC4

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable146_2:
        DC32     curFileName

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable146_3:
        DC32     logo_tick2

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable146_4:
        DC32     logo_tick1

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock119 Using cfiCommon0
          CFI Function _ZN7MKS_DLP15get_sdcard_bmpsEv
        THUMB
// __interwork __softfp void MKS_DLP::get_sdcard_bmps()
_ZN7MKS_DLP15get_sdcard_bmpsEv:
        PUSH     {R4-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+28
        SUB      SP,SP,#+36
          CFI CFA R13+64
        MOV      R4,R0
        LDR.W    R5,??DataTable152_3
        LDRB     R0,[R5, #+2488]
        CMP      R0,#+0
        BEQ.W    ??get_sdcard_bmps_0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader3eofEv
        BL       _ZN10CardReader3eofEv
        MOV      R0,R5
          CFI FunCall _ZN10CardReader8getsdposEv
        BL       _ZN10CardReader8getsdposEv
        STR      R0,[R5, #+3340]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        ADD      R6,SP,#+0
        LDRB     R0,[SP, #+0]
        LDRB     R1,[R6, #+1]
        LSLS     R1,R1,#+16
        ORR      R0,R1,R0, LSL #+24
        LDRB     R1,[R6, #+2]
        ORR      R0,R0,R1, LSL #+8
        LDRB     R1,[SP, #+3]
        ORRS     R0,R1,R0
        STR      R0,[R4, #+56]
        ADDW     R7,R5,#+3480
        MOV      R2,#+1536
        MOVS     R1,#+0
        MOV      R0,R7
          CFI FunCall memset
        BL       memset
        MOV      R2,#+7360
        MOVS     R1,#+0
        LDR.W    R0,??DataTable152_10
          CFI FunCall memset
        BL       memset
        MOV      R8,#+0
        ADD      R9,R4,#+56
        B.N      ??get_sdcard_bmps_1
??get_sdcard_bmps_2:
        ADD      R8,R8,#+1
??get_sdcard_bmps_1:
        LDR      R0,[R4, #+56]
        CMP      R8,R0
        BCS.W    ??get_sdcard_bmps_3
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R0,[SP, #+0]
        LDRB     R1,[R6, #+1]
        ORR      R0,R1,R0, LSL #+8
        STRH     R0,[R9, #+12]
        CMP      R0,#+1440
        BLT.N    ??get_sdcard_bmps_4
        MOVW     R0,#+1439
        STRH     R0,[R9, #+12]
??get_sdcard_bmps_4:
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R0,[SP, #+0]
        LDRB     R1,[R6, #+1]
        ORR      R0,R1,R0, LSL #+8
        STRH     R0,[R9, #+14]
        CMP      R0,#+1440
        BLT.N    ??get_sdcard_bmps_5
        MOVW     R0,#+1439
        STRH     R0,[R9, #+14]
??get_sdcard_bmps_5:
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R0,[SP, #+0]
        LDRB     R1,[R6, #+1]
        ORR      R0,R1,R0, LSL #+8
        STRH     R0,[R9, #+8]
        CMP      R0,#+2560
        BLT.N    ??get_sdcard_bmps_6
        MOVW     R0,#+2559
        STRH     R0,[R9, #+8]
??get_sdcard_bmps_6:
        CMP      R8,#+0
        BNE.N    ??get_sdcard_bmps_7
        MOVS     R3,#+0
        LDRH     R2,[R9, #+8]
        MOV      R1,R3
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP18line_fill_all_zeroEcth
        BL       _ZN7MKS_DLP18line_fill_all_zeroEcth
        LDRH     R0,[R9, #+8]
        STRH     R0,[R9, #+10]
??get_sdcard_bmps_7:
        LDRH     R1,[R9, #+10]
        LDRH     R0,[R9, #+8]
        CMP      R1,R0
        BNE.N    ??get_sdcard_bmps_8
        LDRH     R1,[R9, #+12]
        ADDS     R0,R1,R5
        ADDW     R0,R0,#+3480
        B.N      ??get_sdcard_bmps_9
??get_sdcard_bmps_10:
        MOVS     R2,#+1
        STRB     R2,[R0, #+48]
??get_sdcard_bmps_11:
        ADDS     R0,R0,#+1
        ADDS     R1,R1,#+1
??get_sdcard_bmps_9:
        LDRH     R2,[R9, #+14]
        ADDS     R2,R2,#+1
        CMP      R1,R2
        BGE.N    ??get_sdcard_bmps_2
        CMP      R1,#+720
        BGE.N    ??get_sdcard_bmps_10
        MOVS     R2,#+1
        STRB     R2,[R0, #+0]
        B.N      ??get_sdcard_bmps_11
??get_sdcard_bmps_8:
        MOVS     R2,#+0
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP13line_gen_dataEth
        BL       _ZN7MKS_DLP13line_gen_dataEth
        LDRH     R1,[R9, #+10]
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP17line_gen_data_TFTEt
        BL       _ZN7MKS_DLP17line_gen_data_TFTEt
        B.N      ??get_sdcard_bmps_12
??get_sdcard_bmps_13:
        ADDS     R1,R0,#+1
        STRH     R1,[R9, #+10]
        MOVS     R2,#+0
        UXTH     R1,R1
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP14line_fill_zeroEth
        BL       _ZN7MKS_DLP14line_fill_zeroEth
??get_sdcard_bmps_12:
        LDRH     R0,[R9, #+10]
        LDRH     R1,[R9, #+8]
        SUBS     R2,R1,R0
        CMP      R2,#+2
        BGE.N    ??get_sdcard_bmps_13
        STRH     R1,[R9, #+10]
        MOV      R2,#+1536
        MOVS     R1,#+0
        MOV      R0,R7
          CFI FunCall memset
        BL       memset
        LDRH     R1,[R9, #+12]
        ADDS     R0,R1,R5
        ADDW     R0,R0,#+3480
        B.N      ??get_sdcard_bmps_14
??get_sdcard_bmps_15:
        MOVS     R2,#+1
        STRB     R2,[R0, #+48]
??get_sdcard_bmps_16:
        ADDS     R0,R0,#+1
        ADDS     R1,R1,#+1
??get_sdcard_bmps_14:
        LDRH     R2,[R9, #+14]
        ADDS     R2,R2,#+1
        CMP      R1,R2
        BGE.W    ??get_sdcard_bmps_2
        CMP      R1,#+720
        BGE.N    ??get_sdcard_bmps_15
        MOVS     R2,#+1
        STRB     R2,[R0, #+0]
        B.N      ??get_sdcard_bmps_16
??get_sdcard_bmps_3:
        CMP      R0,#+2
        BCC.N    ??get_sdcard_bmps_17
        MOVS     R2,#+0
        LDRH     R1,[R9, #+10]
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP13line_gen_dataEth
        BL       _ZN7MKS_DLP13line_gen_dataEth
        LDRH     R1,[R9, #+10]
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP17line_gen_data_TFTEt
        BL       _ZN7MKS_DLP17line_gen_data_TFTEt
??get_sdcard_bmps_17:
        LDR.W    R0,??DataTable152_7
        LDRSB    R0,[R0, #+53]
        CMP      R0,#+2
        BEQ.N    ??get_sdcard_bmps_17
        MOVS     R0,#+1
        LDR.W    R1,??DataTable152_4  ;; 0x424282b4
        STR      R0,[R1, #+0]
        MOVS     R3,#+0
        ADD      R0,R4,#+56
        LDRH     R0,[R0, #+10]
        ADDS     R2,R0,#+1
        UXTH     R2,R2
        MOVS     R1,#+1
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP18line_fill_all_zeroEcth
        BL       _ZN7MKS_DLP18line_fill_all_zeroEcth
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R0,[SP, #+0]
        CMP      R0,#+13
        BNE.N    ??get_sdcard_bmps_18
        LDRB     R0,[R6, #+1]
        CMP      R0,#+10
        BEQ.N    ??get_sdcard_bmps_0
??get_sdcard_bmps_18:
          CFI FunCall _Z13find_next_bmpv
        BL       _Z13find_next_bmpv
??get_sdcard_bmps_0:
        ADD      SP,SP,#+36
          CFI CFA R13+28
        POP      {R4-R9,PC}       ;; return
          CFI EndBlock cfiBlock119

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable147:
        DC32     from_flash_pic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable147_1:
        DC32     flash_preview_begin

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable147_2:
        DC32     default_preview_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable147_3:
        DC32     continue_print_error_flg

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock120 Using cfiCommon0
          CFI Function _ZN7MKS_DLP16bottomLayerPrintEv
        THUMB
// __interwork __softfp void MKS_DLP::bottomLayerPrint()
_ZN7MKS_DLP16bottomLayerPrintEv:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        MOV      R4,R0
        ADD      R5,R4,#+468
        LDRB     R0,[R5, #+2]
        CMP      R0,#+0
        BNE.N    ??bottomLayerPrint_0
        MOVS     R3,#+0
        MOV      R2,R3
        MOV      R1,R2
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP15get_sdcard_bmpsEv
        BL       _ZN7MKS_DLP15get_sdcard_bmpsEv
        MOVS     R0,#+1
        STRB     R0,[R5, #+3]
        MOV      R3,R0
        MOV      R2,R0
        MOVS     R1,#+0
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
        LDR.W    R0,??DataTable152
        LDR      R1,[R4, #+36]
        STR      R1,[R0, #+56]
        LDR.W    R1,??DataTable152_11
        VLDR     S0,[R1, #+16]
        VLDR.W   S1,??DataTable151  ;; 0x42f00000
        VDIV.F32 S0,S0,S1
        VSTR     S0,[SP, #+0]
        ADD      R1,SP,#+0
        ADDS     R0,R0,#+56
          CFI FunCall _Z21do_blocking_move_to_zRKfS0_
        BL       _Z21do_blocking_move_to_zRKfS0_
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
        LDRB     R0,[R5, #+2]
        ADDS     R0,R0,#+1
        STRB     R0,[R5, #+2]
          CFI FunCall _Z22report_mksdlp_positionv
        BL       _Z22report_mksdlp_positionv
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP6led_onEv
        BL       _ZN7MKS_DLP6led_onEv
          CFI FunCall _Z10clr_ticketv
        BL       _Z10clr_ticketv
??bottomLayerPrint_0:
        LDRB     R0,[R5, #+3]
        CMP      R0,#+0
        BNE.N    ??bottomLayerPrint_1
        ADD      R0,R4,#+36
        LDR      R0,[R0, #+8]
        LDR      R1,[R4, #+720]
        CMP      R0,R1
        BCS.N    ??bottomLayerPrint_1
        MOVS     R3,#+1
        MOV      R2,R3
        MOVS     R1,#+0
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
        MOVS     R0,#+1
        STRB     R0,[R5, #+3]
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP6led_onEv
        BL       _ZN7MKS_DLP6led_onEv
          CFI FunCall _Z10clr_ticketv
        BL       _Z10clr_ticketv
??bottomLayerPrint_1:
        LDRB     R0,[R5, #+3]
        CMP      R0,#+0
        BEQ.N    ??bottomLayerPrint_2
        ADD      R0,R4,#+36
        LDR      R1,[R0, #+12]
        LDR      R2,[R4, #+720]
        CMP      R1,R2
        BCS.N    ??bottomLayerPrint_2
        LDRB     R1,[R5, #+2]
        LDRH     R2,[R0, #+16]
        CMP      R1,R2
        BCS.N    ??bottomLayerPrint_3
        MOVS     R0,#+0
        STRB     R0,[R5, #+3]
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP7led_offEv
        BL       _ZN7MKS_DLP7led_offEv
          CFI FunCall _Z10clr_ticketv
        BL       _Z10clr_ticketv
        MOVS     R1,#+166
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP23write_Information_layerE15DLP_MOVE_STATUS
        BL       _ZN7MKS_DLP23write_Information_layerE15DLP_MOVE_STATUS
        LDR.N    R6,??DataTable152_12
        LDR.N    R7,??DataTable152_11
        VLDR     S0,[R7, #+16]
        VLDR.W   S1,??DataTable151  ;; 0x42f00000
        VDIV.F32 S1,S0,S1
        VLDR     S0,[R6, #+8]
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP14moveRelative_ZEff
        BL       _ZN7MKS_DLP14moveRelative_ZEff
        LDR.N    R0,??DataTable152_3
        LDRB     R0,[R0, #+3336]
        CMP      R0,#+167
        BNE.N    ??bottomLayerPrint_4
        VLDR     S0,[R7, #+16]
        VLDR.W   S1,??DataTable151  ;; 0x42f00000
        VDIV.F32 S1,S0,S1
        VLDR     S0,[R4, #+36]
        VLDR     S2,[R6, #+8]
        VSUB.F32 S0,S0,S2
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP14moveRelative_ZEff
        BL       _ZN7MKS_DLP14moveRelative_ZEff
??bottomLayerPrint_4:
        MOVS     R1,#+167
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP23write_Information_layerE15DLP_MOVE_STATUS
        BL       _ZN7MKS_DLP23write_Information_layerE15DLP_MOVE_STATUS
        LDRB     R0,[R5, #+2]
        ADDS     R0,R0,#+1
        STRB     R0,[R5, #+2]
          CFI FunCall _Z22report_mksdlp_positionv
        BL       _Z22report_mksdlp_positionv
        POP      {R0,R4-R7,PC}
??bottomLayerPrint_3:
        LDR      R0,[R0, #+4]
        ADDS     R0,R0,#+1
        STR      R0,[R4, #+720]
        LDRH     R0,[R4, #+468]
        ADDS     R0,R0,#+1
        STRH     R0,[R4, #+468]
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP18GeneralLayersPrintEv
        BL       _ZN7MKS_DLP18GeneralLayersPrintEv
??bottomLayerPrint_2:
        POP      {R0,R4-R7,PC}    ;; return
          CFI EndBlock cfiBlock120

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock121 Using cfiCommon0
          CFI Function _ZN7MKS_DLP18GeneralLayersPrintEv
        THUMB
// __interwork __softfp void MKS_DLP::GeneralLayersPrint()
_ZN7MKS_DLP18GeneralLayersPrintEv:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        MOV      R4,R0
        ADD      R5,R4,#+468
        LDRB     R0,[R5, #+3]
        CMP      R0,#+0
        BEQ.N    ??GeneralLayersPrint_0
        ADD      R6,R4,#+12
        LDR      R0,[R6, #+28]
        LDR      R1,[R4, #+720]
        CMP      R0,R1
        BCS.N    ??GeneralLayersPrint_0
        MOVS     R0,#+0
        STRB     R0,[R5, #+3]
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP7led_offEv
        BL       _ZN7MKS_DLP7led_offEv
          CFI FunCall _Z10clr_ticketv
        BL       _Z10clr_ticketv
        LDRH     R0,[R4, #+468]
        LDRH     R1,[R4, #+12]
        CMP      R0,R1
        BCS.N    ??GeneralLayersPrint_1
        MOVS     R3,#+0
        MOV      R2,R3
        MOV      R1,R2
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
        MOVS     R1,#+166
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP23write_Information_layerE15DLP_MOVE_STATUS
        BL       _ZN7MKS_DLP23write_Information_layerE15DLP_MOVE_STATUS
        LDR.N    R7,??DataTable152_12
        LDR.W    R8,??DataTable152_11
        VLDR     S0,[R8, #+16]
        VLDR.W   S1,??DataTable151  ;; 0x42f00000
        VDIV.F32 S1,S0,S1
        VLDR     S0,[R7, #+8]
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP22moveRelativeZandGetBmpEff
        BL       _ZN7MKS_DLP22moveRelativeZandGetBmpEff
        LDR.N    R0,??DataTable152_3
        LDRB     R0,[R0, #+3336]
        CMP      R0,#+167
        BNE.N    ??GeneralLayersPrint_2
        VLDR     S0,[R8, #+16]
        VLDR.W   S1,??DataTable151  ;; 0x42f00000
        VDIV.F32 S1,S0,S1
        VLDR     S0,[R6, #+24]
        VLDR     S2,[R7, #+8]
        VSUB.F32 S0,S0,S2
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP14moveRelative_ZEff
        BL       _ZN7MKS_DLP14moveRelative_ZEff
??GeneralLayersPrint_2:
        MOVS     R1,#+167
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP23write_Information_layerE15DLP_MOVE_STATUS
        BL       _ZN7MKS_DLP23write_Information_layerE15DLP_MOVE_STATUS
          CFI FunCall _Z22report_mksdlp_positionv
        BL       _Z22report_mksdlp_positionv
        B.N      ??GeneralLayersPrint_0
??GeneralLayersPrint_1:
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP19printingHasFinishedEv
        BL       _ZN7MKS_DLP19printingHasFinishedEv
??GeneralLayersPrint_0:
        LDRB     R0,[R5, #+3]
        CMP      R0,#+0
        BNE.N    ??GeneralLayersPrint_3
        ADD      R0,R4,#+12
        LDR      R0,[R0, #+32]
        LDR      R1,[R4, #+720]
        CMP      R0,R1
        BCS.N    ??GeneralLayersPrint_3
        MOVS     R3,#+1
        MOV      R2,R3
        MOVS     R1,#+0
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP6led_onEv
        BL       _ZN7MKS_DLP6led_onEv
        MOVS     R0,#+1
        STRB     R0,[R5, #+3]
          CFI FunCall _Z10clr_ticketv
        BL       _Z10clr_ticketv
        LDRH     R0,[R4, #+468]
        ADDS     R0,R0,#+1
        STRH     R0,[R4, #+468]
??GeneralLayersPrint_3:
        POP      {R4-R8,PC}       ;; return
          CFI EndBlock cfiBlock121

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock122 Using cfiCommon0
          CFI Function _ZN7MKS_DLP18get_available_bmpsEv
        THUMB
// __interwork __softfp void MKS_DLP::get_available_bmps()
_ZN7MKS_DLP18get_available_bmpsEv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
        LDR.N    R0,??DataTable152_3
        LDRB     R1,[R0, #+2488]
        CMP      R1,#+0
        BEQ.N    ??get_available_bmps_0
          CFI FunCall _ZN10CardReader3eofEv
        BL       _ZN10CardReader3eofEv
        LDRH     R1,[R4, #+468]
        LDRH     R2,[R4, #+12]
        CMP      R2,R1
        BCC.N    ??get_available_bmps_1
        CMP      R0,#+0
        BEQ.N    ??get_available_bmps_2
??get_available_bmps_1:
        MOV      R0,R4
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7MKS_DLP19printingHasFinishedEv
        B.W      _ZN7MKS_DLP19printingHasFinishedEv
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??get_available_bmps_2:
        CMP      R1,#+0
        MOV      R0,R4
        BNE.N    ??get_available_bmps_3
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7MKS_DLP16bottomLayerPrintEv
        B.N      _ZN7MKS_DLP16bottomLayerPrintEv
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??get_available_bmps_3:
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7MKS_DLP18GeneralLayersPrintEv
        B.N      _ZN7MKS_DLP18GeneralLayersPrintEv
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??get_available_bmps_0:
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock122

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable150:
        DC32     card+0xD88

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock123 Using cfiCommon0
          CFI Function _ZN7MKS_DLP24ExposureDataTrans_circleEv
        THUMB
// __interwork __softfp void MKS_DLP::ExposureDataTrans_circle()
_ZN7MKS_DLP24ExposureDataTrans_circleEv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R4,R0
        MOVS     R3,#+0
        MOV      R2,R3
        MOVS     R1,#+1
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
        MOVS     R3,#+1
        MOV      R2,#+780
        MOVS     R1,#+0
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP18line_fill_all_zeroEcth
        BL       _ZN7MKS_DLP18line_fill_all_zeroEcth
        MOV      R2,#+7360
        MOVS     R1,#+0
        LDR.N    R0,??DataTable152_10
          CFI FunCall memset
        BL       memset
        MOVS     R5,#+0
        B.N      ??ExposureDataTrans_circle_0
??ExposureDataTrans_circle_1:
        ADD      R6,R5,#+780
        MOVS     R2,#+1
        MOV      R1,R6
        UXTH     R1,R1
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP13line_gen_dataEth
        BL       _ZN7MKS_DLP13line_gen_dataEth
        MOV      R1,R6
        UXTH     R1,R1
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP17line_gen_data_TFTEt
        BL       _ZN7MKS_DLP17line_gen_data_TFTEt
        ADDS     R5,R5,#+1
??ExposureDataTrans_circle_0:
        CMP      R5,#+1000
        BGE.N    ??ExposureDataTrans_circle_2
        LDR.N    R6,??DataTable152_3
        MOV      R2,#+1536
        MOVS     R1,#+0
        ADDW     R0,R6,#+3480
          CFI FunCall memset
        BL       memset
        ADD      R0,R5,R5, LSL #+1
        LSLS     R0,R0,#+1
        ADR.W    R1,exposure_bmp_data_circle
        LDRH     R2,[R0, R1]
        ADDS     R3,R2,R6
        ADDW     R3,R3,#+3480
        B.N      ??ExposureDataTrans_circle_3
??ExposureDataTrans_circle_4:
        MOVS     R6,#+1
        STRB     R6,[R3, #+48]
??ExposureDataTrans_circle_5:
        ADDS     R3,R3,#+1
        ADDS     R2,R2,#+1
??ExposureDataTrans_circle_3:
        ADDS     R6,R0,R1
        LDRH     R6,[R6, #+2]
        ADDS     R6,R6,#+1
        CMP      R2,R6
        BGE.N    ??ExposureDataTrans_circle_1
        CMP      R2,#+720
        BGE.N    ??ExposureDataTrans_circle_4
        MOVS     R6,#+1
        STRB     R6,[R3, #+0]
        B.N      ??ExposureDataTrans_circle_5
??ExposureDataTrans_circle_2:
        LDR.N    R0,??DataTable152_7
        LDRSB    R0,[R0, #+53]
        CMP      R0,#+2
        BEQ.N    ??ExposureDataTrans_circle_2
        MOVS     R0,#+1
        LDR.N    R1,??DataTable152_4  ;; 0x424282b4
        STR      R0,[R1, #+0]
        MOV      R3,R0
        MOVW     R2,#+1780
        MOV      R1,R0
        MOV      R0,R4
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7MKS_DLP18line_fill_all_zeroEcth
        B.N      _ZN7MKS_DLP18line_fill_all_zeroEcth
          CFI EndBlock cfiBlock123

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable151:
        DC32     0x42f00000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable151_1:
        DC32     Serial6

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock124 Using cfiCommon0
          CFI Function _ZN7MKS_DLP14CleanDataTransEv
        THUMB
// __interwork __softfp void MKS_DLP::CleanDataTrans()
_ZN7MKS_DLP14CleanDataTransEv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
        MOVS     R3,#+0
        MOV      R2,R3
        MOVS     R1,#+2
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
        MOVS     R3,#+2
        MOV      R2,#+2560
        MOVS     R1,#+0
        MOV      R0,R4
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7MKS_DLP18line_fill_all_zeroEcth
        B.W      _ZN7MKS_DLP18line_fill_all_zeroEcth
          CFI EndBlock cfiBlock124

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock125 Using cfiCommon0
          CFI Function _ZN7MKS_DLP23ExposureData2TFT_circleEv
        THUMB
// __interwork __softfp void MKS_DLP::ExposureData2TFT_circle()
_ZN7MKS_DLP23ExposureData2TFT_circleEv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R4,R0
        MOVS     R3,#+1
        MOV      R2,#+780
        MOVS     R1,#+0
          CFI FunCall _ZN7MKS_DLP18line_fill_all_zeroEcth
        BL       _ZN7MKS_DLP18line_fill_all_zeroEcth
        MOV      R2,#+7360
        MOVS     R1,#+0
        LDR.N    R0,??DataTable152_10
          CFI FunCall memset
        BL       memset
        MOVS     R5,#+0
        B.N      ??ExposureData2TFT_circle_0
??ExposureData2TFT_circle_1:
        ADD      R1,R5,#+780
        UXTH     R1,R1
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP17line_gen_data_TFTEt
        BL       _ZN7MKS_DLP17line_gen_data_TFTEt
??ExposureData2TFT_circle_2:
        ADDS     R5,R5,#+1
??ExposureData2TFT_circle_0:
        CMP      R5,#+1000
        BGE.N    ??ExposureData2TFT_circle_3
        ADD      R0,R5,#+780
        ASRS     R1,R0,#+2
        ADD      R1,R0,R1, LSR #+29
        ASRS     R1,R1,#+3
        SUBS     R0,R0,R1, LSL #+3
        BNE.N    ??ExposureData2TFT_circle_2
        LDR.N    R6,??DataTable152_3
        MOV      R2,#+1536
        MOVS     R1,#+0
        ADDW     R0,R6,#+3480
          CFI FunCall memset
        BL       memset
        ADD      R0,R5,R5, LSL #+1
        LSLS     R0,R0,#+1
        ADR.W    R1,exposure_bmp_data_circle
        LDRH     R2,[R0, R1]
        ADDS     R3,R2,R6
        ADDW     R3,R3,#+3480
        B.N      ??ExposureData2TFT_circle_4
??ExposureData2TFT_circle_5:
        MOVS     R6,#+1
        STRB     R6,[R3, #+48]
??ExposureData2TFT_circle_6:
        ADDS     R3,R3,#+1
        ADDS     R2,R2,#+1
??ExposureData2TFT_circle_4:
        ADDS     R6,R0,R1
        LDRH     R6,[R6, #+2]
        ADDS     R6,R6,#+1
        CMP      R2,R6
        BGE.N    ??ExposureData2TFT_circle_1
        CMP      R2,#+720
        BGE.N    ??ExposureData2TFT_circle_5
        MOVS     R6,#+1
        STRB     R6,[R3, #+0]
        B.N      ??ExposureData2TFT_circle_6
??ExposureData2TFT_circle_3:
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock125

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable152:
        DC32     axis_relative_modes

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable152_1:
        DC32     0x186af

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable152_2:
        DC32     0x2fa37

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable152_3:
        DC32     card

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable152_4:
        DC32     0x424282b4

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable152_5:
        DC32     reTransmission_zero_cnt

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable152_6:
        DC32     hspi1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable152_7:
        DC32     hdma_spi1_tx

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable152_8:
        DC32     0x42430200

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable152_9:
        DC32     card+0xD98

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable152_10:
        DC32     bmp_layer_buf

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable152_11:
        DC32     mksCfg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable152_12:
        DC32     home_bump_mm_P

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
// static __absolute unsigned short const exposure_bmp_data_circle[1000][3]
exposure_bmp_data_circle:
        DC16 720, 720, 780, 690, 750, 781, 681, 759, 782, 673, 767, 783, 665
        DC16 775, 784, 656, 784, 785, 648, 792, 786, 639, 801, 787, 632, 808
        DC16 788, 627, 813, 789, 623, 817, 790, 619, 821, 791, 615, 825, 792
        DC16 611, 829, 793, 607, 833, 794, 603, 837, 795, 598, 842, 796, 594
        DC16 846, 797, 590, 850, 798, 586, 854, 799, 582, 858, 800, 578, 862
        DC16 801, 574, 866, 802, 571, 869, 803, 569, 871, 804, 566, 874, 805
        DC16 563, 877, 806, 560, 880, 807, 558, 882, 808, 555, 885, 809, 552
        DC16 888, 810, 550, 890, 811, 547, 893, 812, 544, 896, 813, 542, 898
        DC16 814, 539, 901, 815, 536, 904, 816, 534, 906, 817, 531, 909, 818
        DC16 528, 912, 819, 525, 915, 820, 523, 917, 821, 520, 920, 822, 518
        DC16 922, 823, 516, 924, 824, 514, 926, 825, 512, 928, 826, 510, 930
        DC16 827, 508, 932, 828, 506, 934, 829, 504, 936, 830, 502, 938, 831
        DC16 500, 940, 832, 498, 942, 833, 496, 944, 834, 494, 946, 835, 492
        DC16 948, 836, 491, 949, 837, 489, 951, 838, 487, 953, 839, 485, 955
        DC16 840, 483, 957, 841, 481, 959, 842, 479, 961, 843, 477, 963, 844
        DC16 475, 965, 845, 473, 967, 846, 471, 969, 847, 469, 971, 848, 467
        DC16 973, 849, 465, 975, 850, 464, 976, 851, 462, 978, 852, 461, 979
        DC16 853, 460, 980, 854, 458, 982, 855, 457, 983, 856, 455, 985, 857
        DC16 454, 986, 858, 452, 988, 859, 451, 989, 860, 449, 991, 861, 448
        DC16 992, 862, 446, 994, 863, 445, 995, 864, 443, 997, 865, 442, 998
        DC16 866, 440, 1000, 867, 439, 1001, 868, 437, 1003, 869, 436, 1004
        DC16 870, 434, 1006, 871, 433, 1007, 872, 431, 1009, 873, 430, 1010
        DC16 874, 428, 1012, 875, 427, 1013, 876, 425, 1015, 877, 424, 1016
        DC16 878, 422, 1018, 879, 421, 1019, 880, 419, 1021, 881, 418, 1022
        DC16 882, 417, 1023, 883, 415, 1025, 884, 414, 1026, 885, 413, 1027
        DC16 886, 412, 1028, 887, 411, 1029, 888, 410, 1030, 889, 408, 1032
        DC16 890, 407, 1033, 891, 406, 1034, 892, 405, 1035, 893, 404, 1036
        DC16 894, 403, 1037, 895, 402, 1038, 896, 400, 1040, 897, 399, 1041
        DC16 898, 398, 1042, 899, 397, 1043, 900, 396, 1044, 901, 395, 1045
        DC16 902, 393, 1047, 903, 392, 1048, 904, 391, 1049, 905, 390, 1050
        DC16 906, 389, 1051, 907, 388, 1052, 908, 386, 1054, 909, 385, 1055
        DC16 910, 384, 1056, 911, 383, 1057, 912, 382, 1058, 913, 381, 1059
        DC16 914, 379, 1061, 915, 378, 1062, 916, 377, 1063, 917, 376, 1064
        DC16 918, 375, 1065, 919, 374, 1066, 920, 372, 1067, 921, 372, 1068
        DC16 922, 371, 1069, 923, 370, 1070, 924, 369, 1071, 925, 368, 1072
        DC16 926, 367, 1073, 927, 366, 1074, 928, 365, 1075, 929, 364, 1076
        DC16 930, 363, 1077, 931, 362, 1078, 932, 361, 1079, 933, 361, 1079
        DC16 934, 360, 1080, 935, 359, 1081, 936, 358, 1082, 937, 357, 1083
        DC16 938, 356, 1084, 939, 355, 1085, 940, 354, 1086, 941, 353, 1087
        DC16 942, 352, 1088, 943, 351, 1089, 944, 350, 1090, 945, 350, 1090
        DC16 946, 349, 1091, 947, 348, 1092, 948, 347, 1093, 949, 346, 1094
        DC16 950, 345, 1095, 951, 344, 1096, 952, 343, 1097, 953, 342, 1098
        DC16 954, 341, 1099, 955, 340, 1100, 956, 339, 1100, 957, 339, 1101
        DC16 958, 338, 1102, 959, 337, 1103, 960, 336, 1104, 961, 335, 1105
        DC16 962, 334, 1106, 963, 333, 1107, 964, 332, 1108, 965, 331, 1108
        DC16 966, 331, 1109, 967, 330, 1110, 968, 329, 1111, 969, 329, 1111
        DC16 970, 328, 1112, 971, 327, 1113, 972, 326, 1114, 973, 326, 1114
        DC16 974, 325, 1115, 975, 324, 1116, 976, 324, 1116, 977, 323, 1117
        DC16 978, 322, 1118, 979, 321, 1119, 980, 321, 1119, 981, 320, 1120
        DC16 982, 319, 1121, 983, 319, 1121, 984, 318, 1122, 985, 317, 1123
        DC16 986, 316, 1124, 987, 316, 1124, 988, 315, 1125, 989, 314, 1126
        DC16 990, 314, 1126, 991, 313, 1127, 992, 312, 1128, 993, 311, 1129
        DC16 994, 311, 1129, 995, 310, 1130, 996, 309, 1131, 997, 309, 1131
        DC16 998, 308, 1132, 999, 307, 1133, 1000, 306, 1134, 1001, 306, 1134
        DC16 1002, 305, 1135, 1003, 304, 1136, 1004, 303, 1136, 1005, 303, 1137
        DC16 1006, 302, 1138, 1007, 301, 1139, 1008, 301, 1139, 1009, 300, 1140
        DC16 1010, 299, 1141, 1011, 298, 1142, 1012, 298, 1142, 1013, 297, 1143
        DC16 1014, 297, 1143, 1015, 296, 1144, 1016, 296, 1144, 1017, 295, 1145
        DC16 1018, 294, 1146, 1019, 294, 1146, 1020, 293, 1147, 1021, 293, 1147
        DC16 1022, 292, 1148, 1023, 292, 1148, 1024, 291, 1149, 1025, 291, 1149
        DC16 1026, 290, 1150, 1027, 289, 1151, 1028, 289, 1151, 1029, 288, 1152
        DC16 1030, 288, 1152, 1031, 287, 1153, 1032, 287, 1153, 1033, 286, 1154
        DC16 1034, 286, 1154, 1035, 285, 1155, 1036, 285, 1155, 1037, 284, 1156
        DC16 1038, 283, 1157, 1039, 283, 1157, 1040, 282, 1158, 1041, 282, 1158
        DC16 1042, 281, 1159, 1043, 281, 1159, 1044, 280, 1160, 1045, 280, 1160
        DC16 1046, 279, 1161, 1047, 278, 1162, 1048, 278, 1162, 1049, 277, 1163
        DC16 1050, 277, 1163, 1051, 276, 1164, 1052, 276, 1164, 1053, 275, 1165
        DC16 1054, 275, 1165, 1055, 274, 1166, 1056, 273, 1167, 1057, 273, 1167
        DC16 1058, 272, 1168, 1059, 272, 1168, 1060, 271, 1169, 1061, 271, 1169
        DC16 1062, 270, 1170, 1063, 270, 1170, 1064, 269, 1171, 1065, 269, 1171
        DC16 1066, 268, 1172, 1067, 268, 1172, 1068, 267, 1173, 1069, 267, 1173
        DC16 1070, 267, 1173, 1071, 266, 1174, 1072, 266, 1174, 1073, 265, 1175
        DC16 1074, 265, 1175, 1075, 265, 1175, 1076, 264, 1176, 1077, 264, 1176
        DC16 1078, 263, 1177, 1079, 263, 1177, 1080, 263, 1177, 1081, 262, 1178
        DC16 1082, 262, 1178, 1083, 261, 1179, 1084, 261, 1179, 1085, 261, 1179
        DC16 1086, 260, 1180, 1087, 260, 1180, 1088, 259, 1181, 1089, 259, 1181
        DC16 1090, 259, 1181, 1091, 258, 1182, 1092, 258, 1182, 1093, 257, 1183
        DC16 1094, 257, 1183, 1095, 257, 1183, 1096, 256, 1184, 1097, 256, 1184
        DC16 1098, 255, 1185, 1099, 255, 1185, 1100, 254, 1186, 1101, 254, 1186
        DC16 1102, 254, 1186, 1103, 253, 1187, 1104, 253, 1187, 1105, 252, 1188
        DC16 1106, 252, 1188, 1107, 252, 1188, 1108, 251, 1189, 1109, 251, 1189
        DC16 1110, 250, 1190, 1111, 250, 1190, 1112, 250, 1190, 1113, 249, 1191
        DC16 1114, 249, 1191, 1115, 248, 1192, 1116, 248, 1192, 1117, 248, 1192
        DC16 1118, 247, 1193, 1119, 247, 1193, 1120, 247, 1193, 1121, 246, 1194
        DC16 1122, 246, 1194, 1123, 246, 1194, 1124, 245, 1195, 1125, 245, 1195
        DC16 1126, 245, 1195, 1127, 245, 1195, 1128, 244, 1196, 1129, 244, 1196
        DC16 1130, 244, 1196, 1131, 244, 1196, 1132, 243, 1197, 1133, 243, 1197
        DC16 1134, 243, 1197, 1135, 242, 1198, 1136, 242, 1198, 1137, 242, 1198
        DC16 1138, 242, 1198, 1139, 241, 1199, 1140, 241, 1199, 1141, 241, 1199
        DC16 1142, 241, 1199, 1143, 240, 1200, 1144, 240, 1200, 1145, 240, 1200
        DC16 1146, 239, 1201, 1147, 239, 1201, 1148, 239, 1201, 1149, 239, 1201
        DC16 1150, 238, 1202, 1151, 238, 1202, 1152, 238, 1202, 1153, 238, 1202
        DC16 1154, 237, 1203, 1155, 237, 1203, 1156, 237, 1203, 1157, 236, 1204
        DC16 1158, 236, 1204, 1159, 236, 1204, 1160, 236, 1204, 1161, 235, 1205
        DC16 1162, 235, 1205, 1163, 235, 1205, 1164, 234, 1205, 1165, 234, 1206
        DC16 1166, 234, 1206, 1167, 234, 1206, 1168, 233, 1207, 1169, 233, 1207
        DC16 1170, 233, 1207, 1171, 233, 1207, 1172, 232, 1208, 1173, 232, 1208
        DC16 1174, 232, 1208, 1175, 231, 1208, 1176, 231, 1209, 1177, 231, 1209
        DC16 1178, 231, 1209, 1179, 231, 1209, 1180, 231, 1209, 1181, 230, 1210
        DC16 1182, 230, 1210, 1183, 230, 1210, 1184, 230, 1210, 1185, 230, 1210
        DC16 1186, 230, 1210, 1187, 230, 1210, 1188, 229, 1211, 1189, 229, 1211
        DC16 1190, 229, 1211, 1191, 229, 1211, 1192, 229, 1211, 1193, 229, 1211
        DC16 1194, 229, 1211, 1195, 228, 1212, 1196, 228, 1212, 1197, 228, 1212
        DC16 1198, 228, 1212, 1199, 228, 1212, 1200, 228, 1212, 1201, 227, 1213
        DC16 1202, 227, 1213, 1203, 227, 1213, 1204, 227, 1213, 1205, 227, 1213
        DC16 1206, 227, 1213, 1207, 227, 1213, 1208, 226, 1214, 1209, 226, 1214
        DC16 1210, 226, 1214, 1211, 226, 1214, 1212, 226, 1214, 1213, 226, 1214
        DC16 1214, 226, 1214, 1215, 225, 1215, 1216, 225, 1215, 1217, 225, 1215
        DC16 1218, 225, 1215, 1219, 225, 1215, 1220, 225, 1215, 1221, 224, 1215
        DC16 1222, 224, 1216, 1223, 224, 1216, 1224, 224, 1216, 1225, 224, 1216
        DC16 1226, 224, 1216, 1227, 224, 1216, 1228, 223, 1217, 1229, 223, 1217
        DC16 1230, 223, 1217, 1231, 223, 1217, 1232, 223, 1217, 1233, 223, 1217
        DC16 1234, 223, 1217, 1235, 222, 1218, 1236, 222, 1218, 1237, 222, 1218
        DC16 1238, 222, 1218, 1239, 222, 1218, 1240, 222, 1218, 1241, 222, 1218
        DC16 1242, 222, 1218, 1243, 222, 1218, 1244, 222, 1218, 1245, 222, 1218
        DC16 1246, 222, 1218, 1247, 222, 1218, 1248, 222, 1218, 1249, 222, 1218
        DC16 1250, 222, 1218, 1251, 222, 1218, 1252, 222, 1218, 1253, 222, 1218
        DC16 1254, 222, 1218, 1255, 222, 1218, 1256, 222, 1218, 1257, 222, 1218
        DC16 1258, 222, 1218, 1259, 222, 1218, 1260, 222, 1218, 1261, 222, 1218
        DC16 1262, 222, 1218, 1263, 222, 1218, 1264, 222, 1218, 1265, 222, 1218
        DC16 1266, 222, 1218, 1267, 222, 1218, 1268, 221, 1219, 1269, 221, 1219
        DC16 1270, 221, 1219, 1271, 221, 1219, 1272, 221, 1219, 1273, 221, 1219
        DC16 1274, 221, 1219, 1275, 221, 1219, 1276, 221, 1219, 1277, 221, 1219
        DC16 1278, 221, 1219, 1279, 221, 1219, 1280, 221, 1219, 1281, 221, 1219
        DC16 1282, 221, 1219, 1283, 221, 1219, 1284, 221, 1219, 1285, 221, 1219
        DC16 1286, 221, 1219, 1287, 221, 1219, 1288, 221, 1219, 1289, 221, 1219
        DC16 1290, 221, 1219, 1291, 221, 1219, 1292, 221, 1219, 1293, 221, 1219
        DC16 1294, 221, 1219, 1295, 221, 1219, 1296, 221, 1219, 1297, 221, 1219
        DC16 1298, 221, 1219, 1299, 221, 1219, 1300, 221, 1219, 1301, 221, 1219
        DC16 1302, 221, 1219, 1303, 222, 1218, 1304, 222, 1218, 1305, 222, 1218
        DC16 1306, 222, 1218, 1307, 222, 1218, 1308, 222, 1218, 1309, 222, 1218
        DC16 1310, 222, 1218, 1311, 222, 1218, 1312, 222, 1218, 1313, 222, 1218
        DC16 1314, 223, 1217, 1315, 223, 1217, 1316, 223, 1217, 1317, 223, 1217
        DC16 1318, 223, 1217, 1319, 223, 1217, 1320, 223, 1217, 1321, 223, 1217
        DC16 1322, 223, 1217, 1323, 223, 1217, 1324, 223, 1217, 1325, 223, 1216
        DC16 1326, 224, 1216, 1327, 224, 1216, 1328, 224, 1216, 1329, 224, 1216
        DC16 1330, 224, 1216, 1331, 224, 1216, 1332, 224, 1216, 1333, 224, 1216
        DC16 1334, 224, 1216, 1335, 224, 1216, 1336, 224, 1216, 1337, 225, 1215
        DC16 1338, 225, 1215, 1339, 225, 1215, 1340, 225, 1215, 1341, 225, 1215
        DC16 1342, 225, 1215, 1343, 225, 1215, 1344, 225, 1215, 1345, 225, 1215
        DC16 1346, 225, 1215, 1347, 225, 1215, 1348, 226, 1214, 1349, 226, 1214
        DC16 1350, 226, 1214, 1351, 226, 1214, 1352, 226, 1214, 1353, 226, 1214
        DC16 1354, 226, 1214, 1355, 226, 1214, 1356, 227, 1213, 1357, 227, 1213
        DC16 1358, 227, 1213, 1359, 227, 1213, 1360, 227, 1213, 1361, 228, 1212
        DC16 1362, 228, 1212, 1363, 228, 1212, 1364, 228, 1212, 1365, 229, 1211
        DC16 1366, 229, 1211, 1367, 229, 1211, 1368, 229, 1211, 1369, 229, 1211
        DC16 1370, 230, 1210, 1371, 230, 1210, 1372, 230, 1210, 1373, 230, 1210
        DC16 1374, 230, 1210, 1375, 231, 1209, 1376, 231, 1209, 1377, 231, 1209
        DC16 1378, 231, 1209, 1379, 231, 1209, 1380, 232, 1208, 1381, 232, 1208
        DC16 1382, 232, 1208, 1383, 232, 1208, 1384, 233, 1207, 1385, 233, 1207
        DC16 1386, 233, 1207, 1387, 233, 1207, 1388, 233, 1207, 1389, 234, 1206
        DC16 1390, 234, 1206, 1391, 234, 1206, 1392, 234, 1206, 1393, 234, 1206
        DC16 1394, 235, 1205, 1395, 235, 1205, 1396, 235, 1205, 1397, 235, 1205
        DC16 1398, 235, 1205, 1399, 236, 1204, 1400, 236, 1204, 1401, 236, 1204
        DC16 1402, 236, 1204, 1403, 237, 1203, 1404, 237, 1203, 1405, 237, 1203
        DC16 1406, 237, 1203, 1407, 237, 1203, 1408, 238, 1202, 1409, 238, 1202
        DC16 1410, 238, 1202, 1411, 238, 1202, 1412, 239, 1201, 1413, 239, 1201
        DC16 1414, 239, 1201, 1415, 240, 1200, 1416, 240, 1200, 1417, 240, 1200
        DC16 1418, 241, 1199, 1419, 241, 1199, 1420, 241, 1199, 1421, 242, 1198
        DC16 1422, 242, 1198, 1423, 242, 1198, 1424, 243, 1197, 1425, 243, 1197
        DC16 1426, 243, 1197, 1427, 244, 1196, 1428, 244, 1196, 1429, 244, 1196
        DC16 1430, 245, 1195, 1431, 245, 1195, 1432, 245, 1195, 1433, 246, 1194
        DC16 1434, 246, 1194, 1435, 246, 1194, 1436, 247, 1193, 1437, 247, 1193
        DC16 1438, 247, 1193, 1439, 248, 1192, 1440, 248, 1192, 1441, 248, 1192
        DC16 1442, 249, 1191, 1443, 249, 1191, 1444, 249, 1191, 1445, 250, 1190
        DC16 1446, 250, 1190, 1447, 250, 1190, 1448, 251, 1189, 1449, 251, 1189
        DC16 1450, 251, 1189, 1451, 252, 1188, 1452, 252, 1188, 1453, 252, 1188
        DC16 1454, 253, 1187, 1455, 253, 1187, 1456, 253, 1187, 1457, 254, 1186
        DC16 1458, 254, 1186, 1459, 254, 1186, 1460, 255, 1185, 1461, 255, 1185
        DC16 1462, 255, 1185, 1463, 256, 1184, 1464, 256, 1184, 1465, 256, 1183
        DC16 1466, 257, 1183, 1467, 257, 1183, 1468, 258, 1182, 1469, 258, 1182
        DC16 1470, 259, 1181, 1471, 259, 1181, 1472, 260, 1180, 1473, 260, 1180
        DC16 1474, 261, 1179, 1475, 261, 1179, 1476, 261, 1179, 1477, 262, 1178
        DC16 1478, 262, 1178, 1479, 263, 1177, 1480, 263, 1177, 1481, 264, 1176
        DC16 1482, 264, 1176, 1483, 265, 1175, 1484, 265, 1175, 1485, 266, 1174
        DC16 1486, 266, 1174, 1487, 267, 1173, 1488, 267, 1173, 1489, 268, 1172
        DC16 1490, 268, 1172, 1491, 269, 1171, 1492, 269, 1171, 1493, 270, 1170
        DC16 1494, 270, 1170, 1495, 271, 1169, 1496, 271, 1169, 1497, 271, 1169
        DC16 1498, 272, 1168, 1499, 272, 1168, 1500, 273, 1167, 1501, 273, 1167
        DC16 1502, 274, 1166, 1503, 274, 1166, 1504, 275, 1165, 1505, 275, 1165
        DC16 1506, 276, 1164, 1507, 276, 1164, 1508, 277, 1163, 1509, 277, 1163
        DC16 1510, 278, 1162, 1511, 278, 1162, 1512, 279, 1161, 1513, 279, 1161
        DC16 1514, 280, 1160, 1515, 280, 1160, 1516, 281, 1159, 1517, 281, 1159
        DC16 1518, 281, 1158, 1519, 282, 1158, 1520, 282, 1158, 1521, 283, 1157
        DC16 1522, 284, 1156, 1523, 284, 1156, 1524, 285, 1155, 1525, 286, 1154
        DC16 1526, 286, 1154, 1527, 287, 1153, 1528, 287, 1153, 1529, 288, 1152
        DC16 1530, 289, 1151, 1531, 289, 1151, 1532, 290, 1150, 1533, 291, 1149
        DC16 1534, 291, 1149, 1535, 292, 1148, 1536, 292, 1148, 1537, 293, 1147
        DC16 1538, 294, 1146, 1539, 294, 1146, 1540, 295, 1145, 1541, 296, 1144
        DC16 1542, 296, 1144, 1543, 297, 1143, 1544, 298, 1142, 1545, 298, 1142
        DC16 1546, 299, 1141, 1547, 299, 1141, 1548, 300, 1140, 1549, 301, 1139
        DC16 1550, 301, 1139, 1551, 302, 1138, 1552, 303, 1137, 1553, 303, 1137
        DC16 1554, 304, 1136, 1555, 304, 1136, 1556, 305, 1135, 1557, 306, 1134
        DC16 1558, 306, 1134, 1559, 307, 1133, 1560, 308, 1132, 1561, 308, 1132
        DC16 1562, 309, 1131, 1563, 310, 1130, 1564, 310, 1130, 1565, 311, 1129
        DC16 1566, 311, 1129, 1567, 312, 1128, 1568, 313, 1127, 1569, 313, 1127
        DC16 1570, 314, 1126, 1571, 315, 1125, 1572, 315, 1125, 1573, 316, 1124
        DC16 1574, 317, 1123, 1575, 318, 1122, 1576, 319, 1121, 1577, 320, 1120
        DC16 1578, 320, 1120, 1579, 321, 1119, 1580, 322, 1118, 1581, 323, 1117
        DC16 1582, 324, 1116, 1583, 324, 1116, 1584, 325, 1115, 1585, 326, 1114
        DC16 1586, 327, 1113, 1587, 328, 1112, 1588, 328, 1112, 1589, 329, 1111
        DC16 1590, 330, 1110, 1591, 331, 1109, 1592, 332, 1108, 1593, 333, 1107
        DC16 1594, 333, 1107, 1595, 334, 1106, 1596, 335, 1105, 1597, 336, 1104
        DC16 1598, 337, 1103, 1599, 337, 1103, 1600, 338, 1102, 1601, 339, 1101
        DC16 1602, 340, 1100, 1603, 341, 1099, 1604, 341, 1099, 1605, 342, 1098
        DC16 1606, 343, 1097, 1607, 344, 1096, 1608, 345, 1095, 1609, 346, 1094
        DC16 1610, 346, 1094, 1611, 347, 1093, 1612, 348, 1092, 1613, 349, 1091
        DC16 1614, 350, 1090, 1615, 350, 1090, 1616, 351, 1089, 1617, 352, 1088
        DC16 1618, 353, 1087, 1619, 354, 1086, 1620, 355, 1085, 1621, 356, 1084
        DC16 1622, 357, 1083, 1623, 358, 1082, 1624, 359, 1081, 1625, 360, 1080
        DC16 1626, 361, 1079, 1627, 362, 1078, 1628, 363, 1077, 1629, 364, 1076
        DC16 1630, 365, 1074, 1631, 367, 1073, 1632, 368, 1072, 1633, 369, 1071
        DC16 1634, 370, 1070, 1635, 371, 1069, 1636, 372, 1068, 1637, 373, 1067
        DC16 1638, 374, 1066, 1639, 375, 1065, 1640, 376, 1064, 1641, 377, 1063
        DC16 1642, 378, 1062, 1643, 379, 1061, 1644, 380, 1060, 1645, 381, 1059
        DC16 1646, 382, 1058, 1647, 383, 1057, 1648, 384, 1056, 1649, 385, 1055
        DC16 1650, 386, 1054, 1651, 387, 1053, 1652, 388, 1052, 1653, 389, 1051
        DC16 1654, 390, 1050, 1655, 391, 1049, 1656, 392, 1048, 1657, 393, 1047
        DC16 1658, 394, 1046, 1659, 396, 1044, 1660, 397, 1043, 1661, 398, 1042
        DC16 1662, 400, 1040, 1663, 401, 1039, 1664, 402, 1038, 1665, 404, 1036
        DC16 1666, 405, 1035, 1667, 406, 1034, 1668, 408, 1032, 1669, 409, 1031
        DC16 1670, 410, 1030, 1671, 411, 1029, 1672, 413, 1027, 1673, 414, 1026
        DC16 1674, 415, 1025, 1675, 417, 1023, 1676, 418, 1022, 1677, 419, 1021
        DC16 1678, 421, 1019, 1679, 422, 1018, 1680, 423, 1017, 1681, 425, 1015
        DC16 1682, 426, 1014, 1683, 427, 1013, 1684, 428, 1012, 1685, 430, 1010
        DC16 1686, 431, 1009, 1687, 432, 1008, 1688, 434, 1006, 1689, 435, 1005
        DC16 1690, 436, 1004, 1691, 438, 1002, 1692, 439, 1001, 1693, 440, 1000
        DC16 1694, 442, 998, 1695, 443, 997, 1696, 445, 995, 1697, 447, 993
        DC16 1698, 448, 992, 1699, 450, 990, 1700, 452, 988, 1701, 454, 986
        DC16 1702, 455, 985, 1703, 457, 983, 1704, 459, 981, 1705, 460, 980
        DC16 1706, 462, 978, 1707, 464, 976, 1708, 465, 975, 1709, 467, 973
        DC16 1710, 469, 971, 1711, 470, 970, 1712, 472, 968, 1713, 474, 966
        DC16 1714, 476, 964, 1715, 477, 963, 1716, 479, 961, 1717, 481, 959
        DC16 1718, 482, 958, 1719, 484, 956, 1720, 486, 954, 1721, 487, 953
        DC16 1722, 489, 951, 1723, 491, 949, 1724, 493, 947, 1725, 495, 945
        DC16 1726, 497, 943, 1727, 499, 941, 1728, 502, 938, 1729, 504, 936
        DC16 1730, 506, 934, 1731, 508, 932, 1732, 511, 929, 1733, 513, 927
        DC16 1734, 515, 925, 1735, 518, 922, 1736, 520, 920, 1737, 522, 918
        DC16 1738, 524, 916, 1739, 527, 913, 1740, 529, 911, 1741, 531, 909
        DC16 1742, 533, 907, 1743, 536, 904, 1744, 538, 902, 1745, 540, 900
        DC16 1746, 543, 897, 1747, 545, 895, 1748, 547, 893, 1749, 551, 889
        DC16 1750, 554, 886, 1751, 557, 883, 1752, 560, 880, 1753, 564, 876
        DC16 1754, 567, 873, 1755, 570, 870, 1756, 574, 866, 1757, 577, 863
        DC16 1758, 580, 860, 1759, 583, 857, 1760, 587, 853, 1761, 590, 850
        DC16 1762, 593, 847, 1763, 596, 843, 1764, 600, 840, 1765, 603, 837
        DC16 1766, 609, 831, 1767, 614, 826, 1768, 620, 820, 1769, 625, 815
        DC16 1770, 631, 809, 1771, 636, 804, 1772, 642, 798, 1773, 648, 792
        DC16 1774, 653, 787, 1775, 659, 781, 1776, 670, 770, 1777, 687, 753
        DC16 1778, 704, 736, 1779

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock126 Using cfiCommon0
          CFI Function _ZN7MKS_DLP24ExposureDataTrans_squareEv
        THUMB
// __interwork __softfp void MKS_DLP::ExposureDataTrans_square()
_ZN7MKS_DLP24ExposureDataTrans_squareEv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R4,R0
        MOVS     R3,#+0
        MOV      R2,R3
        MOVS     R1,#+1
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
        MOVS     R3,#+1
        MOV      R2,#+880
        MOVS     R1,#+0
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP18line_fill_all_zeroEcth
        BL       _ZN7MKS_DLP18line_fill_all_zeroEcth
        MOV      R2,#+7360
        MOVS     R1,#+0
        LDR.N    R0,??DataTable153
          CFI FunCall memset
        BL       memset
        MOVS     R5,#+0
        B.N      ??ExposureDataTrans_square_0
??ExposureDataTrans_square_1:
        MOVS     R2,#+1
        ADD      R1,R5,#+880
        UXTH     R1,R1
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP13line_gen_dataEth
        BL       _ZN7MKS_DLP13line_gen_dataEth
        ADD      R1,R5,#+780
        UXTH     R1,R1
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP17line_gen_data_TFTEt
        BL       _ZN7MKS_DLP17line_gen_data_TFTEt
        ADDS     R5,R5,#+1
??ExposureDataTrans_square_0:
        CMP      R5,#+800
        BGE.N    ??ExposureDataTrans_square_2
        LDR.N    R6,??DataTable153_1
        MOV      R2,#+1536
        MOVS     R1,#+0
        ADDW     R0,R6,#+3480
          CFI FunCall memset
        BL       memset
        ADD      R0,R5,R5, LSL #+1
        LSLS     R0,R0,#+1
        ADR.W    R1,exposure_bmp_data_square
        LDRH     R2,[R0, R1]
        ADDS     R3,R2,R6
        ADDW     R3,R3,#+3480
        B.N      ??ExposureDataTrans_square_3
??ExposureDataTrans_square_4:
        MOVS     R6,#+1
        STRB     R6,[R3, #+48]
??ExposureDataTrans_square_5:
        ADDS     R3,R3,#+1
        ADDS     R2,R2,#+1
??ExposureDataTrans_square_3:
        ADDS     R6,R0,R1
        LDRH     R6,[R6, #+2]
        ADDS     R6,R6,#+1
        CMP      R2,R6
        BGE.N    ??ExposureDataTrans_square_1
        CMP      R2,#+720
        BGE.N    ??ExposureDataTrans_square_4
        MOVS     R6,#+1
        STRB     R6,[R3, #+0]
        B.N      ??ExposureDataTrans_square_5
??ExposureDataTrans_square_2:
        LDR.N    R0,??DataTable153_2
        LDRSB    R0,[R0, #+53]
        CMP      R0,#+2
        BEQ.N    ??ExposureDataTrans_square_2
        MOVS     R0,#+1
        LDR.N    R1,??DataTable153_3  ;; 0x424282b4
        STR      R0,[R1, #+0]
        MOV      R3,R0
        MOV      R2,#+1680
        MOV      R1,R0
        MOV      R0,R4
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7MKS_DLP18line_fill_all_zeroEcth
        B.W      _ZN7MKS_DLP18line_fill_all_zeroEcth
          CFI EndBlock cfiBlock126

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable153:
        DC32     bmp_layer_buf

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable153_1:
        DC32     card

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable153_2:
        DC32     hdma_spi1_tx

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable153_3:
        DC32     0x424282b4

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
// static __absolute unsigned short const exposure_bmp_data_square[800][3]
exposure_bmp_data_square:
        DC16 320, 1119, 880, 320, 1119, 881, 320, 1119, 882, 320, 1119, 883
        DC16 320, 1119, 884, 320, 1119, 885, 320, 1119, 886, 320, 1119, 887
        DC16 320, 1119, 888, 320, 1119, 889, 320, 1119, 890, 320, 1119, 891
        DC16 320, 1119, 892, 320, 1119, 893, 320, 1119, 894, 320, 1119, 895
        DC16 320, 1119, 896, 320, 1119, 897, 320, 1119, 898, 320, 1119, 899
        DC16 320, 1119, 900, 320, 1119, 901, 320, 1119, 902, 320, 1119, 903
        DC16 320, 1119, 904, 320, 1119, 905, 320, 1119, 906, 320, 1119, 907
        DC16 320, 1119, 908, 320, 1119, 909, 320, 1119, 910, 320, 1119, 911
        DC16 320, 1119, 912, 320, 1119, 913, 320, 1119, 914, 320, 1119, 915
        DC16 320, 1119, 916, 320, 1119, 917, 320, 1119, 918, 320, 1119, 919
        DC16 320, 1119, 920, 320, 1119, 921, 320, 1119, 922, 320, 1119, 923
        DC16 320, 1119, 924, 320, 1119, 925, 320, 1119, 926, 320, 1119, 927
        DC16 320, 1119, 928, 320, 1119, 929, 320, 1119, 930, 320, 1119, 931
        DC16 320, 1119, 932, 320, 1119, 933, 320, 1119, 934, 320, 1119, 935
        DC16 320, 1119, 936, 320, 1119, 937, 320, 1119, 938, 320, 1119, 939
        DC16 320, 1119, 940, 320, 1119, 941, 320, 1119, 942, 320, 1119, 943
        DC16 320, 1119, 944, 320, 1119, 945, 320, 1119, 946, 320, 1119, 947
        DC16 320, 1119, 948, 320, 1119, 949, 320, 1119, 950, 320, 1119, 951
        DC16 320, 1119, 952, 320, 1119, 953, 320, 1119, 954, 320, 1119, 955
        DC16 320, 1119, 956, 320, 1119, 957, 320, 1119, 958, 320, 1119, 959
        DC16 320, 1119, 960, 320, 1119, 961, 320, 1119, 962, 320, 1119, 963
        DC16 320, 1119, 964, 320, 1119, 965, 320, 1119, 966, 320, 1119, 967
        DC16 320, 1119, 968, 320, 1119, 969, 320, 1119, 970, 320, 1119, 971
        DC16 320, 1119, 972, 320, 1119, 973, 320, 1119, 974, 320, 1119, 975
        DC16 320, 1119, 976, 320, 1119, 977, 320, 1119, 978, 320, 1119, 979
        DC16 320, 1119, 980, 320, 1119, 981, 320, 1119, 982, 320, 1119, 983
        DC16 320, 1119, 984, 320, 1119, 985, 320, 1119, 986, 320, 1119, 987
        DC16 320, 1119, 988, 320, 1119, 989, 320, 1119, 990, 320, 1119, 991
        DC16 320, 1119, 992, 320, 1119, 993, 320, 1119, 994, 320, 1119, 995
        DC16 320, 1119, 996, 320, 1119, 997, 320, 1119, 998, 320, 1119, 999
        DC16 320, 1119, 1000, 320, 1119, 1001, 320, 1119, 1002, 320, 1119, 1003
        DC16 320, 1119, 1004, 320, 1119, 1005, 320, 1119, 1006, 320, 1119, 1007
        DC16 320, 1119, 1008, 320, 1119, 1009, 320, 1119, 1010, 320, 1119, 1011
        DC16 320, 1119, 1012, 320, 1119, 1013, 320, 1119, 1014, 320, 1119, 1015
        DC16 320, 1119, 1016, 320, 1119, 1017, 320, 1119, 1018, 320, 1119, 1019
        DC16 320, 1119, 1020, 320, 1119, 1021, 320, 1119, 1022, 320, 1119, 1023
        DC16 320, 1119, 1024, 320, 1119, 1025, 320, 1119, 1026, 320, 1119, 1027
        DC16 320, 1119, 1028, 320, 1119, 1029, 320, 1119, 1030, 320, 1119, 1031
        DC16 320, 1119, 1032, 320, 1119, 1033, 320, 1119, 1034, 320, 1119, 1035
        DC16 320, 1119, 1036, 320, 1119, 1037, 320, 1119, 1038, 320, 1119, 1039
        DC16 320, 1119, 1040, 320, 1119, 1041, 320, 1119, 1042, 320, 1119, 1043
        DC16 320, 1119, 1044, 320, 1119, 1045, 320, 1119, 1046, 320, 1119, 1047
        DC16 320, 1119, 1048, 320, 1119, 1049, 320, 1119, 1050, 320, 1119, 1051
        DC16 320, 1119, 1052, 320, 1119, 1053, 320, 1119, 1054, 320, 1119, 1055
        DC16 320, 1119, 1056, 320, 1119, 1057, 320, 1119, 1058, 320, 1119, 1059
        DC16 320, 1119, 1060, 320, 1119, 1061, 320, 1119, 1062, 320, 1119, 1063
        DC16 320, 1119, 1064, 320, 1119, 1065, 320, 1119, 1066, 320, 1119, 1067
        DC16 320, 1119, 1068, 320, 1119, 1069, 320, 1119, 1070, 320, 1119, 1071
        DC16 320, 1119, 1072, 320, 1119, 1073, 320, 1119, 1074, 320, 1119, 1075
        DC16 320, 1119, 1076, 320, 1119, 1077, 320, 1119, 1078, 320, 1119, 1079
        DC16 320, 1119, 1080, 320, 1119, 1081, 320, 1119, 1082, 320, 1119, 1083
        DC16 320, 1119, 1084, 320, 1119, 1085, 320, 1119, 1086, 320, 1119, 1087
        DC16 320, 1119, 1088, 320, 1119, 1089, 320, 1119, 1090, 320, 1119, 1091
        DC16 320, 1119, 1092, 320, 1119, 1093, 320, 1119, 1094, 320, 1119, 1095
        DC16 320, 1119, 1096, 320, 1119, 1097, 320, 1119, 1098, 320, 1119, 1099
        DC16 320, 1119, 1100, 320, 1119, 1101, 320, 1119, 1102, 320, 1119, 1103
        DC16 320, 1119, 1104, 320, 1119, 1105, 320, 1119, 1106, 320, 1119, 1107
        DC16 320, 1119, 1108, 320, 1119, 1109, 320, 1119, 1110, 320, 1119, 1111
        DC16 320, 1119, 1112, 320, 1119, 1113, 320, 1119, 1114, 320, 1119, 1115
        DC16 320, 1119, 1116, 320, 1119, 1117, 320, 1119, 1118, 320, 1119, 1119
        DC16 320, 1119, 1120, 320, 1119, 1121, 320, 1119, 1122, 320, 1119, 1123
        DC16 320, 1119, 1124, 320, 1119, 1125, 320, 1119, 1126, 320, 1119, 1127
        DC16 320, 1119, 1128, 320, 1119, 1129, 320, 1119, 1130, 320, 1119, 1131
        DC16 320, 1119, 1132, 320, 1119, 1133, 320, 1119, 1134, 320, 1119, 1135
        DC16 320, 1119, 1136, 320, 1119, 1137, 320, 1119, 1138, 320, 1119, 1139
        DC16 320, 1119, 1140, 320, 1119, 1141, 320, 1119, 1142, 320, 1119, 1143
        DC16 320, 1119, 1144, 320, 1119, 1145, 320, 1119, 1146, 320, 1120, 1147
        DC16 320, 1119, 1148, 320, 1119, 1149, 320, 1119, 1150, 320, 1119, 1151
        DC16 320, 1119, 1152, 320, 1119, 1153, 320, 1119, 1154, 320, 1119, 1155
        DC16 320, 1119, 1156, 320, 1119, 1157, 320, 1119, 1158, 320, 1119, 1159
        DC16 320, 1119, 1160, 320, 1119, 1161, 320, 1119, 1162, 320, 1119, 1163
        DC16 320, 1119, 1164, 320, 1119, 1165, 320, 1119, 1166, 320, 1119, 1167
        DC16 320, 1119, 1168, 320, 1119, 1169, 320, 1119, 1170, 320, 1119, 1171
        DC16 320, 1119, 1172, 320, 1119, 1173, 320, 1119, 1174, 320, 1119, 1175
        DC16 320, 1119, 1176, 320, 1119, 1177, 320, 1119, 1178, 320, 1119, 1179
        DC16 320, 1119, 1180, 320, 1119, 1181, 320, 1119, 1182, 320, 1119, 1183
        DC16 320, 1119, 1184, 320, 1119, 1185, 320, 1119, 1186, 320, 1119, 1187
        DC16 320, 1119, 1188, 320, 1119, 1189, 320, 1119, 1190, 320, 1119, 1191
        DC16 320, 1119, 1192, 320, 1119, 1193, 320, 1119, 1194, 320, 1119, 1195
        DC16 320, 1119, 1196, 320, 1119, 1197, 320, 1119, 1198, 320, 1119, 1199
        DC16 320, 1119, 1200, 320, 1119, 1201, 320, 1119, 1202, 320, 1119, 1203
        DC16 320, 1119, 1204, 320, 1119, 1205, 320, 1119, 1206, 320, 1119, 1207
        DC16 320, 1119, 1208, 320, 1119, 1209, 320, 1119, 1210, 320, 1119, 1211
        DC16 320, 1119, 1212, 320, 1119, 1213, 320, 1119, 1214, 320, 1119, 1215
        DC16 320, 1119, 1216, 320, 1119, 1217, 320, 1119, 1218, 320, 1119, 1219
        DC16 320, 1119, 1220, 320, 1119, 1221, 320, 1119, 1222, 320, 1119, 1223
        DC16 320, 1119, 1224, 320, 1119, 1225, 320, 1119, 1226, 320, 1119, 1227
        DC16 320, 1119, 1228, 320, 1119, 1229, 320, 1119, 1230, 320, 1119, 1231
        DC16 320, 1119, 1232, 320, 1119, 1233, 320, 1119, 1234, 320, 1119, 1235
        DC16 320, 1119, 1236, 320, 1119, 1237, 320, 1119, 1238, 320, 1119, 1239
        DC16 320, 1119, 1240, 320, 1119, 1241, 320, 1119, 1242, 320, 1119, 1243
        DC16 320, 1119, 1244, 320, 1119, 1245, 320, 1119, 1246, 320, 1119, 1247
        DC16 320, 1119, 1248, 320, 1119, 1249, 320, 1119, 1250, 320, 1119, 1251
        DC16 320, 1119, 1252, 320, 1119, 1253, 320, 1119, 1254, 320, 1119, 1255
        DC16 320, 1119, 1256, 320, 1119, 1257, 320, 1119, 1258, 320, 1119, 1259
        DC16 320, 1119, 1260, 320, 1119, 1261, 320, 1119, 1262, 320, 1119, 1263
        DC16 320, 1119, 1264, 320, 1119, 1265, 320, 1119, 1266, 320, 1119, 1267
        DC16 320, 1119, 1268, 320, 1119, 1269, 320, 1119, 1270, 320, 1119, 1271
        DC16 320, 1119, 1272, 320, 1119, 1273, 320, 1119, 1274, 320, 1119, 1275
        DC16 320, 1119, 1276, 320, 1119, 1277, 320, 1119, 1278, 320, 1119, 1279
        DC16 320, 1119, 1280, 320, 1119, 1281, 320, 1119, 1282, 320, 1119, 1283
        DC16 320, 1119, 1284, 320, 1119, 1285, 320, 1119, 1286, 320, 1119, 1287
        DC16 320, 1119, 1288, 320, 1119, 1289, 320, 1119, 1290, 320, 1119, 1291
        DC16 320, 1119, 1292, 320, 1119, 1293, 320, 1119, 1294, 320, 1119, 1295
        DC16 320, 1119, 1296, 320, 1119, 1297, 320, 1119, 1298, 320, 1119, 1299
        DC16 320, 1119, 1300, 320, 1119, 1301, 320, 1119, 1302, 320, 1119, 1303
        DC16 320, 1119, 1304, 320, 1119, 1305, 320, 1119, 1306, 320, 1119, 1307
        DC16 320, 1119, 1308, 320, 1119, 1309, 320, 1119, 1310, 320, 1119, 1311
        DC16 320, 1119, 1312, 320, 1119, 1313, 320, 1119, 1314, 320, 1119, 1315
        DC16 320, 1119, 1316, 320, 1119, 1317, 320, 1119, 1318, 320, 1119, 1319
        DC16 320, 1119, 1320, 320, 1119, 1321, 320, 1119, 1322, 320, 1119, 1323
        DC16 320, 1119, 1324, 320, 1119, 1325, 320, 1119, 1326, 320, 1119, 1327
        DC16 320, 1119, 1328, 320, 1119, 1329, 320, 1119, 1330, 320, 1119, 1331
        DC16 320, 1119, 1332, 320, 1119, 1333, 320, 1119, 1334, 320, 1119, 1335
        DC16 320, 1119, 1336, 320, 1119, 1337, 320, 1119, 1338, 320, 1119, 1339
        DC16 320, 1119, 1340, 320, 1119, 1341, 320, 1119, 1342, 320, 1119, 1343
        DC16 320, 1119, 1344, 320, 1119, 1345, 320, 1119, 1346, 320, 1119, 1347
        DC16 320, 1119, 1348, 320, 1119, 1349, 320, 1119, 1350, 320, 1119, 1351
        DC16 320, 1119, 1352, 320, 1119, 1353, 320, 1119, 1354, 320, 1119, 1355
        DC16 320, 1119, 1356, 320, 1119, 1357, 320, 1119, 1358, 320, 1119, 1359
        DC16 320, 1119, 1360, 320, 1119, 1361, 320, 1119, 1362, 320, 1119, 1363
        DC16 320, 1119, 1364, 320, 1119, 1365, 320, 1119, 1366, 320, 1119, 1367
        DC16 320, 1119, 1368, 320, 1119, 1369, 320, 1119, 1370, 320, 1119, 1371
        DC16 320, 1119, 1372, 320, 1119, 1373, 320, 1119, 1374, 320, 1119, 1375
        DC16 320, 1119, 1376, 320, 1119, 1377, 320, 1119, 1378, 320, 1119, 1379
        DC16 320, 1119, 1380, 320, 1119, 1381, 320, 1119, 1382, 320, 1119, 1383
        DC16 320, 1119, 1384, 320, 1119, 1385, 320, 1119, 1386, 320, 1119, 1387
        DC16 320, 1119, 1388, 320, 1119, 1389, 320, 1119, 1390, 320, 1119, 1391
        DC16 320, 1119, 1392, 320, 1119, 1393, 320, 1119, 1394, 320, 1119, 1395
        DC16 320, 1119, 1396, 320, 1119, 1397, 320, 1119, 1398, 320, 1119, 1399
        DC16 320, 1119, 1400, 320, 1119, 1401, 320, 1119, 1402, 320, 1119, 1403
        DC16 320, 1119, 1404, 320, 1119, 1405, 320, 1119, 1406, 320, 1119, 1407
        DC16 320, 1119, 1408, 320, 1119, 1409, 320, 1119, 1410, 320, 1119, 1411
        DC16 320, 1119, 1412, 320, 1120, 1413, 320, 1119, 1414, 320, 1119, 1415
        DC16 320, 1119, 1416, 320, 1119, 1417, 320, 1119, 1418, 320, 1119, 1419
        DC16 320, 1119, 1420, 320, 1119, 1421, 320, 1119, 1422, 320, 1119, 1423
        DC16 320, 1119, 1424, 320, 1119, 1425, 320, 1119, 1426, 320, 1119, 1427
        DC16 320, 1119, 1428, 320, 1119, 1429, 320, 1119, 1430, 320, 1119, 1431
        DC16 320, 1119, 1432, 320, 1119, 1433, 320, 1119, 1434, 320, 1119, 1435
        DC16 320, 1119, 1436, 320, 1119, 1437, 320, 1119, 1438, 320, 1119, 1439
        DC16 320, 1119, 1440, 320, 1119, 1441, 320, 1119, 1442, 320, 1119, 1443
        DC16 320, 1119, 1444, 320, 1119, 1445, 320, 1119, 1446, 320, 1119, 1447
        DC16 320, 1119, 1448, 320, 1119, 1449, 320, 1119, 1450, 320, 1119, 1451
        DC16 320, 1119, 1452, 320, 1119, 1453, 320, 1119, 1454, 320, 1119, 1455
        DC16 320, 1119, 1456, 320, 1119, 1457, 320, 1119, 1458, 320, 1119, 1459
        DC16 320, 1119, 1460, 320, 1119, 1461, 320, 1119, 1462, 320, 1119, 1463
        DC16 320, 1119, 1464, 320, 1119, 1465, 320, 1119, 1466, 320, 1119, 1467
        DC16 320, 1119, 1468, 320, 1119, 1469, 320, 1119, 1470, 320, 1119, 1471
        DC16 320, 1119, 1472, 320, 1119, 1473, 320, 1119, 1474, 320, 1119, 1475
        DC16 320, 1119, 1476, 320, 1119, 1477, 320, 1119, 1478, 320, 1119, 1479
        DC16 320, 1119, 1480, 320, 1119, 1481, 320, 1119, 1482, 320, 1119, 1483
        DC16 320, 1119, 1484, 320, 1119, 1485, 320, 1119, 1486, 320, 1119, 1487
        DC16 320, 1119, 1488, 320, 1119, 1489, 320, 1119, 1490, 320, 1119, 1491
        DC16 320, 1119, 1492, 320, 1119, 1493, 320, 1119, 1494, 320, 1119, 1495
        DC16 320, 1119, 1496, 320, 1119, 1497, 320, 1119, 1498, 320, 1119, 1499
        DC16 320, 1119, 1500, 320, 1119, 1501, 320, 1119, 1502, 320, 1119, 1503
        DC16 320, 1119, 1504, 320, 1119, 1505, 320, 1119, 1506, 320, 1119, 1507
        DC16 320, 1119, 1508, 320, 1119, 1509, 320, 1119, 1510, 320, 1119, 1511
        DC16 320, 1119, 1512, 320, 1119, 1513, 320, 1119, 1514, 320, 1119, 1515
        DC16 320, 1119, 1516, 320, 1119, 1517, 320, 1119, 1518, 320, 1119, 1519
        DC16 320, 1119, 1520, 320, 1119, 1521, 320, 1119, 1522, 320, 1119, 1523
        DC16 320, 1119, 1524, 320, 1119, 1525, 320, 1119, 1526, 320, 1119, 1527
        DC16 320, 1119, 1528, 320, 1119, 1529, 320, 1119, 1530, 320, 1119, 1531
        DC16 320, 1119, 1532, 320, 1119, 1533, 320, 1119, 1534, 320, 1119, 1535
        DC16 320, 1119, 1536, 320, 1119, 1537, 320, 1119, 1538, 320, 1119, 1539
        DC16 320, 1119, 1540, 320, 1119, 1541, 320, 1119, 1542, 320, 1119, 1543
        DC16 320, 1119, 1544, 320, 1119, 1545, 320, 1119, 1546, 320, 1119, 1547
        DC16 320, 1119, 1548, 320, 1119, 1549, 320, 1119, 1550, 320, 1119, 1551
        DC16 320, 1119, 1552, 320, 1119, 1553, 320, 1119, 1554, 320, 1119, 1555
        DC16 320, 1119, 1556, 320, 1119, 1557, 320, 1119, 1558, 320, 1119, 1559
        DC16 320, 1119, 1560, 320, 1119, 1561, 320, 1119, 1562, 320, 1119, 1563
        DC16 320, 1119, 1564, 320, 1119, 1565, 320, 1119, 1566, 320, 1119, 1567
        DC16 320, 1119, 1568, 320, 1119, 1569, 320, 1119, 1570, 320, 1119, 1571
        DC16 320, 1119, 1572, 320, 1119, 1573, 320, 1119, 1574, 320, 1119, 1575
        DC16 320, 1119, 1576, 320, 1119, 1577, 320, 1119, 1578, 320, 1119, 1579
        DC16 320, 1119, 1580, 320, 1119, 1581, 320, 1119, 1582, 320, 1119, 1583
        DC16 320, 1119, 1584, 320, 1119, 1585, 320, 1119, 1586, 320, 1119, 1587
        DC16 320, 1119, 1588, 320, 1119, 1589, 320, 1119, 1590, 320, 1119, 1591
        DC16 320, 1119, 1592, 320, 1119, 1593, 320, 1119, 1594, 320, 1119, 1595
        DC16 320, 1119, 1596, 320, 1119, 1597, 320, 1119, 1598, 320, 1119, 1599
        DC16 320, 1119, 1600, 320, 1119, 1601, 320, 1119, 1602, 320, 1119, 1603
        DC16 320, 1119, 1604, 320, 1119, 1605, 320, 1119, 1606, 320, 1119, 1607
        DC16 320, 1119, 1608, 320, 1119, 1609, 320, 1119, 1610, 320, 1119, 1611
        DC16 320, 1119, 1612, 320, 1119, 1613, 320, 1119, 1614, 320, 1119, 1615
        DC16 320, 1119, 1616, 320, 1119, 1617, 320, 1119, 1618, 320, 1119, 1619
        DC16 320, 1119, 1620, 320, 1119, 1621, 320, 1119, 1622, 320, 1119, 1623
        DC16 320, 1119, 1624, 320, 1119, 1625, 320, 1119, 1626, 320, 1119, 1627
        DC16 320, 1119, 1628, 320, 1119, 1629, 320, 1119, 1630, 320, 1119, 1631
        DC16 320, 1119, 1632, 320, 1119, 1633, 320, 1119, 1634, 320, 1119, 1635
        DC16 320, 1119, 1636, 320, 1119, 1637, 320, 1119, 1638, 320, 1119, 1639
        DC16 320, 1119, 1640, 320, 1119, 1641, 320, 1119, 1642, 320, 1119, 1643
        DC16 320, 1119, 1644, 320, 1119, 1645, 320, 1119, 1646, 320, 1119, 1647
        DC16 320, 1119, 1648, 320, 1119, 1649, 320, 1119, 1650, 320, 1119, 1651
        DC16 320, 1119, 1652, 320, 1119, 1653, 320, 1119, 1654, 320, 1119, 1655
        DC16 320, 1119, 1656, 320, 1119, 1657, 320, 1119, 1658, 320, 1119, 1659
        DC16 320, 1119, 1660, 320, 1119, 1661, 320, 1119, 1662, 320, 1119, 1663
        DC16 320, 1119, 1664, 320, 1119, 1665, 320, 1119, 1666, 320, 1119, 1667
        DC16 320, 1119, 1668, 320, 1119, 1669, 320, 1119, 1670, 320, 1119, 1671
        DC16 320, 1119, 1672, 320, 1119, 1673, 320, 1119, 1674, 320, 1119, 1675
        DC16 320, 1119, 1676, 320, 1119, 1677, 320, 1119, 1678, 320, 1119, 1679

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock127 Using cfiCommon0
          CFI Function _ZN7MKS_DLP12ExposureTestEv
        THUMB
// __interwork __softfp void MKS_DLP::ExposureTest()
_ZN7MKS_DLP12ExposureTestEv:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        MOV      R4,R0
        MOVS     R0,#+2
          CFI FunCall exposure_msg_display
        BL       exposure_msg_display
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP23ExposureData2TFT_circleEv
        BL       _ZN7MKS_DLP23ExposureData2TFT_circleEv
        MOVS     R0,#+180
        STR      R0,[SP, #+0]
        MOV      R3,#+320
        MOVS     R2,#+20
        MOVS     R1,#+80
        LDR.W    R0,??DataTable172
          CFI FunCall layer_pic_display
        BL       layer_pic_display
        MOVS     R3,#+1
        MOV      R2,R3
        MOV      R1,R2
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
        ADDW     R5,R4,#+746
        MOV      R0,R5
          CFI FunCall _ZN7SSD28289sleep_outEv
        BL       _ZN7SSD28289sleep_outEv
        LDR.W    R6,??DataTable173  ;; 0x42428288
        MOVS     R0,#+1
        STR      R0,[R6, #+0]
        ADD      R7,R4,#+476
        STRB     R0,[R7, #+4]
        MOVS     R0,#+0
        LDR.W    R1,??DataTable173_1
        STR      R0,[R1, #+0]
          CFI FunCall _Z10clr_ticketv
        BL       _Z10clr_ticketv
        B.N      ??ExposureTest_0
??ExposureTest_1:
          CFI FunCall _Z4idlev
        BL       _Z4idlev
??ExposureTest_0:
        LDR      R0,[R4, #+720]
        LDR      R1,[R4, #+476]
        CMP      R0,R1
        BCC.N    ??ExposureTest_1
        MOVS     R0,#+0
        STR      R0,[R6, #+0]
        STRB     R0,[R7, #+4]
        MOVS     R3,#+1
        MOV      R2,R3
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
        MOV      R0,R5
          CFI FunCall _ZN7SSD28288sleep_inEv
        BL       _ZN7SSD28288sleep_inEv
        MOVS     R0,#+20
          CFI FunCall HAL_Delay
        BL       HAL_Delay
        MOVS     R3,#+0
        MOV      R2,R3
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
        LDR.W    R0,??DataTable174
        LDRSB    R0,[R0, #+0]
        CMP      R0,#+35
        BNE.N    ??ExposureTest_2
        MOVS     R0,#+0
        STR      R0,[SP, #+0]
        MOVS     R3,#+180
        MOV      R2,#+320
        MOVS     R1,#+20
        MOVS     R0,#+80
          CFI FunCall layer_pic_clean
        BL       layer_pic_clean
        MOVS     R0,#+3
        POP      {R1,R4-R7,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall exposure_msg_display
        B.W      exposure_msg_display
          CFI R4 Frame(CFA, -20)
          CFI R5 Frame(CFA, -16)
          CFI R6 Frame(CFA, -12)
          CFI R7 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+24
??ExposureTest_2:
        POP      {R0,R4-R7,PC}    ;; return
          CFI EndBlock cfiBlock127

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock128 Using cfiCommon0
          CFI Function _ZN7MKS_DLP6led_onEv
        THUMB
// __interwork __softfp void MKS_DLP::led_on()
_ZN7MKS_DLP6led_onEv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        SUB      SP,SP,#+8
          CFI CFA R13+16
        MOV      R4,R0
        ADDW     R0,R4,#+746
          CFI FunCall _ZN7SSD28289sleep_outEv
        BL       _ZN7SSD28289sleep_outEv
        MOVS     R0,#+1
        LDR.W    R1,??DataTable173  ;; 0x42428288
        STR      R0,[R1, #+0]
        STRB     R0,[R4, #+480]
        ADR.W    R0,`?<Constant "led on:">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.W    R0,??DataTable174_1
          CFI FunCall _ZN7MKS_DLP16get_currentLayerEv
        BL       _ZN7MKS_DLP16get_currentLayerEv
        MOVS     R2,#+10
        MOV      R1,R0
        LDR.W    R0,??DataTable174_2
          CFI FunCall _ZN5Print5printEii
        BL       _ZN5Print5printEii
        LDR.W    R0,??DataTable174
        LDRSB    R0,[R0, #+0]
        CMP      R0,#+3
        BNE.N    ??led_on_0
        MOVS     R0,#+180
        STR      R0,[SP, #+0]
        MOV      R3,#+320
        MOVS     R2,#+15
        MOVS     R1,#+30
        LDR.W    R0,??DataTable172
          CFI FunCall layer_pic_display
        BL       layer_pic_display
          CFI FunCall draw_status_clear
        BL       draw_status_clear
          CFI FunCall display_print_statue
        BL       display_print_statue
          CFI FunCall setProBarRate
        BL       setProBarRate
        POP      {R0,R1,R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall GUI_Exec
        B.W      GUI_Exec
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??led_on_0:
        POP      {R0,R1,R4,PC}    ;; return
          CFI EndBlock cfiBlock128

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "led on:">`:
        DC8 "led on:"

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock129 Using cfiCommon0
          CFI Function _ZN7MKS_DLP7led_offEv
        THUMB
// __interwork __softfp void MKS_DLP::led_off()
_ZN7MKS_DLP7led_offEv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        SUB      SP,SP,#+8
          CFI CFA R13+16
        MOV      R4,R0
        MOVS     R0,#+0
        LDR.W    R1,??DataTable173  ;; 0x42428288
        STR      R0,[R1, #+0]
        STRB     R0,[R4, #+480]
        MOVS     R3,#+1
        MOV      R2,R3
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
        ADDW     R0,R4,#+746
          CFI FunCall _ZN7SSD28288sleep_inEv
        BL       _ZN7SSD28288sleep_inEv
        MOVS     R0,#+10
          CFI FunCall HAL_Delay
        BL       HAL_Delay
        MOVS     R3,#+0
        MOV      R2,R3
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
        LDR.W    R0,??DataTable174
        LDRSB    R0,[R0, #+0]
        CMP      R0,#+3
        BNE.N    ??led_off_0
        MOVS     R0,#+0
        STR      R0,[SP, #+0]
        MOVS     R3,#+180
        MOV      R2,#+320
        MOVS     R1,#+15
        MOVS     R0,#+30
          CFI FunCall layer_pic_clean
        BL       layer_pic_clean
??led_off_0:
        POP      {R0,R1,R4,PC}    ;; return
          CFI EndBlock cfiBlock129

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock130 Using cfiCommon0
          CFI Function _ZN7MKS_DLP8power_onEv
        THUMB
// __interwork __softfp void MKS_DLP::power_on()
_ZN7MKS_DLP8power_onEv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.W    R4,??DataTable175  ;; 0x42430284
        MOVS     R0,#+0
        STR      R0,[R4, #+0]
        MOVS     R0,#+200
          CFI FunCall HAL_Delay
        BL       HAL_Delay
        MOVS     R0,#+1
        LDR.W    R1,??DataTable175_1  ;; 0x42408288
        STR      R0,[R1, #+0]
        MOVS     R0,#+200
          CFI FunCall HAL_Delay
        BL       HAL_Delay
        MOVS     R0,#+1
        LDR.W    R1,??DataTable176  ;; 0x424282ac
        STR      R0,[R1, #+0]
        MOVS     R0,#+50
          CFI FunCall HAL_Delay
        BL       HAL_Delay
        MOVS     R0,#+1
        STR      R0,[R4, #+0]
        MOVS     R0,#+100
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall HAL_Delay
        B.W      HAL_Delay
          CFI EndBlock cfiBlock130

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock131 Using cfiCommon0
          CFI Function _ZN7MKS_DLP9power_offEv
        THUMB
// __interwork __softfp void MKS_DLP::power_off()
_ZN7MKS_DLP9power_offEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+0
        LDR.W    R1,??DataTable175  ;; 0x42430284
        STR      R0,[R1, #+0]
        MOVS     R0,#+5
          CFI FunCall HAL_Delay
        BL       HAL_Delay
        MOVS     R0,#+0
        LDR.W    R1,??DataTable176  ;; 0x424282ac
        STR      R0,[R1, #+0]
        MOVS     R0,#+200
          CFI FunCall HAL_Delay
        BL       HAL_Delay
        MOVS     R0,#+0
        LDR.W    R1,??DataTable175_1  ;; 0x42408288
        STR      R0,[R1, #+0]
        MOVS     R0,#+100
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall HAL_Delay
        B.W      HAL_Delay
          CFI EndBlock cfiBlock131

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock132 Using cfiCommon0
          CFI Function _ZN7MKS_DLP21bank2disp_enable_grayEhhhh
        THUMB
// __interwork __softfp uint8_t MKS_DLP::bank2disp_enable_gray(uint8_t, uint8_t, uint8_t, uint8_t)
_ZN7MKS_DLP21bank2disp_enable_grayEhhhh:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        MOV      R4,R0
        MOVS     R0,#+0
        STRB     R0,[R4, #+488]
        ADD      R5,R4,#+488
        LDR      R0,[SP, #+24]
        STRB     R0,[R5, #+1]
        LSLS     R0,R3,#+6
        ORR      R0,R0,R2, LSL #+7
        ORR      R0,R0,R1, LSL #+4
        STRB     R0,[R5, #+2]
        MOVS     R6,#+0
        B.N      ??bank2disp_enable_gray_0
??bank2disp_enable_gray_1:
        ADDS     R6,R6,#+1
??bank2disp_enable_gray_0:
        UXTB     R6,R6
        CMP      R6,#+5
        BGE.N    ??bank2disp_enable_gray_2
        LDR.W    R7,??DataTable178  ;; 0x424282b4
        MOVS     R0,#+0
        STR      R0,[R7, #+0]
        LDRB     R0,[R4, #+488]
          CFI FunCall SPI1_ReadWriteByte
        BL       SPI1_ReadWriteByte
        LDRB     R0,[R5, #+1]
          CFI FunCall SPI1_ReadWriteByte
        BL       SPI1_ReadWriteByte
        LDRB     R0,[R5, #+2]
          CFI FunCall SPI1_ReadWriteByte
        BL       SPI1_ReadWriteByte
        MOVS     R0,#+1
        STR      R0,[R7, #+0]
        LDRB     R7,[R5, #+2]
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP14bank2disp_readEv
        BL       _ZN7MKS_DLP14bank2disp_readEv
        AND      R0,R0,#0xF0
        CMP      R7,R0
        BNE.N    ??bank2disp_enable_gray_1
        MOVS     R0,#+1
        POP      {R1,R4-R7,PC}
??bank2disp_enable_gray_2:
        MOVS     R0,#+0
        POP      {R1,R4-R7,PC}    ;; return
          CFI EndBlock cfiBlock132

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock133 Using cfiCommon0
          CFI Function _ZN7MKS_DLP9grag_testEv
        THUMB
// __interwork __softfp void MKS_DLP::grag_test()
_ZN7MKS_DLP9grag_testEv:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        SUB      SP,SP,#+8
          CFI CFA R13+32
        MOV      R4,R0
        MOVS     R5,#+0
        ADD      R6,R4,#+476
        ADDW     R7,R4,#+746
        LDR.W    R8,??DataTable173  ;; 0x42428288
        B.N      ??grag_test_0
??grag_test_1:
          CFI FunCall _Z4idlev
        BL       _Z4idlev
??grag_test_2:
        LDR      R0,[R4, #+720]
        LDR      R1,[R4, #+476]
        CMP      R0,R1
        BCC.N    ??grag_test_1
        MOV      R0,#+2000
          CFI FunCall HAL_Delay
        BL       HAL_Delay
        MOVS     R0,#+0
        STR      R0,[R8, #+0]
        STRB     R0,[R6, #+4]
        MOVS     R3,#+1
        MOV      R2,R3
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
        MOV      R0,R7
          CFI FunCall _ZN7SSD28288sleep_inEv
        BL       _ZN7SSD28288sleep_inEv
        MOVS     R0,#+20
          CFI FunCall HAL_Delay
        BL       HAL_Delay
        MOVS     R3,#+0
        MOV      R2,R3
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
        LDR.W    R0,??DataTable174
        LDRSB    R0,[R0, #+0]
        CMP      R0,#+35
        BNE.N    ??grag_test_3
        MOVS     R0,#+0
        STR      R0,[SP, #+0]
        MOVS     R3,#+180
        MOV      R2,#+320
        MOVS     R1,#+20
        MOVS     R0,#+80
          CFI FunCall layer_pic_clean
        BL       layer_pic_clean
        MOVS     R0,#+3
          CFI FunCall exposure_msg_display
        BL       exposure_msg_display
??grag_test_3:
        MOV      R0,#+2000
          CFI FunCall HAL_Delay
        BL       HAL_Delay
        ADDS     R0,R5,#+1
        ASRS     R1,R0,#+2
        ADD      R1,R0,R1, LSR #+29
        ASRS     R1,R1,#+3
        SUB      R5,R0,R1, LSL #+3
??grag_test_0:
        MOVS     R0,#+2
          CFI FunCall exposure_msg_display
        BL       exposure_msg_display
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP23ExposureData2TFT_circleEv
        BL       _ZN7MKS_DLP23ExposureData2TFT_circleEv
        MOVS     R0,#+180
        STR      R0,[SP, #+0]
        MOV      R3,#+320
        MOVS     R2,#+20
        MOVS     R1,#+80
        LDR.W    R0,??DataTable172
          CFI FunCall layer_pic_display
        BL       layer_pic_display
        UXTB     R5,R5
        STR      R5,[SP, #+0]
        MOVS     R3,#+1
        MOV      R2,R3
        MOV      R1,R2
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP21bank2disp_enable_grayEhhhh
        BL       _ZN7MKS_DLP21bank2disp_enable_grayEhhhh
        MOV      R0,R7
          CFI FunCall _ZN7SSD28289sleep_outEv
        BL       _ZN7SSD28289sleep_outEv
        MOVS     R0,#+1
        STR      R0,[R8, #+0]
        STRB     R0,[R6, #+4]
        MOVS     R0,#+0
        LDR.W    R1,??DataTable173_1
        STR      R0,[R1, #+0]
          CFI FunCall _Z10clr_ticketv
        BL       _Z10clr_ticketv
        B.N      ??grag_test_2
          CFI EndBlock cfiBlock133

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock134 Using cfiCommon0
          CFI Function _ZN7MKS_DLP9dlp_startEv
        THUMB
// __interwork __softfp void MKS_DLP::dlp_start()
_ZN7MKS_DLP9dlp_startEv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
        ADDW     R0,R4,#+746
          CFI FunCall _ZN7SSD28284initEv
        BL       _ZN7SSD28284initEv
        CMP      R0,#+0
        BNE.N    ??dlp_start_0
        ADR.W    R0,`?<Constant "ssd dev is error!\\r\\n\\n">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??dlp_start_0:
        ADR.W    R0,`?<Constant "CPLD VER:">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP12get_cpld_verEv
        BL       _ZN7MKS_DLP12get_cpld_verEv
        MOVS     R2,#+10
        MOV      R1,R0
        LDR.W    R0,??DataTable174_2
          CFI FunCall _ZN5Print5printEhi
        BL       _ZN5Print5printEhi
        MOVS     R2,#+1
        ADD      R1,R4,#+744
        MOVW     R0,#+1594
          CFI FunCall AT24CXX_Read
        BL       AT24CXX_Read
        LDRB     R0,[R4, #+744]
        LDR.W    R1,??DataTable178_2
        STRB     R0,[R1, #+432]
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP24ExposureDataTrans_circleEv
        BL       _ZN7MKS_DLP24ExposureDataTrans_circleEv
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP14CleanDataTransEv
        BL       _ZN7MKS_DLP14CleanDataTransEv
        LDR.W    R0,??DataTable178_3  ;; 0x4242828c
        MOVS     R1,#+1
        STR      R1,[R0, #+4]
        STR      R1,[R0, #+0]
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock134

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "ssd dev is error!\\r\\n\\n">`:
        DC8 "ssd dev is error!\015\012\012"
        DC8 0, 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "CPLD VER:">`:
        DC8 "CPLD VER:"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock135 Using cfiCommon0
          CFI Function _ZN7MKS_DLP13set_LedOnTimeEt
        THUMB
// __interwork __softfp void MKS_DLP::set_LedOnTime(uint16_t)
_ZN7MKS_DLP13set_LedOnTimeEt:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        MOV      R0,#+1000
        MULS     R0,R0,R1
        STR      R0,[R4, #+40]
        MOVW     R5,#+1031
        MOVS     R2,#+4
        ADD      R1,R4,#+40
        MOV      R0,R5
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R0,#+0
        STR      R0,[R4, #+40]
        MOVS     R2,#+4
        ADD      R1,R4,#+40
        MOV      R0,R5
        POP      {R3-R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall epr_read_data
        B.W      epr_read_data
          CFI EndBlock cfiBlock135

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock136 Using cfiCommon0
          CFI Function _ZN7MKS_DLP14set_LedOffTimeEt
        THUMB
// __interwork __softfp void MKS_DLP::set_LedOffTime(uint16_t)
_ZN7MKS_DLP14set_LedOffTimeEt:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        MOV      R0,#+1000
        MULS     R0,R0,R1
        STR      R0,[R4, #+44]
        MOVW     R5,#+1035
        MOVS     R2,#+4
        ADD      R1,R4,#+44
        MOV      R0,R5
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R0,#+0
        STR      R0,[R4, #+44]
        MOVS     R2,#+4
        ADD      R1,R4,#+44
        MOV      R0,R5
        POP      {R3-R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall epr_read_data
        B.W      epr_read_data
          CFI EndBlock cfiBlock136

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock137 Using cfiCommon0
          CFI Function _ZN7MKS_DLP16set_BottomlayersEt
        THUMB
// __interwork __softfp void MKS_DLP::set_Bottomlayers(uint16_t)
_ZN7MKS_DLP16set_BottomlayersEt:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        LDRH     R0,[R4, #+468]
        CMP      R0,#+0
        BNE.N    ??set_Bottomlayers_0
        STRH     R1,[R4, #+52]
        MOVW     R5,#+1043
        MOVS     R2,#+2
        ADD      R1,R4,#+52
        MOV      R0,R5
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R0,#+0
        STRH     R0,[R4, #+52]
        MOVS     R2,#+2
        ADD      R1,R4,#+52
        MOV      R0,R5
        POP      {R3-R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall epr_read_data
        B.W      epr_read_data
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??set_Bottomlayers_0:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock137

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock138 Using cfiCommon0
          CFI Function _ZN7MKS_DLP19set_BottomLedOnTimeEt
        THUMB
// __interwork __softfp void MKS_DLP::set_BottomLedOnTime(uint16_t)
_ZN7MKS_DLP19set_BottomLedOnTimeEt:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        MOV      R0,#+1000
        MULS     R0,R0,R1
        STR      R0,[R4, #+48]
        MOVW     R5,#+1039
        MOVS     R2,#+4
        ADD      R1,R4,#+48
        MOV      R0,R5
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R0,#+0
        STR      R0,[R4, #+48]
        MOVS     R2,#+4
        ADD      R1,R4,#+48
        MOV      R0,R5
        POP      {R3-R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall epr_read_data
        B.W      epr_read_data
          CFI EndBlock cfiBlock138

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock139 Using cfiCommon0
          CFI Function _ZN7MKS_DLP13get_LedOnTimeEv
          CFI NoCalls
        THUMB
// __interwork __softfp uint16_t MKS_DLP::get_LedOnTime()
_ZN7MKS_DLP13get_LedOnTimeEv:
        LDR      R0,[R0, #+40]
        MOV      R1,#+1000
        UDIV     R0,R0,R1
        UXTH     R0,R0
        BX       LR               ;; return
          CFI EndBlock cfiBlock139

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock140 Using cfiCommon0
          CFI Function _ZN7MKS_DLP14get_LedOffTimeEv
          CFI NoCalls
        THUMB
// __interwork __softfp uint16_t MKS_DLP::get_LedOffTime()
_ZN7MKS_DLP14get_LedOffTimeEv:
        LDR      R0,[R0, #+44]
        MOV      R1,#+1000
        UDIV     R0,R0,R1
        UXTH     R0,R0
        BX       LR               ;; return
          CFI EndBlock cfiBlock140

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock141 Using cfiCommon0
          CFI Function _ZN7MKS_DLP16get_BottomlayersEv
          CFI NoCalls
        THUMB
// __interwork __softfp uint16_t MKS_DLP::get_Bottomlayers()
_ZN7MKS_DLP16get_BottomlayersEv:
        LDRH     R0,[R0, #+52]
        BX       LR               ;; return
          CFI EndBlock cfiBlock141

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock142 Using cfiCommon0
          CFI Function _ZN7MKS_DLP19get_BottomLedOnTimeEv
          CFI NoCalls
        THUMB
// __interwork __softfp uint32_t MKS_DLP::get_BottomLedOnTime()
_ZN7MKS_DLP19get_BottomLedOnTimeEv:
        LDR      R0,[R0, #+48]
        MOV      R1,#+1000
        UDIV     R0,R0,R1
        BX       LR               ;; return
          CFI EndBlock cfiBlock142

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock143 Using cfiCommon0
          CFI Function _ZN7MKS_DLP22set_test_exposure_timeEt
          CFI NoCalls
        THUMB
// __interwork __softfp void MKS_DLP::set_test_exposure_time(uint16_t)
_ZN7MKS_DLP22set_test_exposure_timeEt:
        MOV      R2,#+1000
        MULS     R1,R2,R1
        STR      R1,[R0, #+476]
        BX       LR               ;; return
          CFI EndBlock cfiBlock143

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock144 Using cfiCommon0
          CFI Function _ZN7MKS_DLP11set_ZoffsetEv
        THUMB
// __interwork __softfp void MKS_DLP::set_Zoffset()
_ZN7MKS_DLP11set_ZoffsetEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+1
          CFI FunCall _Z18axis_unhomed_errorb
        BL       _Z18axis_unhomed_errorb
        CMP      R0,#+0
        BNE.N    ??set_Zoffset_0
          CFI FunCall _Z10gcode_M428v
        BL       _Z10gcode_M428v
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z10gcode_M500v
        B.W      _Z10gcode_M500v
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??set_Zoffset_0:
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock144

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock145 Using cfiCommon0
          CFI Function _ZN7MKS_DLP15get_totalLayersEv
          CFI NoCalls
        THUMB
// __interwork __softfp uint16_t MKS_DLP::get_totalLayers()
_ZN7MKS_DLP15get_totalLayersEv:
        LDRH     R1,[R0, #+12]
        LDRH     R0,[R0, #+52]
        ADDS     R0,R0,R1
        SUBS     R0,R0,#+1
        UXTH     R0,R0
        BX       LR               ;; return
          CFI EndBlock cfiBlock145

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock146 Using cfiCommon0
          CFI Function _ZN7MKS_DLP16get_currentLayerEv
        THUMB
// __interwork __softfp uint16_t MKS_DLP::get_currentLayer()
_ZN7MKS_DLP16get_currentLayerEv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
          CFI FunCall _ZN7MKS_DLP15get_totalLayersEv
        BL       _ZN7MKS_DLP15get_totalLayersEv
        LDRB     R1,[R4, #+470]
        LDRH     R2,[R4, #+468]
        ADDS     R1,R2,R1
        UXTH     R1,R1
        CMP      R0,R1
        BLS.N    ??get_currentLayer_0
        MOV      R0,R1
??get_currentLayer_0:
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock146

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock147 Using cfiCommon0
          CFI Function _ZN7MKS_DLP18get_totalPrintTimeEv
        THUMB
// __interwork __softfp uint32_t MKS_DLP::get_totalPrintTime()
_ZN7MKS_DLP18get_totalPrintTimeEv:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        MOV      R7,R0
        LDR.W    R0,??DataTable178_4
        LDRH     R1,[R0, #+2]
        MOV      R2,#+3600
        LDRB     R3,[R0, #+4]
        RSB      R4,R3,R3, LSL #+4
        LSLS     R3,R4,#+2
        MLA      R1,R2,R1,R3
        LDRSB    R0,[R0, #+5]
        SXTAB    R4,R1,R0
        MOV      R0,R7
          CFI FunCall _ZN7MKS_DLP15get_totalLayersEv
        BL       _ZN7MKS_DLP15get_totalLayersEv
        MOV      R5,R0
        MOV      R0,R7
          CFI FunCall _ZN7MKS_DLP16get_currentLayerEv
        BL       _ZN7MKS_DLP16get_currentLayerEv
        SUBS     R0,R5,R0
        UXTH     R0,R0
        ADD      R1,R7,#+36
        LDR      R2,[R1, #+4]
        LDRH     R3,[R1, #+16]
        LDRB     R5,[R7, #+470]
        MOV      R6,R5
        CMP      R6,R3
        BCS.N    ??get_totalPrintTime_0
        LDR      R6,[R1, #+12]
        CMP      R2,R6
        BCS.N    ??get_totalPrintTime_0
        MUL      R12,R2,R0
        MOV      LR,#+1000
        UDIV     R12,R12,LR
        SUBS     R3,R3,R5
        SUBS     R2,R6,R2
        MULS     R2,R2,R3
        MOV      R3,LR
        UDIV     R2,R2,R3
        ADD      R5,R2,R12
        B.N      ??get_totalPrintTime_1
??get_totalPrintTime_0:
        MULS     R2,R2,R0
        MOV      R3,#+1000
        UDIV     R5,R2,R3
??get_totalPrintTime_1:
        LDR      R1,[R1, #+8]
        MULS     R1,R1,R0
        MOV      R2,R3
        UDIV     R6,R1,R2
        MOV      R1,R0
        VMOV     S0,R1
        VCVT.F32.U32 S0,S0
        LDR.W    R1,??DataTable178_5
        VLDR     S1,[R1, #+8]
        VMOV.F32 S2,#2.0
        VMUL.F32 S1,S1,S2
        VLDR     S2,[R7, #+36]
        VSUB.F32 S1,S1,S2
        VMUL.F32 S0,S0,S1
        LDR.W    R1,??DataTable178_6
        VLDR     S1,[R1, #+16]
        VLDR.W   S2,??DataTable167  ;; 0x42f00000
        VDIV.F32 S1,S1,S2
        VDIV.F32 S0,S0,S1
        VCVT.U32.F32 S0,S0
        VMOV     R7,S0
          CFI FunCall __aeabi_ui2d
        BL       __aeabi_ui2d
        MOVS     R2,#+0
        LDR.W    R3,??DataTable178_7  ;; 0x3fe00000
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2uiz
        BL       __aeabi_d2uiz
        CMP      R7,R6
        BCS.N    ??get_totalPrintTime_2
        MOV      R7,R6
??get_totalPrintTime_2:
        ADDS     R0,R0,R5
        ADDS     R0,R7,R0
        ADDS     R0,R0,R4
        POP      {R1,R4-R7,PC}    ;; return
          CFI EndBlock cfiBlock147

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock148 Using cfiCommon0
          CFI Function _ZN7MKS_DLP20get_currentPrintTimeEv
        THUMB
// __interwork __softfp uint32_t MKS_DLP::get_currentPrintTime()
_ZN7MKS_DLP20get_currentPrintTimeEv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R4,R0
        ADD      R5,R4,#+36
        LDRB     R0,[R4, #+470]
        LDR      R1,[R5, #+12]
        MULS     R0,R1,R0
        MOV      R1,#+1000
        UDIV     R0,R0,R1
        LDRH     R1,[R4, #+468]
        LDR      R2,[R5, #+4]
        MULS     R1,R2,R1
        MOV      R2,#+1000
        UDIV     R1,R1,R2
        ADDS     R6,R1,R0
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16get_currentLayerEv
        BL       _ZN7MKS_DLP16get_currentLayerEv
        LDR      R1,[R5, #+8]
        MULS     R0,R1,R0
        MOV      R1,#+1000
        UDIV     R5,R0,R1
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16get_currentLayerEv
        BL       _ZN7MKS_DLP16get_currentLayerEv
        VMOV     S0,R0
        VCVT.F32.U32 S0,S0
        LDR.W    R0,??DataTable178_5
        VLDR     S1,[R0, #+8]
        VMOV.F32 S2,#2.0
        VMUL.F32 S1,S1,S2
        VLDR     S2,[R4, #+36]
        VSUB.F32 S1,S1,S2
        VMUL.F32 S0,S0,S1
        LDR.W    R0,??DataTable178_6
        VLDR     S1,[R0, #+16]
        VLDR.W   S2,??DataTable167  ;; 0x42f00000
        VDIV.F32 S1,S1,S2
        VDIV.F32 S0,S0,S1
        VCVT.U32.F32 S0,S0
        VMOV     R0,S0
        CMP      R0,R5
        BCS.N    ??get_currentPrintTime_0
        MOV      R0,R5
??get_currentPrintTime_0:
        ADDS     R0,R0,R6
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock148

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock149 Using cfiCommon0
          CFI Function _ZN7MKS_DLP10get_HeightEv
          CFI NoCalls
        THUMB
// __interwork __vfp float MKS_DLP::get_Height()
_ZN7MKS_DLP10get_HeightEv:
        LDRB     R1,[R0, #+470]
        LDRH     R2,[R0, #+468]
        ADDS     R1,R2,R1
        VMOV     S0,R1
        VCVT.F32.S32 S0,S0
        VLDR     S1,[R0, #+36]
        VMUL.F32 S0,S0,S1
        BX       LR               ;; return
          CFI EndBlock cfiBlock149

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock150 Using cfiCommon0
          CFI Function _ZN7MKS_DLP17get_ttfStatus_OFFEv
          CFI NoCalls
        THUMB
// __interwork __softfp char MKS_DLP::get_ttfStatus_OFF()
_ZN7MKS_DLP17get_ttfStatus_OFFEv:
        LDRSB    R1,[R0, #+492]
        CMP      R1,#+0
        BEQ.N    ??get_ttfStatus_OFF_0
        MOVS     R1,#+0
        STRB     R1,[R0, #+492]
        MOVS     R0,#+1
        BX       LR
??get_ttfStatus_OFF_0:
        MOVS     R0,#+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock150

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock151 Using cfiCommon0
          CFI Function _ZN7MKS_DLP16get_ttfStatus_ONEv
          CFI NoCalls
        THUMB
// __interwork __softfp char MKS_DLP::get_ttfStatus_ON()
_ZN7MKS_DLP16get_ttfStatus_ONEv:
        LDRSB    R1,[R0, #+491]
        CMP      R1,#+0
        BEQ.N    ??get_ttfStatus_ON_0
        MOVS     R1,#+0
        STRB     R1,[R0, #+491]
        MOVS     R0,#+1
        BX       LR
??get_ttfStatus_ON_0:
        MOVS     R0,#+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock151

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock152 Using cfiCommon0
          CFI Function _ZN7MKS_DLP12get_cpld_verEv
        THUMB
// __interwork __softfp uint8_t MKS_DLP::get_cpld_ver()
_ZN7MKS_DLP12get_cpld_verEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZN7MKS_DLP14bank2disp_readEv
        BL       _ZN7MKS_DLP14bank2disp_readEv
        AND      R0,R0,#0xF
        MOVS     R1,#+10
        SDIV     R1,R0,R1
        ADD      R2,R1,R1, LSL #+2
        SUB      R0,R0,R2, LSL #+1
        UXTB     R0,R0
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock152

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock153 Using cfiCommon0
          CFI Function _ZN7MKS_DLP13buzzer_enableEh
        THUMB
// __interwork __softfp void MKS_DLP::buzzer_enable(uint8_t)
_ZN7MKS_DLP13buzzer_enableEh:
        PUSH     {R1,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        STRB     R1,[R0, #+744]
        MOVS     R2,#+1
        ADD      R1,SP,#+0
        MOVW     R0,#+1594
          CFI FunCall AT24CXX_Write
        BL       AT24CXX_Write
        LDR.W    R0,??DataTable178_8
        LDRB     R0,[R0, #+3244]
        LDR.W    R1,??DataTable178_2
        STRB     R0,[R1, #+432]
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock153

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock154 Using cfiCommon0
          CFI Function _ZN7MKS_DLP11buzzer_toneEtth
          CFI NoCalls
        THUMB
// __interwork __softfp void MKS_DLP::buzzer_tone(uint16_t, uint16_t, uint8_t)
_ZN7MKS_DLP11buzzer_toneEtth:
        PUSH     {R4,R5}
          CFI R5 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDRB     R4,[R0, #+744]
        CMP      R4,#+0
        BEQ.N    ??buzzer_tone_0
        CMP      R3,#+6
        BLT.N    ??buzzer_tone_1
        MOVS     R3,#+5
??buzzer_tone_1:
        cpsid i
        MOVS     R4,#+0
        B.N      ??buzzer_tone_2
??buzzer_tone_3:
        ADD      R5,R0,R4, LSL #+2
        STRH     R1,[R5, #+724]
        STRH     R2,[R5, #+726]
        ADDS     R4,R4,#+1
??buzzer_tone_2:
        CMP      R4,R3
        BLT.N    ??buzzer_tone_3
        cpsie i
??buzzer_tone_0:
        POP      {R4,R5}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI CFA R13+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock154

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock155 Using cfiCommon0
          CFI Function _ZN7MKS_DLP14buzzer_pollingEv
          CFI NoCalls
        THUMB
// __interwork __softfp void MKS_DLP::buzzer_polling()
_ZN7MKS_DLP14buzzer_pollingEv:
        LDRB     R1,[R0, #+744]
        CMP      R1,#+0
        BEQ.N    ??buzzer_polling_0
        MOVS     R1,#+0
        B.N      ??buzzer_polling_1
??buzzer_polling_2:
        ADDS     R1,R1,#+1
??buzzer_polling_1:
        CMP      R1,#+5
        BGE.N    ??buzzer_polling_0
        ADD      R2,R0,R1, LSL #+2
        LDRH     R3,[R2, #+724]
        CMP      R3,#+0
        BEQ.N    ??buzzer_polling_3
        SUBS     R0,R3,#+1
        STRH     R0,[R2, #+724]
        UXTH     R0,R0
        AND      R0,R0,#0x1
        LDR.W    R1,??DataTable178_9  ;; 0x42430288
        STR      R0,[R1, #+0]
        BX       LR
??buzzer_polling_3:
        ADD      R2,R2,#+724
        LDRH     R3,[R2, #+2]
        CMP      R3,#+0
        BEQ.N    ??buzzer_polling_2
        SUBS     R0,R3,#+1
        STRH     R0,[R2, #+2]
??buzzer_polling_0:
        BX       LR               ;; return
          CFI EndBlock cfiBlock155

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock156 Using cfiCommon0
          CFI Function _ZN7MKS_DLP17get_buzzer_statusEv
          CFI NoCalls
        THUMB
// __interwork __softfp uint8_t MKS_DLP::get_buzzer_status()
_ZN7MKS_DLP17get_buzzer_statusEv:
        LDRB     R0,[R0, #+744]
        BX       LR               ;; return
          CFI EndBlock cfiBlock156

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock157 Using cfiCommon0
          CFI Function _ZN7MKS_DLP19printingHasFinishedEv
        THUMB
// __interwork __softfp void MKS_DLP::printingHasFinished()
_ZN7MKS_DLP19printingHasFinishedEv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        SUB      SP,SP,#+8
          CFI CFA R13+16
        MOV      R4,R0
        MOVS     R3,#+0
        MOV      R2,R3
        MOVS     R1,#+2
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP7led_offEv
        BL       _ZN7MKS_DLP7led_offEv
        LDR.W    R0,??DataTable178_8
          CFI FunCall _ZN10CardReader19printingHasFinishedEv
        BL       _ZN10CardReader19printingHasFinishedEv
        MOVS     R0,#+166
        STRB     R0,[SP, #+0]
        MOVS     R2,#+1
        ADD      R1,SP,#+0
        MOV      R0,#+1000
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP9moveMax_ZEv
        BL       _ZN7MKS_DLP9moveMax_ZEv
        MOVS     R2,#+1
        LDR.W    R0,??DataTable178_10
        LDRH     R1,[R0, #+4]
        LDR.W    R0,??DataTable178_11
        LDR      R0,[R0, #+8]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        MOVS     R0,#+0
        LDR.W    R1,??DataTable178_12
        STRB     R0,[R1, #+10]
        MOVS     R3,#+5
        MOV      R2,#+2000
        MOV      R1,#+1000
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP11buzzer_toneEtth
        BL       _ZN7MKS_DLP11buzzer_toneEtth
          CFI FunCall _Z10clr_ticketv
        BL       _Z10clr_ticketv
        POP      {R0,R1,R4,PC}    ;; return
          CFI EndBlock cfiBlock157

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock158 Using cfiCommon0
          CFI Function _ZN7MKS_DLP17PrintStatePollingEv
        THUMB
// __interwork __softfp void MKS_DLP::PrintStatePolling()
_ZN7MKS_DLP17PrintStatePollingEv:
        LDR.W    R1,??DataTable178_8
        LDRB     R2,[R1, #+2488]
        CMP      R2,#+0
        BEQ.N    ??PrintStatePolling_0
        BX       LR
??PrintStatePolling_0:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDRB     R2,[R0, #+482]
        CMP      R2,#+0
        BNE.N    ??PrintStatePolling_1
        LDRB     R1,[R1, #+3336]
        CMP      R1,#+168
        BEQ.N    ??PrintStatePolling_2
        CMP      R1,#+172
        BNE.N    ??PrintStatePolling_1
??PrintStatePolling_2:
        MOVS     R1,#+1
        STRB     R1,[R0, #+482]
          CFI FunCall _ZN7Planner13blocks_queuedEv
        BL       _ZN7Planner13blocks_queuedEv
        CMP      R0,#+0
        BNE.N    ??PrintStatePolling_3
        LDR.W    R0,??DataTable178_13
        LDRSH    R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??PrintStatePolling_1
??PrintStatePolling_3:
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z17quickstop_stepperv
        B.W      _Z17quickstop_stepperv
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??PrintStatePolling_1:
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock158

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable167:
        DC32     0x42f00000

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock159 Using cfiCommon0
          CFI Function _ZN7MKS_DLP10pausePrintEv
        THUMB
// __interwork __softfp bool MKS_DLP::pausePrint()
_ZN7MKS_DLP10pausePrintEv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        ADD      R4,R0,#+468
        LDRH     R1,[R0, #+468]
        CMP      R1,#+0
        BEQ.N    ??pausePrint_0
        LDRB     R1,[R4, #+12]
        CMP      R1,#+0
        BEQ.N    ??pausePrint_0
        MOVS     R1,#+1
        STRB     R1,[R4, #+13]
??pausePrint_0:
        MOVS     R1,#+0
        STRB     R1,[R4, #+3]
          CFI FunCall _ZN7MKS_DLP7led_offEv
        BL       _ZN7MKS_DLP7led_offEv
        LDRB     R0,[R4, #+12]
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock159

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock160 Using cfiCommon0
          CFI Function _ZN7MKS_DLP11resumePrintEv
        THUMB
// __interwork __softfp void MKS_DLP::resumePrint()
_ZN7MKS_DLP11resumePrintEv:
        PUSH     {R2-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+24
        MOV      R4,R0
        ADD      R5,R4,#+36
        ADD      R0,R4,#+468
        LDRB     R1,[R0, #+13]
        CMP      R1,#+0
        BEQ.N    ??resumePrint_0
        MOVS     R1,#+0
        STRB     R1,[R0, #+13]
        LDRB     R1,[R0, #+2]
        MOV      R2,R1
        LDRH     R3,[R5, #+16]
        CMP      R2,R3
        BCS.N    ??resumePrint_1
        SUBS     R1,R1,#+1
        STRB     R1,[R0, #+2]
        UXTB     R1,R1
        CMP      R1,#+2
        BGE.N    ??resumePrint_0
        MOVS     R1,#+1
        STRB     R1,[R0, #+2]
        B.N      ??resumePrint_0
??resumePrint_1:
        LDRH     R0,[R4, #+468]
        SUBS     R0,R0,#+1
        STRH     R0,[R4, #+468]
??resumePrint_0:
        MOVS     R0,#+166
        STRB     R0,[SP, #+0]
        MOVW     R6,#+1059
        MOVS     R2,#+1
        ADD      R1,SP,#+0
        MOV      R0,R6
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16get_currentLayerEv
        BL       _ZN7MKS_DLP16get_currentLayerEv
        LDR.W    R2,??DataTable178_12
        VMOV     S0,R0
        VCVT.F32.U32 S0,S0
        VLDR     S1,[R4, #+36]
        VMUL.F32 S0,S0,S1
        VSTR     S0,[R2, #+56]
        LDR.W    R0,??DataTable178_6
        VLDR     S0,[R0, #+16]
        VLDR.W   S1,??DataTable171  ;; 0x42f00000
        VDIV.F32 S0,S0,S1
        VSTR     S0,[SP, #+4]
        ADD      R1,SP,#+4
        ADD      R0,R2,#+56
          CFI FunCall _Z21do_blocking_move_to_zRKfS0_
        BL       _Z21do_blocking_move_to_zRKfS0_
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        MOVS     R0,#+167
        STRB     R0,[SP, #+0]
        MOVS     R2,#+1
        ADD      R1,SP,#+0
        MOV      R0,R6
          CFI FunCall epr_write_data
        BL       epr_write_data
        ADR.W    R0,`?<Constant "resume:">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
        LDR      R0,[R5, #+8]
        ADDS     R0,R0,#+1
        STR      R0,[R4, #+720]
        POP      {R0,R1,R4-R6,PC}  ;; return
          CFI EndBlock cfiBlock160

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock161 Using cfiCommon0
          CFI Function _ZN7MKS_DLP9stopPrintEv
        THUMB
// __interwork __softfp void MKS_DLP::stopPrint()
_ZN7MKS_DLP9stopPrintEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZN7MKS_DLP7led_offEv
        BL       _ZN7MKS_DLP7led_offEv
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z17quickstop_stepperv
        B.W      _Z17quickstop_stepperv
          CFI EndBlock cfiBlock161

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock162 Using cfiCommon0
          CFI Function _ZN7MKS_DLP24write_Information_pausedEv
        THUMB
// __interwork __softfp void MKS_DLP::write_Information_paused()
_ZN7MKS_DLP24write_Information_pausedEv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        SUB      SP,SP,#+8
          CFI CFA R13+16
        ADD      R1,R0,#+468
        LDRB     R2,[R1, #+13]
        CMP      R2,#+0
        BEQ.N    ??write_Information_paused_0
        MOVS     R2,#+0
        STRB     R2,[R1, #+13]
        LDRB     R2,[R1, #+2]
        MOV      R3,R2
        LDRH     R4,[R0, #+52]
        CMP      R3,R4
        BCS.N    ??write_Information_paused_1
        SUBS     R2,R2,#+1
        STRB     R2,[R1, #+2]
        UXTB     R2,R2
        CMP      R2,#+2
        BGE.N    ??write_Information_paused_0
        MOVS     R2,#+1
        STRB     R2,[R1, #+2]
        B.N      ??write_Information_paused_0
??write_Information_paused_1:
        LDRH     R1,[R0, #+468]
        SUBS     R1,R1,#+1
        STRH     R1,[R0, #+468]
??write_Information_paused_0:
          CFI FunCall _ZN7MKS_DLP16get_currentLayerEv
        BL       _ZN7MKS_DLP16get_currentLayerEv
        STRH     R0,[SP, #+0]
        LDR.W    R4,??DataTable178_8
        MOVS     R2,#+4
        ADDW     R1,R4,#+3340
        MOVW     R0,#+1053
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        MOVW     R0,#+1057
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R4,#+3312
        MOVW     R0,#+1045
          CFI FunCall epr_write_data
        BL       epr_write_data
        LDR.W    R4,??DataTable178_4
        MOVS     R2,#+2
        ADDS     R1,R4,#+2
        MOVW     R0,#+1049
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDS     R1,R4,#+4
        MOVW     R0,#+1051
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDS     R1,R4,#+5
        MOVW     R0,#+1052
          CFI FunCall epr_write_data
        BL       epr_write_data
        POP      {R0,R1,R4,PC}    ;; return
          CFI EndBlock cfiBlock162

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock163 Using cfiCommon0
          CFI Function _ZN7MKS_DLP23read_Information_pausedEv
        THUMB
// __interwork __softfp void MKS_DLP::read_Information_paused()
_ZN7MKS_DLP23read_Information_pausedEv:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R5,R0
        LDR.W    R4,??DataTable178_8
        MOVS     R2,#+30
        ADDW     R1,R4,#+3268
        MOVW     R0,#+1001
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADDW     R1,R4,#+3340
        MOVW     R0,#+1053
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R5,#+40
        MOVW     R0,#+1031
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R5,#+44
        MOVW     R0,#+1035
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADD      R1,R5,#+52
        MOVW     R0,#+1043
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R5,#+48
        MOVW     R0,#+1039
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        MOVW     R0,#+1057
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDRH     R0,[R5, #+52]
        ADD      R1,R5,#+468
        LDRH     R2,[SP, #+0]
        CMP      R0,R2
        BCC.N    ??read_Information_paused_0
        MOV      R0,R2
        STRB     R0,[R1, #+2]
        MOVS     R0,#+0
        STRH     R0,[R5, #+468]
        B.N      ??read_Information_paused_1
??read_Information_paused_0:
        STRB     R0,[R1, #+2]
        LDRH     R0,[SP, #+0]
        LDRH     R1,[R5, #+52]
        SUBS     R0,R0,R1
        STRH     R0,[R5, #+468]
??read_Information_paused_1:
        MOVS     R2,#+4
        ADD      R1,R4,#+3312
        MOVW     R0,#+1045
          CFI FunCall epr_read_data
        BL       epr_read_data
          CFI FunCall mks_setPositionZ
        BL       mks_setPositionZ
        LDR.W    R4,??DataTable178_4
        MOVS     R2,#+2
        ADDS     R1,R4,#+2
        MOVW     R0,#+1049
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDS     R1,R4,#+4
        MOVW     R0,#+1051
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDS     R1,R4,#+5
        MOVW     R0,#+1052
          CFI FunCall epr_read_data
        BL       epr_read_data
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock163

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock164 Using cfiCommon0
          CFI Function _ZN7MKS_DLP19contiuePrint_pausedEv
        THUMB
// __interwork __softfp void MKS_DLP::contiuePrint_paused()
_ZN7MKS_DLP19contiuePrint_pausedEv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+8
          CFI CFA R13+24
        MOV      R5,R0
        LDR.W    R4,??DataTable178_8
        MOVS     R0,#+1
        STRB     R0,[R4, #+2488]
        MOV      R0,R5
          CFI FunCall _ZN7MKS_DLP8getHead1Ev
        BL       _ZN7MKS_DLP8getHead1Ev
        LDR      R1,[R4, #+3340]
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8setIndexEl
        BL       _ZN10CardReader8setIndexEl
        MOV      R0,R5
          CFI FunCall _ZN7MKS_DLP15get_sdcard_bmpsEv
        BL       _ZN7MKS_DLP15get_sdcard_bmpsEv
        MOVS     R0,#+0
        STRB     R0,[R5, #+471]
        LDR      R0,[R5, #+44]
        ADDS     R0,R0,#+1
        STR      R0,[R5, #+720]
        LDR.W    R6,??DataTable178_12
        MOV      R0,R5
          CFI FunCall _ZN7MKS_DLP10get_HeightEv
        BL       _ZN7MKS_DLP10get_HeightEv
        VSTR     S0,[R6, #+56]
        LDR.W    R0,??DataTable178_6
        VLDR     S0,[R0, #+16]
        VLDR.W   S1,??DataTable171  ;; 0x42f00000
        VDIV.F32 S0,S0,S1
        VSTR     S0,[SP, #+0]
        ADD      R1,SP,#+0
        ADD      R0,R6,#+56
          CFI FunCall _Z21do_blocking_move_to_zRKfS0_
        BL       _Z21do_blocking_move_to_zRKfS0_
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
        MOVS     R0,#+167
        STRB     R0,[R4, #+3336]
          CFI FunCall _Z9gcode_M24v
        BL       _Z9gcode_M24v
        POP      {R0,R1,R4-R6,PC}  ;; return
          CFI EndBlock cfiBlock164

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable171:
        DC32     0x42f00000

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock165 Using cfiCommon0
          CFI Function _ZN7MKS_DLP18Is_Paused_FinishedEv
        THUMB
// __interwork __softfp bool MKS_DLP::Is_Paused_Finished()
_ZN7MKS_DLP18Is_Paused_FinishedEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R2,#+1
        ADD      R1,SP,#+0
        MOVW     R0,#+1059
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDRB     R0,[SP, #+0]
        CMP      R0,#+166
        BNE.N    ??Is_Paused_Finished_0
        MOVS     R0,#+0
        POP      {R1,PC}
??Is_Paused_Finished_0:
        CMP      R0,#+167
        BNE.N    ??Is_Paused_Finished_1
        MOVS     R0,#+1
        POP      {R1,PC}
??Is_Paused_Finished_1:
        MOVS     R0,#+0
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock165

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock166 Using cfiCommon0
          CFI Function _ZN7MKS_DLP23clean_Information_layerEv
        THUMB
// __interwork __softfp void MKS_DLP::clean_Information_layer()
_ZN7MKS_DLP23clean_Information_layerEv:
        PUSH     {R2-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+24
        MOV      R4,R0
        MOVS     R0,#+0
        STR      R0,[SP, #+4]
        STRH     R0,[SP, #+2]
        STRB     R0,[SP, #+0]
        MOV      R5,R0
        B.N      ??clean_Information_layer_0
??clean_Information_layer_1:
        MOVS     R0,#+20
        SDIV     R0,R5,R0
        ADD      R1,R0,R0, LSL #+2
        SUB      R0,R5,R1, LSL #+2
        MOVS     R1,#+11
        SMULBB   R0,R0,R1
        ADDW     R6,R0,#+1067
        UXTH     R6,R6
        MOVS     R2,#+4
        ADD      R1,SP,#+4
        MOV      R0,R6
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+2
        ADD      R1,SP,#+2
        ADDS     R0,R6,#+4
        UXTH     R0,R0
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,SP,#+0
        ADDS     R0,R6,#+6
        UXTH     R0,R0
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        ADDS     R0,R6,#+7
        UXTH     R0,R0
          CFI FunCall epr_write_data
        BL       epr_write_data
        ADDS     R5,R5,#+1
??clean_Information_layer_0:
        CMP      R5,#+20
        BLT.N    ??clean_Information_layer_1
        MOVS     R0,#+0
        B.N      ??clean_Information_layer_2
??clean_Information_layer_3:
        ADD      R1,R4,R0, LSL #+2
        MOVS     R2,#+0
        STR      R2,[R1, #+496]
        ADD      R3,R4,R0, LSL #+1
        STRH     R2,[R3, #+576]
        MOVS     R2,#+166
        ADDS     R3,R0,R4
        STRB     R2,[R3, #+616]
        MOVS     R2,#+0
        STR      R2,[R1, #+636]
        ADDS     R0,R0,#+1
??clean_Information_layer_2:
        CMP      R0,#+20
        BLT.N    ??clean_Information_layer_3
        POP      {R0,R1,R4-R6,PC}  ;; return
          CFI EndBlock cfiBlock166

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock167 Using cfiCommon0
          CFI Function _ZN7MKS_DLP23write_Information_layerE15DLP_MOVE_STATUS
        THUMB
// __interwork __softfp void MKS_DLP::write_Information_layer(DLP_MOVE_STATUS)
_ZN7MKS_DLP23write_Information_layerE15DLP_MOVE_STATUS:
        PUSH     {R1,R4-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        SUB      SP,SP,#+8
          CFI CFA R13+32
        MOV      R4,R0
          CFI FunCall _ZN7MKS_DLP16get_currentLayerEv
        BL       _ZN7MKS_DLP16get_currentLayerEv
        STRH     R0,[SP, #+0]
        MOVS     R5,#+20
        MOV      R1,R5
        SDIV     R1,R0,R1
        MLS      R0,R5,R1,R0
        MOVS     R1,#+11
        MULS     R0,R1,R0
        ADDW     R0,R0,#+1067
        STRH     R0,[R4, #+716]
        LDR.W    R6,??DataTable178_8
        LDRB     R0,[SP, #+8]
        CMP      R0,#+167
        BNE.N    ??write_Information_layer_0
        MOVS     R2,#+4
        ADDW     R1,R6,#+3340
        LDRH     R0,[R4, #+716]
          CFI FunCall epr_write_data
        BL       epr_write_data
        LDR.N    R0,??DataTable178_4
        LDRH     R1,[R0, #+2]
        MOV      R2,#+3600
        LDRB     R3,[R0, #+4]
        RSB      R7,R3,R3, LSL #+4
        LSLS     R3,R7,#+2
        MLA      R1,R2,R1,R3
        LDRSB    R0,[R0, #+5]
        SXTAB    R0,R1,R0
        STR      R0,[SP, #+4]
        MOVS     R2,#+4
        ADD      R1,SP,#+4
        LDRH     R0,[R4, #+716]
        ADDS     R0,R0,#+7
        UXTH     R0,R0
          CFI FunCall epr_write_data
        BL       epr_write_data
??write_Information_layer_0:
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        LDRH     R0,[R4, #+716]
        ADDS     R0,R0,#+4
        UXTH     R0,R0
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,SP,#+8
        LDRH     R0,[R4, #+716]
        ADDS     R0,R0,#+6
        UXTH     R0,R0
          CFI FunCall epr_write_data
        BL       epr_write_data
        LDRH     R0,[SP, #+0]
        MOV      R1,R5
        SDIV     R1,R0,R1
        MLS      R0,R5,R1,R0
        ADD      R0,R4,R0, LSL #+2
        LDR      R1,[R6, #+3340]
        STR      R1,[R0, #+496]
        LDRH     R0,[SP, #+0]
        MOV      R1,R5
        SDIV     R1,R0,R1
        MLS      R0,R5,R1,R0
        ADD      R0,R4,R0, LSL #+1
        LDRH     R1,[SP, #+0]
        STRH     R1,[R0, #+576]
        LDRH     R0,[SP, #+0]
        MOV      R1,R5
        SDIV     R1,R0,R1
        MLS      R0,R5,R1,R0
        ADDS     R0,R0,R4
        LDRB     R1,[SP, #+8]
        STRB     R1,[R0, #+616]
        LDRH     R0,[SP, #+0]
        MOV      R1,R5
        SDIV     R1,R0,R1
        MLS      R0,R5,R1,R0
        ADD      R0,R4,R0, LSL #+2
        LDR      R1,[SP, #+4]
        STR      R1,[R0, #+636]
        POP      {R0-R2,R4-R7,PC}  ;; return
          CFI EndBlock cfiBlock167

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable172:
        DC32     bmp_layer_buf

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock168 Using cfiCommon0
          CFI Function _ZN7MKS_DLP16Can_Resume_PrintEv
        THUMB
// __interwork __softfp uint16_t MKS_DLP::Can_Resume_Print()
_ZN7MKS_DLP16Can_Resume_PrintEv:
        PUSH     {R4-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
        MOV      R5,R0
        MOVS     R4,#+0
        MOV      R7,R4
        B.N      ??Can_Resume_Print_0
??Can_Resume_Print_1:
        MOVS     R0,#+20
        SDIV     R0,R7,R0
        ADD      R1,R0,R0, LSL #+2
        SUB      R0,R7,R1, LSL #+2
        MOVS     R1,#+11
        SMULBB   R0,R0,R1
        ADDW     R8,R0,#+1067
        UXTH     R8,R8
        ADD      R9,R5,R7, LSL #+2
        MOVS     R2,#+4
        ADD      R1,R9,#+496
        MOV      R0,R8
          CFI FunCall epr_read_data
        BL       epr_read_data
        ADD      R10,R5,R7, LSL #+1
        MOVS     R2,#+2
        ADD      R1,R10,#+576
        ADD      R0,R8,#+4
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDS     R0,R7,R5
        ADD      R1,R0,#+616
        ADD      R0,R8,#+6
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R9,#+636
        ADD      R0,R8,#+7
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDRH     R0,[R10, #+576]
        CMP      R4,R0
        BCS.N    ??Can_Resume_Print_2
        MOV      R4,R0
        MOV      R6,R7
??Can_Resume_Print_2:
        ADDS     R7,R7,#+1
??Can_Resume_Print_0:
        CMP      R7,#+20
        BLT.N    ??Can_Resume_Print_1
        UXTB     R6,R6
        ADDS     R0,R6,R5
        LDRB     R0,[R0, #+616]
        CMP      R0,#+167
        BNE.N    ??Can_Resume_Print_3
        ADD      R0,R5,R6, LSL #+2
        LDR      R1,[R0, #+496]
        LDR.N    R2,??DataTable178_8
        STR      R1,[R2, #+3340]
        LDR.N    R1,??DataTable178_4
        LDR      R2,[R0, #+636]
        MOV      R3,#+3600
        UDIV     R2,R2,R3
        STRH     R2,[R1, #+2]
        LDR      R2,[R0, #+636]
        MOV      R5,R3
        UDIV     R5,R2,R5
        MLS      R2,R3,R5,R2
        MOVS     R5,#+60
        UDIV     R2,R2,R5
        STRB     R2,[R1, #+4]
        LDR      R0,[R0, #+636]
        MOV      R2,R3
        UDIV     R2,R0,R2
        MLS      R0,R3,R2,R0
        MOV      R2,R5
        UDIV     R2,R0,R2
        RSB      R3,R2,R2, LSL #+4
        SUB      R0,R0,R3, LSL #+2
        STRB     R0,[R1, #+5]
        ADDS     R0,R4,#+1
        UXTH     R0,R0
        B.N      ??Can_Resume_Print_4
??Can_Resume_Print_3:
        MOVS     R0,#+0
??Can_Resume_Print_4:
        POP      {R4-R10,PC}      ;; return
          CFI EndBlock cfiBlock168

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable173:
        DC32     0x42428288

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable173_1:
        DC32     mipi_te_cnt

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock169 Using cfiCommon0
          CFI Function _ZN7MKS_DLP22read_Information_layerEv
        THUMB
// __interwork __softfp bool MKS_DLP::read_Information_layer()
_ZN7MKS_DLP22read_Information_layerEv:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
          CFI FunCall _ZN7MKS_DLP16Can_Resume_PrintEv
        BL       _ZN7MKS_DLP16Can_Resume_PrintEv
        MOVS     R5,R0
        BNE.N    ??read_Information_layer_0
        MOVS     R0,#+0
        POP      {R1,R4,R5,PC}
??read_Information_layer_0:
        MOVS     R2,#+30
        LDR.N    R1,??DataTable178_14
        MOVW     R0,#+1001
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+40
        MOVW     R0,#+1031
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+44
        MOVW     R0,#+1035
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADD      R1,R4,#+52
        MOVW     R0,#+1043
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+48
        MOVW     R0,#+1039
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDRH     R0,[R4, #+52]
        ADD      R1,R4,#+468
        CMP      R0,R5
        BLT.N    ??read_Information_layer_1
        STRB     R5,[R1, #+2]
        MOVS     R0,#+0
        STRH     R0,[R4, #+468]
        B.N      ??read_Information_layer_2
??read_Information_layer_1:
        STRB     R0,[R1, #+2]
        LDRH     R0,[R4, #+52]
        SUBS     R0,R5,R0
        STRH     R0,[R4, #+468]
        UXTH     R0,R0
        CMP      R0,#+0
        BEQ.N    ??read_Information_layer_2
        SUBS     R0,R0,#+1
        STRH     R0,[R4, #+468]
??read_Information_layer_2:
        MOVS     R0,#+1
        POP      {R1,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock169

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable174:
        DC32     disp_state

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable174_1:
        DC32     card+0x9C4

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable174_2:
        DC32     Serial6

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock170 Using cfiCommon0
          CFI Function _ZN7MKS_DLP18contiuePrint_PwdwnEv
        THUMB
// __interwork __softfp void MKS_DLP::contiuePrint_Pwdwn()
_ZN7MKS_DLP18contiuePrint_PwdwnEv:
        PUSH     {R4-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+20
        SUB      SP,SP,#+12
          CFI CFA R13+32
        MOV      R5,R0
        LDR.N    R6,??DataTable178_8
        MOVS     R0,#+1
        STRB     R0,[R6, #+2488]
        MOV      R0,R5
          CFI FunCall _ZN7MKS_DLP8getHead1Ev
        BL       _ZN7MKS_DLP8getHead1Ev
        ADDW     R4,R6,#+3312
        LDR      R1,[R4, #+28]
        MOV      R0,R6
          CFI FunCall _ZN10CardReader8setIndexEl
        BL       _ZN10CardReader8setIndexEl
        MOV      R0,R5
          CFI FunCall _ZN7MKS_DLP15get_sdcard_bmpsEv
        BL       _ZN7MKS_DLP15get_sdcard_bmpsEv
        MOVS     R0,#+0
        STRB     R0,[R5, #+471]
        LDR      R0,[R5, #+44]
        ADDS     R0,R0,#+1
        STR      R0,[R5, #+720]
        MOV      R0,R5
          CFI FunCall _ZN7MKS_DLP10get_HeightEv
        BL       _ZN7MKS_DLP10get_HeightEv
        ADDW     R0,R6,#+3312
        VSTR     S0,[R0, #0]
          CFI FunCall mks_setPositionZ
        BL       mks_setPositionZ
        LDR.N    R5,??DataTable178_5
        LDR.N    R6,??DataTable178_12
        VLDR     S0,[R6, #+40]
        VLDR     S1,[R5, #+8]
        VADD.F32 S0,S0,S1
        VSTR     S0,[R6, #+56]
        LDR.N    R7,??DataTable178_6
        VLDR     S0,[R7, #+16]
        VLDR.W   S1,??DataTable178_1  ;; 0x42f00000
        VDIV.F32 S0,S0,S1
        VSTR     S0,[SP, #+4]
        ADD      R1,SP,#+4
        ADD      R0,R6,#+56
          CFI FunCall _Z21do_blocking_move_to_zRKfS0_
        BL       _Z21do_blocking_move_to_zRKfS0_
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
        VLDR     S0,[R6, #+40]
        VLDR     S1,[R5, #+8]
        VSUB.F32 S0,S0,S1
        VSTR     S0,[R6, #+56]
        VLDR     S0,[R7, #+16]
        VLDR.W   S1,??DataTable178_1  ;; 0x42f00000
        VDIV.F32 S0,S0,S1
        VSTR     S0,[SP, #+0]
        ADD      R1,SP,#+0
        ADD      R0,R6,#+56
          CFI FunCall _Z21do_blocking_move_to_zRKfS0_
        BL       _Z21do_blocking_move_to_zRKfS0_
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
        MOVS     R0,#+167
        STRB     R0,[R4, #+24]
          CFI FunCall _Z9gcode_M24v
        BL       _Z9gcode_M24v
        POP      {R0-R2,R4-R7,PC}  ;; return
          CFI EndBlock cfiBlock170

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable175:
        DC32     0x42430284

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable175_1:
        DC32     0x42408288

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock171 Using cfiCommon0
          CFI Function _ZN7MKS_DLP10quick_stopEv
        THUMB
// __interwork __softfp void MKS_DLP::quick_stop()
_ZN7MKS_DLP10quick_stopEv:
        MOVS     R1,#+1
        STRB     R1,[R0, #+745]
          CFI FunCall _Z17quickstop_stepperv
        B.W      _Z17quickstop_stepperv
          CFI EndBlock cfiBlock171

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock172 Using cfiCommon0
          CFI Function _ZN7MKS_DLP16TFT_display_testEv
        THUMB
// __interwork __softfp void MKS_DLP::TFT_display_test()
_ZN7MKS_DLP16TFT_display_testEv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        SUB      SP,SP,#+8
          CFI CFA R13+16
        LDR.N    R4,??DataTable178_15
        MOV      R2,#+8192
        MOVS     R1,#+85
        MOV      R0,R4
          CFI FunCall memset
        BL       memset
        MOVS     R0,#+180
        STR      R0,[SP, #+0]
        MOV      R3,#+320
        MOVS     R2,#+20
        MOVS     R1,#+80
        MOV      R0,R4
          CFI FunCall layer_pic_display
        BL       layer_pic_display
        MOVS     R0,#+2
          CFI FunCall exposure_msg_display
        BL       exposure_msg_display
??TFT_display_test_0:
          CFI FunCall _Z4idlev
        BL       _Z4idlev
        B.N      ??TFT_display_test_0
          CFI EndBlock cfiBlock172

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable176:
        DC32     0x424282ac

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock173 Using cfiCommon0
          CFI Function _ZN7MKS_DLP23draw_return_printing_uiEv
        THUMB
// __interwork __softfp void MKS_DLP::draw_return_printing_ui()
_ZN7MKS_DLP23draw_return_printing_uiEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall display_print_statue
        BL       display_print_statue
          CFI FunCall setProBarRate
        BL       setProBarRate
          CFI FunCall GUI_Exec
        BL       GUI_Exec
        LDR.N    R0,??DataTable178_8
        LDRB     R0,[R0, #+2980]
        CMP      R0,#+0
        BEQ.N    ??draw_return_printing_ui_0
        MOVS     R0,#+180
        STR      R0,[SP, #+0]
        MOV      R3,#+320
        MOVS     R2,#+15
        MOVS     R1,#+30
        LDR.N    R0,??DataTable178_15
          CFI FunCall layer_pic_display
        BL       layer_pic_display
??draw_return_printing_ui_0:
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock173

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock174 Using cfiCommon0
          CFI Function _ZN7MKS_DLP13draw_printingEv
        THUMB
// __interwork __softfp void MKS_DLP::draw_printing()
_ZN7MKS_DLP13draw_printingEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZN7MKS_DLP8getHead1Ev
        BL       _ZN7MKS_DLP8getHead1Ev
          CFI FunCall draw_status_clear
        BL       draw_status_clear
          CFI FunCall display_print_statue
        BL       display_print_statue
          CFI FunCall setProBarRate
        BL       setProBarRate
          CFI FunCall GUI_Exec
        BL       GUI_Exec
        MOVS     R1,#+0
        LDR.N    R0,??DataTable178_8
        POP      {R2,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10CardReader8setIndexEl
        B.W      _ZN10CardReader8setIndexEl
          CFI EndBlock cfiBlock174

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable178:
        DC32     0x424282b4

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable178_1:
        DC32     0x42f00000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable178_2:
        DC32     gCfgItems

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable178_3:
        DC32     0x4242828c

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable178_4:
        DC32     print_time

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable178_5:
        DC32     home_bump_mm_P

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable178_6:
        DC32     mksCfg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable178_7:
        DC32     0x3fe00000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable178_8:
        DC32     card

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable178_9:
        DC32     0x42430288

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable178_10:
        DC32     gArrayGpioPin

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable178_11:
        DC32     gArrayGpioPort

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable178_12:
        DC32     axis_relative_modes

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable178_13:
        DC32     _ZN7Stepper23cleaning_buffer_counterE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable178_14:
        DC32     card+0xCC4

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable178_15:
        DC32     bmp_layer_buf

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "resume:">`:
        DC8 "resume:"

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z6strchrPci
          CFI Block cfiBlock175 Using cfiCommon0
          CFI Function _Z6strchrPci
          CFI FunCall __iar_Strchr
        THUMB
// __intrinsic __nounwind __interwork __softfp char *strchr(char *, int)
_Z6strchrPci:
        B.W      __iar_Strchr
          CFI EndBlock cfiBlock175

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z7strrchrPci
          CFI Block cfiBlock176 Using cfiCommon0
          CFI Function _Z7strrchrPci
          CFI FunCall __iar_Strrchr
        THUMB
// __intrinsic __nounwind __interwork __softfp char *strrchr(char *, int)
_Z7strrchrPci:
        B.W      __iar_Strrchr
          CFI EndBlock cfiBlock176

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z6strstrPcPKc
          CFI Block cfiBlock177 Using cfiCommon0
          CFI Function _Z6strstrPcPKc
          CFI FunCall __iar_Strstr
        THUMB
// __intrinsic __nounwind __interwork __softfp char *strstr(char *, char const *)
_Z6strstrPcPKc:
        B.W      __iar_Strstr
          CFI EndBlock cfiBlock177

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z14serialprintPGMPKc
          CFI Block cfiBlock178 Using cfiCommon0
          CFI Function _Z14serialprintPGMPKc
        THUMB
// __interwork __softfp void serialprintPGM(char const *)
_Z14serialprintPGMPKc:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
        B.N      ??serialprintPGM_0
??serialprintPGM_1:
        UXTB     R1,R1
        LDR.N    R0,??serialprintPGM_2
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??serialprintPGM_0:
        LDRSB    R1,[R4], #+1
        MOVS     R0,R1
        BNE.N    ??serialprintPGM_1
        POP      {R4,PC}          ;; return
        DATA
??serialprintPGM_2:
        DC32     Serial6
          CFI EndBlock cfiBlock178

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9IsRunningv
          CFI Block cfiBlock179 Using cfiCommon0
          CFI Function _Z9IsRunningv
          CFI NoCalls
        THUMB
// __interwork __softfp bool IsRunning()
_Z9IsRunningv:
        LDR.N    R0,??IsRunning_0
        LDRB     R0,[R0, #+0]
        BX       LR               ;; return
        Nop      
        DATA
??IsRunning_0:
        DC32     Running
          CFI EndBlock cfiBlock179

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9IsStoppedv
          CFI Block cfiBlock180 Using cfiCommon0
          CFI Function _Z9IsStoppedv
          CFI NoCalls
        THUMB
// __interwork __softfp bool IsStopped()
_Z9IsStoppedv:
        LDR.N    R0,??IsStopped_0
        LDRB     R0,[R0, #+0]
        EOR      R0,R0,#0x1
        BX       LR               ;; return
        Nop      
        DATA
??IsStopped_0:
        DC32     Running
          CFI EndBlock cfiBlock180

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z19refresh_cmd_timeoutv
          CFI Block cfiBlock181 Using cfiCommon0
          CFI Function _Z19refresh_cmd_timeoutv
        THUMB
// __interwork __softfp void refresh_cmd_timeout()
_Z19refresh_cmd_timeoutv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        LDR.N    R1,??refresh_cmd_timeout_0
        STR      R0,[R1, #+0]
        POP      {R0,PC}          ;; return
        DATA
??refresh_cmd_timeout_0:
        DC32     previous_cmd_ms
          CFI EndBlock cfiBlock181

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z28set_current_from_destinationv
          CFI Block cfiBlock182 Using cfiCommon0
          CFI Function _Z28set_current_from_destinationv
        THUMB
// __interwork __softfp void set_current_from_destination()
_Z28set_current_from_destinationv:
        LDR.N    R0,??set_current_from_destination_0
        MOVS     R2,#+16
        ADD      R1,R0,#+48
        ADDS     R0,R0,#+32
          CFI FunCall memcpy
        B.W      memcpy
        Nop      
        DATA
??set_current_from_destination_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock182

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z28set_destination_from_currentv
          CFI Block cfiBlock183 Using cfiCommon0
          CFI Function _Z28set_destination_from_currentv
        THUMB
// __interwork __softfp void set_destination_from_current()
_Z28set_destination_from_currentv:
        LDR.N    R0,??set_destination_from_current_0
        MOVS     R2,#+16
        ADD      R1,R0,#+32
        ADDS     R0,R0,#+48
          CFI FunCall memcpy
        B.W      memcpy
        Nop      
        DATA
??set_destination_from_current_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock183

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z8lcd_initv
          CFI Block cfiBlock184 Using cfiCommon0
          CFI Function _Z8lcd_initv
          CFI NoCalls
        THUMB
// __interwork __softfp void lcd_init()
_Z8lcd_initv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock184

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z13lcd_hasstatusv
          CFI Block cfiBlock185 Using cfiCommon0
          CFI Function _Z13lcd_hasstatusv
          CFI NoCalls
        THUMB
// __interwork __softfp bool lcd_hasstatus()
_Z13lcd_hasstatusv:
        MOVS     R0,#+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock185

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z13lcd_setstatusPKcb
          CFI Block cfiBlock186 Using cfiCommon0
          CFI Function _Z13lcd_setstatusPKcb
          CFI NoCalls
        THUMB
// __interwork __softfp void lcd_setstatus(char const *, bool)
_Z13lcd_setstatusPKcb:
        BX       LR               ;; return
          CFI EndBlock cfiBlock186

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z16lcd_setstatusPGMPKca
          CFI Block cfiBlock187 Using cfiCommon0
          CFI Function _Z16lcd_setstatusPGMPKca
          CFI NoCalls
        THUMB
// __interwork __softfp void lcd_setstatusPGM(char const *, int8_t)
_Z16lcd_setstatusPGMPKca:
        BX       LR               ;; return
          CFI EndBlock cfiBlock187

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z21lcd_setalertstatusPGMPKc
          CFI Block cfiBlock188 Using cfiCommon0
          CFI Function _Z21lcd_setalertstatusPGMPKc
          CFI NoCalls
        THUMB
// __interwork __softfp void lcd_setalertstatusPGM(char const *)
_Z21lcd_setalertstatusPGMPKc:
        BX       LR               ;; return
          CFI EndBlock cfiBlock188

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z21lcd_reset_alert_levelv
          CFI Block cfiBlock189 Using cfiCommon0
          CFI Function _Z21lcd_reset_alert_levelv
          CFI NoCalls
        THUMB
// __interwork __softfp void lcd_reset_alert_level()
_Z21lcd_reset_alert_levelv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock189

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z11lcd_refreshv
          CFI Block cfiBlock190 Using cfiCommon0
          CFI Function _Z11lcd_refreshv
          CFI NoCalls
        THUMB
// __interwork __softfp void lcd_refresh()
_Z11lcd_refreshv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock190

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN7Planner16refresh_e_factorEh
          CFI Block cfiBlock191 Using cfiCommon0
          CFI Function _ZN7Planner16refresh_e_factorEh
        THUMB
// __interwork __softfp void Planner::refresh_e_factor(uint8_t)
_ZN7Planner16refresh_e_factorEh:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R6,R0
        LDR.N    R0,??refresh_e_factor_0
        LDRSH    R0,[R0, R6, LSL #+1]
          CFI FunCall __aeabi_i2d
        BL       __aeabi_i2d
        LDR.N    R2,??refresh_e_factor_0+0x4  ;; 0x47ae147b
        LDR.N    R3,??refresh_e_factor_0+0x8  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R4,R0
        MOV      R5,R1
        LDR.N    R0,??refresh_e_factor_0+0xC
        LDR      R0,[R0, R6, LSL #+2]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        LDR.N    R1,??refresh_e_factor_0+0x10
        STR      R0,[R1, R6, LSL #+2]
        POP      {R4-R6,PC}       ;; return
        DATA
??refresh_e_factor_0:
        DC32     _ZN7Planner15flow_percentageE
        DC32     0x47ae147b
        DC32     0x3f847ae1
        DC32     _ZN7Planner21volumetric_multiplierE
        DC32     _ZN7Planner8e_factorE
          CFI EndBlock cfiBlock191

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN7Planner17set_filament_sizeEhRKf
          CFI Block cfiBlock192 Using cfiCommon0
          CFI Function _ZN7Planner17set_filament_sizeEhRKf
          CFI NoCalls
        THUMB
// __interwork __softfp void Planner::set_filament_size(uint8_t, float const &)
_ZN7Planner17set_filament_sizeEhRKf:
        LDR.N    R2,??set_filament_size_0
        LDR      R1,[R1, #+0]
        STR      R1,[R2, R0, LSL #+2]
        MOVS     R0,#+0
        B.N      ??set_filament_size_1
??set_filament_size_2:
        VLDR     S0,[R2, #0]
        VCMP.F32 S0,#0.0
        FMSTAT   
        BNE.N    ??set_filament_size_3
        LDR.N    R0,??set_filament_size_0+0x4  ;; 0x40400000
        STR      R0,[R2, #+0]
??set_filament_size_3:
        MOVS     R0,#+1
??set_filament_size_1:
        CMP      R0,#+0
        BEQ.N    ??set_filament_size_2
        BX       LR               ;; return
        Nop      
        DATA
??set_filament_size_0:
        DC32     _ZN7Planner13filament_sizeE
        DC32     0x40400000
          CFI EndBlock cfiBlock192

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN7Planner11buffer_lineEfffRKfS1_h
          CFI Block cfiBlock193 Using cfiCommon0
          CFI Function _ZN7Planner11buffer_lineEfffRKfS1_h
        THUMB
// __interwork __vfp void Planner::buffer_line(float, float, float, float const &, float const &, uint8_t)
_ZN7Planner11buffer_lineEfffRKfS1_h:
        PUSH     {LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+4
        VPUSH    {S0-S2}
          CFI CFA R13+16
        SUB      SP,SP,#+8
          CFI CFA R13+24
        UXTB     R2,R2
        STR      R2,[SP, #+4]
        STR      R1,[SP, #+0]
        MOV      R3,R0
        ADD      R2,SP,#+16
        ADD      R1,SP,#+12
        ADD      R0,SP,#+8
          CFI FunCall _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h
        BL       _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h
        ADD      SP,SP,#+20
          CFI CFA R13+4
        POP      {PC}             ;; return
          CFI EndBlock cfiBlock193

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
          CFI Block cfiBlock194 Using cfiCommon0
          CFI Function _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
        THUMB
// __interwork __softfp void Planner::buffer_line_kinematic(float const (&)[4], float const &, uint8_t)
_ZN7Planner21buffer_line_kinematicERA4_KfRS0_h:
        PUSH     {LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+4
        SUB      SP,SP,#+12
          CFI CFA R13+16
        STR      R2,[SP, #+4]
        STR      R1,[SP, #+0]
        ADD      R3,R0,#+12
        ADD      R2,R0,#+8
        ADDS     R1,R0,#+4
          CFI FunCall _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h
        BL       _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h
        POP      {R0-R2,PC}       ;; return
          CFI EndBlock cfiBlock194

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN7Planner15set_position_mmEfffRKf
          CFI Block cfiBlock195 Using cfiCommon0
          CFI Function _ZN7Planner15set_position_mmEfffRKf
        THUMB
// __interwork __vfp void Planner::set_position_mm(float, float, float, float const &)
_ZN7Planner15set_position_mmEfffRKf:
        PUSH     {LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+4
        VPUSH    {S0-S2}
          CFI CFA R13+16
        MOV      R3,R0
        ADD      R2,SP,#+8
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
          CFI FunCall _ZN7Planner16_set_position_mmERKfS1_S1_S1_
        BL       _ZN7Planner16_set_position_mmERKfS1_S1_S1_
        POP      {R0-R2,PC}       ;; return
          CFI EndBlock cfiBlock195

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN7Planner17set_e_position_mmERKf
          CFI Block cfiBlock196 Using cfiCommon0
          CFI Function _ZN7Planner17set_e_position_mmERKf
        THUMB
// __interwork __softfp void Planner::set_e_position_mm(float const &)
_ZN7Planner17set_e_position_mmERKf:
        MOV      R1,R0
        MOVS     R0,#+3
          CFI FunCall _ZN7Planner15set_position_mmE8AxisEnumRKf
        B.W      _ZN7Planner15set_position_mmE8AxisEnumRKf
          CFI EndBlock cfiBlock196

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN7Planner13blocks_queuedEv
          CFI Block cfiBlock197 Using cfiCommon0
          CFI Function _ZN7Planner13blocks_queuedEv
          CFI NoCalls
        THUMB
// __interwork __softfp bool Planner::blocks_queued()
_ZN7Planner13blocks_queuedEv:
        LDR.N    R0,??blocks_queued_0
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??blocks_queued_0+0x4
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BEQ.N    ??blocks_queued_1
        MOVS     R0,#+1
        BX       LR
??blocks_queued_1:
        MOVS     R0,#+0
        BX       LR               ;; return
        DATA
??blocks_queued_0:
        DC32     _ZN7Planner17block_buffer_headE
        DC32     _ZN7Planner17block_buffer_tailE
          CFI EndBlock cfiBlock197

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN8Endstops15enable_globallyEb
          CFI Block cfiBlock198 Using cfiCommon0
          CFI Function _ZN8Endstops15enable_globallyEb
          CFI NoCalls
        THUMB
// __interwork __softfp void Endstops::enable_globally(bool)
_ZN8Endstops15enable_globallyEb:
        LDR.N    R1,??enable_globally_0
        STRB     R0,[R1, #+0]
        LDR.N    R1,??enable_globally_0+0x4
        STRB     R0,[R1, #+0]
        BX       LR               ;; return
        Nop      
        DATA
??enable_globally_0:
        DC32     _ZN8Endstops7enabledE
        DC32     _ZN8Endstops16enabled_globallyE
          CFI EndBlock cfiBlock198

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN8Endstops6enableEb
          CFI Block cfiBlock199 Using cfiCommon0
          CFI Function _ZN8Endstops6enableEb
          CFI NoCalls
        THUMB
// __interwork __softfp void Endstops::enable(bool)
_ZN8Endstops6enableEb:
        LDR.N    R1,??enable_0
        STRB     R0,[R1, #+0]
        BX       LR               ;; return
        Nop      
        DATA
??enable_0:
        DC32     _ZN8Endstops7enabledE
          CFI EndBlock cfiBlock199

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN8Endstops10not_homingEv
          CFI Block cfiBlock200 Using cfiCommon0
          CFI Function _ZN8Endstops10not_homingEv
          CFI NoCalls
        THUMB
// __interwork __softfp void Endstops::not_homing()
_ZN8Endstops10not_homingEv:
        LDR.N    R0,??not_homing_0
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??not_homing_0+0x4
        STRB     R0,[R1, #+0]
        BX       LR               ;; return
        Nop      
        DATA
??not_homing_0:
        DC32     _ZN8Endstops16enabled_globallyE
        DC32     _ZN8Endstops7enabledE
          CFI EndBlock cfiBlock200

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN8Endstops14hit_on_purposeEv
          CFI Block cfiBlock201 Using cfiCommon0
          CFI Function _ZN8Endstops14hit_on_purposeEv
          CFI NoCalls
        THUMB
// __interwork __softfp void Endstops::hit_on_purpose()
_ZN8Endstops14hit_on_purposeEv:
        MOVS     R0,#+0
        LDR.N    R1,??hit_on_purpose_0
        STRB     R0,[R1, #+0]
        BX       LR               ;; return
        DATA
??hit_on_purpose_0:
        DC32     _ZN8Endstops16endstop_hit_bitsE
          CFI EndBlock cfiBlock201

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11Temperature9degHotendEh
          CFI Block cfiBlock202 Using cfiCommon0
          CFI Function _ZN11Temperature9degHotendEh
          CFI NoCalls
        THUMB
// __interwork __vfp float Temperature::degHotend(uint8_t)
_ZN11Temperature9degHotendEh:
        LDR.N    R0,??degHotend_0
        VLDR     S0,[R0, #0]
        BX       LR               ;; return
        DATA
??degHotend_0:
        DC32     _ZN11Temperature19current_temperatureE
          CFI EndBlock cfiBlock202

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11Temperature15degTargetHotendEh
          CFI Block cfiBlock203 Using cfiCommon0
          CFI Function _ZN11Temperature15degTargetHotendEh
          CFI NoCalls
        THUMB
// __interwork __vfp float Temperature::degTargetHotend(uint8_t)
_ZN11Temperature15degTargetHotendEh:
        LDR.N    R0,??degTargetHotend_0
        VLDR     S0,[R0, #0]
        VCVT.F32.S32 S0,S0
        BX       LR               ;; return
        DATA
??degTargetHotend_0:
        DC32     _ZN11Temperature18target_temperatureE
          CFI EndBlock cfiBlock203

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11Temperature15setTargetHotendEfh
          CFI Block cfiBlock204 Using cfiCommon0
          CFI Function _ZN11Temperature15setTargetHotendEfh
        THUMB
// __interwork __vfp void Temperature::setTargetHotend(float, uint8_t)
_ZN11Temperature15setTargetHotendEfh:
        VCVT.S32.F32 S0,S0
        LDR.N    R0,??setTargetHotend_0
        VSTR     S0,[R0, #0]
        MOVS     R0,#+0
          CFI FunCall _ZN11Temperature21start_watching_heaterEh
        B.W      _ZN11Temperature21start_watching_heaterEh
        DATA
??setTargetHotend_0:
        DC32     _ZN11Temperature18target_temperatureE
          CFI EndBlock cfiBlock204

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11Temperature12setTargetBedEf
          CFI Block cfiBlock205 Using cfiCommon0
          CFI Function _ZN11Temperature12setTargetBedEf
          CFI NoCalls
        THUMB
// __interwork __vfp void Temperature::setTargetBed(float)
_ZN11Temperature12setTargetBedEf:
        BX       LR               ;; return
          CFI EndBlock cfiBlock205

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11Temperature15isCoolingHotendEh
          CFI Block cfiBlock206 Using cfiCommon0
          CFI Function _ZN11Temperature15isCoolingHotendEh
          CFI NoCalls
        THUMB
// __interwork __softfp bool Temperature::isCoolingHotend(uint8_t)
_ZN11Temperature15isCoolingHotendEh:
        LDR.N    R0,??isCoolingHotend_0
        VLDR     S0,[R0, #0]
        VCVT.F32.S32 S0,S0
        LDR.N    R0,??isCoolingHotend_0+0x4
        VLDR     S1,[R0, #0]
        VCMP.F32 S0,S1
        FMSTAT   
        BPL.N    ??isCoolingHotend_1
        MOVS     R0,#+1
        BX       LR
??isCoolingHotend_1:
        MOVS     R0,#+0
        BX       LR               ;; return
        Nop      
        DATA
??isCoolingHotend_0:
        DC32     _ZN11Temperature18target_temperatureE
        DC32     _ZN11Temperature19current_temperatureE
          CFI EndBlock cfiBlock206

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11Temperature9updatePIDEv
          CFI Block cfiBlock207 Using cfiCommon0
          CFI Function _ZN11Temperature9updatePIDEv
          CFI NoCalls
        THUMB
// __interwork __softfp void Temperature::updatePID()
_ZN11Temperature9updatePIDEv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock207

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN10CardReader10isFileOpenEv
          CFI Block cfiBlock208 Using cfiCommon0
          CFI Function _ZN10CardReader10isFileOpenEv
          CFI NoCalls
        THUMB
// __interwork __softfp bool CardReader::isFileOpen()
_ZN10CardReader10isFileOpenEv:
        LDR      R0,[R0, #+512]
        CMP      R0,#+0
        BEQ.N    ??isFileOpen_0
        MOVS     R0,#+1
        BX       LR
??isFileOpen_0:
        MOVS     R0,#+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock208

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN10CardReader3eofEv
          CFI Block cfiBlock209 Using cfiCommon0
          CFI Function _ZN10CardReader3eofEv
          CFI NoCalls
        THUMB
// __interwork __softfp bool CardReader::eof()
_ZN10CardReader3eofEv:
        LDR      R1,[R0, #+1120]
        LDR      R0,[R0, #+1116]
        CMP      R1,R0
        SBCS     R0,R0,R0
        MVNS     R0,R0
        LSRS     R0,R0,#+31
        BX       LR               ;; return
          CFI EndBlock cfiBlock209

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN10CardReader4getsEPhj
          CFI Block cfiBlock210 Using cfiCommon0
          CFI Function _ZN10CardReader4getsEPhj
        THUMB
// __interwork __softfp UINT CardReader::gets(BYTE *, UINT)
_ZN10CardReader4getsEPhj:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        MOV      R5,R1
        ADD      R3,SP,#+0
          CFI FunCall f_read
        BL       f_read
        CMP      R0,#+0
        BEQ.N    ??gets_0
        MOVS     R0,#+255
        STRB     R0,[R5, #+0]
        MOV      R0,#-1
        STR      R0,[SP, #+0]
        B.N      ??gets_1
??gets_0:
        LDR      R0,[R4, #+1120]
        LDR      R1,[SP, #+0]
        ADDS     R0,R1,R0
        STR      R0,[R4, #+1120]
??gets_1:
        LDR      R0,[SP, #+0]
        POP      {R1,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock210

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN10CardReader8setIndexEl
          CFI Block cfiBlock211 Using cfiCommon0
          CFI Function _ZN10CardReader8setIndexEl
        THUMB
// __interwork __softfp void CardReader::setIndex(long)
_ZN10CardReader8setIndexEl:
        STR      R1,[R0, #+1120]
          CFI FunCall f_lseek
        B.W      f_lseek
          CFI EndBlock cfiBlock211

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN10duration_tC1ERKj
          CFI Block cfiBlock212 Using cfiCommon0
          CFI Function _ZN10duration_tC1ERKj
          CFI NoCalls
        THUMB
// __code __interwork __softfp duration_t::duration_t(uint32_t const &)
_ZN10duration_tC1ERKj:
        LDR      R1,[R1, #+0]
        STR      R1,[R0, #+0]
        BX       LR               ;; return
          CFI EndBlock cfiBlock212

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZNK10duration_t4yearEv
          CFI Block cfiBlock213 Using cfiCommon0
          CFI Function _ZNK10duration_t4yearEv
        THUMB
// __interwork __softfp uint8_t duration_t::year() const
_ZNK10duration_t4yearEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZNK10duration_t3dayEv
        BL       _ZNK10duration_t3dayEv
        MOVW     R1,#+365
        SDIV     R0,R0,R1
        UXTB     R0,R0
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock213

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZNK10duration_t3dayEv
          CFI Block cfiBlock214 Using cfiCommon0
          CFI Function _ZNK10duration_t3dayEv
        THUMB
// __interwork __softfp uint16_t duration_t::day() const
_ZNK10duration_t3dayEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZNK10duration_t4hourEv
        BL       _ZNK10duration_t4hourEv
        MOVS     R1,#+24
        UDIV     R0,R0,R1
        UXTH     R0,R0
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock214

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZNK10duration_t4hourEv
          CFI Block cfiBlock215 Using cfiCommon0
          CFI Function _ZNK10duration_t4hourEv
        THUMB
// __interwork __softfp uint32_t duration_t::hour() const
_ZNK10duration_t4hourEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZNK10duration_t6minuteEv
        BL       _ZNK10duration_t6minuteEv
        MOVS     R1,#+60
        UDIV     R0,R0,R1
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock215

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZNK10duration_t6minuteEv
          CFI Block cfiBlock216 Using cfiCommon0
          CFI Function _ZNK10duration_t6minuteEv
        THUMB
// __interwork __softfp uint32_t duration_t::minute() const
_ZNK10duration_t6minuteEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZNK10duration_t6secondEv
        BL       _ZNK10duration_t6secondEv
        MOVS     R1,#+60
        UDIV     R0,R0,R1
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock216

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZNK10duration_t6secondEv
          CFI Block cfiBlock217 Using cfiCommon0
          CFI Function _ZNK10duration_t6secondEv
          CFI NoCalls
        THUMB
// __interwork __softfp uint32_t duration_t::second() const
_ZNK10duration_t6secondEv:
        LDR      R0,[R0, #+0]
        BX       LR               ;; return
          CFI EndBlock cfiBlock217

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZNK10duration_t8toStringEPc
          CFI Block cfiBlock218 Using cfiCommon0
          CFI Function _ZNK10duration_t8toStringEPc
        THUMB
// __interwork __softfp void duration_t::toString(char *) const
_ZNK10duration_t8toStringEPc:
        PUSH     {R4-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
        SUB      SP,SP,#+16
          CFI CFA R13+48
        MOV      R7,R0
        MOV      R4,R1
          CFI FunCall _ZNK10duration_t4yearEv
        BL       _ZNK10duration_t4yearEv
        MOV      R5,R0
        MOV      R0,R7
          CFI FunCall _ZNK10duration_t3dayEv
        BL       _ZNK10duration_t3dayEv
        MOVW     R1,#+365
        SDIV     R1,R0,R1
        MOVW     R2,#+365
        MLS      R6,R2,R1,R0
        MOV      R0,R7
          CFI FunCall _ZNK10duration_t4hourEv
        BL       _ZNK10duration_t4hourEv
        MOVS     R1,#+24
        UDIV     R1,R0,R1
        ADD      R2,R1,R1, LSL #+1
        SUB      R8,R0,R2, LSL #+3
        MOV      R0,R7
          CFI FunCall _ZNK10duration_t6minuteEv
        BL       _ZNK10duration_t6minuteEv
        MOV      R9,#+60
        MOV      R1,R9
        UDIV     R1,R0,R1
        MLS      R10,R9,R1,R0
        MOV      R0,R7
          CFI FunCall _ZNK10duration_t6secondEv
        BL       _ZNK10duration_t6secondEv
        MOV      R1,R9
        UDIV     R1,R0,R1
        MLS      R2,R9,R1,R0
        CMP      R5,#+0
        BEQ.N    ??toString_0
        STR      R2,[SP, #+8]
        STR      R10,[SP, #+4]
        STR      R8,[SP, #+0]
        MOV      R3,R6
        MOV      R2,R5
        LDR.N    R1,??toString_1
        MOV      R0,R4
          CFI FunCall sprintf
        BL       sprintf
        B.N      ??toString_2
??toString_0:
        CMP      R6,#+0
        BEQ.N    ??toString_3
        STR      R2,[SP, #+4]
        STR      R10,[SP, #+0]
        MOV      R3,R8
        MOV      R2,R6
        LDR.N    R1,??toString_1+0x4
        MOV      R0,R4
          CFI FunCall sprintf
        BL       sprintf
        B.N      ??toString_2
??toString_3:
        CMP      R8,#+0
        BEQ.N    ??toString_4
        STR      R2,[SP, #+0]
        MOV      R3,R10
        MOV      R2,R8
        LDR.N    R1,??toString_1+0x8
        MOV      R0,R4
          CFI FunCall sprintf
        BL       sprintf
        B.N      ??toString_2
??toString_4:
        CMP      R10,#+0
        BEQ.N    ??toString_5
        MOV      R3,R2
        MOV      R2,R10
        LDR.N    R1,??toString_1+0xC
        MOV      R0,R4
        ADD      SP,SP,#+16
          CFI CFA R13+32
        POP      {R4-R10,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall sprintf
        B.W      sprintf
          CFI R4 Frame(CFA, -32)
          CFI R5 Frame(CFA, -28)
          CFI R6 Frame(CFA, -24)
          CFI R7 Frame(CFA, -20)
          CFI R8 Frame(CFA, -16)
          CFI R9 Frame(CFA, -12)
          CFI R10 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+48
??toString_5:
        LDR.N    R1,??toString_1+0x10
        MOV      R0,R4
        ADD      SP,SP,#+16
          CFI CFA R13+32
        POP      {R4-R10,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall sprintf
        B.W      sprintf
          CFI R4 Frame(CFA, -32)
          CFI R5 Frame(CFA, -28)
          CFI R6 Frame(CFA, -24)
          CFI R7 Frame(CFA, -20)
          CFI R8 Frame(CFA, -16)
          CFI R9 Frame(CFA, -12)
          CFI R10 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+48
??toString_2:
        POP      {R0-R10,PC}      ;; return
        Nop      
        DATA
??toString_1:
        DC32     _ZZNK10duration_t8toStringEPcEs
        DC32     _ZZNK10duration_t8toStringEPcEs_0
        DC32     _ZZNK10duration_t8toStringEPcEs_1
        DC32     _ZZNK10duration_t8toStringEPcEs_2
        DC32     _ZZNK10duration_t8toStringEPcEs_3
          CFI EndBlock cfiBlock218

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11GCodeParser4seenEc
          CFI Block cfiBlock219 Using cfiCommon0
          CFI Function _ZN11GCodeParser4seenEc
          CFI NoCalls
        THUMB
// __interwork __softfp bool GCodeParser::seen(char)
_ZN11GCodeParser4seenEc:
        SUB      R1,R0,#+65
        UXTB     R1,R1
        CMP      R1,#+26
        BCC.N    ??seen_0
        MOVS     R0,#+0
        BX       LR
??seen_0:
        ASRS     R0,R1,#+3
        LDR.N    R2,??seen_1
        LDRB     R0,[R0, R2]
        AND      R2,R1,#0x7
        LSRS     R0,R0,R2
        ANDS     R0,R0,#0x1
        BEQ.N    ??seen_2
        LDR.N    R2,??seen_1+0x4
        LDRB     R1,[R1, R2]
        LDR.N    R2,??seen_1+0x8
        CMP      R1,#+0
        BEQ.N    ??seen_3
        LDR.N    R3,??seen_1+0xC
        LDR      R3,[R3, #+0]
        ADDS     R1,R1,R3
        STR      R1,[R2, #+0]
        BX       LR
??seen_3:
        MOVS     R1,#+0
        STR      R1,[R2, #+0]
??seen_2:
        BX       LR               ;; return
        Nop      
        DATA
??seen_1:
        DC32     _ZN11GCodeParser8codebitsE
        DC32     _ZN11GCodeParser5paramE
        DC32     _ZN11GCodeParser9value_ptrE
        DC32     _ZN11GCodeParser11command_ptrE
          CFI EndBlock cfiBlock219

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11GCodeParser9has_valueEv
          CFI Block cfiBlock220 Using cfiCommon0
          CFI Function _ZN11GCodeParser9has_valueEv
          CFI NoCalls
        THUMB
// __interwork __softfp bool GCodeParser::has_value()
_ZN11GCodeParser9has_valueEv:
        LDR.N    R0,??has_value_0
        LDR      R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??has_value_1
        MOVS     R0,#+1
        BX       LR
??has_value_1:
        MOVS     R0,#+0
        BX       LR               ;; return
        DATA
??has_value_0:
        DC32     _ZN11GCodeParser9value_ptrE
          CFI EndBlock cfiBlock220

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser7seenvalEc
          CFI Block cfiBlock221 Using cfiCommon0
          CFI Function _ZN11GCodeParser7seenvalEc
        THUMB
// __interwork __softfp bool GCodeParser::seenval(char)
_ZN11GCodeParser7seenvalEc:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??seenval_0
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN11GCodeParser9has_valueEv
        B.W      _ZN11GCodeParser9has_valueEv
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??seenval_0:
        MOVS     R0,#+0
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock221

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11GCodeParser11value_floatEv
          CFI Block cfiBlock222 Using cfiCommon0
          CFI Function _ZN11GCodeParser11value_floatEv
        THUMB
// __interwork __vfp float GCodeParser::value_float()
_ZN11GCodeParser11value_floatEv:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        LDR.N    R2,??value_float_0+0x4
        LDR      R0,[R2, #+0]
        CMP      R0,#+0
        BEQ.N    ??value_float_1
        MOV      R4,R0
        B.N      ??value_float_2
??value_float_3:
        ADDS     R4,R4,#+1
??value_float_2:
        LDRSB    R5,[R4, #+0]
        CMP      R5,#+0
        BEQ.N    ??value_float_4
        CMP      R5,#+32
        BNE.N    ??value_float_5
??value_float_4:
        MOVS     R1,#+0
          CFI FunCall strtod
        BL       strtod
        VMOV     R0,R1,D0
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        VMOV     S0,R0
        POP      {R0,R4,R5,PC}
??value_float_5:
        CMP      R5,#+69
        BEQ.N    ??value_float_6
        CMP      R5,#+101
        BNE.N    ??value_float_3
??value_float_6:
        MOVS     R0,#+0
        STRB     R0,[R4, #+0]
        MOV      R1,R0
        LDR      R0,[R2, #+0]
          CFI FunCall strtod
        BL       strtod
        VMOV     R0,R1,D0
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        VMOV     S0,R0
        STRB     R5,[R4, #+0]
        POP      {R0,R4,R5,PC}
??value_float_1:
        VLDR.W   S0,??value_float_0  ;; 0x0
        POP      {R0,R4,R5,PC}    ;; return
        Nop      
        DATA
??value_float_0:
        DC32     0x0
        DC32     _ZN11GCodeParser9value_ptrE
          CFI EndBlock cfiBlock222

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11GCodeParser10value_longEv
          CFI Block cfiBlock223 Using cfiCommon0
          CFI Function _ZN11GCodeParser10value_longEv
        THUMB
// __interwork __softfp int32_t GCodeParser::value_long()
_ZN11GCodeParser10value_longEv:
        LDR.N    R0,??value_long_0
        LDR      R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??value_long_1
        MOVS     R2,#+10
        MOVS     R1,#+0
          CFI FunCall strtol
        B.W      strtol
??value_long_1:
        MOVS     R0,#+0
        BX       LR               ;; return
        DATA
??value_long_0:
        DC32     _ZN11GCodeParser9value_ptrE
          CFI EndBlock cfiBlock223

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11GCodeParser11value_ulongEv
          CFI Block cfiBlock224 Using cfiCommon0
          CFI Function _ZN11GCodeParser11value_ulongEv
        THUMB
// __interwork __softfp uint32_t GCodeParser::value_ulong()
_ZN11GCodeParser11value_ulongEv:
        LDR.N    R0,??value_ulong_0
        LDR      R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??value_ulong_1
        MOVS     R2,#+10
        MOVS     R1,#+0
          CFI FunCall strtoul
        B.W      strtoul
??value_ulong_1:
        MOVS     R0,#+0
        BX       LR               ;; return
        DATA
??value_ulong_0:
        DC32     _ZN11GCodeParser9value_ptrE
          CFI EndBlock cfiBlock224

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser12value_millisEv
          CFI Block cfiBlock225 Using cfiCommon0
          CFI Function _ZN11GCodeParser12value_millisEv
          CFI FunCall _ZN11GCodeParser11value_ulongEv
        THUMB
// __interwork __softfp millis_t GCodeParser::value_millis()
_ZN11GCodeParser12value_millisEv:
        B.W      _ZN11GCodeParser11value_ulongEv
          CFI EndBlock cfiBlock225

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11GCodeParser25value_millis_from_secondsEv
          CFI Block cfiBlock226 Using cfiCommon0
          CFI Function _ZN11GCodeParser25value_millis_from_secondsEv
        THUMB
// __interwork __softfp millis_t GCodeParser::value_millis_from_seconds()
_ZN11GCodeParser25value_millis_from_secondsEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        VLDR.W   S1,??value_millis_from_seconds_0  ;; 0x447a0000
        VMUL.F32 S0,S0,S1
        VCVT.U32.F32 S0,S0
        VMOV     R0,S0
        POP      {R1,PC}          ;; return
        DATA
??value_millis_from_seconds_0:
        DC32     0x447a0000
          CFI EndBlock cfiBlock226

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser9value_intEv
          CFI Block cfiBlock227 Using cfiCommon0
          CFI Function _ZN11GCodeParser9value_intEv
        THUMB
// __interwork __softfp int16_t GCodeParser::value_int()
_ZN11GCodeParser9value_intEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZN11GCodeParser10value_longEv
        BL       _ZN11GCodeParser10value_longEv
        SXTH     R0,R0
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock227

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser12value_ushortEv
          CFI Block cfiBlock228 Using cfiCommon0
          CFI Function _ZN11GCodeParser12value_ushortEv
        THUMB
// __interwork __softfp uint16_t GCodeParser::value_ushort()
_ZN11GCodeParser12value_ushortEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZN11GCodeParser10value_longEv
        BL       _ZN11GCodeParser10value_longEv
        UXTH     R0,R0
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock228

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser10value_byteEv
          CFI Block cfiBlock229 Using cfiCommon0
          CFI Function _ZN11GCodeParser10value_byteEv
        THUMB
// __interwork __softfp uint8_t GCodeParser::value_byte()
_ZN11GCodeParser10value_byteEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZN11GCodeParser10value_longEv
        BL       _ZN11GCodeParser10value_longEv
        CMP      R0,#+0
        BPL.N    ??value_byte_0
        MOVS     R0,#+0
        B.N      ??value_byte_1
??value_byte_0:
          CFI FunCall _ZN11GCodeParser10value_longEv
        BL       _ZN11GCodeParser10value_longEv
        CMP      R0,#+255
        BLE.N    ??value_byte_2
        MOVS     R0,#+255
        B.N      ??value_byte_1
??value_byte_2:
          CFI FunCall _ZN11GCodeParser10value_longEv
        BL       _ZN11GCodeParser10value_longEv
??value_byte_1:
        UXTB     R0,R0
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock229

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser10value_boolEv
          CFI Block cfiBlock230 Using cfiCommon0
          CFI Function _ZN11GCodeParser10value_boolEv
        THUMB
// __interwork __softfp bool GCodeParser::value_bool()
_ZN11GCodeParser10value_boolEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZN11GCodeParser9has_valueEv
        BL       _ZN11GCodeParser9has_valueEv
        CMP      R0,#+0
        BEQ.N    ??value_bool_0
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        SUBS     R0,R0,#+1
        SBCS     R0,R0,R0
        MVNS     R0,R0
        LSRS     R0,R0,#+31
        POP      {R1,PC}
??value_bool_0:
        MOVS     R0,#+1
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock230

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser18value_linear_unitsEv
          CFI Block cfiBlock231 Using cfiCommon0
          CFI Function _ZN11GCodeParser18value_linear_unitsEv
          CFI FunCall _ZN11GCodeParser11value_floatEv
        THUMB
// __interwork __vfp float GCodeParser::value_linear_units()
_ZN11GCodeParser18value_linear_unitsEv:
        B.W      _ZN11GCodeParser11value_floatEv
          CFI EndBlock cfiBlock231

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser16value_axis_unitsE8AxisEnum
          CFI Block cfiBlock232 Using cfiCommon0
          CFI Function _ZN11GCodeParser16value_axis_unitsE8AxisEnum
          CFI FunCall _ZN11GCodeParser11value_floatEv
        THUMB
// __interwork __vfp float GCodeParser::value_axis_units(AxisEnum)
_ZN11GCodeParser16value_axis_unitsE8AxisEnum:
        B.W      _ZN11GCodeParser11value_floatEv
          CFI EndBlock cfiBlock232

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser19value_per_axis_unitE8AxisEnum
          CFI Block cfiBlock233 Using cfiCommon0
          CFI Function _ZN11GCodeParser19value_per_axis_unitE8AxisEnum
          CFI FunCall _ZN11GCodeParser11value_floatEv
        THUMB
// __interwork __vfp float GCodeParser::value_per_axis_unit(AxisEnum)
_ZN11GCodeParser19value_per_axis_unitE8AxisEnum:
        B.W      _ZN11GCodeParser11value_floatEv
          CFI EndBlock cfiBlock233

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser13value_celsiusEv
          CFI Block cfiBlock234 Using cfiCommon0
          CFI Function _ZN11GCodeParser13value_celsiusEv
          CFI FunCall _ZN11GCodeParser11value_floatEv
        THUMB
// __interwork __vfp float GCodeParser::value_celsius()
_ZN11GCodeParser13value_celsiusEv:
        B.W      _ZN11GCodeParser11value_floatEv
          CFI EndBlock cfiBlock234

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser14value_feedrateEv
          CFI Block cfiBlock235 Using cfiCommon0
          CFI Function _ZN11GCodeParser14value_feedrateEv
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        THUMB
// __interwork __vfp float GCodeParser::value_feedrate()
_ZN11GCodeParser14value_feedrateEv:
        B.W      _ZN11GCodeParser18value_linear_unitsEv
          CFI EndBlock cfiBlock235

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser7boolvalEc
          CFI Block cfiBlock236 Using cfiCommon0
          CFI Function _ZN11GCodeParser7boolvalEc
        THUMB
// __interwork __softfp bool GCodeParser::boolval(char)
_ZN11GCodeParser7boolvalEc:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??boolval_0
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN11GCodeParser10value_boolEv
        B.W      _ZN11GCodeParser10value_boolEv
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??boolval_0:
        MOV      R0,R4
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN11GCodeParser4seenEc
        B.W      _ZN11GCodeParser4seenEc
          CFI EndBlock cfiBlock236

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser7bytevalEch
          CFI Block cfiBlock237 Using cfiCommon0
          CFI Function _ZN11GCodeParser7bytevalEch
        THUMB
// __interwork __softfp uint8_t GCodeParser::byteval(char, uint8_t)
_ZN11GCodeParser7bytevalEch:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R1
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??byteval_0
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        MOV      R4,R0
??byteval_0:
        MOV      R0,R4
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock237

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser6intvalEcs
          CFI Block cfiBlock238 Using cfiCommon0
          CFI Function _ZN11GCodeParser6intvalEcs
        THUMB
// __interwork __softfp int16_t GCodeParser::intval(char, int16_t)
_ZN11GCodeParser6intvalEcs:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R1
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??intval_0
          CFI FunCall _ZN11GCodeParser9value_intEv
        BL       _ZN11GCodeParser9value_intEv
        MOV      R4,R0
??intval_0:
        MOV      R0,R4
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock238

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser9ushortvalEct
          CFI Block cfiBlock239 Using cfiCommon0
          CFI Function _ZN11GCodeParser9ushortvalEct
        THUMB
// __interwork __softfp uint16_t GCodeParser::ushortval(char, uint16_t)
_ZN11GCodeParser9ushortvalEct:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R1
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??ushortval_0
          CFI FunCall _ZN11GCodeParser12value_ushortEv
        BL       _ZN11GCodeParser12value_ushortEv
        MOV      R4,R0
??ushortval_0:
        MOV      R0,R4
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock239

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser9linearvalEcf
          CFI Block cfiBlock240 Using cfiCommon0
          CFI Function _ZN11GCodeParser9linearvalEcf
        THUMB
// __interwork __vfp float GCodeParser::linearval(char, float)
_ZN11GCodeParser9linearvalEcf:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        VPUSH    {D8}
          CFI D8 Frame(CFA, -16)
          CFI CFA R13+16
        VMOV.F32 S16,S0
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??linearval_0
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        VMOV.F32 S16,S0
??linearval_0:
        VMOV.F32 S0,S16
        VPOP     {D8}
          CFI D8 SameValue
          CFI CFA R13+8
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock240

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser10celsiusvalEcf
          CFI Block cfiBlock241 Using cfiCommon0
          CFI Function _ZN11GCodeParser10celsiusvalEcf
        THUMB
// __interwork __vfp float GCodeParser::celsiusval(char, float)
_ZN11GCodeParser10celsiusvalEcf:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        VPUSH    {D8}
          CFI D8 Frame(CFA, -16)
          CFI CFA R13+16
        VMOV.F32 S16,S0
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??celsiusval_0
          CFI FunCall _ZN11GCodeParser13value_celsiusEv
        BL       _ZN11GCodeParser13value_celsiusEv
        VMOV.F32 S16,S0
??celsiusval_0:
        VMOV.F32 S0,S16
        VPOP     {D8}
          CFI D8 SameValue
          CFI CFA R13+8
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock241

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z20sync_plan_position_ev
          CFI Block cfiBlock242 Using cfiCommon0
          CFI Function _Z20sync_plan_position_ev
        THUMB
_Z20sync_plan_position_ev:
        LDR.N    R0,??sync_plan_position_e_0
          CFI FunCall _ZN7Planner17set_e_position_mmERKf
        B.W      _ZN7Planner17set_e_position_mmERKf
        Nop      
        DATA
??sync_plan_position_e_0:
        DC32     axis_relative_modes+0x2C
          CFI EndBlock cfiBlock242

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z15_commit_commandb
          CFI Block cfiBlock243 Using cfiCommon0
          CFI Function _Z15_commit_commandb
          CFI NoCalls
        THUMB
_Z15_commit_commandb:
        LDR.N    R1,??_commit_command_0
        LDRB     R2,[R1, #+16]
        ADDS     R3,R2,R1
        STRB     R0,[R3, #+24]
        ADDS     R0,R2,#+1
        STRB     R0,[R1, #+16]
        UXTB     R0,R0
        CMP      R0,#+4
        BLT.N    ??_commit_command_1
        MOVS     R0,#+0
        STRB     R0,[R1, #+16]
??_commit_command_1:
        LDRB     R0,[R1, #+14]
        ADDS     R0,R0,#+1
        STRB     R0,[R1, #+14]
        BX       LR               ;; return
        Nop      
        DATA
??_commit_command_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock243

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z15_enqueuecommandPKcb
          CFI Block cfiBlock244 Using cfiCommon0
          CFI Function _Z15_enqueuecommandPKcb
        THUMB
_Z15_enqueuecommandPKcb:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R1
        LDRSB    R1,[R0, #+0]
        CMP      R1,#+59
        BEQ.N    ??_enqueuecommand_0
        LDR.N    R2,??_enqueuecommand_1
        LDRB     R1,[R2, #+14]
        CMP      R1,#+4
        BLT.N    ??_enqueuecommand_2
??_enqueuecommand_0:
        MOVS     R0,#+0
        POP      {R4,PC}
??_enqueuecommand_2:
        MOV      R1,R0
        LDRB     R0,[R2, #+16]
        ADD      R3,R0,R0, LSL #+1
        ADD      R0,R2,R3, LSL #+5
        ADDS     R0,R0,#+140
          CFI FunCall strcpy
        BL       strcpy
        MOV      R0,R4
          CFI FunCall _Z15_commit_commandb
        BL       _Z15_commit_commandb
        MOVS     R0,#+1
        POP      {R4,PC}          ;; return
        DATA
??_enqueuecommand_1:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock244

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z19get_serial_commandsv
          CFI Block cfiBlock245 Using cfiCommon0
          CFI Function _Z19get_serial_commandsv
        THUMB
_Z19get_serial_commandsv:
        PUSH     {R3-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+32
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        MOV      R5,R0
        LDR.N    R4,??get_serial_commands_0
        LDRB     R0,[R4, #+14]
        CMP      R0,#+0
        BNE.W    ??get_serial_commands_1
        LDR.N    R0,??get_serial_commands_0+0x4
          CFI FunCall _ZN10USARTClass9availableEv
        BL       _ZN10USARTClass9availableEv
        CMP      R0,#+0
        BNE.W    ??get_serial_commands_1
        LDR.N    R0,??get_serial_commands_0+0x8
        LDR      R1,[R0, #+0]
        SUBS     R1,R5,R1
        SUBS     R1,R1,#+1000
        BMI.W    ??get_serial_commands_1
        LDRB     R1,[R4, #+22]
        CMP      R1,#+6
        BGE.N    ??get_serial_commands_2
        ADDS     R1,R1,#+1
        STRB     R1,[R4, #+22]
??get_serial_commands_2:
        STR      R5,[R0, #+0]
        B.N      ??get_serial_commands_1
??get_serial_commands_3:
        ADDS     R6,R6,#+1
??get_serial_commands_4:
        LDRSB    R0,[R6, #+0]
        CMP      R0,#+32
        BEQ.N    ??get_serial_commands_3
        CMP      R0,#+78
        BNE.N    ??get_serial_commands_5
        MOV      R9,R6
        B.N      ??get_serial_commands_6
??get_serial_commands_5:
        MOV      R9,#+0
??get_serial_commands_6:
        CMP      R9,#+0
        BEQ.N    ??get_serial_commands_7
        LDR.N    R1,??get_serial_commands_0+0xC
        MOV      R0,R6
          CFI FunCall _Z6strstrPcPKc
        BL       _Z6strstrPcPKc
        CMP      R0,#+0
        BEQ.N    ??get_serial_commands_8
        MOV      R8,#+1
        B.N      ??get_serial_commands_9
??get_serial_commands_8:
        MOV      R8,#+0
??get_serial_commands_9:
        CMP      R8,#+0
        BEQ.N    ??get_serial_commands_10
        MOVS     R1,#+78
        ADDS     R0,R6,#+4
          CFI FunCall _Z6strchrPci
        BL       _Z6strchrPci
        CMP      R0,#+0
        BEQ.N    ??get_serial_commands_10
        MOV      R9,R0
??get_serial_commands_10:
        MOVS     R2,#+10
        MOVS     R1,#+0
        ADD      R0,R9,#+1
          CFI FunCall strtol
        BL       strtol
        STR      R0,[R4, #+116]
        LDR      R1,[R7, #+4]
        ADDS     R1,R1,#+1
        CMP      R0,R1
        BEQ.N    ??get_serial_commands_11
        CMP      R8,#+0
        BNE.N    ??get_serial_commands_11
        MOVS     R1,#+1
        LDR.N    R0,??get_serial_commands_0+0x10
        POP      {R2,R4-R9,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z16gcode_line_errorPKcb
        B.W      _Z16gcode_line_errorPKcb
          CFI R4 Frame(CFA, -28)
          CFI R5 Frame(CFA, -24)
          CFI R6 Frame(CFA, -20)
          CFI R7 Frame(CFA, -16)
          CFI R8 Frame(CFA, -12)
          CFI R9 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+32
??get_serial_commands_11:
        MOVS     R1,#+42
        MOV      R0,R6
          CFI FunCall _Z7strrchrPci
        BL       _Z7strrchrPci
        CMP      R0,#+0
        BEQ.N    ??get_serial_commands_12
        MOV      R8,#+0
        SUBS     R1,R0,R6
        B.N      ??get_serial_commands_13
??get_serial_commands_14:
        SUBS     R1,R1,#+1
        UXTB     R1,R1
        LDRSB    R2,[R1, R6]
        EOR      R8,R2,R8
??get_serial_commands_13:
        UXTB     R1,R1
        CMP      R1,#+0
        BNE.N    ??get_serial_commands_14
        MOVS     R2,#+10
        MOVS     R1,#+0
        ADDS     R0,R0,#+1
          CFI FunCall strtol
        BL       strtol
        UXTB     R8,R8
        CMP      R0,R8
        BEQ.N    ??get_serial_commands_15
        MOVS     R1,#+1
        LDR.N    R0,??get_serial_commands_0+0x14
        POP      {R2,R4-R9,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z16gcode_line_errorPKcb
        B.W      _Z16gcode_line_errorPKcb
          CFI R4 Frame(CFA, -28)
          CFI R5 Frame(CFA, -24)
          CFI R6 Frame(CFA, -20)
          CFI R7 Frame(CFA, -16)
          CFI R8 Frame(CFA, -12)
          CFI R9 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+32
??get_serial_commands_15:
        LDR      R0,[R4, #+116]
        STR      R0,[R7, #+4]
??get_serial_commands_7:
          CFI FunCall _Z9IsStoppedv
        BL       _Z9IsStoppedv
        CMP      R0,#+0
        BEQ.N    ??get_serial_commands_16
        MOVS     R1,#+71
        MOV      R0,R6
          CFI FunCall _Z6strchrPci
        BL       _Z6strchrPci
        CMP      R0,#+0
        BEQ.N    ??get_serial_commands_16
        MOVS     R2,#+10
        MOVS     R1,#+0
        ADDS     R0,R0,#+1
          CFI FunCall strtol
        BL       strtol
        CMP      R0,#+3
        BHI.N    ??get_serial_commands_16
        LDR.N    R0,??get_serial_commands_0+0x18
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R1,#+0
        LDR.N    R0,??get_serial_commands_0+0x1C
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
??get_serial_commands_16:
        LDR.N    R1,??get_serial_commands_0+0x20
        MOV      R0,R6
          CFI FunCall strcmp
        BL       strcmp
        CMP      R0,#+0
        BNE.N    ??get_serial_commands_17
        MOVS     R0,#+0
        STRB     R0,[R4, #+20]
??get_serial_commands_17:
        LDR.N    R1,??get_serial_commands_0+0x24
        MOV      R0,R6
          CFI FunCall strcmp
        BL       strcmp
        CMP      R0,#+0
        BNE.N    ??get_serial_commands_18
        LDR.N    R0,??get_serial_commands_0+0x28
          CFI FunCall _Z4killPKc
        BL       _Z4killPKc
??get_serial_commands_18:
        LDR.N    R1,??get_serial_commands_0+0x2C
        MOV      R0,R6
          CFI FunCall strcmp
        BL       strcmp
        CMP      R0,#+0
        BNE.N    ??get_serial_commands_19
          CFI FunCall _Z17quickstop_stepperv
        BL       _Z17quickstop_stepperv
??get_serial_commands_19:
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall _Z15_enqueuecommandPKcb
        BL       _Z15_enqueuecommandPKcb
??get_serial_commands_1:
        LDRB     R0,[R4, #+14]
        CMP      R0,#+4
        BGE.N    ??get_serial_commands_20
        LDR.N    R5,??get_serial_commands_0+0x4
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass4readEv
        BL       _ZN10USARTClass4readEv
        CMP      R0,#+0
        BMI.N    ??get_serial_commands_20
        SXTB     R0,R0
        MOVS     R1,#+0
        STRB     R1,[R4, #+22]
        CMP      R0,#+10
        BEQ.N    ??get_serial_commands_21
        CMP      R0,#+13
        BNE.N    ??get_serial_commands_22
??get_serial_commands_21:
        MOV      R0,R1
        LDR.N    R1,??get_serial_commands_0+0x30
        STRB     R0,[R1, #+0]
        LDR.N    R7,??get_serial_commands_0+0x34
        LDR      R1,[R7, #+12]
        CMP      R1,#+0
        BEQ.N    ??get_serial_commands_1
        LDR.N    R5,??get_serial_commands_0+0x38
        STRB     R0,[R1, R5]
        STR      R0,[R7, #+12]
        MOV      R6,R5
        B.N      ??get_serial_commands_4
??get_serial_commands_12:
        MOVS     R1,#+1
        LDR.N    R0,??get_serial_commands_0+0x3C
        POP      {R2,R4-R9,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z16gcode_line_errorPKcb
        B.W      _Z16gcode_line_errorPKcb
          CFI R4 Frame(CFA, -28)
          CFI R5 Frame(CFA, -24)
          CFI R6 Frame(CFA, -20)
          CFI R7 Frame(CFA, -16)
          CFI R8 Frame(CFA, -12)
          CFI R9 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+32
??get_serial_commands_22:
        LDR.N    R7,??get_serial_commands_0+0x34
        LDR      R1,[R7, #+12]
        CMP      R1,#+95
        BGE.N    ??get_serial_commands_1
        CMP      R0,#+92
        BNE.N    ??get_serial_commands_23
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass4readEv
        BL       _ZN10USARTClass4readEv
        CMP      R0,#+0
        BMI.N    ??get_serial_commands_1
        LDR.N    R1,??get_serial_commands_0+0x30
        LDRB     R1,[R1, #+0]
        CMP      R1,#+0
        BNE.N    ??get_serial_commands_1
        LDR      R1,[R7, #+12]
        LDR.N    R2,??get_serial_commands_0+0x38
        STRB     R0,[R1, R2]
        ADDS     R0,R1,#+1
        STR      R0,[R7, #+12]
        B.N      ??get_serial_commands_1
??get_serial_commands_23:
        LDR.N    R2,??get_serial_commands_0+0x30
        CMP      R0,#+59
        BNE.N    ??get_serial_commands_24
        MOVS     R3,#+1
        STRB     R3,[R2, #+0]
??get_serial_commands_24:
        LDRB     R2,[R2, #+0]
        CMP      R2,#+0
        BNE.N    ??get_serial_commands_1
        LDR.N    R2,??get_serial_commands_0+0x38
        STRB     R0,[R1, R2]
        ADDS     R0,R1,#+1
        STR      R0,[R7, #+12]
        B.N      ??get_serial_commands_1
??get_serial_commands_20:
        POP      {R0,R4-R9,PC}    ;; return
        Nop      
        DATA
??get_serial_commands_0:
        DC32     axis_relative_modes
        DC32     Serial6
        DC32     _ZZ19get_serial_commandsvE14last_wait_time
        DC32     _ZZ19get_serial_commandsvEs
        DC32     _ZZ19get_serial_commandsvEs_0
        DC32     _ZZ19get_serial_commandsvEs_1
        DC32     _ZZ19get_serial_commandsvEs_3
        DC32     _ZZ19get_serial_commandsvEs_4
        DC32     _ZZ19get_serial_commandsvEs_5
        DC32     _ZZ19get_serial_commandsvEs_6
        DC32     _ZZ19get_serial_commandsvEs_7
        DC32     _ZZ19get_serial_commandsvEs_8
        DC32     _ZZ19get_serial_commandsvE19serial_comment_mode
        DC32     Running
        DC32     _ZZ19get_serial_commandsvE18serial_line_buffer
        DC32     _ZZ19get_serial_commandsvEs_2
          CFI EndBlock cfiBlock245

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z24get_homing_bump_feedrate8AxisEnum
          CFI Block cfiBlock246 Using cfiCommon0
          CFI Function _Z24get_homing_bump_feedrate8AxisEnum
        THUMB
_Z24get_homing_bump_feedrate8AxisEnum:
        PUSH     {R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        SUB      SP,SP,#+20
          CFI CFA R13+32
        MOV      R4,R0
        MOVS     R0,#+2
        STR      R0,[SP, #+0]
        ADD      R0,SP,#+0
        MOVS     R1,#+2
        STR      R1,[R0, #+4]
        MOVS     R1,#+4
        STR      R1,[SP, #+8]
        LDRB     R5,[R0, R4, LSL #+2]
        CMP      R5,#+0
        BNE.N    ??get_homing_bump_feedrate_0
        MOVS     R5,#+10
        LDR.N    R0,??get_homing_bump_feedrate_1
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??get_homing_bump_feedrate_1+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??get_homing_bump_feedrate_0:
        VMOV     S0,R5
        VCVT.F32.U32 S0,S0
        LDR.N    R0,??get_homing_bump_feedrate_1+0x8
        ADD      R0,R0,R4, LSL #+2
        VLDR     S1,[R0, #+64]
        VDIV.F32 S0,S1,S0
        ADD      SP,SP,#+20
          CFI CFA R13+12
        POP      {R4,R5,PC}       ;; return
        DATA
??get_homing_bump_feedrate_1:
        DC32     echomagic
        DC32     _ZZ24get_homing_bump_feedrate8AxisEnumEs
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock246

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z31buffer_line_to_current_positionv
          CFI Block cfiBlock247 Using cfiCommon0
          CFI Function _Z31buffer_line_to_current_positionv
        THUMB
_Z31buffer_line_to_current_positionv:
        LDR.N    R3,??buffer_line_to_current_position_0
        LDRB     R2,[R3, #+18]
        ADD      R1,R3,#+120
        ADD      R0,R3,#+44
        VLDR     S2,[R3, #+40]
        VLDR     S1,[R3, #+36]
        VLDR     S0,[R3, #+32]
          CFI FunCall _ZN7Planner11buffer_lineEfffRKfS1_h
        B.W      _ZN7Planner11buffer_lineEfffRKfS1_h
        DATA
??buffer_line_to_current_position_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock247

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z26buffer_line_to_destinationf
          CFI Block cfiBlock248 Using cfiCommon0
          CFI Function _Z26buffer_line_to_destinationf
        THUMB
_Z26buffer_line_to_destinationf:
        PUSH     {LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+4
        VPUSH    {S0}
          CFI CFA R13+8
        LDR.N    R3,??buffer_line_to_destination_0
        LDRB     R2,[R3, #+18]
        ADD      R1,SP,#+0
        ADD      R0,R3,#+60
        VLDR     S2,[R3, #+56]
        VLDR     S1,[R3, #+52]
        VLDR     S0,[R3, #+48]
          CFI FunCall _ZN7Planner11buffer_lineEfffRKfS1_h
        BL       _ZN7Planner11buffer_lineEfffRKfS1_h
        POP      {R0,PC}          ;; return
        Nop      
        DATA
??buffer_line_to_destination_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock248

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z11gcode_G0_G1v
          CFI Block cfiBlock249 Using cfiCommon0
          CFI Function _Z11gcode_G0_G1v
        THUMB
_Z11gcode_G0_G1v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _Z9IsRunningv
        BL       _Z9IsRunningv
        CMP      R0,#+0
        BEQ.N    ??gcode_G0_G1_0
          CFI FunCall _Z21gcode_get_destinationv
        BL       _Z21gcode_get_destinationv
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z27prepare_move_to_destinationv
        B.W      _Z27prepare_move_to_destinationv
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_G0_G1_0:
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock249

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z11gcode_G2_G3b
          CFI Block cfiBlock250 Using cfiCommon0
          CFI Function _Z11gcode_G2_G3b
        THUMB
_Z11gcode_G2_G3b:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        VPUSH    {D8-D14}
          CFI D14 Frame(CFA, -24)
          CFI D13 Frame(CFA, -32)
          CFI D12 Frame(CFA, -40)
          CFI D11 Frame(CFA, -48)
          CFI D10 Frame(CFA, -56)
          CFI D9 Frame(CFA, -64)
          CFI D8 Frame(CFA, -72)
          CFI CFA R13+72
        SUB      SP,SP,#+8
          CFI CFA R13+80
        MOV      R4,R0
          CFI FunCall _Z9IsRunningv
        BL       _Z9IsRunningv
        CMP      R0,#+0
        BEQ.W    ??gcode_G2_G3_0
          CFI FunCall _Z21gcode_get_destinationv
        BL       _Z21gcode_get_destinationv
        ADD      R0,SP,#+0
        MOVS     R1,#+0
        MOV      R2,R1
        STM      R0!,{R1,R2}
        MOVS     R0,#+82
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.W    ??gcode_G2_G3_1
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        VMOV.F32 S16,S0
        LDR.N    R0,??gcode_G2_G3_2+0x4
        VLDR     S20,[R0, #+32]
        VLDR     S21,[R0, #+36]
        VLDR     S22,[R0, #+48]
        VLDR     S23,[R0, #+52]
        VCMP.F32 S16,#0.0
        FMSTAT   
        BEQ.W    ??gcode_G2_G3_3
        VCMP.F32 S22,S20
        FMSTAT   
        BNE.N    ??gcode_G2_G3_4
        VCMP.F32 S23,S21
        FMSTAT   
        BEQ.W    ??gcode_G2_G3_3
??gcode_G2_G3_4:
        VCMP.F32 S16,#0.0
        FMSTAT   
        BPL.N    ??gcode_G2_G3_5
        MOVS     R0,#+1
        B.N      ??gcode_G2_G3_6
??gcode_G2_G3_5:
        MOVS     R0,#+0
??gcode_G2_G3_6:
        VMOV.F32 S27,#1.0
        TEQ      R0,R4
        BEQ.N    ??gcode_G2_G3_7
        VMOV.F32 S24,#-1.0
        B.N      ??gcode_G2_G3_8
??gcode_G2_G3_7:
        VMOV.F32 S24,S27
??gcode_G2_G3_8:
        VSUB.F32 S25,S22,S20
        VSUB.F32 S26,S23,S21
        VMOV.F32 S0,S25
        MOVS     R0,#+2
        VMOV.F32 S1,S27
        B.N      ??gcode_G2_G3_9
??gcode_G2_G3_10:
        VMUL.F32 S0,S0,S0
??gcode_G2_G3_9:
        LSLS     R1,R0,#+31
        BPL.N    ??gcode_G2_G3_11
        VMUL.F32 S1,S1,S0
??gcode_G2_G3_11:
        LSRS     R0,R0,#+1
        BNE.N    ??gcode_G2_G3_10
        VMOV.F32 S0,S26
        MOVS     R0,#+2
        VMOV.F32 S2,S27
        B.N      ??gcode_G2_G3_12
??gcode_G2_G3_13:
        VMUL.F32 S0,S0,S0
??gcode_G2_G3_12:
        LSLS     R1,R0,#+31
        BPL.N    ??gcode_G2_G3_14
        VMUL.F32 S2,S2,S0
??gcode_G2_G3_14:
        LSRS     R0,R0,#+1
        BNE.N    ??gcode_G2_G3_13
        VADD.F32 S0,S1,S2
          CFI FunCall sqrtf
        BL       sqrtf
        VMOV.F32 S28,S0
        MOVS     R0,#+2
        B.N      ??gcode_G2_G3_15
??gcode_G2_G3_16:
        VMUL.F32 S16,S16,S16
??gcode_G2_G3_15:
        LSLS     R1,R0,#+31
        BPL.N    ??gcode_G2_G3_17
        VMUL.F32 S27,S27,S16
??gcode_G2_G3_17:
        LSRS     R0,R0,#+1
        BNE.N    ??gcode_G2_G3_16
        VMOV     R0,S28
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOVS     R2,#+0
        LDR.N    R3,??gcode_G2_G3_2+0x8  ;; 0x3fe00000
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        VMOV     D8,R0,R1
        MOVS     R5,#+2
        VLDR.W   D9,??gcode_G2_G3_2+0xC
        B.N      ??gcode_G2_G3_18
??gcode_G2_G3_19:
        VMOV     R0,R1,D8
        VMOV     R2,R3,D8
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        VMOV     D8,R0,R1
??gcode_G2_G3_18:
        LSLS     R0,R5,#+31
        BPL.N    ??gcode_G2_G3_20
        VMOV     R0,R1,D9
        VMOV     R2,R3,D8
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        VMOV     D9,R0,R1
??gcode_G2_G3_20:
        LSRS     R5,R5,#+1
        BNE.N    ??gcode_G2_G3_19
        VMOV     R0,S27
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        VMOV     R2,R3,D9
          CFI FunCall __aeabi_dsub
        BL       __aeabi_dsub
        VMOV     D0,R0,R1
          CFI FunCall sqrt
        BL       sqrt
        VMOV     R0,R1,D0
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        VMOV     S0,R0
        VMUL.F32 S0,S24,S0
        VMOV.F32 S1,#0.5
        VADD.F32 S2,S20,S22
        VMUL.F32 S2,S2,S1
        VDIV.F32 S3,S26,S28
        VMLS.F32 S2,S0,S3
        VSUB.F32 S2,S2,S20
        VSTR     S2,[SP, #+0]
        VADD.F32 S2,S21,S23
        VMUL.F32 S1,S2,S1
        VDIV.F32 S2,S25,S28
        VMLA.F32 S1,S0,S2
        VSUB.F32 S0,S1,S21
        VSTR     S0,[SP, #+4]
        B.N      ??gcode_G2_G3_3
??gcode_G2_G3_1:
        MOVS     R0,#+73
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G2_G3_21
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        VSTR     S0,[SP, #+0]
??gcode_G2_G3_21:
        MOVS     R0,#+74
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G2_G3_3
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        VSTR     S0,[SP, #+4]
??gcode_G2_G3_3:
        VLDR     S0,[SP, #+0]
        VCMP.F32 S0,#0.0
        FMSTAT   
        BNE.N    ??gcode_G2_G3_22
        VLDR     S0,[SP, #+4]
        VCMP.F32 S0,#0.0
        FMSTAT   
        BEQ.N    ??gcode_G2_G3_23
??gcode_G2_G3_22:
        MOV      R2,R4
        ADD      R1,SP,#+0
        LDR.N    R0,??gcode_G2_G3_2+0x14
          CFI FunCall _Z8plan_arcRA4_KfRA2_S_b
        BL       _Z8plan_arcRA4_KfRA2_S_b
          CFI FunCall _Z19refresh_cmd_timeoutv
        BL       _Z19refresh_cmd_timeoutv
        B.N      ??gcode_G2_G3_0
??gcode_G2_G3_23:
        LDR.N    R0,??gcode_G2_G3_2+0x18
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_G2_G3_2
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??gcode_G2_G3_0:
        ADD      SP,SP,#+8
          CFI CFA R13+72
        VPOP     {D8-D14}
          CFI D8 SameValue
          CFI D9 SameValue
          CFI D10 SameValue
          CFI D11 SameValue
          CFI D12 SameValue
          CFI D13 SameValue
          CFI D14 SameValue
          CFI CFA R13+16
        POP      {R0,R4,R5,PC}    ;; return
        Nop      
        DATA
??gcode_G2_G3_2:
        DC32     _ZZ11gcode_G2_G3bEs
        DC32     axis_relative_modes
        DC32     0x3fe00000
        DC32     0x0,0x3FF00000
        DC32     axis_relative_modes+0x30
        DC32     errormagic
          CFI EndBlock cfiBlock250

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z8gcode_G4v
          CFI Block cfiBlock251 Using cfiCommon0
          CFI Function _Z8gcode_G4v
        THUMB
_Z8gcode_G4v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R4,#+0
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G4_0
          CFI FunCall _ZN11GCodeParser12value_millisEv
        BL       _ZN11GCodeParser12value_millisEv
        MOV      R4,R0
??gcode_G4_0:
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G4_1
          CFI FunCall _ZN11GCodeParser25value_millis_from_secondsEv
        BL       _ZN11GCodeParser25value_millis_from_secondsEv
        MOV      R4,R0
??gcode_G4_1:
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
          CFI FunCall _Z13lcd_hasstatusv
        BL       _Z13lcd_hasstatusv
        CMP      R0,#+0
        BNE.N    ??gcode_G4_2
        MOVS     R1,#+0
        LDR.N    R0,??gcode_G4_3
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
??gcode_G4_2:
        MOV      R0,R4
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z5dwellm
        B.W      _Z5dwellm
        Nop      
        DATA
??gcode_G4_3:
        DC32     _ZZ8gcode_G4vEs
          CFI EndBlock cfiBlock251

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_G28b
          CFI Block cfiBlock252 Using cfiCommon0
          CFI Function _Z9gcode_G28b
        THUMB
_Z9gcode_G28b:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        SUB      SP,SP,#+8
          CFI CFA R13+32
        MOV      R5,R0
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
          CFI FunCall _Z31setup_for_endstop_or_probe_movev
        BL       _Z31setup_for_endstop_or_probe_movev
        MOVS     R0,#+1
          CFI FunCall _ZN8Endstops6enableEb
        BL       _ZN8Endstops6enableEb
        CMP      R5,#+0
        BNE.N    ??gcode_G28_0
        MOVS     R0,#+88
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOV      R6,R0
        B.N      ??gcode_G28_1
??gcode_G28_0:
        MOVS     R6,#+1
??gcode_G28_1:
        CMP      R5,#+0
        BNE.N    ??gcode_G28_2
        MOVS     R0,#+89
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOV      R4,R0
        B.N      ??gcode_G28_3
??gcode_G28_2:
        MOVS     R4,#+1
??gcode_G28_3:
        CMP      R5,#+0
        BNE.N    ??gcode_G28_4
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOV      R5,R0
        B.N      ??gcode_G28_5
??gcode_G28_4:
        MOVS     R5,#+1
??gcode_G28_5:
        ORR      R0,R4,R6
        ORRS     R0,R5,R0
        EOR      R0,R0,#0x1
        AND      R1,R4,R6
        ANDS     R1,R5,R1
        ORR      R7,R1,R0
          CFI FunCall _Z28set_destination_from_currentv
        BL       _Z28set_destination_from_currentv
        LDR.W    R8,??gcode_G28_6
        LDRSB    R0,[R8, #+1]
        CMP      R0,#+1
        BLT.N    ??gcode_G28_7
        ORRS     R0,R5,R7
        BEQ.N    ??gcode_G28_7
        MOVS     R0,#+2
          CFI FunCall _Z8homeaxis8AxisEnum
        BL       _Z8homeaxis8AxisEnum
??gcode_G28_7:
        ORRS     R6,R6,R7
        ORRS     R0,R4,R6
        BEQ.N    ??gcode_G28_8
        LDR.N    R0,??gcode_G28_6+0x4
        MOVS     R1,#+0
        STR      R1,[R0, #+56]
        VLDR     S0,[R0, #+40]
        VCMP.F32 S0,#0.0
        FMSTAT   
        BPL.N    ??gcode_G28_8
        STR      R1,[SP, #+0]
        ADD      R1,SP,#+0
        ADDS     R0,R0,#+56
          CFI FunCall _Z21do_blocking_move_to_zRKfS0_
        BL       _Z21do_blocking_move_to_zRKfS0_
??gcode_G28_8:
        CMP      R6,#+0
        BEQ.N    ??gcode_G28_9
        MOVS     R0,#+0
          CFI FunCall _Z8homeaxis8AxisEnum
        BL       _Z8homeaxis8AxisEnum
??gcode_G28_9:
        ORRS     R0,R4,R7
        BEQ.N    ??gcode_G28_10
        MOVS     R0,#+1
          CFI FunCall _Z8homeaxis8AxisEnum
        BL       _Z8homeaxis8AxisEnum
??gcode_G28_10:
        LDRSB    R0,[R8, #+1]
        CMP      R0,#+0
        BPL.N    ??gcode_G28_11
        ORRS     R0,R5,R7
        BEQ.N    ??gcode_G28_11
        MOVS     R0,#+2
          CFI FunCall _Z8homeaxis8AxisEnum
        BL       _Z8homeaxis8AxisEnum
??gcode_G28_11:
          CFI FunCall _Z18sync_plan_positionv
        BL       _Z18sync_plan_positionv
          CFI FunCall _ZN8Endstops10not_homingEv
        BL       _ZN8Endstops10not_homingEv
          CFI FunCall _Z36clean_up_after_endstop_or_probe_movev
        BL       _Z36clean_up_after_endstop_or_probe_movev
          CFI FunCall _Z11lcd_refreshv
        BL       _Z11lcd_refreshv
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
        POP      {R0,R1,R4-R8,PC}  ;; return
        Nop      
        DATA
??gcode_G28_6:
        DC32     mksCfg
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock252

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_G92v
          CFI Block cfiBlock253 Using cfiCommon0
          CFI Function _Z9gcode_G92v
        THUMB
_Z9gcode_G92v:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        MOVS     R4,#+0
        MOV      R5,R4
        MOV      R6,R4
        B.N      ??gcode_G92_0
??gcode_G92_1:
        MOVS     R5,#+1
??gcode_G92_2:
        VSTR     S0,[R0, #+32]
??gcode_G92_3:
        ADDS     R6,R6,#+1
??gcode_G92_0:
        CMP      R6,#+4
        BGE.N    ??gcode_G92_4
        LDR.N    R0,??gcode_G92_5+0x8
        LDRSB    R0,[R6, R0]
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G92_3
        MOV      R0,R6
        SXTB     R0,R0
          CFI FunCall _ZN11GCodeParser16value_axis_unitsE8AxisEnum
        BL       _ZN11GCodeParser16value_axis_unitsE8AxisEnum
        CMP      R6,#+3
        BEQ.N    ??gcode_G92_6
        LDR.N    R0,??gcode_G92_5+0xC
        ADD      R0,R0,R6, LSL #+2
        VLDR     S1,[R0, #0]
        VSUB.F32 S0,S0,S1
??gcode_G92_6:
        LDR.N    R0,??gcode_G92_5+0x10
        ADD      R0,R0,R6, LSL #+2
        VLDR     S1,[R0, #+32]
        VSUB.F32 S1,S0,S1
        VLDR.W   S2,??gcode_G92_5  ;; 0xb58637bd
        VCMP.F32 S1,S2
        FMSTAT   
        BLT.N    ??gcode_G92_7
        VLDR.W   S2,??gcode_G92_5+0x4  ;; 0x358637be
        VCMP.F32 S1,S2
        FMSTAT   
        BMI.N    ??gcode_G92_3
??gcode_G92_7:
        CMP      R6,#+3
        BNE.N    ??gcode_G92_1
        MOVS     R4,#+1
        B.N      ??gcode_G92_2
??gcode_G92_4:
        CMP      R5,#+0
        BEQ.N    ??gcode_G92_8
          CFI FunCall _Z18sync_plan_positionv
        BL       _Z18sync_plan_positionv
        B.N      ??gcode_G92_9
??gcode_G92_8:
        CMP      R4,#+0
        BEQ.N    ??gcode_G92_9
          CFI FunCall _Z20sync_plan_position_ev
        BL       _Z20sync_plan_position_ev
??gcode_G92_9:
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z23report_current_positionv
        B.W      _Z23report_current_positionv
        DATA
??gcode_G92_5:
        DC32     0xb58637bd
        DC32     0x358637be
        DC32     axis_codes
        DC32     workspace_offset
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock253

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M17v
          CFI Block cfiBlock254 Using cfiCommon0
          CFI Function _Z9gcode_M17v
        THUMB
_Z9gcode_M17v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M17_0
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z19enable_all_steppersv
        B.W      _Z19enable_all_steppersv
        Nop      
        DATA
??gcode_M17_0:
        DC32     _ZZ9gcode_M17vEs
          CFI EndBlock cfiBlock254

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M20v
          CFI Block cfiBlock255 Using cfiCommon0
          CFI Function _Z9gcode_M20v
        THUMB
_Z9gcode_M20v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R0,??gcode_M20_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M20_0+0x4
          CFI FunCall _ZN10CardReader2lsEv
        BL       _ZN10CardReader2lsEv
        LDR.N    R0,??gcode_M20_0+0x8
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
        DATA
??gcode_M20_0:
        DC32     _ZZ9gcode_M20vEs
        DC32     card
        DC32     _ZZ9gcode_M20vEs_0
          CFI EndBlock cfiBlock255

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M22v
          CFI Block cfiBlock256 Using cfiCommon0
          CFI Function _Z9gcode_M22v
        THUMB
_Z9gcode_M22v:
        LDR.N    R0,??gcode_M22_0
          CFI FunCall _ZN10CardReader7releaseEv
        B.W      _ZN10CardReader7releaseEv
        Nop      
        DATA
??gcode_M22_0:
        DC32     card
          CFI EndBlock cfiBlock256

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M23v
          CFI Block cfiBlock257 Using cfiCommon0
          CFI Function _Z9gcode_M23v
        THUMB
_Z9gcode_M23v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R0,??gcode_M23_0
        LDR      R1,[R0, #+0]
        B.N      ??gcode_M23_1
??gcode_M23_2:
        CMP      R2,#+32
        BNE.N    ??gcode_M23_3
        MOVS     R2,#+0
        STRB     R2,[R1, #+0]
??gcode_M23_3:
        ADDS     R1,R1,#+1
??gcode_M23_1:
        LDRSB    R2,[R1, #+0]
        CMP      R2,#+0
        BNE.N    ??gcode_M23_2
        LDR.N    R4,??gcode_M23_0+0x4
        MOVS     R3,#+1
        MOV      R2,R3
        LDR      R1,[R0, #+0]
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8openFileEPcbb
        BL       _ZN10CardReader8openFileEPcbb
        ADDW     R1,R4,#+3268
        LDR.N    R0,??gcode_M23_0+0x8
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall strcpy
        B.W      strcpy
        Nop      
        DATA
??gcode_M23_0:
        DC32     _ZN11GCodeParser10string_argE
        DC32     card
        DC32     curFileName
          CFI EndBlock cfiBlock257

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M24v
          CFI Block cfiBlock258 Using cfiCommon0
          CFI Function _Z9gcode_M24v
        THUMB
_Z9gcode_M24v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
          CFI FunCall mks_resumePrint
        BL       mks_resumePrint
        LDR.N    R4,??gcode_M24_0
        LDRB     R0,[R4, #+3336]
        CMP      R0,#+170
        BEQ.N    ??gcode_M24_1
        CMP      R0,#+171
        BEQ.N    ??gcode_M24_1
        MOV      R0,R4
          CFI FunCall _ZN10CardReader14startFileprintEv
        BL       _ZN10CardReader14startFileprintEv
        ADDW     R0,R4,#+3464
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN9Stopwatch5startEv
        B.W      _ZN9Stopwatch5startEv
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M24_1:
        POP      {R4,PC}          ;; return
        DATA
??gcode_M24_0:
        DC32     card
          CFI EndBlock cfiBlock258

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M25v
          CFI Block cfiBlock259 Using cfiCommon0
          CFI Function _Z9gcode_M25v
        THUMB
_Z9gcode_M25v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R4,??gcode_M25_0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader12pauseSDPrintEv
        BL       _ZN10CardReader12pauseSDPrintEv
        ADDW     R0,R4,#+3464
          CFI FunCall _ZN9Stopwatch5pauseEv
        BL       _ZN9Stopwatch5pauseEv
        MOVS     R0,#+168
        STRB     R0,[R4, #+3336]
        POP      {R4,PC}          ;; return
        Nop      
        DATA
??gcode_M25_0:
        DC32     card
          CFI EndBlock cfiBlock259

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M998v
          CFI Block cfiBlock260 Using cfiCommon0
          CFI Function _Z10gcode_M998v
        THUMB
_Z10gcode_M998v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R4,??gcode_M998_0
        LDRB     R0,[R4, #+3336]
        CMP      R0,#+171
        BEQ.N    ??gcode_M998_1
        MOVS     R0,#+166
        STRB     R0,[R4, #+3336]
        LDR.N    R0,??gcode_M998_0+0x4
        LDRB     R0,[R0, #+379]
        CMP      R0,#+1
        BEQ.N    ??gcode_M998_2
        MOVS     R2,#+1
        ADDW     R1,R4,#+3336
        MOV      R0,#+1000
          CFI FunCall epr_write_data
        BL       epr_write_data
??gcode_M998_2:
        MOV      R0,R4
          CFI FunCall _ZN10CardReader11stopSDPrintEv
        BL       _ZN10CardReader11stopSDPrintEv
          CFI FunCall _Z19clear_command_queuev
        BL       _Z19clear_command_queuev
          CFI FunCall _Z17quickstop_stepperv
        BL       _Z17quickstop_stepperv
        ADDW     R0,R4,#+3464
          CFI FunCall _ZN9Stopwatch4stopEv
        BL       _ZN9Stopwatch4stopEv
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
        MOVS     R0,#+0
        B.N      ??gcode_M998_3
??gcode_M998_4:
        MOVS     R0,#+0
        LDR.N    R1,??gcode_M998_0+0x8
        STR      R0,[R1, #+0]
        LDR.N    R1,??gcode_M998_0+0xC  ;; 0x42430294
        STR      R0,[R1, #+0]
        MOVS     R0,#+1
??gcode_M998_3:
        CMP      R0,#+0
        BEQ.N    ??gcode_M998_4
        MOVS     R0,#+0
        LDR.N    R1,??gcode_M998_0+0x10
        STRB     R0,[R1, #+20]
??gcode_M998_1:
        POP      {R4,PC}          ;; return
        DATA
??gcode_M998_0:
        DC32     card
        DC32     gCfgItems
        DC32     fanSpeeds
        DC32     0x42430294
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock260

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M26v
          CFI Block cfiBlock261 Using cfiCommon0
          CFI Function _Z9gcode_M26v
        THUMB
_Z9gcode_M26v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R4,??gcode_M26_0
        LDRB     R0,[R4, #+2491]
        CMP      R0,#+0
        BEQ.N    ??gcode_M26_1
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M26_1
          CFI FunCall _ZN11GCodeParser10value_longEv
        BL       _ZN11GCodeParser10value_longEv
        MOV      R1,R0
        MOV      R0,R4
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10CardReader8setIndexEl
        B.W      _ZN10CardReader8setIndexEl
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M26_1:
        POP      {R4,PC}          ;; return
        DATA
??gcode_M26_0:
        DC32     card
          CFI EndBlock cfiBlock261

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M27v
          CFI Block cfiBlock262 Using cfiCommon0
          CFI Function _Z9gcode_M27v
        THUMB
_Z9gcode_M27v:
        LDR.N    R0,??gcode_M27_0
          CFI FunCall _ZN10CardReader9getStatusEv
        B.W      _ZN10CardReader9getStatusEv
        Nop      
        DATA
??gcode_M27_0:
        DC32     card
          CFI EndBlock cfiBlock262

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M28v
          CFI Block cfiBlock263 Using cfiCommon0
          CFI Function _Z9gcode_M28v
        THUMB
_Z9gcode_M28v:
        MOVS     R3,#+1
        MOVS     R2,#+0
        LDR.N    R0,??gcode_M28_0
        LDR      R1,[R0, #+0]
        LDR.N    R0,??gcode_M28_0+0x4
          CFI FunCall _ZN10CardReader8openFileEPcbb
        B.W      _ZN10CardReader8openFileEPcbb
        Nop      
        DATA
??gcode_M28_0:
        DC32     _ZN11GCodeParser10string_argE
        DC32     card
          CFI EndBlock cfiBlock263

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z9gcode_M29v
          CFI Block cfiBlock264 Using cfiCommon0
          CFI Function _Z9gcode_M29v
          CFI NoCalls
        THUMB
_Z9gcode_M29v:
        BX       LR               ;; return
          CFI EndBlock cfiBlock264

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M30v
          CFI Block cfiBlock265 Using cfiCommon0
          CFI Function _Z9gcode_M30v
        THUMB
_Z9gcode_M30v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R4,??gcode_M30_0
        LDRB     R0,[R4, #+2491]
        CMP      R0,#+0
        BEQ.N    ??gcode_M30_1
        MOVS     R1,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader9closefileEb
        BL       _ZN10CardReader9closefileEb
        LDR.N    R0,??gcode_M30_0+0x4
        LDR      R1,[R0, #+0]
        MOV      R0,R4
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10CardReader10removeFileEPc
        B.W      _ZN10CardReader10removeFileEPc
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M30_1:
        POP      {R4,PC}          ;; return
        DATA
??gcode_M30_0:
        DC32     card
        DC32     _ZN11GCodeParser10string_argE
          CFI EndBlock cfiBlock265

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M31v
          CFI Block cfiBlock266 Using cfiCommon0
          CFI Function _Z9gcode_M31v
        THUMB
_Z9gcode_M31v:
        PUSH     {LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+4
        SUB      SP,SP,#+36
          CFI CFA R13+40
        LDR.N    R0,??gcode_M31_0
          CFI FunCall _ZN9Stopwatch8durationEv
        BL       _ZN9Stopwatch8durationEv
        STR      R0,[SP, #+0]
        ADD      R1,SP,#+0
        ADD      R0,SP,#+4
          CFI FunCall _ZN10duration_tC1ERKj
        BL       _ZN10duration_tC1ERKj
        ADD      R1,SP,#+8
          CFI FunCall _ZNK10duration_t8toStringEPc
        BL       _ZNK10duration_t8toStringEPc
        MOVS     R1,#+0
        ADD      R0,SP,#+8
          CFI FunCall _Z13lcd_setstatusPKcb
        BL       _Z13lcd_setstatusPKcb
        LDR.N    R0,??gcode_M31_0+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        ADD      R1,SP,#+8
        LDR.N    R0,??gcode_M31_0+0x8
          CFI FunCall _Z17serial_echopair_PPKcS0_
        BL       _Z17serial_echopair_PPKcS0_
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M31_0+0xC
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        ADD      SP,SP,#+36
          CFI CFA R13+4
        POP      {PC}             ;; return
        DATA
??gcode_M31_0:
        DC32     card+0xD88
        DC32     echomagic
        DC32     _ZZ9gcode_M31vEs
        DC32     Serial6
          CFI EndBlock cfiBlock266

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M32v
          CFI Block cfiBlock267 Using cfiCommon0
          CFI Function _Z9gcode_M32v
        THUMB
_Z9gcode_M32v:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        LDR.N    R4,??gcode_M32_0
        LDRB     R0,[R4, #+2488]
        CMP      R0,#+0
        BEQ.N    ??gcode_M32_1
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
??gcode_M32_1:
        ADDW     R0,R4,#+2488
        LDRB     R1,[R0, #+3]
        LDRB     R0,[R0, #+4]
        ORRS     R0,R0,R1
        BEQ.N    ??gcode_M32_2
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser7boolvalEc
        BL       _ZN11GCodeParser7boolvalEc
        MOV      R5,R0
        MOV      R3,R5
        MOVS     R2,#+1
        LDR.N    R0,??gcode_M32_0+0x4
        LDR      R1,[R0, #+0]
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8openFileEPcbb
        BL       _ZN10CardReader8openFileEPcbb
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M32_3
          CFI FunCall _ZN11GCodeParser10value_longEv
        BL       _ZN11GCodeParser10value_longEv
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8setIndexEl
        BL       _ZN10CardReader8setIndexEl
??gcode_M32_3:
        MOV      R0,R4
          CFI FunCall _ZN10CardReader14startFileprintEv
        BL       _ZN10CardReader14startFileprintEv
        CMP      R5,#+0
        BNE.N    ??gcode_M32_2
        ADDW     R0,R4,#+3464
        POP      {R1,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN9Stopwatch5startEv
        B.W      _ZN9Stopwatch5startEv
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??gcode_M32_2:
        POP      {R0,R4,R5,PC}    ;; return
        DATA
??gcode_M32_0:
        DC32     card
        DC32     _ZN11GCodeParser10string_argE
          CFI EndBlock cfiBlock267

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M928v
          CFI Block cfiBlock268 Using cfiCommon0
          CFI Function _Z10gcode_M928v
        THUMB
_Z10gcode_M928v:
        LDR.N    R0,??gcode_M928_0
        LDR      R1,[R0, #+0]
        LDR.N    R0,??gcode_M928_0+0x4
          CFI FunCall _ZN10CardReader11openLogFileEPc
        B.W      _ZN10CardReader11openLogFileEPc
        Nop      
        DATA
??gcode_M928_0:
        DC32     _ZN11GCodeParser10string_argE
        DC32     card
          CFI EndBlock cfiBlock268

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M42v
          CFI Block cfiBlock269 Using cfiCommon0
          CFI Function _Z9gcode_M42v
        THUMB
_Z9gcode_M42v:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M42_0
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        MOV      R4,R0
        MOV      R1,#-1
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser6intvalEcs
        BL       _ZN11GCodeParser6intvalEcs
        MOVS     R5,R0
        BMI.N    ??gcode_M42_0
        SXTB     R0,R0
          CFI FunCall _Z16pin_is_protecteda
        BL       _Z16pin_is_protecteda
        CMP      R0,#+0
        BEQ.N    ??gcode_M42_1
        LDR.N    R0,??gcode_M42_2
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M42_2+0x4
        POP      {R1,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??gcode_M42_1:
        CMP      R5,#+0
        MOV      R2,R4
        SXTB     R2,R2
        BMI.N    ??gcode_M42_3
        LDR.N    R0,??gcode_M42_2+0x8
        LDRH     R1,[R0, R5, LSL #+1]
        LDR.N    R0,??gcode_M42_2+0xC
        LDR      R0,[R0, R5, LSL #+2]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        B.N      ??gcode_M42_4
??gcode_M42_3:
        MOVS     R1,#+0
        MOV      R0,R1
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
??gcode_M42_4:
        CMP      R5,#+8
        BNE.N    ??gcode_M42_0
        LDR.N    R0,??gcode_M42_2+0x10
        STR      R4,[R0, #+0]
??gcode_M42_0:
        POP      {R0,R4,R5,PC}    ;; return
        Nop      
        DATA
??gcode_M42_2:
        DC32     errormagic
        DC32     _ZZ9gcode_M42vEs
        DC32     gArrayGpioPin
        DC32     gArrayGpioPort
        DC32     fanSpeeds
          CFI EndBlock cfiBlock269

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M75v
          CFI Block cfiBlock270 Using cfiCommon0
          CFI Function _Z9gcode_M75v
        THUMB
_Z9gcode_M75v:
        LDR.N    R0,??gcode_M75_0
          CFI FunCall _ZN9Stopwatch5startEv
        B.W      _ZN9Stopwatch5startEv
        Nop      
        DATA
??gcode_M75_0:
        DC32     card+0xD88
          CFI EndBlock cfiBlock270

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M76v
          CFI Block cfiBlock271 Using cfiCommon0
          CFI Function _Z9gcode_M76v
        THUMB
_Z9gcode_M76v:
        LDR.N    R0,??gcode_M76_0
          CFI FunCall _ZN9Stopwatch5pauseEv
        B.W      _ZN9Stopwatch5pauseEv
        Nop      
        DATA
??gcode_M76_0:
        DC32     card+0xD88
          CFI EndBlock cfiBlock271

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M77v
          CFI Block cfiBlock272 Using cfiCommon0
          CFI Function _Z9gcode_M77v
        THUMB
_Z9gcode_M77v:
        LDR.N    R0,??gcode_M77_0
          CFI FunCall _ZN9Stopwatch4stopEv
        B.W      _ZN9Stopwatch4stopEv
        Nop      
        DATA
??gcode_M77_0:
        DC32     card+0xD88
          CFI EndBlock cfiBlock272

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M104v
          CFI Block cfiBlock273 Using cfiCommon0
          CFI Function _Z10gcode_M104v
        THUMB
_Z10gcode_M104v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        VPUSH    {D8}
          CFI D8 Frame(CFA, -16)
          CFI CFA R13+16
        MOVS     R0,#+104
          CFI FunCall _Z32get_target_extruder_from_commandt
        BL       _Z32get_target_extruder_from_commandt
        CMP      R0,#+0
        BNE.N    ??gcode_M104_1
        LDR.N    R4,??gcode_M104_2+0x4
        LDRB     R0,[R4, #+13]
        LSLS     R0,R0,#+28
        BMI.N    ??gcode_M104_1
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M104_3
          CFI FunCall _ZN11GCodeParser13value_celsiusEv
        BL       _ZN11GCodeParser13value_celsiusEv
        VCVT.S32.F32 S0,S0
        VMOV     R1,S0
        LDRB     R0,[R4, #+21]
        SXTH     R1,R1
        VMOV     S0,R1
        VCVT.F32.S32 S0,S0
          CFI FunCall _ZN11Temperature15setTargetHotendEfh
        BL       _ZN11Temperature15setTargetHotendEfh
          CFI FunCall _ZN11GCodeParser13value_celsiusEv
        BL       _ZN11GCodeParser13value_celsiusEv
        VLDR.W   S1,??gcode_M104_2  ;; 0x42aa0001
        VCMP.F32 S0,S1
        FMSTAT   
        BPL.N    ??gcode_M104_4
        LDR.N    R0,??gcode_M104_2+0x8
          CFI FunCall _ZN9Stopwatch4stopEv
        BL       _ZN9Stopwatch4stopEv
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M104_2+0xC
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
??gcode_M104_4:
        LDRB     R0,[R4, #+21]
          CFI FunCall _ZN11Temperature9degHotendEh
        BL       _ZN11Temperature9degHotendEh
        VMOV.F32 S16,S0
          CFI FunCall _ZN11GCodeParser13value_celsiusEv
        BL       _ZN11GCodeParser13value_celsiusEv
        VCMP.F32 S16,S0
        FMSTAT   
        BPL.N    ??gcode_M104_3
        LDRB     R0,[R4, #+21]
        CMP      R0,#+4
        BHI.N    ??gcode_M104_3
        TBB      [PC, R0]
        DATA
??gcode_M104_0:
        DC8      0x3,0x8,0xD,0x12
        DC8      0x17,0x0
        THUMB
??gcode_M104_5:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M104_2+0x10
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        B.N      ??gcode_M104_3
??gcode_M104_6:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M104_2+0x14
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        B.N      ??gcode_M104_3
??gcode_M104_7:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M104_2+0x18
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        B.N      ??gcode_M104_3
??gcode_M104_8:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M104_2+0x1C
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        B.N      ??gcode_M104_3
??gcode_M104_9:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M104_2+0x20
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
??gcode_M104_3:
        VPOP     {D8}
          CFI D8 SameValue
          CFI CFA R13+8
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Planner18autotemp_M104_M109Ev
        B.W      _ZN7Planner18autotemp_M104_M109Ev
          CFI D8 Frame(CFA, -16)
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??gcode_M104_1:
        VPOP     {D8}
          CFI D8 SameValue
          CFI CFA R13+8
        POP      {R4,PC}          ;; return
        DATA
??gcode_M104_2:
        DC32     0x42aa0001
        DC32     axis_relative_modes
        DC32     card+0xD88
        DC32     _ZZ10gcode_M104vEs
        DC32     _ZZ10gcode_M104vEs_0
        DC32     _ZZ10gcode_M104vEs_1
        DC32     _ZZ10gcode_M104vEs_2
        DC32     _ZZ10gcode_M104vEs_3
        DC32     _ZZ10gcode_M104vEs_4
          CFI EndBlock cfiBlock273

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M105v
          CFI Block cfiBlock274 Using cfiCommon0
          CFI Function _Z10gcode_M105v
        THUMB
_Z10gcode_M105v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+105
          CFI FunCall _Z32get_target_extruder_from_commandt
        BL       _Z32get_target_extruder_from_commandt
        CMP      R0,#+0
        BNE.N    ??gcode_M105_0
        LDR.N    R0,??gcode_M105_1
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M105_1+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M105_1+0x8
        POP      {R2,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M105_0:
        POP      {R0,PC}          ;; return
        Nop      
        DATA
??gcode_M105_1:
        DC32     errormagic
        DC32     _ZZ10gcode_M105vEs
        DC32     Serial6
          CFI EndBlock cfiBlock274

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M106v
          CFI Block cfiBlock275 Using cfiCommon0
          CFI Function _Z10gcode_M106v
        THUMB
_Z10gcode_M106v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R1,#+0
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser7bytevalEch
        BL       _ZN11GCodeParser7bytevalEch
        CMP      R0,#+0
        BNE.N    ??gcode_M106_0
        MOVS     R1,#+255
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser9ushortvalEct
        BL       _ZN11GCodeParser9ushortvalEct
        MOVS     R1,#+255
        CMP      R0,#+255
        BGT.N    ??gcode_M106_1
        MOV      R1,R0
??gcode_M106_1:
        LDR.N    R2,??gcode_M106_2
        STR      R1,[R2, #+0]
        MOVW     R1,#+10000
        MULS     R0,R1,R0
        MOVS     R1,#+255
        SDIV     R0,R0,R1
        LDR.N    R1,??gcode_M106_2+0x4  ;; 0x42430294
        STR      R0,[R1, #+0]
??gcode_M106_0:
        POP      {R0,PC}          ;; return
        DATA
??gcode_M106_2:
        DC32     fanSpeeds
        DC32     0x42430294
          CFI EndBlock cfiBlock275

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M107v
          CFI Block cfiBlock276 Using cfiCommon0
          CFI Function _Z10gcode_M107v
        THUMB
_Z10gcode_M107v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R1,#+0
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser9ushortvalEct
        BL       _ZN11GCodeParser9ushortvalEct
        CMP      R0,#+0
        BNE.N    ??gcode_M107_0
        MOVS     R0,#+0
        LDR.N    R1,??gcode_M107_1
        STR      R0,[R1, #+0]
        LDR.N    R1,??gcode_M107_1+0x4  ;; 0x42430294
        STR      R0,[R1, #+0]
??gcode_M107_0:
        POP      {R0,PC}          ;; return
        Nop      
        DATA
??gcode_M107_1:
        DC32     fanSpeeds
        DC32     0x42430294
          CFI EndBlock cfiBlock276

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M108v
          CFI Block cfiBlock277 Using cfiCommon0
          CFI Function _Z10gcode_M108v
          CFI NoCalls
        THUMB
_Z10gcode_M108v:
        MOVS     R0,#+0
        LDR.N    R1,??gcode_M108_0
        STRB     R0,[R1, #+20]
        BX       LR               ;; return
        DATA
??gcode_M108_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock277

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M112v
          CFI Block cfiBlock278 Using cfiCommon0
          CFI Function _Z10gcode_M112v
        THUMB
_Z10gcode_M112v:
        LDR.N    R0,??gcode_M112_0
          CFI FunCall _Z4killPKc
        B.W      _Z4killPKc
        Nop      
        DATA
??gcode_M112_0:
        DC32     _ZZ10gcode_M112vEs
          CFI EndBlock cfiBlock278

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M410v
          CFI Block cfiBlock279 Using cfiCommon0
          CFI Function _Z10gcode_M410v
          CFI FunCall _Z17quickstop_stepperv
        THUMB
_Z10gcode_M410v:
        B.W      _Z17quickstop_stepperv
          CFI EndBlock cfiBlock279

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M109v
          CFI Block cfiBlock280 Using cfiCommon0
          CFI Function _Z10gcode_M109v
        THUMB
_Z10gcode_M109v:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        VPUSH    {D8}
          CFI D8 Frame(CFA, -48)
          CFI CFA R13+48
        MOVS     R0,#+109
          CFI FunCall _Z32get_target_extruder_from_commandt
        BL       _Z32get_target_extruder_from_commandt
        CMP      R0,#+0
        BNE.W    ??gcode_M109_1
        LDR.N    R4,??gcode_M109_2+0xC
        LDRB     R0,[R4, #+13]
        LSLS     R0,R0,#+28
        BMI.W    ??gcode_M109_1
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        MOVS     R5,R0
        BNE.N    ??gcode_M109_3
        MOVS     R0,#+82
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.W    ??gcode_M109_1
??gcode_M109_3:
          CFI FunCall _ZN11GCodeParser13value_celsiusEv
        BL       _ZN11GCodeParser13value_celsiusEv
        VCVT.S32.F32 S0,S0
        VMOV     R1,S0
        LDRB     R0,[R4, #+21]
        SXTH     R1,R1
        VMOV     S0,R1
        VCVT.F32.S32 S0,S0
          CFI FunCall _ZN11Temperature15setTargetHotendEfh
        BL       _ZN11Temperature15setTargetHotendEfh
        LDR.N    R6,??gcode_M109_2+0x10
          CFI FunCall _ZN11GCodeParser13value_celsiusEv
        BL       _ZN11GCodeParser13value_celsiusEv
        VLDR.W   S1,??gcode_M109_2  ;; 0x42aa0001
        VCMP.F32 S0,S1
        FMSTAT   
        MOV      R0,R6
        BPL.N    ??gcode_M109_4
          CFI FunCall _ZN9Stopwatch4stopEv
        BL       _ZN9Stopwatch4stopEv
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M109_2+0x14
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        B.N      ??gcode_M109_5
??gcode_M109_4:
          CFI FunCall _ZN9Stopwatch5startEv
        BL       _ZN9Stopwatch5startEv
??gcode_M109_5:
        LDRB     R0,[R4, #+21]
          CFI FunCall _ZN11Temperature9degHotendEh
        BL       _ZN11Temperature9degHotendEh
        VMOV.F32 S16,S0
          CFI FunCall _ZN11GCodeParser13value_celsiusEv
        BL       _ZN11GCodeParser13value_celsiusEv
        VCMP.F32 S16,S0
        FMSTAT   
        BPL.N    ??gcode_M109_6
        LDRB     R0,[R4, #+21]
        CMP      R0,#+4
        BHI.N    ??gcode_M109_6
        TBB      [PC, R0]
        DATA
??gcode_M109_0:
        DC8      0x3,0x8,0xD,0x12
        DC8      0x17,0x0
        THUMB
??gcode_M109_7:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M109_2+0x18
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        B.N      ??gcode_M109_6
??gcode_M109_8:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M109_2+0x1C
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        B.N      ??gcode_M109_6
??gcode_M109_9:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M109_2+0x20
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        B.N      ??gcode_M109_6
??gcode_M109_10:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M109_2+0x24
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        B.N      ??gcode_M109_6
??gcode_M109_11:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M109_2+0x28
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
??gcode_M109_6:
          CFI FunCall _ZN7Planner18autotemp_M104_M109Ev
        BL       _ZN7Planner18autotemp_M104_M109Ev
        MOVS     R6,#+0
        VMOV.F32 S16,#-1.0
        VLDR.W   S17,??gcode_M109_2+0x4  ;; 0x461c3c00
        MOV      R7,R6
        MOVS     R0,#+1
        STRB     R0,[R4, #+20]
        MOV      R8,R6
        MOV      R9,R6
        STRB     R0,[R4, #+12]
        LDR.W    R11,??gcode_M109_2+0x2C
??gcode_M109_12:
        LDRB     R10,[R4, #+21]
        MOV      R0,R10
          CFI FunCall _ZN11Temperature15degTargetHotendEh
        BL       _ZN11Temperature15degTargetHotendEh
        VCMP.F32 S16,S0
        FMSTAT   
        BEQ.N    ??gcode_M109_13
        MOV      R0,R10
          CFI FunCall _ZN11Temperature15isCoolingHotendEh
        BL       _ZN11Temperature15isCoolingHotendEh
        MOV      R7,R0
        MOV      R0,R10
          CFI FunCall _ZN11Temperature15degTargetHotendEh
        BL       _ZN11Temperature15degTargetHotendEh
        VMOV.F32 S16,S0
        MOV      R0,R5
        MOV      R1,R7
        TST      R0,R1
        BNE.N    ??gcode_M109_14
??gcode_M109_13:
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        MOV      R10,R0
        SUBS     R0,R10,R8
        BMI.N    ??gcode_M109_15
        ADD      R8,R10,#+1000
        LDR.N    R0,??gcode_M109_2+0x30
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        CMP      R6,#+0
        BEQ.N    ??gcode_M109_16
        MOVS     R2,#+10
        MOVW     R0,#+10000
        SUB      R0,R0,R10
        ADDS     R0,R6,R0
        MOV      R1,#+1000
        UDIV     R1,R0,R1
        MOV      R0,R11
          CFI FunCall _ZN5Print5printEli
        BL       _ZN5Print5printEli
        B.N      ??gcode_M109_17
??gcode_M109_16:
        MOVS     R1,#+63
        MOV      R0,R11
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_M109_17:
        MOVS     R1,#+10
        MOV      R0,R11
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_M109_15:
          CFI FunCall _Z4idlev
        BL       _Z4idlev
          CFI FunCall _Z19refresh_cmd_timeoutv
        BL       _Z19refresh_cmd_timeoutv
        LDRB     R0,[R4, #+21]
          CFI FunCall _ZN11Temperature9degHotendEh
        BL       _ZN11Temperature9degHotendEh
        VSUB.F32 S1,S16,S0
        VABS.F32 S1,S1
        CMP      R6,#+0
        BNE.N    ??gcode_M109_18
        VMOV.F32 S2,#1.0
        VCMP.F32 S1,S2
        FMSTAT   
        BPL.N    ??gcode_M109_19
        MOV      R6,R10
        B.N      ??gcode_M109_19
??gcode_M109_18:
        VLDR.W   S2,??gcode_M109_2+0x8  ;; 0x40400001
        VCMP.F32 S1,S2
        FMSTAT   
        BLT.N    ??gcode_M109_19
        MOV      R6,R10
??gcode_M109_19:
        CMP      R7,#+0
        BEQ.N    ??gcode_M109_20
        CMP      R9,#+0
        BEQ.N    ??gcode_M109_21
        SUBS     R0,R10,R9
        BMI.N    ??gcode_M109_20
??gcode_M109_21:
        VSUB.F32 S1,S17,S0
        VMOV.F32 S2,#1.5
        VCMP.F32 S1,S2
        FMSTAT   
        BMI.N    ??gcode_M109_14
        ADD      R9,R10,#+59904
        ADD      R9,R9,#+96
        VMOV.F32 S17,S0
??gcode_M109_20:
        LDRB     R0,[R4, #+20]
        CMP      R0,#+0
        BEQ.N    ??gcode_M109_14
        CMP      R6,#+0
        BEQ.N    ??gcode_M109_12
        SUB      R0,R10,R6
        LDR.N    R1,??gcode_M109_2+0x34  ;; 0xffffd8f0
        ADDS     R0,R1,R0
        BMI.N    ??gcode_M109_12
??gcode_M109_14:
        MOVS     R0,#+0
        STRB     R0,[R4, #+12]
        LDRB     R0,[R4, #+20]
        CMP      R0,#+0
        BEQ.N    ??gcode_M109_1
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M109_2+0x38
        VPOP     {D8}
          CFI D8 SameValue
          CFI CFA R13+40
        POP      {R2,R4-R11,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z16lcd_setstatusPGMPKca
        B.W      _Z16lcd_setstatusPGMPKca
          CFI D8 Frame(CFA, -48)
          CFI R4 Frame(CFA, -36)
          CFI R5 Frame(CFA, -32)
          CFI R6 Frame(CFA, -28)
          CFI R7 Frame(CFA, -24)
          CFI R8 Frame(CFA, -20)
          CFI R9 Frame(CFA, -16)
          CFI R10 Frame(CFA, -12)
          CFI R11 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+48
??gcode_M109_1:
        VPOP     {D8}
          CFI D8 SameValue
          CFI CFA R13+40
        POP      {R0,R4-R11,PC}   ;; return
        Nop      
        DATA
??gcode_M109_2:
        DC32     0x42aa0001
        DC32     0x461c3c00
        DC32     0x40400001
        DC32     axis_relative_modes
        DC32     card+0xD88
        DC32     _ZZ10gcode_M109vEs
        DC32     _ZZ10gcode_M109vEs_0
        DC32     _ZZ10gcode_M109vEs_1
        DC32     _ZZ10gcode_M109vEs_2
        DC32     _ZZ10gcode_M109vEs_3
        DC32     _ZZ10gcode_M109vEs_4
        DC32     Serial6
        DC32     _ZZ10gcode_M109vEs_5
        DC32     0xffffd8f0
        DC32     _ZZ10gcode_M109vEs_6
          CFI EndBlock cfiBlock280

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M110v
          CFI Block cfiBlock281 Using cfiCommon0
          CFI Function _Z10gcode_M110v
        THUMB
_Z10gcode_M110v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+78
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M110_0
          CFI FunCall _ZN11GCodeParser10value_longEv
        BL       _ZN11GCodeParser10value_longEv
        LDR.N    R1,??gcode_M110_1
        STR      R0,[R1, #+4]
??gcode_M110_0:
        POP      {R0,PC}          ;; return
        Nop      
        DATA
??gcode_M110_1:
        DC32     Running
          CFI EndBlock cfiBlock281

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M111v
          CFI Block cfiBlock282 Using cfiCommon0
          CFI Function _Z10gcode_M111v
        THUMB
_Z10gcode_M111v:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        LDR.N    R4,??gcode_M111_0
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M111_1
        MOVS     R1,#+0
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7bytevalEch
        BL       _ZN11GCodeParser7bytevalEch
        STRB     R0,[R4, #+13]
??gcode_M111_1:
        LDR.N    R0,??gcode_M111_0+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M111_0+0x8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDRB     R0,[R4, #+13]
        CMP      R0,#+0
        BEQ.N    ??gcode_M111_2
        MOVS     R6,#+0
        MOV      R5,R6
??gcode_M111_3:
        CMP      R5,#+5
        BCS.N    ??gcode_M111_4
        LDRB     R0,[R4, #+13]
        MOVS     R1,#+1
        LSLS     R1,R1,R5
        TST      R0,R1
        BEQ.N    ??gcode_M111_5
        MOV      R0,R6
        ADDS     R6,R0,#+1
        UXTB     R0,R0
        CMP      R0,#+0
        BEQ.N    ??gcode_M111_6
        MOVS     R1,#+44
        LDR.N    R0,??gcode_M111_0+0xC
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_M111_6:
        LDR.N    R0,??gcode_M111_0+0x10
        ADD      R0,R0,R5, LSL #+2
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??gcode_M111_5:
        ADDS     R5,R5,#+1
        B.N      ??gcode_M111_3
??gcode_M111_2:
        LDR.N    R0,??gcode_M111_0+0x14
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??gcode_M111_4:
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M111_0+0xC
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
        Nop      
        DATA
??gcode_M111_0:
        DC32     axis_relative_modes
        DC32     echomagic
        DC32     _ZZ10gcode_M111vEs_4
        DC32     Serial6
        DC32     _ZZ10gcode_M111vE13debug_strings
        DC32     _ZZ10gcode_M111vEs_5
          CFI EndBlock cfiBlock282

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M140v
          CFI Block cfiBlock283 Using cfiCommon0
          CFI Function _Z10gcode_M140v
        THUMB
_Z10gcode_M140v:
        LDR.N    R0,??gcode_M140_0
        LDRB     R0,[R0, #+13]
        LSLS     R0,R0,#+28
        BPL.N    ??gcode_M140_1
        BX       LR
??gcode_M140_1:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M140_2
          CFI FunCall _ZN11GCodeParser13value_celsiusEv
        BL       _ZN11GCodeParser13value_celsiusEv
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN11Temperature12setTargetBedEf
        B.W      _ZN11Temperature12setTargetBedEf
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M140_2:
        POP      {R0,PC}          ;; return
        DATA
??gcode_M140_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock283

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M81v
          CFI Block cfiBlock284 Using cfiCommon0
          CFI Function _Z9gcode_M81v
        THUMB
_Z9gcode_M81v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
          CFI FunCall _ZN7Stepper18finish_and_disableEv
        BL       _ZN7Stepper18finish_and_disableEv
        MOVS     R0,#+0
        LDR.N    R1,??gcode_M81_0
        B.N      ??gcode_M81_1
??gcode_M81_2:
        MOVS     R0,#+0
        STR      R0,[R1, #+0]
        MOVS     R0,#+1
??gcode_M81_1:
        CMP      R0,#+0
        BEQ.N    ??gcode_M81_2
        MOV      R0,#+1000
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z10safe_delaym
        B.W      _Z10safe_delaym
        Nop      
        DATA
??gcode_M81_0:
        DC32     fanSpeeds
          CFI EndBlock cfiBlock284

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M82v
          CFI Block cfiBlock285 Using cfiCommon0
          CFI Function _Z9gcode_M82v
          CFI NoCalls
        THUMB
_Z9gcode_M82v:
        MOVS     R0,#+0
        LDR.N    R1,??gcode_M82_0
        STRB     R0,[R1, #+3]
        BX       LR               ;; return
        DATA
??gcode_M82_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock285

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M83v
          CFI Block cfiBlock286 Using cfiCommon0
          CFI Function _Z9gcode_M83v
          CFI NoCalls
        THUMB
_Z9gcode_M83v:
        MOVS     R0,#+1
        LDR.N    R1,??gcode_M83_0
        STRB     R0,[R1, #+3]
        BX       LR               ;; return
        DATA
??gcode_M83_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock286

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z13gcode_M18_M84v
          CFI Block cfiBlock287 Using cfiCommon0
          CFI Function _Z13gcode_M18_M84v
        THUMB
_Z13gcode_M18_M84v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M18_M84_0
          CFI FunCall _ZN11GCodeParser25value_millis_from_secondsEv
        BL       _ZN11GCodeParser25value_millis_from_secondsEv
        LDR.N    R1,??gcode_M18_M84_1
        STR      R0,[R1, #+8]
        POP      {R0,PC}
??gcode_M18_M84_0:
        MOVS     R0,#+88
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BNE.N    ??gcode_M18_M84_2
        MOVS     R0,#+89
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BNE.N    ??gcode_M18_M84_2
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BNE.N    ??gcode_M18_M84_2
        MOVS     R0,#+69
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        AND      R0,R0,#0x1
        EOR      R0,R0,#0x1
        B.N      ??gcode_M18_M84_3
??gcode_M18_M84_2:
        MOVS     R0,#+0
??gcode_M18_M84_3:
        CMP      R0,#+0
        BEQ.N    ??gcode_M18_M84_4
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Stepper18finish_and_disableEv
        B.W      _ZN7Stepper18finish_and_disableEv
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M18_M84_4:
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        MOVS     R0,#+88
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOVS     R0,#+89
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M18_M84_5
        MOVS     R2,#+1
        LDR.N    R0,??gcode_M18_M84_1+0x4
        LDRH     R1,[R0, #+4]
        LDR.N    R0,??gcode_M18_M84_1+0x8
        LDR      R0,[R0, #+8]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        MOVS     R0,#+0
        LDR.N    R1,??gcode_M18_M84_1+0xC
        STRB     R0,[R1, #+10]
??gcode_M18_M84_5:
        POP      {R0,PC}          ;; return
        Nop      
        DATA
??gcode_M18_M84_1:
        DC32     previous_cmd_ms
        DC32     gArrayGpioPin
        DC32     gArrayGpioPort
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock287

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M85v
          CFI Block cfiBlock288 Using cfiCommon0
          CFI Function _Z9gcode_M85v
        THUMB
_Z9gcode_M85v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M85_0
          CFI FunCall _ZN11GCodeParser25value_millis_from_secondsEv
        BL       _ZN11GCodeParser25value_millis_from_secondsEv
        LDR.N    R1,??gcode_M85_1
        STR      R0,[R1, #+4]
??gcode_M85_0:
        POP      {R0,PC}          ;; return
        Nop      
        DATA
??gcode_M85_1:
        DC32     previous_cmd_ms
          CFI EndBlock cfiBlock288

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M92v
          CFI Block cfiBlock289 Using cfiCommon0
          CFI Function _Z9gcode_M92v
        THUMB
_Z9gcode_M92v:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R4,#+0
        LDR.N    R5,??gcode_M92_0
        B.N      ??gcode_M92_1
??gcode_M92_2:
        MOV      R0,R4
        SXTB     R0,R0
          CFI FunCall _ZN11GCodeParser19value_per_axis_unitE8AxisEnum
        BL       _ZN11GCodeParser19value_per_axis_unitE8AxisEnum
        ADD      R0,R5,R4, LSL #+2
        VSTR     S0,[R0, #0]
??gcode_M92_3:
        ADDS     R4,R4,#+1
??gcode_M92_1:
        CMP      R4,#+4
        BGE.N    ??gcode_M92_4
        LDR.N    R0,??gcode_M92_0+0x4
        LDRSB    R0,[R4, R0]
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M92_3
        CMP      R4,#+3
        BNE.N    ??gcode_M92_2
        MOVS     R0,#+3
          CFI FunCall _ZN11GCodeParser19value_per_axis_unitE8AxisEnum
        BL       _ZN11GCodeParser19value_per_axis_unitE8AxisEnum
        VMOV.F32 S1,#20.0
        VCMP.F32 S0,S1
        FMSTAT   
        BPL.N    ??gcode_M92_5
        VLDR     S1,[R5, #+12]
        VDIV.F32 S1,S1,S0
        LDR.N    R0,??gcode_M92_0+0x8
        VLDR     S2,[R0, #+12]
        VMUL.F32 S2,S2,S1
        VSTR     S2,[R0, #+12]
        LDR.N    R0,??gcode_M92_0+0xC
        VLDR     S2,[R0, #+12]
        VMUL.F32 S2,S2,S1
        VSTR     S2,[R0, #+12]
        LDR.N    R0,??gcode_M92_0+0x10
        VLDR     S2,[R0, #+12]
        VCVT.F32.U32 S2,S2
        VMUL.F32 S1,S2,S1
        VCVT.U32.F32 S1,S1
        VSTR     S1,[R0, #+12]
??gcode_M92_5:
        VSTR     S0,[R5, #+12]
        B.N      ??gcode_M92_3
??gcode_M92_4:
        POP      {R0,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Planner19refresh_positioningEv
        B.W      _ZN7Planner19refresh_positioningEv
        Nop      
        DATA
??gcode_M92_0:
        DC32     _ZN7Planner17axis_steps_per_mmE
        DC32     axis_codes
        DC32     _ZN7Planner8max_jerkE
        DC32     _ZN7Planner17max_feedrate_mm_sE
        DC32     _ZN7Planner29max_acceleration_steps_per_s2E
          CFI EndBlock cfiBlock289

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M114v
          CFI Block cfiBlock290 Using cfiCommon0
          CFI Function _Z10gcode_M114v
        THUMB
_Z10gcode_M114v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z23report_current_positionv
        B.W      _Z23report_current_positionv
          CFI EndBlock cfiBlock290

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M115v
          CFI Block cfiBlock291 Using cfiCommon0
          CFI Function _Z10gcode_M115v
        THUMB
_Z10gcode_M115v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R0,??gcode_M115_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M115_0+0x4
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+1
        LDR.N    R0,??gcode_M115_0+0x8
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+1
        LDR.N    R0,??gcode_M115_0+0xC
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+1
        LDR.N    R0,??gcode_M115_0+0x10
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M115_0+0x14
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+1
        LDR.N    R0,??gcode_M115_0+0x18
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M115_0+0x1C
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M115_0+0x20
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M115_0+0x24
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M115_0+0x28
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M115_0+0x2C
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M115_0+0x30
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M115_0+0x34
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M115_0+0x38
        POP      {R2,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z8cap_linePKcb
        B.W      _Z8cap_linePKcb
        DATA
??gcode_M115_0:
        DC32     _ZZ10gcode_M115vEs
        DC32     _ZZ10gcode_M115vEs_0
        DC32     _ZZ10gcode_M115vEs_1
        DC32     _ZZ10gcode_M115vEs_2
        DC32     _ZZ10gcode_M115vEs_3
        DC32     _ZZ10gcode_M115vEs_4
        DC32     _ZZ10gcode_M115vEs_5
        DC32     _ZZ10gcode_M115vEs_6
        DC32     _ZZ10gcode_M115vEs_7
        DC32     _ZZ10gcode_M115vEs_8
        DC32     _ZZ10gcode_M115vEs_9
        DC32     _ZZ10gcode_M115vEs__10_
        DC32     _ZZ10gcode_M115vEs__11_
        DC32     _ZZ10gcode_M115vEs__12_
        DC32     _ZZ10gcode_M115vEs__13_
          CFI EndBlock cfiBlock291

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M117v
          CFI Block cfiBlock292 Using cfiCommon0
          CFI Function _Z10gcode_M117v
        THUMB
_Z10gcode_M117v:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M117_0
        LDR      R0,[R0, #+0]
          CFI FunCall _Z13lcd_setstatusPKcb
        B.W      _Z13lcd_setstatusPKcb
        Nop      
        DATA
??gcode_M117_0:
        DC32     _ZN11GCodeParser10string_argE
          CFI EndBlock cfiBlock292

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M118v
          CFI Block cfiBlock293 Using cfiCommon0
          CFI Function _Z10gcode_M118v
        THUMB
_Z10gcode_M118v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R0,#+69
          CFI FunCall _ZN11GCodeParser7boolvalEc
        BL       _ZN11GCodeParser7boolvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M118_0
        LDR.N    R0,??gcode_M118_1
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??gcode_M118_0:
        MOVS     R0,#+65
          CFI FunCall _ZN11GCodeParser7boolvalEc
        BL       _ZN11GCodeParser7boolvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M118_2
        LDR.N    R0,??gcode_M118_1+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??gcode_M118_2:
        LDR.N    R4,??gcode_M118_1+0x8
        LDR.N    R0,??gcode_M118_1+0xC
        LDR      R1,[R0, #+0]
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEPKc
        BL       _ZN5Print5printEPKc
        MOVS     R1,#+10
        MOV      R0,R4
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
        Nop      
        DATA
??gcode_M118_1:
        DC32     echomagic
        DC32     _ZZ10gcode_M118vEs
        DC32     Serial6
        DC32     _ZN11GCodeParser10string_argE
          CFI EndBlock cfiBlock293

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M119v
          CFI Block cfiBlock294 Using cfiCommon0
          CFI Function _Z10gcode_M119v
          CFI FunCall _ZN8Endstops4M119Ev
        THUMB
_Z10gcode_M119v:
        B.W      _ZN8Endstops4M119Ev
          CFI EndBlock cfiBlock294

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M120v
          CFI Block cfiBlock295 Using cfiCommon0
          CFI Function _Z10gcode_M120v
        THUMB
_Z10gcode_M120v:
        MOVS     R0,#+1
          CFI FunCall _ZN8Endstops15enable_globallyEb
        B.W      _ZN8Endstops15enable_globallyEb
          CFI EndBlock cfiBlock295

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M121v
          CFI Block cfiBlock296 Using cfiCommon0
          CFI Function _Z10gcode_M121v
        THUMB
_Z10gcode_M121v:
        MOVS     R0,#+0
          CFI FunCall _ZN8Endstops15enable_globallyEb
        B.W      _ZN8Endstops15enable_globallyEb
          CFI EndBlock cfiBlock296

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M200v
          CFI Block cfiBlock297 Using cfiCommon0
          CFI Function _Z10gcode_M200v
        THUMB
_Z10gcode_M200v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        SUB      SP,SP,#+8
          CFI CFA R13+16
        MOVS     R0,#+200
          CFI FunCall _Z32get_target_extruder_from_commandt
        BL       _Z32get_target_extruder_from_commandt
        CMP      R0,#+0
        BNE.N    ??gcode_M200_0
        MOVS     R0,#+68
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M200_1
        LDR.N    R4,??gcode_M200_2
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        VCMP.F32 S0,#0.0
        FMSTAT   
        BEQ.N    ??gcode_M200_3
        MOVS     R0,#+1
        STRB     R0,[R4, #+0]
        B.N      ??gcode_M200_4
??gcode_M200_3:
        MOVS     R0,#+0
        STRB     R0,[R4, #+0]
??gcode_M200_4:
        LDRB     R0,[R4, #+0]
        CMP      R0,#+0
        BEQ.N    ??gcode_M200_1
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        VSTR     S0,[SP, #+0]
        ADD      R1,SP,#+0
        LDR.N    R0,??gcode_M200_2+0x4
        LDRB     R0,[R0, #+21]
          CFI FunCall _ZN7Planner17set_filament_sizeEhRKf
        BL       _ZN7Planner17set_filament_sizeEhRKf
??gcode_M200_1:
          CFI FunCall _ZN7Planner32calculate_volumetric_multipliersEv
        BL       _ZN7Planner32calculate_volumetric_multipliersEv
??gcode_M200_0:
        POP      {R0,R1,R4,PC}    ;; return
        DATA
??gcode_M200_2:
        DC32     _ZN11GCodeParser18volumetric_enabledE
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock297

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M201v
          CFI Block cfiBlock298 Using cfiCommon0
          CFI Function _Z10gcode_M201v
        THUMB
_Z10gcode_M201v:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R4,#+0
        B.N      ??gcode_M201_0
??gcode_M201_1:
        LDR.N    R0,??gcode_M201_2
        LDRSB    R0,[R4, R0]
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M201_3
        MOV      R5,R4
        MOV      R0,R5
        SXTB     R0,R0
          CFI FunCall _ZN11GCodeParser16value_axis_unitsE8AxisEnum
        BL       _ZN11GCodeParser16value_axis_unitsE8AxisEnum
        VCVT.U32.F32 S0,S0
        LDR.N    R0,??gcode_M201_2+0x4
        ADD      R0,R0,R5, LSL #+2
        VSTR     S0,[R0, #0]
??gcode_M201_3:
        ADDS     R4,R4,#+1
??gcode_M201_0:
        CMP      R4,#+4
        BLT.N    ??gcode_M201_1
        POP      {R0,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Planner24reset_acceleration_ratesEv
        B.W      _ZN7Planner24reset_acceleration_ratesEv
        DATA
??gcode_M201_2:
        DC32     axis_codes
        DC32     _ZN7Planner26max_acceleration_mm_per_s2E
          CFI EndBlock cfiBlock298

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M203v
          CFI Block cfiBlock299 Using cfiCommon0
          CFI Function _Z10gcode_M203v
        THUMB
_Z10gcode_M203v:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R4,#+0
        B.N      ??gcode_M203_0
??gcode_M203_1:
        LDR.N    R0,??gcode_M203_2
        LDRSB    R0,[R4, R0]
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M203_3
        MOV      R5,R4
        MOV      R0,R5
        SXTB     R0,R0
          CFI FunCall _ZN11GCodeParser16value_axis_unitsE8AxisEnum
        BL       _ZN11GCodeParser16value_axis_unitsE8AxisEnum
        LDR.N    R0,??gcode_M203_2+0x4
        ADD      R0,R0,R5, LSL #+2
        VSTR     S0,[R0, #0]
??gcode_M203_3:
        ADDS     R4,R4,#+1
??gcode_M203_0:
        CMP      R4,#+4
        BLT.N    ??gcode_M203_1
        POP      {R0,R4,R5,PC}    ;; return
        Nop      
        DATA
??gcode_M203_2:
        DC32     axis_codes
        DC32     _ZN7Planner17max_feedrate_mm_sE
          CFI EndBlock cfiBlock299

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M204v
          CFI Block cfiBlock300 Using cfiCommon0
          CFI Function _Z10gcode_M204v
        THUMB
_Z10gcode_M204v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M204_0
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R0,??gcode_M204_1
        VSTR     S0,[R0, #0]
        LDR.N    R0,??gcode_M204_1+0x4
        VSTR     S0,[R0, #0]
        LDR.N    R0,??gcode_M204_1+0x8
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M204_1+0xC
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_M204_0:
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M204_2
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R0,??gcode_M204_1
        VSTR     S0,[R0, #0]
        LDR.N    R0,??gcode_M204_1+0x10
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M204_1+0xC
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_M204_2:
        MOVS     R0,#+82
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M204_3
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R0,??gcode_M204_1+0x14
        VSTR     S0,[R0, #0]
        LDR.N    R0,??gcode_M204_1+0x18
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M204_1+0xC
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_M204_3:
        MOVS     R0,#+84
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M204_4
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R0,??gcode_M204_1+0x4
        VSTR     S0,[R0, #0]
        LDR.N    R0,??gcode_M204_1+0x1C
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M204_1+0xC
        POP      {R2,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M204_4:
        POP      {R0,PC}          ;; return
        Nop      
        DATA
??gcode_M204_1:
        DC32     _ZN7Planner12accelerationE
        DC32     _ZN7Planner19travel_accelerationE
        DC32     _ZZ10gcode_M204vEs
        DC32     Serial6
        DC32     _ZZ10gcode_M204vEs_0
        DC32     _ZN7Planner20retract_accelerationE
        DC32     _ZZ10gcode_M204vEs_1
        DC32     _ZZ10gcode_M204vEs_2
          CFI EndBlock cfiBlock300

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M205v
          CFI Block cfiBlock301 Using cfiCommon0
          CFI Function _Z10gcode_M205v
        THUMB
_Z10gcode_M205v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M205_0
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R0,??gcode_M205_1
        VSTR     S0,[R0, #0]
??gcode_M205_0:
        MOVS     R0,#+84
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M205_2
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R0,??gcode_M205_1+0x4
        VSTR     S0,[R0, #0]
??gcode_M205_2:
        MOVS     R0,#+66
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M205_3
          CFI FunCall _ZN11GCodeParser11value_ulongEv
        BL       _ZN11GCodeParser11value_ulongEv
        LDR.N    R1,??gcode_M205_1+0x8
        STR      R0,[R1, #+0]
??gcode_M205_3:
        MOVS     R0,#+88
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M205_4
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R0,??gcode_M205_1+0xC
        VSTR     S0,[R0, #0]
??gcode_M205_4:
        MOVS     R0,#+89
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M205_5
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R0,??gcode_M205_1+0xC
        VSTR     S0,[R0, #+4]
??gcode_M205_5:
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M205_6
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R0,??gcode_M205_1+0xC
        VSTR     S0,[R0, #+8]
??gcode_M205_6:
        MOVS     R0,#+69
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M205_7
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R0,??gcode_M205_1+0xC
        VSTR     S0,[R0, #+12]
??gcode_M205_7:
        POP      {R0,PC}          ;; return
        Nop      
        DATA
??gcode_M205_1:
        DC32     _ZN7Planner17min_feedrate_mm_sE
        DC32     _ZN7Planner24min_travel_feedrate_mm_sE
        DC32     _ZN7Planner19min_segment_time_usE
        DC32     _ZN7Planner8max_jerkE
          CFI EndBlock cfiBlock301

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M206v
          CFI Block cfiBlock302 Using cfiCommon0
          CFI Function _Z10gcode_M206v
        THUMB
_Z10gcode_M206v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R4,#+0
        B.N      ??gcode_M206_0
??gcode_M206_1:
        LDR.N    R0,??gcode_M206_2
        LDRSB    R0,[R4, R0]
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M206_3
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        MOV      R0,R4
        SXTB     R0,R0
          CFI FunCall _Z15set_home_offset8AxisEnumf
        BL       _Z15set_home_offset8AxisEnumf
??gcode_M206_3:
        ADDS     R4,R4,#+1
??gcode_M206_0:
        CMP      R4,#+3
        BLT.N    ??gcode_M206_1
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z23report_current_positionv
        B.W      _Z23report_current_positionv
        DATA
??gcode_M206_2:
        DC32     axis_codes
          CFI EndBlock cfiBlock302

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M211v
          CFI Block cfiBlock303 Using cfiCommon0
          CFI Function _Z10gcode_M211v
        THUMB
_Z10gcode_M211v:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        LDR.N    R0,??gcode_M211_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R4,??gcode_M211_0+0x4
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M211_1
          CFI FunCall _ZN11GCodeParser10value_boolEv
        BL       _ZN11GCodeParser10value_boolEv
        STRB     R0,[R4, #+17]
??gcode_M211_1:
        LDR.N    R0,??gcode_M211_0+0x8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDRB     R0,[R4, #+17]
        CMP      R0,#+0
        BEQ.N    ??gcode_M211_2
        LDR.N    R0,??gcode_M211_0+0xC
        B.N      ??gcode_M211_3
??gcode_M211_2:
        LDR.N    R0,??gcode_M211_0+0x10
??gcode_M211_3:
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M211_0+0x14
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R5,??gcode_M211_0+0x18
        LDR.N    R6,??gcode_M211_0+0x1C
        VLDR     S0,[R4, #+92]
        VLDR     S1,[R6, #0]
        VADD.F32 S0,S0,S1
        MOV      R0,R5
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR.N    R7,??gcode_M211_0+0x20
        VLDR     S0,[R4, #+96]
        VLDR     S1,[R6, #+4]
        VADD.F32 S0,S0,S1
        MOV      R0,R7
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR.W    R8,??gcode_M211_0+0x24
        VLDR     S0,[R4, #+100]
        VLDR     S1,[R6, #+8]
        VADD.F32 S0,S0,S1
        MOV      R0,R8
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR.N    R0,??gcode_M211_0+0x28
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        VLDR     S0,[R4, #+104]
        VLDR     S1,[R6, #0]
        VADD.F32 S0,S0,S1
        MOV      R0,R5
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        VLDR     S0,[R4, #+108]
        VLDR     S1,[R6, #+4]
        VADD.F32 S0,S0,S1
        MOV      R0,R7
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        VLDR     S0,[R4, #+112]
        VLDR     S1,[R6, #+8]
        VADD.F32 S0,S0,S1
        MOV      R0,R8
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M211_0+0x2C
        POP      {R4-R8,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
        DATA
??gcode_M211_0:
        DC32     echomagic
        DC32     axis_relative_modes
        DC32     _ZZ10gcode_M211vEs
        DC32     _ZZ10gcode_M211vEs_0
        DC32     _ZZ10gcode_M211vEs_1
        DC32     _ZZ10gcode_M211vEs_2
        DC32     _ZZ10gcode_M211vEs_3
        DC32     workspace_offset
        DC32     _ZZ10gcode_M211vEs_4
        DC32     _ZZ10gcode_M211vEs_5
        DC32     _ZZ10gcode_M211vEs_6
        DC32     Serial6
          CFI EndBlock cfiBlock303

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M220v
          CFI Block cfiBlock304 Using cfiCommon0
          CFI Function _Z10gcode_M220v
        THUMB
_Z10gcode_M220v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M220_0
          CFI FunCall _ZN11GCodeParser9value_intEv
        BL       _ZN11GCodeParser9value_intEv
        LDR.N    R1,??gcode_M220_1
        STRH     R0,[R1, #+28]
??gcode_M220_0:
        POP      {R0,PC}          ;; return
        Nop      
        DATA
??gcode_M220_1:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock304

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M221v
          CFI Block cfiBlock305 Using cfiCommon0
          CFI Function _Z10gcode_M221v
        THUMB
_Z10gcode_M221v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+221
          CFI FunCall _Z32get_target_extruder_from_commandt
        BL       _Z32get_target_extruder_from_commandt
        CMP      R0,#+0
        BNE.N    ??gcode_M221_0
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M221_0
          CFI FunCall _ZN11GCodeParser9value_intEv
        BL       _ZN11GCodeParser9value_intEv
        LDR.N    R1,??gcode_M221_1
        LDRB     R1,[R1, #+21]
        LDR.N    R2,??gcode_M221_1+0x4
        STRH     R0,[R2, R1, LSL #+1]
        MOV      R0,R1
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Planner16refresh_e_factorEh
        B.W      _ZN7Planner16refresh_e_factorEh
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M221_0:
        POP      {R0,PC}          ;; return
        DATA
??gcode_M221_1:
        DC32     axis_relative_modes
        DC32     _ZN7Planner15flow_percentageE
          CFI EndBlock cfiBlock305

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M226v
          CFI Block cfiBlock306 Using cfiCommon0
          CFI Function _Z10gcode_M226v
        THUMB
_Z10gcode_M226v:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M226_0
          CFI FunCall _ZN11GCodeParser9value_intEv
        BL       _ZN11GCodeParser9value_intEv
        MOV      R4,R0
        MOV      R1,#-1
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser6intvalEcs
        BL       _ZN11GCodeParser6intvalEcs
        MOV      R5,R0
        ADDS     R0,R5,#+1
        CMP      R0,#+3
        BCS.N    ??gcode_M226_0
        CMP      R4,#+0
        BMI.N    ??gcode_M226_0
        MOV      R0,R4
        SXTB     R0,R0
          CFI FunCall _Z16pin_is_protecteda
        BL       _Z16pin_is_protecteda
        CMP      R0,#+0
        BNE.N    ??gcode_M226_0
        MOVS     R6,#+0
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        CMP      R5,#+1
        BEQ.N    ??gcode_M226_1
        CMP      R5,#-1
        BEQ.N    ??gcode_M226_2
        B.N      ??gcode_M226_3
??gcode_M226_1:
        MOVS     R6,#+1
        B.N      ??gcode_M226_3
??gcode_M226_2:
        CMP      R4,#+0
        BPL.N    ??gcode_M226_3
        LDR.N    R0,??gcode_M226_4
        LDRH     R1,[R0, R4, LSL #+1]
        LDR.N    R0,??gcode_M226_4+0x4
        LDR      R0,[R0, R4, LSL #+2]
          CFI FunCall HAL_GPIO_ReadPin
        BL       HAL_GPIO_ReadPin
        MOV      R6,R0
        B.N      ??gcode_M226_3
??gcode_M226_5:
          CFI FunCall _Z4idlev
        BL       _Z4idlev
??gcode_M226_3:
        CMP      R4,#+0
        BMI.N    ??gcode_M226_6
        LDR.N    R0,??gcode_M226_4
        LDRH     R1,[R0, R4, LSL #+1]
        LDR.N    R0,??gcode_M226_4+0x4
        LDR      R0,[R0, R4, LSL #+2]
          CFI FunCall HAL_GPIO_ReadPin
        BL       HAL_GPIO_ReadPin
        B.N      ??gcode_M226_7
??gcode_M226_6:
        MOV      R0,R6
        SUBS     R0,R0,#+1
        SBCS     R0,R0,R0
        MVNS     R0,R0
        LSRS     R0,R0,#+31
??gcode_M226_7:
        CMP      R0,#+0
        BNE.N    ??gcode_M226_5
??gcode_M226_0:
        POP      {R4-R6,PC}       ;; return
        DATA
??gcode_M226_4:
        DC32     gArrayGpioPin
        DC32     gArrayGpioPort
          CFI EndBlock cfiBlock306

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M301v
          CFI Block cfiBlock307 Using cfiCommon0
          CFI Function _Z10gcode_M301v
        THUMB
_Z10gcode_M301v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R1,#+0
        MOVS     R0,#+69
          CFI FunCall _ZN11GCodeParser7bytevalEch
        BL       _ZN11GCodeParser7bytevalEch
        CMP      R0,#+0
        BNE.N    ??gcode_M301_0
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M301_1
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDR.N    R0,??gcode_M301_2
        VSTR     S0,[R0, #0]
??gcode_M301_1:
        MOVS     R0,#+73
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M301_3
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        VMOV     R0,S0
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??gcode_M301_2+0x4  ;; 0x88e368f1
        LDR.N    R3,??gcode_M301_2+0x8  ;; 0x3fc4f8b5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        LDR.N    R1,??gcode_M301_2+0xC
        STR      R0,[R1, #+0]
??gcode_M301_3:
        LDR.N    R4,??gcode_M301_2+0x10
        MOVS     R0,#+68
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M301_4
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        VMOV     R0,S0
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??gcode_M301_2+0x4  ;; 0x88e368f1
        LDR.N    R3,??gcode_M301_2+0x8  ;; 0x3fc4f8b5
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R4, #+0]
??gcode_M301_4:
          CFI FunCall _ZN11Temperature9updatePIDEv
        BL       _ZN11Temperature9updatePIDEv
        LDR.N    R0,??gcode_M301_2+0x14
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M301_2
        VLDR     S0,[R0, #0]
        LDR.N    R0,??gcode_M301_2+0x18
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR.N    R0,??gcode_M301_2+0xC
        LDR      R0,[R0, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??gcode_M301_2+0x4  ;; 0x88e368f1
        LDR.N    R3,??gcode_M301_2+0x8  ;; 0x3fc4f8b5
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        VMOV     D0,R0,R1
        LDR.N    R0,??gcode_M301_2+0x1C
          CFI FunCall _Z17serial_echopair_PPKcd
        BL       _Z17serial_echopair_PPKcd
        LDR      R0,[R4, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??gcode_M301_2+0x4  ;; 0x88e368f1
        LDR.N    R3,??gcode_M301_2+0x8  ;; 0x3fc4f8b5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        VMOV     D0,R0,R1
        LDR.N    R0,??gcode_M301_2+0x20
          CFI FunCall _Z17serial_echopair_PPKcd
        BL       _Z17serial_echopair_PPKcd
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M301_2+0x24
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M301_0:
        LDR.N    R0,??gcode_M301_2+0x28
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R4,??gcode_M301_2+0x24
        LDR.N    R1,??gcode_M301_2+0x2C
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEPKc
        BL       _ZN5Print5printEPKc
        MOVS     R1,#+10
        MOV      R0,R4
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
        Nop      
        DATA
??gcode_M301_2:
        DC32     _ZN11Temperature2KpE
        DC32     0x88e368f1
        DC32     0x3fc4f8b5
        DC32     _ZN11Temperature2KiE
        DC32     _ZN11Temperature2KdE
        DC32     echomagic
        DC32     _ZZ10gcode_M301vEs
        DC32     _ZZ10gcode_M301vEs_0
        DC32     _ZZ10gcode_M301vEs_1
        DC32     Serial6
        DC32     errormagic
        DC32     _ZZ10gcode_M301vEs_2
          CFI EndBlock cfiBlock307

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M303v
          CFI Block cfiBlock308 Using cfiCommon0
          CFI Function _Z10gcode_M303v
        THUMB
_Z10gcode_M303v:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOVS     R1,#+0
        MOVS     R0,#+69
          CFI FunCall _ZN11GCodeParser6intvalEcs
        BL       _ZN11GCodeParser6intvalEcs
        MOV      R4,R0
        MOVS     R1,#+5
        MOVS     R0,#+67
          CFI FunCall _ZN11GCodeParser6intvalEcs
        BL       _ZN11GCodeParser6intvalEcs
        MOV      R5,R0
        MOVS     R0,#+85
          CFI FunCall _ZN11GCodeParser7boolvalEc
        BL       _ZN11GCodeParser7boolvalEc
        MOV      R6,R0
        CMP      R4,#+0
        BPL.N    ??gcode_M303_0
        VLDR.W   S0,??gcode_M303_1  ;; 0x46
        B.N      ??gcode_M303_2
??gcode_M303_0:
        VLDR.W   S0,??gcode_M303_1+0x4  ;; 0x96
??gcode_M303_2:
        VCVT.F32.S32 S0,S0
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser10celsiusvalEcf
        BL       _ZN11GCodeParser10celsiusvalEcf
        VCVT.S32.F32 S0,S0
        VMOV     R3,S0
        CMP      R4,#+0
        BNE.N    ??gcode_M303_3
        MOVS     R0,#+0
        LDR.N    R1,??gcode_M303_1+0x8
        STRB     R0,[R1, #+21]
??gcode_M303_3:
        MOV      R2,R6
        MOV      R1,R5
        SXTB     R1,R1
        MOV      R0,R4
        SXTB     R0,R0
        SXTH     R3,R3
        VMOV     S0,R3
        VCVT.F32.S32 S0,S0
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN11Temperature12PID_autotuneEfaab
        B.W      _ZN11Temperature12PID_autotuneEfaab
        DATA
??gcode_M303_1:
        DC32     0x46
        DC32     0x96
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock308

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M400v
          CFI Block cfiBlock309 Using cfiCommon0
          CFI Function _Z10gcode_M400v
          CFI FunCall _ZN7Stepper11synchronizeEv
        THUMB
_Z10gcode_M400v:
        B.W      _ZN7Stepper11synchronizeEv
          CFI EndBlock cfiBlock309

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M428v
          CFI Block cfiBlock310 Using cfiCommon0
          CFI Function _Z10gcode_M428v
        THUMB
_Z10gcode_M428v:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        VPUSH    {D8}
          CFI D8 Frame(CFA, -24)
          CFI CFA R13+24
        SUB      SP,SP,#+16
          CFI CFA R13+40
        MOVS     R0,#+1
          CFI FunCall _Z18axis_unhomed_errorb
        BL       _Z18axis_unhomed_errorb
        CMP      R0,#+0
        BNE.N    ??gcode_M428_0
        MOVS     R4,#+0
        LDR.N    R5,??gcode_M428_1+0x8
        ADD      R6,SP,#+0
        B.N      ??gcode_M428_2
??gcode_M428_3:
        ADDS     R4,R4,#+1
        UXTB     R4,R4
??gcode_M428_2:
        CMP      R4,#+3
        BGE.N    ??gcode_M428_4
        ADD      R0,R5,R4, LSL #+2
        VLDR     S16,[R0, #+32]
        MOV      R0,R4
        SXTB     R0,R0
          CFI FunCall _Z13base_home_pos8AxisEnum
        BL       _Z13base_home_pos8AxisEnum
        VSUB.F32 S0,S0,S16
        ADD      R0,R6,R4, LSL #+2
        VSTR     S0,[R0, #0]
        VLDR     S0,[R5, #+88]
        VLDR     S1,[R5, #+40]
        VSUB.F32 S0,S0,S1
        VSTR     S0,[SP, #+8]
        LDR      R0,[R6, R4, LSL #+2]
        VMOV     S0,R0
        VLDR.W   S17,??gcode_M428_1  ;; 0xc3480000
        VCMP.F32 S0,S17
        FMSTAT   
        BLT.N    ??gcode_M428_5
        VLDR.W   S1,??gcode_M428_1+0x4  ;; 0x43480001
        VCMP.F32 S0,S1
        FMSTAT   
        BMI.N    ??gcode_M428_6
??gcode_M428_5:
        MOV      R0,R4
        SXTB     R0,R0
          CFI FunCall _Z8home_dir8AxisEnum
        BL       _Z8home_dir8AxisEnum
        CMP      R0,#+1
        BLT.N    ??gcode_M428_6
        ADD      R0,R6,R4, LSL #+2
        VNEG.F32 S0,S16
        VSTR     S0,[R0, #0]
??gcode_M428_6:
        LDR      R0,[R6, R4, LSL #+2]
        VMOV     S0,R0
        VCMP.F32 S0,S17
        FMSTAT   
        BLT.N    ??gcode_M428_7
        VLDR.W   S1,??gcode_M428_1+0x4  ;; 0x43480001
        VCMP.F32 S0,S1
        FMSTAT   
        BMI.N    ??gcode_M428_3
??gcode_M428_7:
        LDR.N    R0,??gcode_M428_1+0xC
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M428_1+0x10
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M428_1+0x14
          CFI FunCall _Z21lcd_setalertstatusPGMPKc
        BL       _Z21lcd_setalertstatusPGMPKc
        B.N      ??gcode_M428_0
??gcode_M428_4:
        MOVS     R4,#+0
        B.N      ??gcode_M428_8
??gcode_M428_9:
        ADD      R0,SP,#+0
        ADD      R0,R0,R4, LSL #+2
        VLDR     S0,[R0, #0]
        MOV      R0,R4
        SXTB     R0,R0
          CFI FunCall _Z15set_home_offset8AxisEnumf
        BL       _Z15set_home_offset8AxisEnumf
        ADDS     R4,R4,#+1
??gcode_M428_8:
        CMP      R4,#+3
        BLT.N    ??gcode_M428_9
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M428_1+0x18
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
??gcode_M428_0:
        ADD      SP,SP,#+16
          CFI CFA R13+24
        VPOP     {D8}
          CFI D8 SameValue
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
        Nop      
        DATA
??gcode_M428_1:
        DC32     0xc3480000
        DC32     0x43480001
        DC32     axis_relative_modes
        DC32     errormagic
        DC32     _ZZ10gcode_M428vEs
        DC32     _ZZ10gcode_M428vEs_0
        DC32     _ZZ10gcode_M428vEs_1
          CFI EndBlock cfiBlock310

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M500v
          CFI Block cfiBlock311 Using cfiCommon0
          CFI Function _Z10gcode_M500v
          CFI FunCall _ZN14MarlinSettings4saveEv
        THUMB
_Z10gcode_M500v:
        B.W      _ZN14MarlinSettings4saveEv
          CFI EndBlock cfiBlock311

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M501v
          CFI Block cfiBlock312 Using cfiCommon0
          CFI Function _Z10gcode_M501v
          CFI FunCall _ZN14MarlinSettings4loadEv
        THUMB
_Z10gcode_M501v:
        B.W      _ZN14MarlinSettings4loadEv
          CFI EndBlock cfiBlock312

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M502v
          CFI Block cfiBlock313 Using cfiCommon0
          CFI Function _Z10gcode_M502v
          CFI FunCall _ZN14MarlinSettings5resetEv
        THUMB
_Z10gcode_M502v:
        B.W      _ZN14MarlinSettings5resetEv
          CFI EndBlock cfiBlock313

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M503v
          CFI Block cfiBlock314 Using cfiCommon0
          CFI Function _Z10gcode_M503v
        THUMB
_Z10gcode_M503v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M503_0
          CFI FunCall _ZN11GCodeParser10value_boolEv
        BL       _ZN11GCodeParser10value_boolEv
        AND      R0,R0,#0x1
        EOR      R0,R0,#0x1
        B.N      ??gcode_M503_1
??gcode_M503_0:
        MOVS     R0,#+0
??gcode_M503_1:
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN14MarlinSettings6reportEb
        B.W      _ZN14MarlinSettings6reportEb
          CFI EndBlock cfiBlock314

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M907v
          CFI Block cfiBlock315 Using cfiCommon0
          CFI Function _Z10gcode_M907v
          CFI NoCalls
        THUMB
_Z10gcode_M907v:
        BX       LR               ;; return
          CFI EndBlock cfiBlock315

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M355v
          CFI Block cfiBlock316 Using cfiCommon0
          CFI Function _Z10gcode_M355v
        THUMB
_Z10gcode_M355v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R0,??gcode_M355_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M355_0+0x4
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
        Nop      
        DATA
??gcode_M355_0:
        DC32     errormagic
        DC32     _ZZ10gcode_M355vEs
          CFI EndBlock cfiBlock316

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M999v
          CFI Block cfiBlock317 Using cfiCommon0
          CFI Function _Z10gcode_M999v
        THUMB
_Z10gcode_M999v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+1
        LDR.N    R1,??gcode_M999_0
        STRB     R0,[R1, #+0]
          CFI FunCall _Z21lcd_reset_alert_levelv
        BL       _Z21lcd_reset_alert_levelv
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7boolvalEc
        BL       _ZN11GCodeParser7boolvalEc
        CMP      R0,#+0
        BNE.N    ??gcode_M999_1
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z24FlushSerialRequestResendv
        B.W      _Z24FlushSerialRequestResendv
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M999_1:
        POP      {R0,PC}          ;; return
        DATA
??gcode_M999_0:
        DC32     Running
          CFI EndBlock cfiBlock317

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z22invalid_extruder_errorh
          CFI Block cfiBlock318 Using cfiCommon0
          CFI Function _Z22invalid_extruder_errorh
        THUMB
_Z22invalid_extruder_errorh:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        LDR.N    R0,??invalid_extruder_error_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R5,??invalid_extruder_error_0+0x4
        MOVS     R1,#+84
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        MOVS     R2,#+10
        MOV      R1,R4
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEhi
        BL       _ZN5Print5printEhi
        MOVS     R1,#+32
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        LDR.N    R1,??invalid_extruder_error_0+0x8
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEPKc
        BL       _ZN5Print5printEPKc
        MOVS     R1,#+10
        MOV      R0,R5
        POP      {R2,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
        Nop      
        DATA
??invalid_extruder_error_0:
        DC32     echomagic
        DC32     Serial6
        DC32     _ZZ22invalid_extruder_errorhEs
          CFI EndBlock cfiBlock318

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z7gcode_Th
          CFI Block cfiBlock319 Using cfiCommon0
          CFI Function _Z7gcode_Th
        THUMB
_Z7gcode_Th:
        MOVS     R1,#+0
        VLDR.W   S0,??gcode_T_0   ;; 0x0
          CFI FunCall _Z11tool_changehfb
        B.W      _Z11tool_changehfb
        Nop      
        DATA
??gcode_T_0:
        DC32     0x0
          CFI EndBlock cfiBlock319

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z37prepare_move_to_destination_cartesianv
          CFI Block cfiBlock320 Using cfiCommon0
          CFI Function _Z37prepare_move_to_destination_cartesianv
        THUMB
_Z37prepare_move_to_destination_cartesianv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R0,??prepare_move_to_destination_cartesian_0
        LDRSH    R1,[R0, #+28]
        VMOV     S0,R1
        VCVT.F32.S32 S0,S0
        VLDR     S1,[R0, #+120]
        VMUL.F32 S0,S0,S1
        VMOV     R0,S0
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??prepare_move_to_destination_cartesian_0+0x4  ;; 0x47ae147b
        LDR.N    R3,??prepare_move_to_destination_cartesian_0+0x8  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        VMOV     S0,R0
          CFI FunCall _Z26buffer_line_to_destinationf
        BL       _Z26buffer_line_to_destinationf
        MOVS     R0,#+0
        POP      {R1,PC}          ;; return
        DATA
??prepare_move_to_destination_cartesian_0:
        DC32     axis_relative_modes
        DC32     0x47ae147b
        DC32     0x3f847ae1
          CFI EndBlock cfiBlock320

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10clr_ticketv
          CFI Block cfiBlock321 Using cfiCommon0
          CFI Function _Z10clr_ticketv
          CFI NoCalls
        THUMB
// __interwork __softfp void clr_ticket()
_Z10clr_ticketv:
        cpsid i
        MOVS     R0,#+0
        LDR.N    R1,??clr_ticket_0
        STR      R0,[R1, #+3220]
        cpsie i
        BX       LR               ;; return
        Nop      
        DATA
??clr_ticket_0:
        DC32     card
          CFI EndBlock cfiBlock321

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z12CRC16_XMODEMPhj
          CFI Block cfiBlock322 Using cfiCommon0
          CFI Function _Z12CRC16_XMODEMPhj
          CFI NoCalls
        THUMB
// __interwork __softfp uint16_t CRC16_XMODEM(unsigned char *, unsigned int)
_Z12CRC16_XMODEMPhj:
        PUSH     {R4}
          CFI R4 Frame(CFA, -4)
          CFI CFA R13+4
        MOVS     R2,#+0
??CRC16_XMODEM_0:
        MOV      R3,R1
        SUBS     R1,R3,#+1
        CMP      R3,#+0
        BEQ.N    ??CRC16_XMODEM_1
        LDRB     R3,[R0], #+1
        EOR      R2,R2,R3, LSL #+8
        MOVS     R3,#+0
        B.N      ??CRC16_XMODEM_2
??CRC16_XMODEM_3:
        MOV      R2,R4
        UXTH     R2,R2
??CRC16_XMODEM_4:
        ADDS     R3,R3,#+1
??CRC16_XMODEM_2:
        CMP      R3,#+8
        BGE.N    ??CRC16_XMODEM_0
        LSLS     R4,R2,#+1
        LSLS     R2,R2,#+16
        BPL.N    ??CRC16_XMODEM_3
        EOR      R2,R4,#0x1000
        EOR      R2,R2,#0x21
        UXTH     R2,R2
        B.N      ??CRC16_XMODEM_4
??CRC16_XMODEM_1:
        MOV      R0,R2
        LSRS     R0,R0,#+8
        ORR      R0,R0,R2, LSL #+8
        UXTH     R0,R0
        POP      {R4}
          CFI R4 SameValue
          CFI CFA R13+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock322

        SECTION `.init_array`:CODE:ROOT(2)
        SECTION_TYPE SHT_INIT_ARRAY, 0
        DATA
        DC32    RELOC_ARM_TARGET1 __sti__routine

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        SECTION __DLIB_PERTHREAD:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        SECTION __DLIB_PERTHREAD_init:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        END
// 15173 
// 15174 
// 
//  5 381 bytes in section .bss
//    624 bytes in section .data
//      4 bytes in section .init_array
//  1 653 bytes in section .rodata
// 36 088 bytes in section .text
// 
// 27 972 bytes of CODE  memory (+ 8 120 bytes shared)
//     62 bytes of CONST memory (+ 1 591 bytes shared)
//  5 904 bytes of DATA  memory (+   101 bytes shared)
//
//Errors: none
//Warnings: 134
