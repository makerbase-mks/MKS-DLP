###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  10:59:24
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Widget\WIDGET.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Widget\WIDGET.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\WIDGET.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\WIDGET.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Widget\WIDGET.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              µC/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : WIDGET.c
     16          Purpose     : Widget core routines
     17          ---------------------------END-OF-HEADER------------------------------
     18          */
     19          
     20          #include <stdlib.h>
     21          #include <string.h>
     22          
     23          #include "WIDGET.h"
     24          #include "GUIDebug.h"
     25          #include "GUI.h"
     26          #include "GUI_Protected.h"
     27          #include "WM_Intern.h"
     28          
     29          #if GUI_WINSUPPORT
     30          
     31          /*********************************************************************
     32          *
     33          *       Static data
     34          *
     35          **********************************************************************
     36          */
     37          

   \                                 In section .data, align 4
     38          const WIDGET_EFFECT* _pEffectDefault = &WIDGET_Effect_3D;
   \                     _pEffectDefault:
   \   00000000   0x........         DC32 WIDGET_Effect_3D
     39          
     40          /*********************************************************************
     41          *
     42          *       Static routines
     43          *
     44          **********************************************************************
     45          */
     46          /*********************************************************************
     47          *
     48          *       _UpdateChildPositions
     49          */

   \                                 In section .text, align 2, keep-with-next
     50          static void _UpdateChildPostions(WM_HWIN hObj, int Diff) {
   \                     _UpdateChildPostions: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x460C             MOV      R4,R1
     51            WM_Obj* pObj;
     52            WM_LOCK();
     53            pObj = (WM_Obj*)WM_H2P(hObj);
   \   00000006   0x.... 0x....      BL       GUI_ALLOC_h2p
     54            WM__UpdateChildPositions(pObj, -Diff, -Diff, Diff, Diff);
   \   0000000A   0x4261             RSBS     R1,R4,#+0
   \   0000000C   0x9400             STR      R4,[SP, #+0]
   \   0000000E   0x4623             MOV      R3,R4
   \   00000010   0x460A             MOV      R2,R1
   \   00000012   0x.... 0x....      BL       WM__UpdateChildPositions
     55            WM_UNLOCK();
     56          }
   \   00000016   0xBD13             POP      {R0,R1,R4,PC}    ;; return
     57          
     58          /*********************************************************************
     59          *
     60          *       _EffectRequiresRedraw
     61          *
     62          * Purpose
     63          *   Check if the effect to draw is inside the invalid rectangle.
     64          * Returns:
     65          *   0 if nothing need to be done.
     66          *   1 if the effect needs to be drawn
     67          */

   \                                 In section .text, align 2, keep-with-next
     68          static int _EffectRequiresRedraw(const WIDGET* pWidget, const GUI_RECT * pRect) {
   \                     _EffectRequiresRedraw: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x4606             MOV      R6,R0
   \   00000004   0x460C             MOV      R4,R1
     69            int EffectSize = pWidget->pEffect->EffectSize;
   \   00000006   0x6A30             LDR      R0,[R6, #+32]
   \   00000008   0x6945             LDR      R5,[R0, #+20]
     70            GUI_RECT InvalidRect;
     71            InvalidRect = pWidget->Win.InvalidRect;
   \   0000000A   0xA800             ADD      R0,SP,#+0
   \   0000000C   0xF106 0x0108      ADD      R1,R6,#+8
   \   00000010   0x2208             MOVS     R2,#+8
   \   00000012   0x.... 0x....      BL       __aeabi_memcpy
     72            WM__Client2Screen(&pWidget->Win, &InvalidRect);
   \   00000016   0xA900             ADD      R1,SP,#+0
   \   00000018   0x4630             MOV      R0,R6
   \   0000001A   0x.... 0x....      BL       WM__Client2Screen
     73            /* Check if there a part of the effect is inside the invalid rectangle */
     74            if ((pRect->x0 + EffectSize) > InvalidRect.x0) {
   \   0000001E   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \   00000022   0xF9B4 0x1000      LDRSH    R1,[R4, #+0]
   \   00000026   0xFA05 0xF181      SXTAH    R1,R5,R1
   \   0000002A   0x4288             CMP      R0,R1
   \   0000002C   0xDA01             BGE.N    ??_EffectRequiresRedraw_0
     75              return 1;               /* Overlap ... Drawing required */
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xBD76             POP      {R1,R2,R4-R6,PC}
     76            }
     77            if ((pRect->x1 - EffectSize) < InvalidRect.x1) {
   \                     ??_EffectRequiresRedraw_0: (+1)
   \   00000032   0xF9B4 0x0004      LDRSH    R0,[R4, #+4]
   \   00000036   0x1B40             SUBS     R0,R0,R5
   \   00000038   0xF9BD 0x1004      LDRSH    R1,[SP, #+4]
   \   0000003C   0x4288             CMP      R0,R1
   \   0000003E   0xDA01             BGE.N    ??_EffectRequiresRedraw_1
     78              return 1;               /* Overlap ... Drawing required */
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xBD76             POP      {R1,R2,R4-R6,PC}
     79            }
     80            if ((pRect->y0 + EffectSize) > InvalidRect.y0) {
   \                     ??_EffectRequiresRedraw_1: (+1)
   \   00000044   0xF9BD 0x0002      LDRSH    R0,[SP, #+2]
   \   00000048   0xF9B4 0x1002      LDRSH    R1,[R4, #+2]
   \   0000004C   0x1869             ADDS     R1,R5,R1
   \   0000004E   0x4288             CMP      R0,R1
   \   00000050   0xDA01             BGE.N    ??_EffectRequiresRedraw_2
     81              return 1;               /* Overlap ... Drawing required */
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0xBD76             POP      {R1,R2,R4-R6,PC}
     82            }
     83            if ((pRect->y1 - EffectSize) < InvalidRect.y1) {
   \                     ??_EffectRequiresRedraw_2: (+1)
   \   00000056   0xF9B4 0x0006      LDRSH    R0,[R4, #+6]
   \   0000005A   0x1B40             SUBS     R0,R0,R5
   \   0000005C   0xF9BD 0x1006      LDRSH    R1,[SP, #+6]
   \   00000060   0x4288             CMP      R0,R1
   \   00000062   0xDA01             BGE.N    ??_EffectRequiresRedraw_3
     84              return 1;               /* Overlap ... Drawing required */
   \   00000064   0x2001             MOVS     R0,#+1
   \   00000066   0xBD76             POP      {R1,R2,R4-R6,PC}
     85            }
     86            return 0;                 /* No overlap ! */
   \                     ??_EffectRequiresRedraw_3: (+1)
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
     87          }
     88          
     89          
     90          /*********************************************************************
     91          *
     92          *       Public routines
     93          *
     94          **********************************************************************
     95          */
     96          /*********************************************************************
     97          *
     98          *       WIDGET__RotateRect90
     99          */

   \                                 In section .text, align 2, keep-with-next
    100          void WIDGET__RotateRect90(WIDGET* pWidget, GUI_RECT* pDest, const GUI_RECT* pRect) {
   \                     WIDGET__RotateRect90: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    101            int x0, x1, XSize;
    102            x0 = pRect->x0;
   \   00000002   0xF9B2 0x3000      LDRSH    R3,[R2, #+0]
    103            x1 = pRect->x1;
   \   00000006   0xF9B2 0x4004      LDRSH    R4,[R2, #+4]
    104            XSize = pWidget->Win.Rect.x1 - pWidget->Win.Rect.x0;
   \   0000000A   0xF9B0 0x5004      LDRSH    R5,[R0, #+4]
   \   0000000E   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000012   0x1A28             SUBS     R0,R5,R0
    105            pDest->x0 = XSize - pRect->y1;
   \   00000014   0x88D5             LDRH     R5,[R2, #+6]
   \   00000016   0x1B45             SUBS     R5,R0,R5
   \   00000018   0x800D             STRH     R5,[R1, #+0]
    106            pDest->x1 = XSize - pRect->y0;
   \   0000001A   0x8852             LDRH     R2,[R2, #+2]
   \   0000001C   0x1A80             SUBS     R0,R0,R2
   \   0000001E   0x8088             STRH     R0,[R1, #+4]
    107            pDest->y0 = x0;
   \   00000020   0x804B             STRH     R3,[R1, #+2]
    108            pDest->y1 = x1;
   \   00000022   0x80CC             STRH     R4,[R1, #+6]
    109          
    110          }
   \   00000024   0xBC30             POP      {R4,R5}
   \   00000026   0x4770             BX       LR               ;; return
    111          
    112          /*********************************************************************
    113          *
    114          *       WIDGET__GetClientRect
    115          
    116            Returns the logical client rectangle, which means the normal
    117            client rectangle for widgets with their standard orientation
    118            and the rotated one for rotated widgets.
    119          */

   \                                 In section .text, align 2, keep-with-next
    120          void WIDGET__GetClientRect(WIDGET* pWidget, GUI_RECT* pRect) {
   \                     WIDGET__GetClientRect: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x460C             MOV      R4,R1
    121            if (pWidget->State & WIDGET_STATE_VERTICAL) {
   \   00000004   0xF890 0x0026      LDRB     R0,[R0, #+38]
   \   00000008   0x0700             LSLS     R0,R0,#+28
   \   0000000A   0xD50F             BPL.N    ??WIDGET__GetClientRect_0
    122              GUI_RECT Rect;
    123              WM_GetClientRect(&Rect);
   \   0000000C   0xA800             ADD      R0,SP,#+0
   \   0000000E   0x.... 0x....      BL       WM_GetClientRect
    124              pRect->x0 = Rect.y0;
   \   00000012   0xF8BD 0x0002      LDRH     R0,[SP, #+2]
   \   00000016   0x8020             STRH     R0,[R4, #+0]
    125              pRect->x1 = Rect.y1;
   \   00000018   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \   0000001C   0x80A0             STRH     R0,[R4, #+4]
    126              pRect->y0 = Rect.x0;
   \   0000001E   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000022   0x8060             STRH     R0,[R4, #+2]
    127              pRect->y1 = Rect.x1;
   \   00000024   0xF8BD 0x0004      LDRH     R0,[SP, #+4]
   \   00000028   0x80E0             STRH     R0,[R4, #+6]
   \   0000002A   0xBD13             POP      {R0,R1,R4,PC}
    128            } else {
    129              WM_GetClientRect(pRect);
   \                     ??WIDGET__GetClientRect_0: (+1)
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       WM_GetClientRect
    130            }
    131          }
   \   00000032   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    132          
    133          /*********************************************************************
    134          *
    135          *       WIDGET__GetBkColor
    136          */

   \                                 In section .text, align 2, keep-with-next
    137          GUI_COLOR WIDGET__GetBkColor(WM_HWIN hObj) {
   \                     WIDGET__GetBkColor: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    138            GUI_COLOR BkColor = WM_GetBkColor(WM_GetParent(hObj));
   \   00000002   0x.... 0x....      BL       WM_GetParent
   \   00000006   0x.... 0x....      BL       WM_GetBkColor
    139            if (BkColor == GUI_INVALID_COLOR) {
   \   0000000A   0xF06F 0x4170      MVN      R1,#-268435456
   \   0000000E   0x4288             CMP      R0,R1
   \   00000010   0xD103             BNE.N    ??WIDGET__GetBkColor_0
    140              BkColor = DIALOG_GetBkColor();
   \   00000012   0xE8BD 0x4001      POP      {R0,LR}
   \   00000016   0x.... 0x....      B.W      DIALOG_GetBkColor
    141            }
    142            return BkColor;
   \                     ??WIDGET__GetBkColor_0: (+1)
   \   0000001A   0xBD02             POP      {R1,PC}          ;; return
    143          }
    144          
    145          /*********************************************************************
    146          *
    147          *       WIDGET__GetInsideRect
    148          */

   \                                 In section .text, align 2, keep-with-next
    149          void WIDGET__GetInsideRect(WIDGET* pWidget, GUI_RECT* pRect) {
   \                     WIDGET__GetInsideRect: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    150            WM__GetClientRectWin(&pWidget->Win, pRect);
   \   00000006   0x.... 0x....      BL       WM__GetClientRectWin
    151            GUI__ReduceRect(pRect, pRect, pWidget->pEffect->EffectSize);
   \   0000000A   0x6A20             LDR      R0,[R4, #+32]
   \   0000000C   0x6942             LDR      R2,[R0, #+20]
   \   0000000E   0x4629             MOV      R1,R5
   \   00000010   0x4628             MOV      R0,R5
   \   00000012   0xE8BD 0x4038      POP      {R3-R5,LR}
   \   00000016   0x.... 0x....      B.W      GUI__ReduceRect
    152          }
    153          
    154          /*********************************************************************
    155          *
    156          *       WIDGET__GetXSize
    157          */

   \                                 In section .text, align 2, keep-with-next
    158          int WIDGET__GetXSize(const WIDGET* pWidget) {
    159            int r;
    160            if (pWidget->State & WIDGET_STATE_VERTICAL) {
   \                     WIDGET__GetXSize: (+1)
   \   00000000   0xF890 0x1026      LDRB     R1,[R0, #+38]
   \   00000004   0x0709             LSLS     R1,R1,#+28
   \   00000006   0xD505             BPL.N    ??WIDGET__GetXSize_0
    161              r = pWidget->Win.Rect.y1 - pWidget->Win.Rect.y0;
   \   00000008   0xF9B0 0x1006      LDRSH    R1,[R0, #+6]
   \   0000000C   0xF9B0 0x0002      LDRSH    R0,[R0, #+2]
   \   00000010   0x1A08             SUBS     R0,R1,R0
   \   00000012   0xE004             B.N      ??WIDGET__GetXSize_1
    162            } else {
    163              r = pWidget->Win.Rect.x1 - pWidget->Win.Rect.x0;
   \                     ??WIDGET__GetXSize_0: (+1)
   \   00000014   0xF9B0 0x1004      LDRSH    R1,[R0, #+4]
   \   00000018   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   0000001C   0x1A08             SUBS     R0,R1,R0
    164            }
    165            return r + 1;
   \                     ??WIDGET__GetXSize_1: (+1)
   \   0000001E   0x1C40             ADDS     R0,R0,#+1
   \   00000020   0x4770             BX       LR               ;; return
    166          }
    167          
    168          /*********************************************************************
    169          *
    170          *       WIDGET__GetYSize
    171          */

   \                                 In section .text, align 2, keep-with-next
    172          int WIDGET__GetYSize(const WIDGET* pWidget) {
    173            int r;
    174            if (pWidget->State & WIDGET_STATE_VERTICAL) {
   \                     WIDGET__GetYSize: (+1)
   \   00000000   0xF890 0x1026      LDRB     R1,[R0, #+38]
   \   00000004   0x0709             LSLS     R1,R1,#+28
   \   00000006   0xD505             BPL.N    ??WIDGET__GetYSize_0
    175              r = pWidget->Win.Rect.x1 - pWidget->Win.Rect.x0;
   \   00000008   0xF9B0 0x1004      LDRSH    R1,[R0, #+4]
   \   0000000C   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000010   0x1A08             SUBS     R0,R1,R0
   \   00000012   0xE004             B.N      ??WIDGET__GetYSize_1
    176            } else {
    177              r = pWidget->Win.Rect.y1 - pWidget->Win.Rect.y0;
   \                     ??WIDGET__GetYSize_0: (+1)
   \   00000014   0xF9B0 0x1006      LDRSH    R1,[R0, #+6]
   \   00000018   0xF9B0 0x0002      LDRSH    R0,[R0, #+2]
   \   0000001C   0x1A08             SUBS     R0,R1,R0
    178            }
    179            return r + 1;
   \                     ??WIDGET__GetYSize_1: (+1)
   \   0000001E   0x1C40             ADDS     R0,R0,#+1
   \   00000020   0x4770             BX       LR               ;; return
    180          }
    181          
    182          /*******************************************************************
    183          *
    184          *       WIDGET__GetWindowSizeX
    185          
    186            Return width (or height in case of rotation) of window in pixels
    187          */

   \                                 In section .text, align 2, keep-with-next
    188          int WIDGET__GetWindowSizeX(WM_HWIN hWin) {
   \                     WIDGET__GetWindowSizeX: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    189            WIDGET* pWidget = WIDGET_H2P(hWin);
   \   00000004   0x.... 0x....      BL       GUI_ALLOC_h2p
    190            if (pWidget->State & WIDGET_STATE_VERTICAL) {
   \   00000008   0xF890 0x0026      LDRB     R0,[R0, #+38]
   \   0000000C   0x0700             LSLS     R0,R0,#+28
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0xD503             BPL.N    ??WIDGET__GetWindowSizeX_0
    191              return WM_GetWindowSizeY(hWin);
   \   00000012   0xE8BD 0x4010      POP      {R4,LR}
   \   00000016   0x.... 0x....      B.W      WM_GetWindowSizeY
    192            } else {
    193              return WM_GetWindowSizeX(hWin);
   \                     ??WIDGET__GetWindowSizeX_0: (+1)
   \   0000001A   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001E   0x.... 0x....      B.W      WM_GetWindowSizeX
    194            }
    195          }
    196          
    197          /*********************************************************************
    198          *
    199          *       WIDGET_SetState
    200          */

   \                                 In section .text, align 2, keep-with-next
    201          void WIDGET_SetState(WM_HWIN hObj, int State) {
   \                     WIDGET_SetState: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    202            WIDGET* pWidget;
    203            WM_LOCK();
    204            pWidget = WIDGET_H2P(hObj);
   \   00000006   0x.... 0x....      BL       GUI_ALLOC_h2p
    205            if (State != pWidget->State) {
   \   0000000A   0x8CC1             LDRH     R1,[R0, #+38]
   \   0000000C   0x428D             CMP      R5,R1
   \   0000000E   0xD005             BEQ.N    ??WIDGET_SetState_0
    206              pWidget->State = State;
   \   00000010   0x84C5             STRH     R5,[R0, #+38]
    207              WM_Invalidate(hObj);
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000018   0x.... 0x....      B.W      WM_InvalidateWindow
    208            }
    209            WM_UNLOCK();
    210          }
   \                     ??WIDGET_SetState_0: (+1)
   \   0000001C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    211          
    212          /*********************************************************************
    213          *
    214          *       WIDGET_GetState
    215          */

   \                                 In section .text, align 2, keep-with-next
    216          int WIDGET_GetState(WM_HWIN hObj) {
   \                     WIDGET_GetState: (+1)
   \   00000000   0x4601             MOV      R1,R0
    217            int Ret = 0;
   \   00000002   0x2000             MOVS     R0,#+0
    218            WIDGET * pWidget;
    219            if (hObj) {
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD100             BNE.N    ??WIDGET_GetState_0
   \   00000008   0x4770             BX       LR
    220              WM_LOCK();
    221              pWidget = WIDGET_H2P(hObj);
   \                     ??WIDGET_GetState_0: (+1)
   \   0000000A   0xB580             PUSH     {R7,LR}
   \   0000000C   0x4608             MOV      R0,R1
   \   0000000E   0x.... 0x....      BL       GUI_ALLOC_h2p
    222              Ret = pWidget->State;
   \   00000012   0x8CC0             LDRH     R0,[R0, #+38]
    223              WM_UNLOCK();
    224            }
    225            return Ret;
   \   00000014   0xBD02             POP      {R1,PC}          ;; return
    226          }
    227          
    228          /*********************************************************************
    229          *
    230          *       WIDGET_OrState
    231          */

   \                                 In section .text, align 2, keep-with-next
    232          void WIDGET_OrState(WM_HWIN hObj, int State) {
   \                     WIDGET_OrState: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    233            if (hObj) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD00D             BEQ.N    ??WIDGET_OrState_0
    234              WIDGET* pWidget;
    235              WM_LOCK();
    236              pWidget = WIDGET_H2P(hObj);
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
    237              if (State != (pWidget->State & State)) {
   \   0000000E   0x8CC1             LDRH     R1,[R0, #+38]
   \   00000010   0xEA05 0x0201      AND      R2,R5,R1
   \   00000014   0x4295             CMP      R5,R2
   \   00000016   0xD006             BEQ.N    ??WIDGET_OrState_0
    238                pWidget->State |= State;
   \   00000018   0x4329             ORRS     R1,R5,R1
   \   0000001A   0x84C1             STRH     R1,[R0, #+38]
    239                WM_Invalidate(hObj);
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000022   0x.... 0x....      B.W      WM_InvalidateWindow
    240              }
    241              WM_UNLOCK();
    242            }
    243          }
   \                     ??WIDGET_OrState_0: (+1)
   \   00000026   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    244          
    245          /*********************************************************************
    246          *
    247          *       WIDGET_AndState
    248          
    249            Purpose:
    250              Clear flags in the State element of the widget.
    251              The bits to be cleared are set.
    252            Example:
    253              ...(..., 3);   // Clears bit 0, 1 int the state member 
    254          
    255          */

   \                                 In section .text, align 2, keep-with-next
    256          void WIDGET_AndState(WM_HWIN hObj, int Mask) {
   \                     WIDGET_AndState: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    257            U16 StateNew;
    258            if (hObj) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD00C             BEQ.N    ??WIDGET_AndState_0
    259              WIDGET* pWidget;
    260              WM_LOCK();
    261              pWidget = WIDGET_H2P(hObj);
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
    262              StateNew = pWidget->State & (~Mask);
   \   0000000E   0x8CC1             LDRH     R1,[R0, #+38]
   \   00000010   0xEA21 0x0205      BIC      R2,R1,R5
    263              if (pWidget->State != StateNew) {
   \   00000014   0x4291             CMP      R1,R2
   \   00000016   0xD005             BEQ.N    ??WIDGET_AndState_0
    264                pWidget->State = StateNew;
   \   00000018   0x84C2             STRH     R2,[R0, #+38]
    265                WM_Invalidate(hObj);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000020   0x.... 0x....      B.W      WM_InvalidateWindow
    266              }
    267              WM_UNLOCK();
    268            }
    269          }
   \                     ??WIDGET_AndState_0: (+1)
   \   00000024   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    270          
    271          /*********************************************************************
    272          *
    273          *       WIDGET__Init
    274          */

   \                                 In section .text, align 2, keep-with-next
    275          void WIDGET__Init(WIDGET* pWidget, int Id, U16 State) {
    276            pWidget->pEffect       = _pEffectDefault;
   \                     WIDGET__Init: (+1)
   \   00000000   0x....             LDR.N    R3,??DataTable2
   \   00000002   0x681B             LDR      R3,[R3, #+0]
   \   00000004   0x6203             STR      R3,[R0, #+32]
    277            pWidget->State         = State;
   \   00000006   0x84C2             STRH     R2,[R0, #+38]
    278            pWidget->Id            = Id;
   \   00000008   0x8481             STRH     R1,[R0, #+36]
    279          }
   \   0000000A   0x4770             BX       LR               ;; return
    280          
    281          
    282          /*********************************************************************
    283          *
    284          *       WIDGET_HandleActive
    285          */

   \                                 In section .text, align 2, keep-with-next
    286          int WIDGET_HandleActive(WM_HWIN hObj, WM_MESSAGE* pMsg) {
   \                     WIDGET_HandleActive: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    287            int Diff, Notification;
    288            WIDGET* pWidget = WIDGET_H2P(hObj);
   \   00000006   0x.... 0x....      BL       GUI_ALLOC_h2p
    289            switch (pMsg->MsgId) {
   \   0000000A   0x6829             LDR      R1,[R5, #+0]
   \   0000000C   0x290D             CMP      R1,#+13
   \   0000000E   0xD02F             BEQ.N    ??WIDGET_HandleActive_0
   \   00000010   0x2911             CMP      R1,#+17
   \   00000012   0xD020             BEQ.N    ??WIDGET_HandleActive_1
   \   00000014   0x2914             CMP      R1,#+20
   \   00000016   0xD05A             BEQ.N    ??WIDGET_HandleActive_2
   \   00000018   0x2915             CMP      R1,#+21
   \   0000001A   0xD017             BEQ.N    ??WIDGET_HandleActive_3
   \   0000001C   0x2916             CMP      R1,#+22
   \   0000001E   0xD033             BEQ.N    ??WIDGET_HandleActive_4
   \   00000020   0x291F             CMP      R1,#+31
   \   00000022   0xD035             BEQ.N    ??WIDGET_HandleActive_5
   \   00000024   0x2920             CMP      R1,#+32
   \   00000026   0xD04A             BEQ.N    ??WIDGET_HandleActive_6
   \   00000028   0xF5B1 0x7F40      CMP      R1,#+768
   \   0000002C   0xD11E             BNE.N    ??WIDGET_HandleActive_7
    290            case WM_WIDGET_SET_EFFECT:
    291              Diff = pWidget->pEffect->EffectSize;
   \   0000002E   0x6A01             LDR      R1,[R0, #+32]
   \   00000030   0x6949             LDR      R1,[R1, #+20]
    292              pWidget->pEffect = (const WIDGET_EFFECT*)pMsg->Data.p;
   \   00000032   0x68AA             LDR      R2,[R5, #+8]
   \   00000034   0x6202             STR      R2,[R0, #+32]
    293              Diff -= pWidget->pEffect->EffectSize;
    294              _UpdateChildPostions(hObj, Diff);
   \   00000036   0x4610             MOV      R0,R2
   \   00000038   0x6940             LDR      R0,[R0, #+20]
   \   0000003A   0x1A09             SUBS     R1,R1,R0
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0x.... 0x....      BL       _UpdateChildPostions
    295              WM_InvalidateWindow(hObj);
   \   00000042   0x4620             MOV      R0,R4
   \   00000044   0x.... 0x....      BL       WM_InvalidateWindow
    296              return 0;                        /* Message handled -> Return */
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xBD32             POP      {R1,R4,R5,PC}
    297            case WM_GET_ID:
    298              pMsg->Data.v = pWidget->Id;
   \                     ??WIDGET_HandleActive_3: (+1)
   \   0000004C   0xF9B0 0x0024      LDRSH    R0,[R0, #+36]
   \   00000050   0x60A8             STR      R0,[R5, #+8]
    299              return 0;                        /* Message handled -> Return */
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xBD32             POP      {R1,R4,R5,PC}
    300            case WM_PID_STATE_CHANGED:
    301              if (pWidget->State & WIDGET_STATE_FOCUSSABLE) {
   \                     ??WIDGET_HandleActive_1: (+1)
   \   00000056   0xF890 0x0026      LDRB     R0,[R0, #+38]
   \   0000005A   0x06C0             LSLS     R0,R0,#+27
   \   0000005C   0xD506             BPL.N    ??WIDGET_HandleActive_7
    302                const WM_PID_STATE_CHANGED_INFO * pInfo = (const WM_PID_STATE_CHANGED_INFO*)pMsg->Data.p;
    303                if (pInfo->State) {
   \   0000005E   0x68A8             LDR      R0,[R5, #+8]
   \   00000060   0x7A00             LDRB     R0,[R0, #+8]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD002             BEQ.N    ??WIDGET_HandleActive_7
    304                  WM_SetFocus(hObj);
   \   00000066   0x4620             MOV      R0,R4
   \   00000068   0x.... 0x....      BL       WM_SetFocus
    305                }
    306              }
    307              break;
    308            case WM_TOUCH_CHILD:
    309              /* A descendent (child) has been touched or released.
    310                 If it has been touched, we need to get to top.
    311               */
    312              {
    313                const WM_MESSAGE * pMsgOrg;
    314                const GUI_PID_STATE * pState;
    315                pMsgOrg = (const WM_MESSAGE*)pMsg->Data.p;      /* The original touch message */
    316                pState = (const GUI_PID_STATE*)pMsgOrg->Data.p;
    317                if (pState) {          /* Message may not have a valid pointer (moved out) ! */
    318                  if (pState->Pressed) {
    319                    WM_BringToTop(hObj);
    320                    return 0;                    /* Message handled -> Return */
    321                  }
    322                }
    323              }
    324              break;
    325            case WM_SET_ID:
    326              pWidget->Id = pMsg->Data.v;
    327              return 0;                        /* Message handled -> Return */
    328            case WM_SET_FOCUS:
    329              if (pMsg->Data.v == 1) {
    330                WIDGET_SetState(hObj, pWidget->State |  WIDGET_STATE_FOCUS);
    331                Notification = WM_NOTIFICATION_GOT_FOCUS;
    332              } else {
    333                WIDGET_SetState(hObj, pWidget->State & ~WIDGET_STATE_FOCUS);
    334                Notification = WM_NOTIFICATION_LOST_FOCUS;
    335              }
    336              WM_NotifyParent(hObj, Notification);
    337              pMsg->Data.v = 0;   /* Focus change accepted */
    338              return 0;
    339            case WM_GET_ACCEPT_FOCUS:
    340              pMsg->Data.v = (pWidget->State & WIDGET_STATE_FOCUSSABLE) ? 1 : 0;               /* Can handle focus */
    341              return 0;                         /* Message handled */
    342            case WM_GET_INSIDE_RECT:
    343              WIDGET__GetInsideRect(pWidget, (GUI_RECT*)pMsg->Data.p);
    344              return 0;                         /* Message handled */
    345            }
    346            return 1;                           /* Message NOT handled */
   \                     ??WIDGET_HandleActive_7: (+1)
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   \                     ??WIDGET_HandleActive_0: (+1)
   \   00000070   0x68A8             LDR      R0,[R5, #+8]
   \   00000072   0x6880             LDR      R0,[R0, #+8]
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD0F9             BEQ.N    ??WIDGET_HandleActive_7
   \   00000078   0x7A00             LDRB     R0,[R0, #+8]
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD0F6             BEQ.N    ??WIDGET_HandleActive_7
   \   0000007E   0x4620             MOV      R0,R4
   \   00000080   0x.... 0x....      BL       WM_BringToTop
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??WIDGET_HandleActive_4: (+1)
   \   00000088   0x68A9             LDR      R1,[R5, #+8]
   \   0000008A   0x8481             STRH     R1,[R0, #+36]
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??WIDGET_HandleActive_5: (+1)
   \   00000090   0x8CC0             LDRH     R0,[R0, #+38]
   \   00000092   0x68A9             LDR      R1,[R5, #+8]
   \   00000094   0x2901             CMP      R1,#+1
   \   00000096   0xD106             BNE.N    ??WIDGET_HandleActive_8
   \   00000098   0xF040 0x0101      ORR      R1,R0,#0x1
   \   0000009C   0x4620             MOV      R0,R4
   \   0000009E   0x.... 0x....      BL       WIDGET_SetState
   \   000000A2   0x2108             MOVS     R1,#+8
   \   000000A4   0xE005             B.N      ??WIDGET_HandleActive_9
   \                     ??WIDGET_HandleActive_8: (+1)
   \   000000A6   0xF020 0x0101      BIC      R1,R0,#0x1
   \   000000AA   0x4620             MOV      R0,R4
   \   000000AC   0x.... 0x....      BL       WIDGET_SetState
   \   000000B0   0x2109             MOVS     R1,#+9
   \                     ??WIDGET_HandleActive_9: (+1)
   \   000000B2   0x4620             MOV      R0,R4
   \   000000B4   0x.... 0x....      BL       WM_NotifyParent
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0x60A8             STR      R0,[R5, #+8]
   \   000000BC   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??WIDGET_HandleActive_6: (+1)
   \   000000BE   0x8CC0             LDRH     R0,[R0, #+38]
   \   000000C0   0xB2C0             UXTB     R0,R0
   \   000000C2   0x0900             LSRS     R0,R0,#+4
   \   000000C4   0xF000 0x0001      AND      R0,R0,#0x1
   \   000000C8   0x60A8             STR      R0,[R5, #+8]
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??WIDGET_HandleActive_2: (+1)
   \   000000CE   0x68A9             LDR      R1,[R5, #+8]
   \   000000D0   0x.... 0x....      BL       WIDGET__GetInsideRect
   \   000000D4   0x2000             MOVS     R0,#+0
   \   000000D6   0xBD32             POP      {R1,R4,R5,PC}
    347          }
    348          
    349          /*********************************************************************
    350          *
    351          *       WIDGET__SetScrollState
    352          */

   \                                 In section .text, align 2, keep-with-next
    353          void WIDGET__SetScrollState(WM_HWIN hWin, const WM_SCROLL_STATE* pVState, const WM_SCROLL_STATE* pHState) {
   \                     WIDGET__SetScrollState: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    354            WM_HWIN hScroll;
    355            /* vertical scrollbar */
    356            hScroll = WM_GetDialogItem(hWin, GUI_ID_VSCROLL);
   \   00000008   0x21FE             MOVS     R1,#+254
   \   0000000A   0x.... 0x....      BL       WM_GetDialogItem
    357            WM_SetScrollState(hScroll, pVState);
   \   0000000E   0x4629             MOV      R1,R5
   \   00000010   0x.... 0x....      BL       WM_SetScrollState
    358            /* horizontal scrollbar */
    359            hScroll = WM_GetDialogItem(hWin, GUI_ID_HSCROLL);
   \   00000014   0x21FF             MOVS     R1,#+255
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       WM_GetDialogItem
    360            WM_SetScrollState(hScroll, pHState);
   \   0000001C   0x4631             MOV      R1,R6
   \   0000001E   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000022   0x.... 0x....      B.W      WM_SetScrollState
    361          }
    362          
    363          /*********************************************************************
    364          *
    365          *       WIDGET__DrawFocusRect
    366          */

   \                                 In section .text, align 2, keep-with-next
    367          void WIDGET__DrawFocusRect(WIDGET* pWidget, const GUI_RECT* pRect, int Dist) {
   \                     WIDGET__DrawFocusRect: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x460B             MOV      R3,R1
   \   00000004   0x4614             MOV      R4,R2
    368            GUI_RECT Rect;
    369            if (pWidget->State & WIDGET_STATE_VERTICAL) {
   \   00000006   0xF890 0x1026      LDRB     R1,[R0, #+38]
   \   0000000A   0x0709             LSLS     R1,R1,#+28
   \   0000000C   0xD504             BPL.N    ??WIDGET__DrawFocusRect_0
    370              WIDGET__RotateRect90(pWidget, &Rect, pRect);
   \   0000000E   0x461A             MOV      R2,R3
   \   00000010   0xA900             ADD      R1,SP,#+0
   \   00000012   0x.... 0x....      BL       WIDGET__RotateRect90
    371              pRect = &Rect;
   \   00000016   0xAB00             ADD      R3,SP,#+0
    372            }
    373            GUI_DrawFocusRect(pRect, Dist);
   \                     ??WIDGET__DrawFocusRect_0: (+1)
   \   00000018   0x4621             MOV      R1,R4
   \   0000001A   0x4618             MOV      R0,R3
   \   0000001C   0x.... 0x....      BL       GUI_DrawFocusRect
    374          }
   \   00000020   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    375          
    376          /*********************************************************************
    377          *
    378          *       WIDGET__DrawVLine
    379          */

   \                                 In section .text, align 2, keep-with-next
    380          void WIDGET__DrawVLine(WIDGET* pWidget, int x, int y0, int y1) {
   \                     WIDGET__DrawVLine: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x4611             MOV      R1,R2
   \   00000006   0x461A             MOV      R2,R3
    381            if (pWidget->State & WIDGET_STATE_VERTICAL) {
   \   00000008   0xF890 0x3026      LDRB     R3,[R0, #+38]
   \   0000000C   0x071B             LSLS     R3,R3,#+28
   \   0000000E   0xD515             BPL.N    ??WIDGET__DrawVLine_0
    382              GUI_RECT r0, r1;
    383              r0.x0 = x;
   \   00000010   0x4623             MOV      R3,R4
   \   00000012   0xF8AD 0x3000      STRH     R3,[SP, #+0]
    384              r0.x1 = x;
   \   00000016   0xF8AD 0x4004      STRH     R4,[SP, #+4]
    385              r0.y0 = y0;
   \   0000001A   0xF8AD 0x1002      STRH     R1,[SP, #+2]
    386              r0.y1 = y1;
   \   0000001E   0xF8AD 0x2006      STRH     R2,[SP, #+6]
    387              WIDGET__RotateRect90(pWidget, &r1, &r0);
   \   00000022   0xAA00             ADD      R2,SP,#+0
   \   00000024   0xA902             ADD      R1,SP,#+8
   \   00000026   0x.... 0x....      BL       WIDGET__RotateRect90
    388              GUI_DrawHLine(r1.y0, r1.x0, r1.x1);
   \   0000002A   0xF9BD 0x200C      LDRSH    R2,[SP, #+12]
   \   0000002E   0xF9BD 0x1008      LDRSH    R1,[SP, #+8]
   \   00000032   0xF9BD 0x000A      LDRSH    R0,[SP, #+10]
   \   00000036   0x.... 0x....      BL       GUI_DrawHLine
   \   0000003A   0xBD1F             POP      {R0-R4,PC}
    389            } else {
    390              GUI_DrawVLine(x, y0, y1);
   \                     ??WIDGET__DrawVLine_0: (+1)
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0x.... 0x....      BL       GUI_DrawVLine
    391            }
    392          }
   \   00000042   0xBD1F             POP      {R0-R4,PC}       ;; return
    393          
    394          /*********************************************************************
    395          *
    396          *       WIDGET__FillRectEx
    397          */

   \                                 In section .text, align 2, keep-with-next
    398          void WIDGET__FillRectEx(WIDGET* pWidget, const GUI_RECT* pRect) {
   \                     WIDGET__FillRectEx: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    399            if (pWidget->State & WIDGET_STATE_VERTICAL) {
   \   00000004   0xF890 0x2026      LDRB     R2,[R0, #+38]
   \   00000008   0x0712             LSLS     R2,R2,#+28
   \   0000000A   0xD504             BPL.N    ??WIDGET__FillRectEx_0
    400              GUI_RECT r;
    401              WIDGET__RotateRect90(pWidget, &r, pRect);
   \   0000000C   0x460A             MOV      R2,R1
   \   0000000E   0xA900             ADD      R1,SP,#+0
   \   00000010   0x.... 0x....      BL       WIDGET__RotateRect90
    402              pRect = &r;
   \   00000014   0xA900             ADD      R1,SP,#+0
    403            }
    404            GUI_FillRectEx(pRect);
   \                     ??WIDGET__FillRectEx_0: (+1)
   \   00000016   0x4608             MOV      R0,R1
   \   00000018   0x.... 0x....      BL       GUI_FillRectEx
    405          }
   \   0000001C   0xBD07             POP      {R0-R2,PC}       ;; return
    406          
    407          /*********************************************************************
    408          *
    409          *       WIDGET__EFFECT_DrawDownRect
    410          */

   \                                 In section .text, align 2, keep-with-next
    411          void WIDGET__EFFECT_DrawDownRect(WIDGET* pWidget, GUI_RECT* pRect) {
   \                     WIDGET__EFFECT_DrawDownRect: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    412            GUI_RECT Rect;
    413            if (pRect == NULL) {
   \   00000008   0xD103             BNE.N    ??WIDGET__EFFECT_DrawDownRect_0
    414              WM_GetClientRect(&Rect);
   \   0000000A   0xA800             ADD      R0,SP,#+0
   \   0000000C   0x.... 0x....      BL       WM_GetClientRect
    415              pRect = &Rect;
   \   00000010   0xAD00             ADD      R5,SP,#+0
    416            }
    417            if (pWidget->State & WIDGET_STATE_VERTICAL) {
   \                     ??WIDGET__EFFECT_DrawDownRect_0: (+1)
   \   00000012   0xF894 0x0026      LDRB     R0,[R4, #+38]
   \   00000016   0x0700             LSLS     R0,R0,#+28
   \   00000018   0xD505             BPL.N    ??WIDGET__EFFECT_DrawDownRect_1
    418              WIDGET__RotateRect90(pWidget, &Rect, pRect);
   \   0000001A   0x462A             MOV      R2,R5
   \   0000001C   0xA900             ADD      R1,SP,#+0
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       WIDGET__RotateRect90
    419              pRect = &Rect;
   \   00000024   0xAD00             ADD      R5,SP,#+0
    420            }
    421            if (_EffectRequiresRedraw(pWidget, pRect)) {
   \                     ??WIDGET__EFFECT_DrawDownRect_1: (+1)
   \   00000026   0x4629             MOV      R1,R5
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       _EffectRequiresRedraw
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD003             BEQ.N    ??WIDGET__EFFECT_DrawDownRect_2
    422              pWidget->pEffect->pfDrawDownRect(pRect);
   \   00000032   0x4628             MOV      R0,R5
   \   00000034   0x6A21             LDR      R1,[R4, #+32]
   \   00000036   0x68C9             LDR      R1,[R1, #+12]
   \   00000038   0x4788             BLX      R1
    423            }
    424          }
   \                     ??WIDGET__EFFECT_DrawDownRect_2: (+1)
   \   0000003A   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    425          
    426          /*********************************************************************
    427          *
    428          *       WIDGET__EFFECT_DrawDown
    429          */

   \                                 In section .text, align 2, keep-with-next
    430          void WIDGET__EFFECT_DrawDown(WIDGET* pWidget) {
    431            WIDGET__EFFECT_DrawDownRect(pWidget, NULL);
   \                     WIDGET__EFFECT_DrawDown: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x....             B.N      WIDGET__EFFECT_DrawDownRect
    432          }
    433          
    434          /*********************************************************************
    435          *
    436          *       WIDGET__EFFECT_DrawUpRect
    437          */

   \                                 In section .text, align 2, keep-with-next
    438          void WIDGET__EFFECT_DrawUpRect(WIDGET* pWidget, GUI_RECT* pRect) {
   \                     WIDGET__EFFECT_DrawUpRect: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    439            GUI_RECT Rect;
    440            if (pWidget->State & WIDGET_STATE_VERTICAL) {
   \   00000008   0xF894 0x0026      LDRB     R0,[R4, #+38]
   \   0000000C   0x0700             LSLS     R0,R0,#+28
   \   0000000E   0xD505             BPL.N    ??WIDGET__EFFECT_DrawUpRect_0
    441              WIDGET__RotateRect90(pWidget, &Rect, pRect);
   \   00000010   0x462A             MOV      R2,R5
   \   00000012   0xA900             ADD      R1,SP,#+0
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       WIDGET__RotateRect90
    442              pRect = &Rect;
   \   0000001A   0xAD00             ADD      R5,SP,#+0
    443            }
    444            if (_EffectRequiresRedraw(pWidget, pRect)) {
   \                     ??WIDGET__EFFECT_DrawUpRect_0: (+1)
   \   0000001C   0x4629             MOV      R1,R5
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       _EffectRequiresRedraw
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD003             BEQ.N    ??WIDGET__EFFECT_DrawUpRect_1
    445              pWidget->pEffect->pfDrawUpRect(pRect);
   \   00000028   0x4628             MOV      R0,R5
   \   0000002A   0x6A21             LDR      R1,[R4, #+32]
   \   0000002C   0x6889             LDR      R1,[R1, #+8]
   \   0000002E   0x4788             BLX      R1
    446            }
    447          }
   \                     ??WIDGET__EFFECT_DrawUpRect_1: (+1)
   \   00000030   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    448          
    449          /*********************************************************************
    450          *
    451          *       WIDGET_SetDefaultEffect
    452          */

   \                                 In section .text, align 2, keep-with-next
    453          const WIDGET_EFFECT* WIDGET_SetDefaultEffect(const WIDGET_EFFECT* pEffect) {
    454            const WIDGET_EFFECT* r;
    455            r = _pEffectDefault;
   \                     WIDGET_SetDefaultEffect: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable2
   \   00000002   0x6811             LDR      R1,[R2, #+0]
    456            _pEffectDefault = pEffect;
   \   00000004   0x6010             STR      R0,[R2, #+0]
    457            return r;
   \   00000006   0x4608             MOV      R0,R1
   \   00000008   0x4770             BX       LR               ;; return
    458          }
    459          
    460          /*********************************************************************
    461          *
    462          *       WIDGET_GetDefaultEffect
    463          */

   \                                 In section .text, align 2, keep-with-next
    464          const WIDGET_EFFECT*  WIDGET_GetDefaultEffect(void) {
    465            return _pEffectDefault;
   \                     WIDGET_GetDefaultEffect: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable2
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    466          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     _pEffectDefault
    467          
    468          
    469          #else                            /* Avoid problems with empty object modules */
    470            void WIDGET_C(void) {}
    471          #endif /* GUI_WINSUPPORT */
    472          
    473          
    474          
    475          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   WIDGET_AndState
        16   -> GUI_ALLOC_h2p
         0   -> WM_InvalidateWindow
       0   WIDGET_GetDefaultEffect
       8   WIDGET_GetState
         8   -> GUI_ALLOC_h2p
      16   WIDGET_HandleActive
        16   -> GUI_ALLOC_h2p
        16   -> WIDGET_SetState
        16   -> WIDGET__GetInsideRect
        16   -> WM_BringToTop
        16   -> WM_InvalidateWindow
        16   -> WM_NotifyParent
        16   -> WM_SetFocus
        16   -> _UpdateChildPostions
      16   WIDGET_OrState
        16   -> GUI_ALLOC_h2p
         0   -> WM_InvalidateWindow
       0   WIDGET_SetDefaultEffect
      16   WIDGET_SetState
        16   -> GUI_ALLOC_h2p
         0   -> WM_InvalidateWindow
      16   WIDGET__DrawFocusRect
        16   -> GUI_DrawFocusRect
        16   -> WIDGET__RotateRect90
      24   WIDGET__DrawVLine
        24   -> GUI_DrawHLine
        24   -> GUI_DrawVLine
        24   -> WIDGET__RotateRect90
       0   WIDGET__EFFECT_DrawDown
         0   -> WIDGET__EFFECT_DrawDownRect
      24   WIDGET__EFFECT_DrawDownRect
        24   -- Indirect call
        24   -> WIDGET__RotateRect90
        24   -> WM_GetClientRect
        24   -> _EffectRequiresRedraw
      24   WIDGET__EFFECT_DrawUpRect
        24   -- Indirect call
        24   -> WIDGET__RotateRect90
        24   -> _EffectRequiresRedraw
      16   WIDGET__FillRectEx
        16   -> GUI_FillRectEx
        16   -> WIDGET__RotateRect90
       8   WIDGET__GetBkColor
         0   -> DIALOG_GetBkColor
         8   -> WM_GetBkColor
         8   -> WM_GetParent
      16   WIDGET__GetClientRect
        16   -> WM_GetClientRect
      16   WIDGET__GetInsideRect
         0   -> GUI__ReduceRect
        16   -> WM__GetClientRectWin
       8   WIDGET__GetWindowSizeX
         8   -> GUI_ALLOC_h2p
         0   -> WM_GetWindowSizeX
         0   -> WM_GetWindowSizeY
       0   WIDGET__GetXSize
       0   WIDGET__GetYSize
       0   WIDGET__Init
       8   WIDGET__RotateRect90
      16   WIDGET__SetScrollState
        16   -> WM_GetDialogItem
         0   -> WM_SetScrollState
        16   -> WM_SetScrollState
      24   _EffectRequiresRedraw
        24   -> WM__Client2Screen
        24   -> __aeabi_memcpy
      16   _UpdateChildPostions
        16   -> GUI_ALLOC_h2p
        16   -> WM__UpdateChildPositions


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
      38  WIDGET_AndState
       6  WIDGET_GetDefaultEffect
      22  WIDGET_GetState
     216  WIDGET_HandleActive
      40  WIDGET_OrState
      10  WIDGET_SetDefaultEffect
      30  WIDGET_SetState
      34  WIDGET__DrawFocusRect
      68  WIDGET__DrawVLine
       4  WIDGET__EFFECT_DrawDown
      60  WIDGET__EFFECT_DrawDownRect
      50  WIDGET__EFFECT_DrawUpRect
      30  WIDGET__FillRectEx
      28  WIDGET__GetBkColor
      52  WIDGET__GetClientRect
      26  WIDGET__GetInsideRect
      34  WIDGET__GetWindowSizeX
      34  WIDGET__GetXSize
      34  WIDGET__GetYSize
      12  WIDGET__Init
      40  WIDGET__RotateRect90
      38  WIDGET__SetScrollState
     108  _EffectRequiresRedraw
      24  _UpdateChildPostions
       4  _pEffectDefault

 
     4 bytes in section .data
 1 042 bytes in section .text
 
 1 042 bytes of CODE memory
     4 bytes of DATA memory

Errors: none
Warnings: none
