###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  10:59:11
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Widget\LISTVIEW.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Widget\LISTVIEW.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\LISTVIEW.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\LISTVIEW.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Widget\LISTVIEW.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              µC/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : LISTVIEW.c
     16          Purpose     : Implementation of listview widget
     17          ---------------------------END-OF-HEADER------------------------------
     18          */
     19          
     20          #include "GUI_ARRAY.h"
     21          #include <stdlib.h>
     22          #include <string.h>
     23          #include "LISTVIEW_Private.h"
     24          #include "HEADER.h"
     25          #include "WIDGET.h"
     26          #include "SCROLLBAR.h"
     27          #include "GUIDebug.h"
     28          #include "GUI_Protected.h"
     29          #include "WM_Intern.h"
     30          
     31          #if GUI_WINSUPPORT
     32          
     33          /*********************************************************************
     34          *
     35          *       Private config defaults
     36          *
     37          **********************************************************************
     38          */
     39          
     40          /* Define default fonts */
     41          #ifndef LISTVIEW_FONT_DEFAULT
     42            #define LISTVIEW_FONT_DEFAULT &GUI_Font13_1
     43          #endif
     44          
     45          /* Define colors */
     46          #ifndef LISTVIEW_BKCOLOR0_DEFAULT
     47            #define LISTVIEW_BKCOLOR0_DEFAULT GUI_WHITE     /* Not selected */
     48          #endif
     49          
     50          #ifndef LISTVIEW_BKCOLOR1_DEFAULT
     51            #define LISTVIEW_BKCOLOR1_DEFAULT GUI_GRAY      /* Selected, no focus */
     52          #endif
     53          
     54          #ifndef LISTVIEW_BKCOLOR2_DEFAULT
     55            #define LISTVIEW_BKCOLOR2_DEFAULT GUI_BLUE      /* Selected, focus */
     56          #endif
     57          
     58          #ifndef LISTVIEW_TEXTCOLOR0_DEFAULT
     59            #define LISTVIEW_TEXTCOLOR0_DEFAULT GUI_BLACK   /* Not selected */
     60          #endif
     61          
     62          #ifndef LISTVIEW_TEXTCOLOR1_DEFAULT
     63            #define LISTVIEW_TEXTCOLOR1_DEFAULT GUI_WHITE   /* Selected, no focus */
     64          #endif
     65          
     66          #ifndef LISTVIEW_TEXTCOLOR2_DEFAULT
     67            #define LISTVIEW_TEXTCOLOR2_DEFAULT GUI_WHITE   /* Selected, focus */
     68          #endif
     69          
     70          #ifndef LISTVIEW_GRIDCOLOR_DEFAULT
     71            #define LISTVIEW_GRIDCOLOR_DEFAULT GUI_LIGHTGRAY
     72          #endif
     73          
     74          /* Define default alignment */
     75          #ifndef LISTVIEW_ALIGN_DEFAULT
     76            #define LISTVIEW_ALIGN_DEFAULT (GUI_TA_VCENTER | GUI_TA_HCENTER)
     77          #endif
     78          
     79          /*********************************************************************
     80          *
     81          *       Static data
     82          *
     83          **********************************************************************
     84          */

   \                                 In section .data, align 4
     85          LISTVIEW_PROPS LISTVIEW_DefaultProps = {
   \                     LISTVIEW_DefaultProps:
   \   00000000   0x00FFFFFF         DC32 16777215, 8421504, 16711680, 0, 16777215, 16777215, 13882323
   \              0x00808080   
   \              0x00FF0000   
   \              0x00000000   
   \              0x00FFFFFF   
   \              0x00FFFFFF   
   \              0x00D3D3D3   
   \   0000001C   0x........         DC32 GUI_Font13_1
     86            LISTVIEW_BKCOLOR0_DEFAULT,
     87            LISTVIEW_BKCOLOR1_DEFAULT,
     88            LISTVIEW_BKCOLOR2_DEFAULT,
     89            LISTVIEW_TEXTCOLOR0_DEFAULT,
     90            LISTVIEW_TEXTCOLOR1_DEFAULT,
     91            LISTVIEW_TEXTCOLOR2_DEFAULT,
     92            LISTVIEW_GRIDCOLOR_DEFAULT,
     93            LISTVIEW_FONT_DEFAULT
     94          };
     95          
     96          /*********************************************************************
     97          *
     98          *       Static routines
     99          *
    100          **********************************************************************
    101          */
    102          /*********************************************************************
    103          *
    104          *       LISTVIEW__GetRowDistY
    105          */

   \                                 In section .text, align 2, keep-with-next
    106          unsigned LISTVIEW__GetRowDistY(const LISTVIEW_Obj* pObj) {
   \                     LISTVIEW__GetRowDistY: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    107            unsigned RowDistY;
    108            if (pObj->RowDistY) {
   \   00000004   0x6DE0             LDR      R0,[R4, #+92]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD106             BNE.N    ??LISTVIEW__GetRowDistY_0
    109              RowDistY = pObj->RowDistY;
    110            } else {
    111              RowDistY = GUI_GetYDistOfFont(pObj->Props.pFont);
   \   0000000A   0x6D20             LDR      R0,[R4, #+80]
   \   0000000C   0x.... 0x....      BL       GUI_GetYDistOfFont
    112              if (pObj->ShowGrid) {
   \   00000010   0x6DA1             LDR      R1,[R4, #+88]
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xD000             BEQ.N    ??LISTVIEW__GetRowDistY_0
    113                RowDistY++;
   \   00000016   0x1C40             ADDS     R0,R0,#+1
    114              }
    115            }
    116            return RowDistY;
   \                     ??LISTVIEW__GetRowDistY_0: (+1)
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
    117          }
    118          
    119          /*********************************************************************
    120          *
    121          *       _GetNumVisibleRows
    122          *
    123          * Purpose:
    124          *   Returns the number of visible rows according the header
    125          *   and (if exist) horizontal scrollbar.
    126          *
    127          * Return value:
    128          *   Number of visible rows. If no entire row can be displayed, this
    129          *   function will return one.
    130          */

   \                                 In section .text, align 2, keep-with-next
    131          static unsigned _GetNumVisibleRows(LISTVIEW_Handle hObj, const LISTVIEW_Obj* pObj) {
   \                     _GetNumVisibleRows: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x460D             MOV      R5,R1
    132            unsigned RowDistY, ySize, r = 1;
   \   00000004   0x2401             MOVS     R4,#+1
    133            GUI_RECT Rect;
    134            WM_GetInsideRectExScrollbar(hObj, &Rect);
   \   00000006   0xA900             ADD      R1,SP,#+0
   \   00000008   0x.... 0x....      BL       WM_GetInsideRectExScrollbar
    135            ySize    = Rect.y1 - Rect.y0 + 1 - HEADER_GetHeight(pObj->hHeader);
   \   0000000C   0xF9B5 0x0028      LDRSH    R0,[R5, #+40]
   \   00000010   0x.... 0x....      BL       HEADER_GetHeight
   \   00000014   0xF9BD 0x1006      LDRSH    R1,[SP, #+6]
   \   00000018   0xF9BD 0x2002      LDRSH    R2,[SP, #+2]
   \   0000001C   0x1A89             SUBS     R1,R1,R2
   \   0000001E   0x1C49             ADDS     R1,R1,#+1
   \   00000020   0x1A0E             SUBS     R6,R1,R0
    136            RowDistY = LISTVIEW__GetRowDistY(pObj);
   \   00000022   0x4628             MOV      R0,R5
   \   00000024   0x.... 0x....      BL       LISTVIEW__GetRowDistY
    137            if (RowDistY) {
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD004             BEQ.N    ??_GetNumVisibleRows_0
    138              r = ySize / RowDistY;
   \   0000002C   0xFBB6 0xF4F0      UDIV     R4,R6,R0
    139              r = (r == 0) ? 1 : r;
   \   00000030   0x2C00             CMP      R4,#+0
   \   00000032   0xD100             BNE.N    ??_GetNumVisibleRows_0
   \   00000034   0x2401             MOVS     R4,#+1
    140            }
    141            return r;
   \                     ??_GetNumVisibleRows_0: (+1)
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    142          }
    143          
    144          /*********************************************************************
    145          *
    146          *       _Paint
    147          */

   \                                 In section .text, align 2, keep-with-next
    148          static void _Paint(LISTVIEW_Handle hObj, LISTVIEW_Obj* pObj, WM_MESSAGE* pMsg) {
   \                     _Paint: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB08F             SUB      SP,SP,#+60
   \   00000006   0x4606             MOV      R6,R0
   \   00000008   0x460C             MOV      R4,R1
   \   0000000A   0x4617             MOV      R7,R2
    149            const GUI_ARRAY* pRow;
    150            GUI_RECT ClipRect, Rect;
    151            int NumRows, NumVisRows, NumColumns;
    152            int LBorder, RBorder, EffectSize;
    153            int xPos, yPos, Width, RowDistY;
    154            int Align, i, j, EndRow;
    155            /* Init some values */
    156            NumColumns = HEADER_GetNumItems(pObj->hHeader);
   \   0000000C   0xF9B4 0x0028      LDRSH    R0,[R4, #+40]
   \   00000010   0x.... 0x....      BL       HEADER_GetNumItems
   \   00000014   0x900A             STR      R0,[SP, #+40]
    157            NumRows    = GUI_ARRAY_GetNumItems(&pObj->RowArray);
   \   00000016   0xF104 0x002A      ADD      R0,R4,#+42
   \   0000001A   0x.... 0x....      BL       GUI_ARRAY_GetNumItems
   \   0000001E   0x4680             MOV      R8,R0
    158            NumVisRows = _GetNumVisibleRows(hObj, pObj);
   \   00000020   0x4621             MOV      R1,R4
   \   00000022   0x4630             MOV      R0,R6
   \   00000024   0x.... 0x....      BL       _GetNumVisibleRows
   \   00000028   0x9007             STR      R0,[SP, #+28]
    159            RowDistY   = LISTVIEW__GetRowDistY(pObj);
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       LISTVIEW__GetRowDistY
   \   00000030   0x9006             STR      R0,[SP, #+24]
    160            LBorder    = pObj->LBorder;
   \   00000032   0x6E20             LDR      R0,[R4, #+96]
   \   00000034   0x900D             STR      R0,[SP, #+52]
    161            RBorder    = pObj->RBorder;
   \   00000036   0x6E60             LDR      R0,[R4, #+100]
   \   00000038   0x900C             STR      R0,[SP, #+48]
    162            EffectSize = pObj->Widget.pEffect->EffectSize;
   \   0000003A   0x6A20             LDR      R0,[R4, #+32]
   \   0000003C   0x6940             LDR      R0,[R0, #+20]
   \   0000003E   0x9004             STR      R0,[SP, #+16]
    163            yPos       = HEADER_GetHeight(pObj->hHeader) + EffectSize;
   \   00000040   0xF9B4 0x0028      LDRSH    R0,[R4, #+40]
   \   00000044   0x.... 0x....      BL       HEADER_GetHeight
   \   00000048   0x9904             LDR      R1,[SP, #+16]
   \   0000004A   0x180D             ADDS     R5,R1,R0
    164            EndRow     = pObj->ScrollStateV.v + (((NumVisRows + 1) > NumRows) ? NumRows : NumVisRows + 1);
   \   0000004C   0x9807             LDR      R0,[SP, #+28]
   \   0000004E   0x1C40             ADDS     R0,R0,#+1
   \   00000050   0x4580             CMP      R8,R0
   \   00000052   0xDD00             BLE.N    ??_Paint_0
   \   00000054   0x4680             MOV      R8,R0
   \                     ??_Paint_0: (+1)
   \   00000056   0x6EE0             LDR      R0,[R4, #+108]
   \   00000058   0x4440             ADD      R0,R8,R0
   \   0000005A   0x900B             STR      R0,[SP, #+44]
    165            /* Calculate clipping rectangle */
    166            ClipRect = *(const GUI_RECT*)pMsg->Data.p;
   \   0000005C   0xA802             ADD      R0,SP,#+8
   \   0000005E   0x68B9             LDR      R1,[R7, #+8]
   \   00000060   0x2208             MOVS     R2,#+8
   \   00000062   0x.... 0x....      BL       __aeabi_memcpy
    167            GUI_MoveRect(&ClipRect, -pObj->Widget.Win.Rect.x0, -pObj->Widget.Win.Rect.y0);
   \   00000066   0xF9B4 0x0002      LDRSH    R0,[R4, #+2]
   \   0000006A   0x4242             RSBS     R2,R0,#+0
   \   0000006C   0xF9B4 0x0000      LDRSH    R0,[R4, #+0]
   \   00000070   0x4241             RSBS     R1,R0,#+0
   \   00000072   0xA802             ADD      R0,SP,#+8
   \   00000074   0x.... 0x....      BL       GUI_MoveRect
    168            WM_GetInsideRectExScrollbar(hObj, &Rect);
   \   00000078   0xA900             ADD      R1,SP,#+0
   \   0000007A   0x4630             MOV      R0,R6
   \   0000007C   0x.... 0x....      BL       WM_GetInsideRectExScrollbar
    169            GUI__IntersectRect(&ClipRect, &Rect);
   \   00000080   0xA900             ADD      R1,SP,#+0
   \   00000082   0xA802             ADD      R0,SP,#+8
   \   00000084   0x.... 0x....      BL       GUI__IntersectRect
    170            /* Set drawing color, font and text mode */
    171            LCD_SetColor(pObj->Props.aTextColor[0]);
   \   00000088   0x6C20             LDR      R0,[R4, #+64]
   \   0000008A   0x.... 0x....      BL       LCD_SetColor
    172            GUI_SetFont(pObj->Props.pFont);
   \   0000008E   0x6D20             LDR      R0,[R4, #+80]
   \   00000090   0x.... 0x....      BL       GUI_SetFont
    173            GUI_SetTextMode(GUI_TM_TRANS);
   \   00000094   0x2002             MOVS     R0,#+2
   \   00000096   0x.... 0x....      BL       GUI_SetTextMode
    174            /* Do the drawing */
    175            for (i = pObj->ScrollStateV.v; i < EndRow; i++) {
   \   0000009A   0x6EE6             LDR      R6,[R4, #+108]
   \   0000009C   0xE00D             B.N      ??_Paint_1
    176              pRow = (const GUI_ARRAY*)GUI_ARRAY_GetpItem(&pObj->RowArray, i);
    177              if (pRow) {
    178                Rect.y0 = yPos;
    179                /* Break when all other rows are outside the drawing area */
    180                if (Rect.y0 > ClipRect.y1) {
    181                  break;
    182                }
    183                Rect.y1 = yPos + RowDistY - 1;
    184                /* Make sure that we draw only when row is in drawing area */
    185                if (Rect.y1 >= ClipRect.y0) {
    186                  int ColorIndex;
    187                  /* Set background color */
    188                  if (i == pObj->Sel) {
    189                    ColorIndex = (pObj->Widget.State & WIDGET_STATE_FOCUS) ? 2 : 1;
    190                  } else {
    191                    ColorIndex = 0;
    192                  }
    193                  LCD_SetBkColor(pObj->Props.aBkColor[ColorIndex]);
    194                  /* Iterate over all columns */
    195                  if (pObj->ShowGrid) {
    196                    Rect.y1--;
    197                  }
    198                  xPos = EffectSize - pObj->ScrollStateH.v;
    199                  for (j = 0; j < NumColumns; j++) {
    200                    Width   = HEADER_GetItemWidth(pObj->hHeader, j);
    201                    Rect.x0 = xPos;
    202                    /* Break when all other columns are outside the drawing area */
    203                    if (Rect.x0 > ClipRect.x1) {
    204                      break;
    205                    }
    206                    Rect.x1 = xPos + Width - 1;
    207                    /* Make sure that we draw only when column is in drawing area */
    208                    if (Rect.x1 >= ClipRect.x0) {
    209                      LISTVIEW_ITEM * pItem;
    210                      pItem = (LISTVIEW_ITEM *)GUI_ARRAY_GetpItem(pRow, j);
    211                      if (pItem->hItemInfo) {
    212                        LISTVIEW_ITEM_INFO * pItemInfo;
    213                        pItemInfo = (LISTVIEW_ITEM_INFO *)GUI_ALLOC_h2p(pItem->hItemInfo);
    214                        LCD_SetBkColor(pItemInfo->aBkColor[ColorIndex]);
    215                        LCD_SetColor(pItemInfo->aTextColor[ColorIndex]);
    216                      } else {
    217                        LCD_SetColor(pObj->Props.aTextColor[ColorIndex]);
    218                      }
    219                      /* Clear background */
    220                      GUI_ClearRect(Rect.x0, Rect.y0, Rect.x1, Rect.y1);
    221                      /* Draw text */
    222                      Rect.x0 += LBorder;
    223                      Rect.x1 -= RBorder;
    224                      Align = *((int*)GUI_ARRAY_GetpItem(&pObj->AlignArray, j));
    225                      GUI_DispStringInRect(pItem->acText, &Rect, Align);
    226                      if (pItem->hItemInfo) {
    227                        LCD_SetBkColor(pObj->Props.aBkColor[ColorIndex]);
    228                      }
    229                    }
    230                    xPos += Width;
    231                  }
    232                  /* Clear unused area to the right of items */
    233                  if (xPos <= ClipRect.x1) {
   \                     ??_Paint_2: (+1)
   \   0000009E   0xF9BD 0x200C      LDRSH    R2,[SP, #+12]
   \   000000A2   0x4542             CMP      R2,R8
   \   000000A4   0xDB06             BLT.N    ??_Paint_3
    234                    GUI_ClearRect(xPos, Rect.y0, ClipRect.x1, Rect.y1);
   \   000000A6   0xF9BD 0x3006      LDRSH    R3,[SP, #+6]
   \   000000AA   0xF9BD 0x1002      LDRSH    R1,[SP, #+2]
   \   000000AE   0x4640             MOV      R0,R8
   \   000000B0   0x.... 0x....      BL       GUI_ClearRect
    235                  }
    236                }
    237                yPos += RowDistY;
   \                     ??_Paint_3: (+1)
   \   000000B4   0x9806             LDR      R0,[SP, #+24]
   \   000000B6   0x1945             ADDS     R5,R0,R5
   \                     ??_Paint_4: (+1)
   \   000000B8   0x1C76             ADDS     R6,R6,#+1
   \                     ??_Paint_1: (+1)
   \   000000BA   0x980B             LDR      R0,[SP, #+44]
   \   000000BC   0x4286             CMP      R6,R0
   \   000000BE   0xF280 0x80A2      BGE.W    ??_Paint_5
   \   000000C2   0x4631             MOV      R1,R6
   \   000000C4   0xF104 0x002A      ADD      R0,R4,#+42
   \   000000C8   0x.... 0x....      BL       GUI_ARRAY_GetpItem
   \   000000CC   0x9009             STR      R0,[SP, #+36]
   \   000000CE   0x2800             CMP      R0,#+0
   \   000000D0   0xD0F2             BEQ.N    ??_Paint_4
   \   000000D2   0x4628             MOV      R0,R5
   \   000000D4   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   \   000000D8   0xF9BD 0x000E      LDRSH    R0,[SP, #+14]
   \   000000DC   0xF9BD 0x1002      LDRSH    R1,[SP, #+2]
   \   000000E0   0x4288             CMP      R0,R1
   \   000000E2   0xF2C0 0x8090      BLT.W    ??_Paint_5
   \   000000E6   0x9806             LDR      R0,[SP, #+24]
   \   000000E8   0x1940             ADDS     R0,R0,R5
   \   000000EA   0x1E40             SUBS     R0,R0,#+1
   \   000000EC   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   \   000000F0   0xF9BD 0x100A      LDRSH    R1,[SP, #+10]
   \   000000F4   0xB200             SXTH     R0,R0
   \   000000F6   0x4288             CMP      R0,R1
   \   000000F8   0xDBDC             BLT.N    ??_Paint_3
   \   000000FA   0x6D60             LDR      R0,[R4, #+84]
   \   000000FC   0x4286             CMP      R6,R0
   \   000000FE   0xD107             BNE.N    ??_Paint_6
   \   00000100   0xF894 0x0026      LDRB     R0,[R4, #+38]
   \   00000104   0x07C0             LSLS     R0,R0,#+31
   \   00000106   0xD501             BPL.N    ??_Paint_7
   \   00000108   0x2702             MOVS     R7,#+2
   \   0000010A   0xE002             B.N      ??_Paint_8
   \                     ??_Paint_7: (+1)
   \   0000010C   0x2701             MOVS     R7,#+1
   \   0000010E   0xE000             B.N      ??_Paint_8
   \                     ??_Paint_6: (+1)
   \   00000110   0x2700             MOVS     R7,#+0
   \                     ??_Paint_8: (+1)
   \   00000112   0xEB04 0x0087      ADD      R0,R4,R7, LSL #+2
   \   00000116   0x9005             STR      R0,[SP, #+20]
   \   00000118   0x6B40             LDR      R0,[R0, #+52]
   \   0000011A   0x.... 0x....      BL       LCD_SetBkColor
   \   0000011E   0x6DA0             LDR      R0,[R4, #+88]
   \   00000120   0x2800             CMP      R0,#+0
   \   00000122   0xD004             BEQ.N    ??_Paint_9
   \   00000124   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \   00000128   0x1E40             SUBS     R0,R0,#+1
   \   0000012A   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   \                     ??_Paint_9: (+1)
   \   0000012E   0x9804             LDR      R0,[SP, #+16]
   \   00000130   0x6FA1             LDR      R1,[R4, #+120]
   \   00000132   0xEBA0 0x0801      SUB      R8,R0,R1
   \   00000136   0xF04F 0x0900      MOV      R9,#+0
   \   0000013A   0xE030             B.N      ??_Paint_10
   \                     ??_Paint_11: (+1)
   \   0000013C   0x9805             LDR      R0,[SP, #+20]
   \   0000013E   0x6C00             LDR      R0,[R0, #+64]
   \   00000140   0x.... 0x....      BL       LCD_SetColor
   \                     ??_Paint_12: (+1)
   \   00000144   0xF9BD 0x3006      LDRSH    R3,[SP, #+6]
   \   00000148   0xF9BD 0x2004      LDRSH    R2,[SP, #+4]
   \   0000014C   0xF9BD 0x1002      LDRSH    R1,[SP, #+2]
   \   00000150   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \   00000154   0x.... 0x....      BL       GUI_ClearRect
   \   00000158   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000015C   0x990D             LDR      R1,[SP, #+52]
   \   0000015E   0x1808             ADDS     R0,R1,R0
   \   00000160   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   00000164   0xF8BD 0x0004      LDRH     R0,[SP, #+4]
   \   00000168   0x990C             LDR      R1,[SP, #+48]
   \   0000016A   0x1A40             SUBS     R0,R0,R1
   \   0000016C   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   \   00000170   0x4649             MOV      R1,R9
   \   00000172   0xF104 0x002E      ADD      R0,R4,#+46
   \   00000176   0x.... 0x....      BL       GUI_ARRAY_GetpItem
   \   0000017A   0x6802             LDR      R2,[R0, #+0]
   \   0000017C   0xA900             ADD      R1,SP,#+0
   \   0000017E   0xF10A 0x0002      ADD      R0,R10,#+2
   \   00000182   0x.... 0x....      BL       GUI_DispStringInRect
   \   00000186   0xF9BA 0x0000      LDRSH    R0,[R10, #+0]
   \   0000018A   0x2800             CMP      R0,#+0
   \   0000018C   0xD003             BEQ.N    ??_Paint_13
   \   0000018E   0x9805             LDR      R0,[SP, #+20]
   \   00000190   0x6B40             LDR      R0,[R0, #+52]
   \   00000192   0x.... 0x....      BL       LCD_SetBkColor
   \                     ??_Paint_13: (+1)
   \   00000196   0x9808             LDR      R0,[SP, #+32]
   \   00000198   0x4480             ADD      R8,R0,R8
   \   0000019A   0xF109 0x0901      ADD      R9,R9,#+1
   \                     ??_Paint_10: (+1)
   \   0000019E   0x980A             LDR      R0,[SP, #+40]
   \   000001A0   0x4581             CMP      R9,R0
   \   000001A2   0xF6BF 0xAF7C      BGE.W    ??_Paint_2
   \   000001A6   0x4649             MOV      R1,R9
   \   000001A8   0xF9B4 0x0028      LDRSH    R0,[R4, #+40]
   \   000001AC   0x.... 0x....      BL       HEADER_GetItemWidth
   \   000001B0   0x9008             STR      R0,[SP, #+32]
   \   000001B2   0x4640             MOV      R0,R8
   \   000001B4   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   000001B8   0xF9BD 0x000C      LDRSH    R0,[SP, #+12]
   \   000001BC   0xF9BD 0x1000      LDRSH    R1,[SP, #+0]
   \   000001C0   0x4288             CMP      R0,R1
   \   000001C2   0xF6FF 0xAF6C      BLT.W    ??_Paint_2
   \   000001C6   0x9808             LDR      R0,[SP, #+32]
   \   000001C8   0x4440             ADD      R0,R0,R8
   \   000001CA   0x1E40             SUBS     R0,R0,#+1
   \   000001CC   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   \   000001D0   0xF9BD 0x1008      LDRSH    R1,[SP, #+8]
   \   000001D4   0xB200             SXTH     R0,R0
   \   000001D6   0x4288             CMP      R0,R1
   \   000001D8   0xDBDD             BLT.N    ??_Paint_13
   \   000001DA   0x4649             MOV      R1,R9
   \   000001DC   0x9809             LDR      R0,[SP, #+36]
   \   000001DE   0x.... 0x....      BL       GUI_ARRAY_GetpItem
   \   000001E2   0x4682             MOV      R10,R0
   \   000001E4   0xF9BA 0x0000      LDRSH    R0,[R10, #+0]
   \   000001E8   0x2800             CMP      R0,#+0
   \   000001EA   0xD0A7             BEQ.N    ??_Paint_11
   \   000001EC   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   000001F0   0x4683             MOV      R11,R0
   \   000001F2   0xF85B 0x0027      LDR      R0,[R11, R7, LSL #+2]
   \   000001F6   0x.... 0x....      BL       LCD_SetBkColor
   \   000001FA   0xEB0B 0x0087      ADD      R0,R11,R7, LSL #+2
   \   000001FE   0x68C0             LDR      R0,[R0, #+12]
   \   00000200   0x.... 0x....      BL       LCD_SetColor
   \   00000204   0xE79E             B.N      ??_Paint_12
    238              }
    239            }
    240            /* Clear unused area below items */
    241            if (yPos <= ClipRect.y1) {
   \                     ??_Paint_5: (+1)
   \   00000206   0xF9BD 0x000E      LDRSH    R0,[SP, #+14]
   \   0000020A   0x42A8             CMP      R0,R5
   \   0000020C   0xDB0B             BLT.N    ??_Paint_14
    242              LCD_SetBkColor(pObj->Props.aBkColor[0]);
   \   0000020E   0x6B60             LDR      R0,[R4, #+52]
   \   00000210   0x.... 0x....      BL       LCD_SetBkColor
    243              GUI_ClearRect(ClipRect.x0, yPos, ClipRect.x1, ClipRect.y1);
   \   00000214   0xF9BD 0x300E      LDRSH    R3,[SP, #+14]
   \   00000218   0xF9BD 0x200C      LDRSH    R2,[SP, #+12]
   \   0000021C   0x4629             MOV      R1,R5
   \   0000021E   0xF9BD 0x0008      LDRSH    R0,[SP, #+8]
   \   00000222   0x.... 0x....      BL       GUI_ClearRect
    244            }
    245            /* Draw grid */
    246            if (pObj->ShowGrid) {
   \                     ??_Paint_14: (+1)
   \   00000226   0x6DA0             LDR      R0,[R4, #+88]
   \   00000228   0x2800             CMP      R0,#+0
   \   0000022A   0xD03F             BEQ.N    ??_Paint_15
    247              LCD_SetColor(pObj->Props.GridColor);
   \   0000022C   0x6CE0             LDR      R0,[R4, #+76]
   \   0000022E   0x.... 0x....      BL       LCD_SetColor
    248              yPos = HEADER_GetHeight(pObj->hHeader) + EffectSize - 1;
   \   00000232   0xF9B4 0x0028      LDRSH    R0,[R4, #+40]
   \   00000236   0x.... 0x....      BL       HEADER_GetHeight
   \   0000023A   0x9904             LDR      R1,[SP, #+16]
   \   0000023C   0x1808             ADDS     R0,R1,R0
   \   0000023E   0x1E45             SUBS     R5,R0,#+1
    249              for (i = 0; i < NumVisRows; i++) {
   \   00000240   0x2600             MOVS     R6,#+0
   \   00000242   0xE00B             B.N      ??_Paint_16
    250                yPos += RowDistY;
    251                /* Break when all other rows are outside the drawing area */
    252                if (yPos > ClipRect.y1) {
    253                  break;
    254                }
    255                /* Make sure that we draw only when row is in drawing area */
    256                if (yPos >= ClipRect.y0) {
   \                     ??_Paint_17: (+1)
   \   00000244   0xF9BD 0x000A      LDRSH    R0,[SP, #+10]
   \   00000248   0x4285             CMP      R5,R0
   \   0000024A   0xDB06             BLT.N    ??_Paint_18
    257                  GUI_DrawHLine(yPos, ClipRect.x0, ClipRect.x1);
   \   0000024C   0xF9BD 0x200C      LDRSH    R2,[SP, #+12]
   \   00000250   0xF9BD 0x1008      LDRSH    R1,[SP, #+8]
   \   00000254   0x4628             MOV      R0,R5
   \   00000256   0x.... 0x....      BL       GUI_DrawHLine
    258                }
   \                     ??_Paint_18: (+1)
   \   0000025A   0x1C76             ADDS     R6,R6,#+1
   \                     ??_Paint_16: (+1)
   \   0000025C   0x9807             LDR      R0,[SP, #+28]
   \   0000025E   0x4286             CMP      R6,R0
   \   00000260   0xDA05             BGE.N    ??_Paint_19
   \   00000262   0x9806             LDR      R0,[SP, #+24]
   \   00000264   0x1945             ADDS     R5,R0,R5
   \   00000266   0xF9BD 0x000E      LDRSH    R0,[SP, #+14]
   \   0000026A   0x42A8             CMP      R0,R5
   \   0000026C   0xDAEA             BGE.N    ??_Paint_17
    259              }
    260              xPos = EffectSize - pObj->ScrollStateH.v;
   \                     ??_Paint_19: (+1)
   \   0000026E   0x9804             LDR      R0,[SP, #+16]
   \   00000270   0x6FA1             LDR      R1,[R4, #+120]
   \   00000272   0xEBA0 0x0801      SUB      R8,R0,R1
    261              for (i = 0; i < NumColumns; i++) {
   \   00000276   0x2600             MOVS     R6,#+0
   \   00000278   0xE00B             B.N      ??_Paint_20
    262                xPos += HEADER_GetItemWidth(pObj->hHeader, i);
    263                /* Break when all other columns are outside the drawing area */
    264                if (xPos > ClipRect.x1) {
    265                  break;
    266                }
    267                /* Make sure that we draw only when column is in drawing area */
    268                if (xPos >= ClipRect.x0) {
   \                     ??_Paint_21: (+1)
   \   0000027A   0xF9BD 0x0008      LDRSH    R0,[SP, #+8]
   \   0000027E   0x4580             CMP      R8,R0
   \   00000280   0xDB06             BLT.N    ??_Paint_22
    269                  GUI_DrawVLine(xPos, ClipRect.y0, ClipRect.y1);
   \   00000282   0xF9BD 0x200E      LDRSH    R2,[SP, #+14]
   \   00000286   0xF9BD 0x100A      LDRSH    R1,[SP, #+10]
   \   0000028A   0x4640             MOV      R0,R8
   \   0000028C   0x.... 0x....      BL       GUI_DrawVLine
    270                }
   \                     ??_Paint_22: (+1)
   \   00000290   0x1C76             ADDS     R6,R6,#+1
   \                     ??_Paint_20: (+1)
   \   00000292   0x980A             LDR      R0,[SP, #+40]
   \   00000294   0x4286             CMP      R6,R0
   \   00000296   0xDA09             BGE.N    ??_Paint_15
   \   00000298   0x4631             MOV      R1,R6
   \   0000029A   0xF9B4 0x0028      LDRSH    R0,[R4, #+40]
   \   0000029E   0x.... 0x....      BL       HEADER_GetItemWidth
   \   000002A2   0x4480             ADD      R8,R0,R8
   \   000002A4   0xF9BD 0x000C      LDRSH    R0,[SP, #+12]
   \   000002A8   0x4540             CMP      R0,R8
   \   000002AA   0xDAE6             BGE.N    ??_Paint_21
    271              }
    272            }
    273            /* Draw the effect */
    274            WIDGET__EFFECT_DrawDown(&pObj->Widget);
   \                     ??_Paint_15: (+1)
   \   000002AC   0x4620             MOV      R0,R4
   \   000002AE   0x.... 0x....      BL       WIDGET__EFFECT_DrawDown
    275          }
   \   000002B2   0xB00F             ADD      SP,SP,#+60
   \   000002B4   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    276          
    277          /*********************************************************************
    278          *
    279          *       LISTVIEW__InvalidateInsideArea
    280          */

   \                                 In section .text, align 2, keep-with-next
    281          void LISTVIEW__InvalidateInsideArea(LISTVIEW_Handle hObj, LISTVIEW_Obj* pObj) {
   \                     LISTVIEW__InvalidateInsideArea: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x4604             MOV      R4,R0
    282            GUI_RECT Rect;
    283            int HeaderHeight;
    284            HeaderHeight = HEADER_GetHeight(pObj->hHeader);
   \   00000006   0xF9B1 0x0028      LDRSH    R0,[R1, #+40]
   \   0000000A   0x.... 0x....      BL       HEADER_GetHeight
   \   0000000E   0x4605             MOV      R5,R0
    285            WM_GetInsideRectExScrollbar(hObj, &Rect);
   \   00000010   0xA900             ADD      R1,SP,#+0
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       WM_GetInsideRectExScrollbar
    286            Rect.y0 += HeaderHeight;
   \   00000018   0xF8BD 0x0002      LDRH     R0,[SP, #+2]
   \   0000001C   0x1828             ADDS     R0,R5,R0
   \   0000001E   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    287            WM_InvalidateRect(hObj, &Rect);
   \   00000022   0xA900             ADD      R1,SP,#+0
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       WM_InvalidateRect
    288          }
   \   0000002A   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    289          
    290          /*********************************************************************
    291          *
    292          *       LISTVIEW__InvalidateRow
    293          */

   \                                 In section .text, align 2, keep-with-next
    294          void LISTVIEW__InvalidateRow(LISTVIEW_Handle hObj, LISTVIEW_Obj* pObj, int Sel) {
   \                     LISTVIEW__InvalidateRow: (+1)
   \   00000000   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460E             MOV      R6,R1
   \   00000008   0x0017             MOVS     R7,R2
    295            if (Sel >= 0) {
   \   0000000A   0xD420             BMI.N    ??LISTVIEW__InvalidateRow_0
    296              GUI_RECT Rect;
    297              int HeaderHeight, RowDistY;
    298              HeaderHeight = HEADER_GetHeight(pObj->hHeader);
   \   0000000C   0xF9B6 0x0028      LDRSH    R0,[R6, #+40]
   \   00000010   0x.... 0x....      BL       HEADER_GetHeight
   \   00000014   0x4680             MOV      R8,R0
    299              RowDistY     = LISTVIEW__GetRowDistY(pObj);
   \   00000016   0x4630             MOV      R0,R6
   \   00000018   0x.... 0x....      BL       LISTVIEW__GetRowDistY
   \   0000001C   0x4605             MOV      R5,R0
    300              WM_GetInsideRectExScrollbar(hObj, &Rect);
   \   0000001E   0xA900             ADD      R1,SP,#+0
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       WM_GetInsideRectExScrollbar
    301              Rect.y0 += HeaderHeight + (Sel - pObj->ScrollStateV.v) * RowDistY;
   \   00000026   0xF9BD 0x0002      LDRSH    R0,[SP, #+2]
   \   0000002A   0xFA08 0xF080      SXTAH    R0,R8,R0
   \   0000002E   0x6EF1             LDR      R1,[R6, #+108]
   \   00000030   0x1A79             SUBS     R1,R7,R1
   \   00000032   0xFB05 0x0001      MLA      R0,R5,R1,R0
   \   00000036   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    302              Rect.y1  = Rect.y0 + RowDistY - 1;
   \   0000003A   0xF8BD 0x0002      LDRH     R0,[SP, #+2]
   \   0000003E   0x1828             ADDS     R0,R5,R0
   \   00000040   0x1E40             SUBS     R0,R0,#+1
   \   00000042   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    303              WM_InvalidateRect(hObj, &Rect);
   \   00000046   0xA900             ADD      R1,SP,#+0
   \   00000048   0x4620             MOV      R0,R4
   \   0000004A   0x.... 0x....      BL       WM_InvalidateRect
    304            }
    305          }
   \                     ??LISTVIEW__InvalidateRow_0: (+1)
   \   0000004E   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}  ;; return
    306          
    307          /*********************************************************************
    308          *
    309          *       _SetSelFromPos
    310          */

   \                                 In section .text, align 2, keep-with-next
    311          static void _SetSelFromPos(LISTVIEW_Handle hObj, LISTVIEW_Obj* pObj, const GUI_PID_STATE* pState) {
   \                     _SetSelFromPos: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4617             MOV      R7,R2
    312            GUI_RECT Rect;
    313            int x, y, HeaderHeight;
    314            HeaderHeight = HEADER_GetHeight(pObj->hHeader);
   \   0000000A   0xF9B5 0x0028      LDRSH    R0,[R5, #+40]
   \   0000000E   0x.... 0x....      BL       HEADER_GetHeight
   \   00000012   0x4606             MOV      R6,R0
    315            WM_GetInsideRectExScrollbar(hObj, &Rect);
   \   00000014   0xA900             ADD      R1,SP,#+0
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       WM_GetInsideRectExScrollbar
    316            x = pState->x - Rect.x0;
   \   0000001C   0x6838             LDR      R0,[R7, #+0]
   \   0000001E   0xF9BD 0x1000      LDRSH    R1,[SP, #+0]
   \   00000022   0x1A40             SUBS     R0,R0,R1
    317            y = pState->y - Rect.y0 - HeaderHeight;
   \   00000024   0xF9BD 0x1002      LDRSH    R1,[SP, #+2]
   \   00000028   0x687A             LDR      R2,[R7, #+4]
   \   0000002A   0x1A52             SUBS     R2,R2,R1
   \   0000002C   0x1B97             SUBS     R7,R2,R6
    318            Rect.x1 -= Rect.x0;
   \   0000002E   0xF8BD 0x2004      LDRH     R2,[SP, #+4]
   \   00000032   0xF8BD 0x3000      LDRH     R3,[SP, #+0]
   \   00000036   0x1AD2             SUBS     R2,R2,R3
   \   00000038   0xF8AD 0x2004      STRH     R2,[SP, #+4]
    319            Rect.y1 -= Rect.y0;
   \   0000003C   0xF8BD 0x3006      LDRH     R3,[SP, #+6]
   \   00000040   0x1A59             SUBS     R1,R3,R1
   \   00000042   0xF8AD 0x1006      STRH     R1,[SP, #+6]
    320            if ((x >= 0) && (x <= Rect.x1) && (y >= 0) && (y <= (Rect.y1 - HeaderHeight))) {
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD419             BMI.N    ??_SetSelFromPos_0
   \   0000004A   0xB212             SXTH     R2,R2
   \   0000004C   0x4282             CMP      R2,R0
   \   0000004E   0xDB16             BLT.N    ??_SetSelFromPos_0
   \   00000050   0x2F00             CMP      R7,#+0
   \   00000052   0xD414             BMI.N    ??_SetSelFromPos_0
   \   00000054   0xB209             SXTH     R1,R1
   \   00000056   0x1B88             SUBS     R0,R1,R6
   \   00000058   0x42B8             CMP      R0,R7
   \   0000005A   0xDB10             BLT.N    ??_SetSelFromPos_0
    321              unsigned Sel;
    322              Sel = (y / LISTVIEW__GetRowDistY(pObj)) + pObj->ScrollStateV.v;
   \   0000005C   0x4628             MOV      R0,R5
   \   0000005E   0x.... 0x....      BL       LISTVIEW__GetRowDistY
   \   00000062   0xFBB7 0xF0F0      UDIV     R0,R7,R0
   \   00000066   0x6EE9             LDR      R1,[R5, #+108]
   \   00000068   0x180E             ADDS     R6,R1,R0
    323              if (Sel < GUI_ARRAY_GetNumItems(&pObj->RowArray)) {
   \   0000006A   0xF105 0x002A      ADD      R0,R5,#+42
   \   0000006E   0x.... 0x....      BL       GUI_ARRAY_GetNumItems
   \   00000072   0x4286             CMP      R6,R0
   \   00000074   0xD203             BCS.N    ??_SetSelFromPos_0
    324                LISTVIEW_SetSel(hObj, Sel);
   \   00000076   0x4631             MOV      R1,R6
   \   00000078   0x4620             MOV      R0,R4
   \   0000007A   0x.... 0x....      BL       LISTVIEW_SetSel
    325              }
    326            }
    327          }
   \                     ??_SetSelFromPos_0: (+1)
   \   0000007E   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
    328          
    329          /*********************************************************************
    330          *
    331          *       _NotifyOwner
    332          *
    333          * Purpose:
    334          *   Notify owner of the window.
    335          *   If no owner is registered, the parent is considered owner.
    336          */

   \                                 In section .text, align 2, keep-with-next
    337          static void _NotifyOwner(WM_HWIN hObj, int Notification) {
   \                     _NotifyOwner: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    338            WM_MESSAGE Msg = {0};
   \   00000006   0xA800             ADD      R0,SP,#+0
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x460A             MOV      R2,R1
   \   0000000C   0x460B             MOV      R3,R1
   \   0000000E   0xC00E             STM      R0!,{R1-R3}
    339            WM_HWIN hOwner;
    340            LISTVIEW_Obj* pObj    = LISTVIEW_H2P(hObj);
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       GUI_ALLOC_h2p
    341            hOwner = pObj->hOwner ? pObj->hOwner : WM_GetParent(hObj);
   \   00000016   0xF9B0 0x0080      LDRSH    R0,[R0, #+128]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD102             BNE.N    ??_NotifyOwner_0
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       WM_GetParent
    342            Msg.MsgId   = WM_NOTIFY_PARENT;
   \                     ??_NotifyOwner_0: (+1)
   \   00000024   0x2126             MOVS     R1,#+38
   \   00000026   0x9100             STR      R1,[SP, #+0]
    343            Msg.Data.v  = Notification;
   \   00000028   0x9502             STR      R5,[SP, #+8]
    344            Msg.hWin    = hObj;
   \   0000002A   0xF8AD 0x4004      STRH     R4,[SP, #+4]
    345            WM_SendMessage(hOwner, &Msg);
   \   0000002E   0xA900             ADD      R1,SP,#+0
   \   00000030   0x.... 0x....      BL       WM_SendMessage
    346          }
   \   00000034   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    347          
    348          /*********************************************************************
    349          *
    350          *       _OnTouch
    351          */

   \                                 In section .text, align 2, keep-with-next
    352          static void _OnTouch(LISTVIEW_Handle hObj, LISTVIEW_Obj* pObj, WM_MESSAGE*pMsg) {
   \                     _OnTouch: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    353            int Notification;
    354            const GUI_PID_STATE* pState = (const GUI_PID_STATE*)pMsg->Data.p;
   \   00000004   0x6892             LDR      R2,[R2, #+8]
    355            GUI_USE_PARA(pObj);
    356            if (pMsg->Data.p) {  /* Something happened in our area (pressed or released) */
   \   00000006   0x2A00             CMP      R2,#+0
   \   00000008   0xD00C             BEQ.N    ??_OnTouch_0
    357              if (pState->Pressed) {
   \   0000000A   0x7A10             LDRB     R0,[R2, #+8]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD007             BEQ.N    ??_OnTouch_1
    358                _SetSelFromPos(hObj, pObj, pState);
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       _SetSelFromPos
    359                Notification = WM_NOTIFICATION_CLICKED;
   \   00000016   0x2501             MOVS     R5,#+1
    360                WM_SetFocus(hObj);
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       WM_SetFocus
   \   0000001E   0xE002             B.N      ??_OnTouch_2
    361              } else {
    362                Notification = WM_NOTIFICATION_RELEASED;
   \                     ??_OnTouch_1: (+1)
   \   00000020   0x2502             MOVS     R5,#+2
   \   00000022   0xE000             B.N      ??_OnTouch_2
    363              }
    364            } else {
    365              Notification = WM_NOTIFICATION_MOVED_OUT;
   \                     ??_OnTouch_0: (+1)
   \   00000024   0x2503             MOVS     R5,#+3
    366            }
    367            _NotifyOwner(hObj, Notification);
   \                     ??_OnTouch_2: (+1)
   \   00000026   0x4629             MOV      R1,R5
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   0000002E   0x....             B.N      _NotifyOwner
    368          }
    369          
    370          /*********************************************************************
    371          *
    372          *       _GetXSize
    373          *
    374          * Purpose:
    375          *   Returns the width of the inside listview area.
    376          */

   \                                 In section .text, align 2, keep-with-next
    377          static int _GetXSize(LISTVIEW_Handle hObj) {
   \                     _GetXSize: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    378            GUI_RECT Rect;
    379            WM_GetInsideRectExScrollbar(hObj, &Rect);
   \   00000004   0xA900             ADD      R1,SP,#+0
   \   00000006   0x.... 0x....      BL       WM_GetInsideRectExScrollbar
    380            return Rect.x1 + 1;
   \   0000000A   0xF9BD 0x0004      LDRSH    R0,[SP, #+4]
   \   0000000E   0x1C40             ADDS     R0,R0,#+1
   \   00000010   0xBD0E             POP      {R1-R3,PC}       ;; return
    381          }
    382          
    383          /*********************************************************************
    384          *
    385          *       _GetHeaderWidth
    386          *
    387          * Purpose:
    388          *   Returns the width of all items in header.
    389          *
    390          * Return value:
    391          *   NumItems > 0:  width of all items.
    392          *   NumItems = 0:  1 (to avoid problem with horizontal scrollbar)
    393          */

   \                                 In section .text, align 2, keep-with-next
    394          static int _GetHeaderWidth(LISTVIEW_Obj* pObj, HEADER_Handle hHeader) {
   \                     _GetHeaderWidth: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    395            int NumItems, i, r = 1;
   \   00000008   0x2601             MOVS     R6,#+1
    396            NumItems = HEADER_GetNumItems(hHeader);
   \   0000000A   0x4628             MOV      R0,R5
   \   0000000C   0x.... 0x....      BL       HEADER_GetNumItems
   \   00000010   0x0007             MOVS     R7,R0
    397            if (NumItems) {
   \   00000012   0xD00C             BEQ.N    ??_GetHeaderWidth_0
    398              for (i = 0, r = 0; i < NumItems; i++) {
   \   00000014   0xF04F 0x0800      MOV      R8,#+0
   \   00000018   0x4646             MOV      R6,R8
   \   0000001A   0xE006             B.N      ??_GetHeaderWidth_1
    399                r += HEADER_GetItemWidth(hHeader, i);
   \                     ??_GetHeaderWidth_2: (+1)
   \   0000001C   0x4641             MOV      R1,R8
   \   0000001E   0x4628             MOV      R0,R5
   \   00000020   0x.... 0x....      BL       HEADER_GetItemWidth
   \   00000024   0x1986             ADDS     R6,R0,R6
    400              }
   \   00000026   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??_GetHeaderWidth_1: (+1)
   \   0000002A   0x45B8             CMP      R8,R7
   \   0000002C   0xDBF6             BLT.N    ??_GetHeaderWidth_2
    401            }
    402            if (pObj->ScrollStateH.v > (r - pObj->ScrollStateH.PageSize)) {
   \                     ??_GetHeaderWidth_0: (+1)
   \   0000002E   0x6FA0             LDR      R0,[R4, #+120]
   \   00000030   0x6FE1             LDR      R1,[R4, #+124]
   \   00000032   0x1A72             SUBS     R2,R6,R1
   \   00000034   0x4282             CMP      R2,R0
   \   00000036   0xDA00             BGE.N    ??_GetHeaderWidth_3
    403              r += pObj->ScrollStateH.PageSize - (r - pObj->ScrollStateH.v);
   \   00000038   0x1846             ADDS     R6,R0,R1
    404            }
    405            return r;
   \                     ??_GetHeaderWidth_3: (+1)
   \   0000003A   0x4630             MOV      R0,R6
   \   0000003C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    406          }
    407          
    408          /*********************************************************************
    409          *
    410          *       LISTVIEW__UpdateScrollPos
    411          *
    412          * Purpose:
    413          *   Checks whether if we must scroll up or scroll down to ensure
    414          *   that selection is in the visible area. This function also
    415          *   makes sure that scroll positions are in valid ranges.
    416          *
    417          * Return value:
    418          *   Difference between old and new vertical scroll pos.
    419          */

   \                                 In section .text, align 2, keep-with-next
    420          int LISTVIEW__UpdateScrollPos(LISTVIEW_Handle hObj, LISTVIEW_Obj* pObj) {
   \                     LISTVIEW__UpdateScrollPos: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    421            int PrevScrollStateV;
    422            PrevScrollStateV = pObj->ScrollStateV.v;
   \   00000006   0x6EEE             LDR      R6,[R5, #+108]
    423            if (pObj->Sel >= 0) {
   \   00000008   0x6D69             LDR      R1,[R5, #+84]
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD406             BMI.N    ??LISTVIEW__UpdateScrollPos_0
    424              WM_CheckScrollPos(&pObj->ScrollStateV, pObj->Sel, 0, 0);
   \   0000000E   0x2300             MOVS     R3,#+0
   \   00000010   0x461A             MOV      R2,R3
   \   00000012   0xF105 0x0068      ADD      R0,R5,#+104
   \   00000016   0x.... 0x....      BL       WM_CheckScrollPos
   \   0000001A   0xE003             B.N      ??LISTVIEW__UpdateScrollPos_1
    425            } else {
    426              WM_CheckScrollBounds(&pObj->ScrollStateV);
   \                     ??LISTVIEW__UpdateScrollPos_0: (+1)
   \   0000001C   0xF105 0x0068      ADD      R0,R5,#+104
   \   00000020   0x.... 0x....      BL       WM_CheckScrollBounds
    427            }
    428            WM_CheckScrollBounds(&pObj->ScrollStateH);
   \                     ??LISTVIEW__UpdateScrollPos_1: (+1)
   \   00000024   0xF105 0x0074      ADD      R0,R5,#+116
   \   00000028   0x.... 0x....      BL       WM_CheckScrollBounds
    429            WIDGET__SetScrollState(hObj, &pObj->ScrollStateV, &pObj->ScrollStateH);
   \   0000002C   0xF105 0x0274      ADD      R2,R5,#+116
   \   00000030   0xF105 0x0168      ADD      R1,R5,#+104
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0x.... 0x....      BL       WIDGET__SetScrollState
    430            return pObj->ScrollStateV.v - PrevScrollStateV;
   \   0000003A   0x6EE8             LDR      R0,[R5, #+108]
   \   0000003C   0x1B80             SUBS     R0,R0,R6
   \   0000003E   0xBD70             POP      {R4-R6,PC}       ;; return
    431          }
    432          
    433          /*********************************************************************
    434          *
    435          *       LISTVIEW__UpdateScrollParas
    436          *
    437          * Purpose:
    438          *   Calculates number of items and page size of both vertical
    439          *   and horizontal scrollbar. After this LISTVIEW__UpdateScrollPos will
    440          *   be called to ensure scroll positions are in valid ranges.
    441          */

   \                                 In section .text, align 2, keep-with-next
    442          int LISTVIEW__UpdateScrollParas(LISTVIEW_Handle hObj, LISTVIEW_Obj* pObj) {
   \                     LISTVIEW__UpdateScrollParas: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    443            int NumRows;
    444            NumRows = GUI_ARRAY_GetNumItems(&pObj->RowArray);
   \   00000006   0xF105 0x002A      ADD      R0,R5,#+42
   \   0000000A   0x.... 0x....      BL       GUI_ARRAY_GetNumItems
   \   0000000E   0x4606             MOV      R6,R0
    445            /* update vertical scrollbar */
    446            pObj->ScrollStateV.PageSize = _GetNumVisibleRows(hObj, pObj);
   \   00000010   0x4629             MOV      R1,R5
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       _GetNumVisibleRows
   \   00000018   0x6728             STR      R0,[R5, #+112]
    447            pObj->ScrollStateV.NumItems = (NumRows) ? NumRows : 1;
   \   0000001A   0x2E00             CMP      R6,#+0
   \   0000001C   0xD100             BNE.N    ??LISTVIEW__UpdateScrollParas_0
   \   0000001E   0x2601             MOVS     R6,#+1
   \                     ??LISTVIEW__UpdateScrollParas_0: (+1)
   \   00000020   0x66AE             STR      R6,[R5, #+104]
    448            /* update horizontal scrollbar */
    449            pObj->ScrollStateH.PageSize = _GetXSize(hObj);
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       _GetXSize
   \   00000028   0x67E8             STR      R0,[R5, #+124]
    450            pObj->ScrollStateH.NumItems = _GetHeaderWidth(pObj, pObj->hHeader);
   \   0000002A   0xF9B5 0x1028      LDRSH    R1,[R5, #+40]
   \   0000002E   0x4628             MOV      R0,R5
   \   00000030   0x.... 0x....      BL       _GetHeaderWidth
   \   00000034   0x6768             STR      R0,[R5, #+116]
    451            return LISTVIEW__UpdateScrollPos(hObj, pObj);
   \   00000036   0x4629             MOV      R1,R5
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000003E   0x....             B.N      LISTVIEW__UpdateScrollPos
    452          }
    453          
    454          /*********************************************************************
    455          *
    456          *       _FreeAttached
    457          *
    458          * Purpose:
    459          *   Delete attached objects (if any).
    460          */

   \                                 In section .text, align 2, keep-with-next
    461          static void _FreeAttached(LISTVIEW_Obj * pObj) {
   \                     _FreeAttached: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
    462            int i, j, NumRows, NumColumns;
    463            NumRows    = GUI_ARRAY_GetNumItems(&pObj->RowArray);
   \   00000006   0xF104 0x002A      ADD      R0,R4,#+42
   \   0000000A   0x.... 0x....      BL       GUI_ARRAY_GetNumItems
   \   0000000E   0x4605             MOV      R5,R0
    464            NumColumns = GUI_ARRAY_GetNumItems(&pObj->AlignArray);
   \   00000010   0xF104 0x002E      ADD      R0,R4,#+46
   \   00000014   0x.... 0x....      BL       GUI_ARRAY_GetNumItems
   \   00000018   0x4606             MOV      R6,R0
    465            for (i = 0; i < NumRows; i++) {
   \   0000001A   0x2700             MOVS     R7,#+0
   \   0000001C   0xE011             B.N      ??_FreeAttached_0
    466              GUI_ARRAY * pRow;
    467              pRow = (GUI_ARRAY *)GUI_ARRAY_GetpItem(&pObj->RowArray, i);
    468              /* Delete attached info items */
    469              for (j = 0; j < NumColumns; j++) {
    470                LISTVIEW_ITEM * pItem;
    471                pItem = (LISTVIEW_ITEM *)GUI_ARRAY_GetpItem(pRow, j);
   \                     ??_FreeAttached_1: (+1)
   \   0000001E   0x4641             MOV      R1,R8
   \   00000020   0x4648             MOV      R0,R9
   \   00000022   0x.... 0x....      BL       GUI_ARRAY_GetpItem
    472                if (pItem->hItemInfo) {
   \   00000026   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD001             BEQ.N    ??_FreeAttached_2
    473                  GUI_ALLOC_Free(pItem->hItemInfo);
   \   0000002E   0x.... 0x....      BL       GUI_ALLOC_Free
    474                }
    475              }
   \                     ??_FreeAttached_2: (+1)
   \   00000032   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??_FreeAttached_3: (+1)
   \   00000036   0x45B0             CMP      R8,R6
   \   00000038   0xDBF1             BLT.N    ??_FreeAttached_1
    476              /* Delete row */
    477              GUI_ARRAY_Delete(pRow);
   \   0000003A   0x4648             MOV      R0,R9
   \   0000003C   0x.... 0x....      BL       GUI_ARRAY_Delete
   \   00000040   0x1C7F             ADDS     R7,R7,#+1
   \                     ??_FreeAttached_0: (+1)
   \   00000042   0x42AF             CMP      R7,R5
   \   00000044   0xDA08             BGE.N    ??_FreeAttached_4
   \   00000046   0x4639             MOV      R1,R7
   \   00000048   0xF104 0x002A      ADD      R0,R4,#+42
   \   0000004C   0x.... 0x....      BL       GUI_ARRAY_GetpItem
   \   00000050   0x4681             MOV      R9,R0
   \   00000052   0xF04F 0x0800      MOV      R8,#+0
   \   00000056   0xE7EE             B.N      ??_FreeAttached_3
    478            }
    479            GUI_ARRAY_Delete(&pObj->AlignArray);
   \                     ??_FreeAttached_4: (+1)
   \   00000058   0xF104 0x002E      ADD      R0,R4,#+46
   \   0000005C   0x.... 0x....      BL       GUI_ARRAY_Delete
    480            GUI_ARRAY_Delete(&pObj->RowArray);
   \   00000060   0xF104 0x002A      ADD      R0,R4,#+42
   \   00000064   0xE8BD 0x43F2      POP      {R1,R4-R9,LR}
   \   00000068   0x.... 0x....      B.W      GUI_ARRAY_Delete
    481          }
    482          
    483          /*********************************************************************
    484          *
    485          *       _AddKey
    486          *
    487          * Returns: 1 if Key has been consumed
    488          *          0 else 
    489          */

   \                                 In section .text, align 2, keep-with-next
    490          static int _AddKey(LISTVIEW_Handle hObj, int Key) {
   \                     _AddKey: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    491            switch (Key) {
   \   00000002   0x2911             CMP      R1,#+17
   \   00000004   0xD005             BEQ.N    ??_AddKey_0
   \   00000006   0x2913             CMP      R1,#+19
   \   00000008   0xD107             BNE.N    ??_AddKey_1
    492            case GUI_KEY_DOWN:
    493              LISTVIEW_IncSel(hObj);
   \   0000000A   0x.... 0x....      BL       LISTVIEW_IncSel
    494              return 1;               /* Key has been consumed */
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xBD02             POP      {R1,PC}
    495            case GUI_KEY_UP:
    496              LISTVIEW_DecSel(hObj);
   \                     ??_AddKey_0: (+1)
   \   00000012   0x.... 0x....      BL       LISTVIEW_DecSel
    497              return 1;               /* Key has been consumed */
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xBD02             POP      {R1,PC}
    498            }
    499            return 0;                 /* Key has NOT been consumed */
   \                     ??_AddKey_1: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xBD02             POP      {R1,PC}          ;; return
    500          }
    501          
    502          /*********************************************************************
    503          *
    504          *       _LISTVIEW_Callback
    505          */

   \                                 In section .text, align 2, keep-with-next
    506          static void _LISTVIEW_Callback (WM_MESSAGE *pMsg) {
   \                     _LISTVIEW_Callback: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x4606             MOV      R6,R0
    507            LISTVIEW_Handle hObj;
    508            LISTVIEW_Obj* pObj;
    509            WM_SCROLL_STATE ScrollState;
    510            hObj = pMsg->hWin;
   \   00000006   0xF9B6 0x4004      LDRSH    R4,[R6, #+4]
    511            /* Let widget handle the standard messages */
    512            if (WIDGET_HandleActive(hObj, pMsg) == 0) {
   \   0000000A   0x4631             MOV      R1,R6
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       WIDGET_HandleActive
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD07C             BEQ.N    ??_LISTVIEW_Callback_0
    513              return;
    514            }
    515            pObj = LISTVIEW_H2P(hObj);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000001C   0x4605             MOV      R5,R0
    516            switch (pMsg->MsgId) {
   \   0000001E   0x6830             LDR      R0,[R6, #+0]
   \   00000020   0x2805             CMP      R0,#+5
   \   00000022   0xD00C             BEQ.N    ??_LISTVIEW_Callback_1
   \   00000024   0x280B             CMP      R0,#+11
   \   00000026   0xD06D             BEQ.N    ??_LISTVIEW_Callback_2
   \   00000028   0x280C             CMP      R0,#+12
   \   0000002A   0xD05A             BEQ.N    ??_LISTVIEW_Callback_3
   \   0000002C   0x280E             CMP      R0,#+14
   \   0000002E   0xD05E             BEQ.N    ??_LISTVIEW_Callback_4
   \   00000030   0x280F             CMP      R0,#+15
   \   00000032   0xD050             BEQ.N    ??_LISTVIEW_Callback_5
   \   00000034   0x2825             CMP      R0,#+37
   \   00000036   0xD002             BEQ.N    ??_LISTVIEW_Callback_1
   \   00000038   0x2826             CMP      R0,#+38
   \   0000003A   0xD005             BEQ.N    ??_LISTVIEW_Callback_6
   \   0000003C   0xE065             B.N      ??_LISTVIEW_Callback_7
    517            case WM_NOTIFY_CLIENTCHANGE:
    518            case WM_SIZE:
    519              LISTVIEW__UpdateScrollParas(hObj, pObj);
   \                     ??_LISTVIEW_Callback_1: (+1)
   \   0000003E   0x4629             MOV      R1,R5
   \   00000040   0x4620             MOV      R0,R4
   \   00000042   0x.... 0x....      BL       LISTVIEW__UpdateScrollParas
    520              return;
   \   00000046   0xBD7F             POP      {R0-R6,PC}
    521            case WM_NOTIFY_PARENT:
    522              switch (pMsg->Data.v) {
   \                     ??_LISTVIEW_Callback_6: (+1)
   \   00000048   0x68B0             LDR      R0,[R6, #+8]
   \   0000004A   0x2805             CMP      R0,#+5
   \   0000004C   0xD00D             BEQ.N    ??_LISTVIEW_Callback_8
   \   0000004E   0xD35F             BCC.N    ??_LISTVIEW_Callback_0
   \   00000050   0x2807             CMP      R0,#+7
   \   00000052   0xD001             BEQ.N    ??_LISTVIEW_Callback_9
   \   00000054   0xD33A             BCC.N    ??_LISTVIEW_Callback_10
   \   00000056   0xBD7F             POP      {R0-R6,PC}
    523              case WM_NOTIFICATION_CHILD_DELETED:
    524                /* make sure we do not send any messages to the header child once it has been deleted */
    525                if (pMsg->hWinSrc == pObj->hHeader) {
   \                     ??_LISTVIEW_Callback_9: (+1)
   \   00000058   0xF9B6 0x0006      LDRSH    R0,[R6, #+6]
   \   0000005C   0xF9B5 0x1028      LDRSH    R1,[R5, #+40]
   \   00000060   0x4288             CMP      R0,R1
   \   00000062   0xD155             BNE.N    ??_LISTVIEW_Callback_0
    526                  pObj->hHeader = 0;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x8528             STRH     R0,[R5, #+40]
   \   00000068   0xBD7F             POP      {R0-R6,PC}
    527                }
    528                break;
    529              case WM_NOTIFICATION_VALUE_CHANGED:
    530                if (pMsg->hWinSrc == WM_GetScrollbarV(hObj)) {
   \                     ??_LISTVIEW_Callback_8: (+1)
   \   0000006A   0x4620             MOV      R0,R4
   \   0000006C   0x.... 0x....      BL       WM_GetScrollbarV
   \   00000070   0xF9B6 0x2006      LDRSH    R2,[R6, #+6]
   \   00000074   0x4282             CMP      R2,R0
   \   00000076   0xD10E             BNE.N    ??_LISTVIEW_Callback_11
    531                  WM_GetScrollState(pMsg->hWinSrc, &ScrollState);
   \   00000078   0xA900             ADD      R1,SP,#+0
   \   0000007A   0x4610             MOV      R0,R2
   \   0000007C   0x.... 0x....      BL       WM_GetScrollState
    532                  pObj->ScrollStateV.v = ScrollState.v;
   \   00000080   0x9801             LDR      R0,[SP, #+4]
   \   00000082   0x66E8             STR      R0,[R5, #+108]
    533                  LISTVIEW__InvalidateInsideArea(hObj, pObj);
   \   00000084   0x4629             MOV      R1,R5
   \   00000086   0x4620             MOV      R0,R4
   \   00000088   0x.... 0x....      BL       LISTVIEW__InvalidateInsideArea
    534                  _NotifyOwner(hObj, WM_NOTIFICATION_SCROLL_CHANGED);
   \   0000008C   0x210A             MOVS     R1,#+10
   \   0000008E   0x4620             MOV      R0,R4
   \   00000090   0x.... 0x....      BL       _NotifyOwner
   \   00000094   0xBD7F             POP      {R0-R6,PC}
    535                } else if (pMsg->hWinSrc == WM_GetScrollbarH(hObj)) {
   \                     ??_LISTVIEW_Callback_11: (+1)
   \   00000096   0x4620             MOV      R0,R4
   \   00000098   0x.... 0x....      BL       WM_GetScrollbarH
   \   0000009C   0x4601             MOV      R1,R0
   \   0000009E   0xF9B6 0x0006      LDRSH    R0,[R6, #+6]
   \   000000A2   0x4288             CMP      R0,R1
   \   000000A4   0xD134             BNE.N    ??_LISTVIEW_Callback_0
    536                  WM_GetScrollState(pMsg->hWinSrc, &ScrollState);
   \   000000A6   0xA900             ADD      R1,SP,#+0
   \   000000A8   0x.... 0x....      BL       WM_GetScrollState
    537                  pObj->ScrollStateH.v = ScrollState.v;
   \   000000AC   0x9801             LDR      R0,[SP, #+4]
   \   000000AE   0x67A8             STR      R0,[R5, #+120]
    538                  LISTVIEW__UpdateScrollParas(hObj, pObj);
   \   000000B0   0x4629             MOV      R1,R5
   \   000000B2   0x4620             MOV      R0,R4
   \   000000B4   0x.... 0x....      BL       LISTVIEW__UpdateScrollParas
    539                  HEADER_SetScrollPos(pObj->hHeader, pObj->ScrollStateH.v);
   \   000000B8   0x6FA9             LDR      R1,[R5, #+120]
   \   000000BA   0xF9B5 0x0028      LDRSH    R0,[R5, #+40]
   \   000000BE   0x.... 0x....      BL       HEADER_SetScrollPos
    540                  _NotifyOwner(hObj, WM_NOTIFICATION_SCROLL_CHANGED);
   \   000000C2   0x210A             MOVS     R1,#+10
   \   000000C4   0x4620             MOV      R0,R4
   \   000000C6   0x.... 0x....      BL       _NotifyOwner
   \   000000CA   0xBD7F             POP      {R0-R6,PC}
    541                }
    542                break;
    543              case WM_NOTIFICATION_SCROLLBAR_ADDED:
    544                LISTVIEW__UpdateScrollParas(hObj, pObj);
   \                     ??_LISTVIEW_Callback_10: (+1)
   \   000000CC   0x4629             MOV      R1,R5
   \   000000CE   0x4620             MOV      R0,R4
   \   000000D0   0x.... 0x....      BL       LISTVIEW__UpdateScrollParas
    545                break;
    546              }
    547              return;
   \   000000D4   0xBD7F             POP      {R0-R6,PC}
    548            case WM_PAINT:
    549              _Paint(hObj, pObj, pMsg);
   \                     ??_LISTVIEW_Callback_5: (+1)
   \   000000D6   0x4632             MOV      R2,R6
   \   000000D8   0x4629             MOV      R1,R5
   \   000000DA   0x4620             MOV      R0,R4
   \   000000DC   0x.... 0x....      BL       _Paint
    550              return;
   \   000000E0   0xBD7F             POP      {R0-R6,PC}
    551            case WM_TOUCH:
    552              _OnTouch(hObj, pObj, pMsg);
   \                     ??_LISTVIEW_Callback_3: (+1)
   \   000000E2   0x4632             MOV      R2,R6
   \   000000E4   0x4629             MOV      R1,R5
   \   000000E6   0x4620             MOV      R0,R4
   \   000000E8   0x.... 0x....      BL       _OnTouch
    553              return;        /* Important: message handled ! */
   \   000000EC   0xBD7F             POP      {R0-R6,PC}
    554            case WM_KEY:
    555              if (((const WM_KEY_INFO*)(pMsg->Data.p))->PressedCnt > 0) {
   \                     ??_LISTVIEW_Callback_4: (+1)
   \   000000EE   0x68B0             LDR      R0,[R6, #+8]
   \   000000F0   0x6841             LDR      R1,[R0, #+4]
   \   000000F2   0x2901             CMP      R1,#+1
   \   000000F4   0xDB09             BLT.N    ??_LISTVIEW_Callback_7
    556                int Key;
    557                Key = ((const WM_KEY_INFO*)(pMsg->Data.p))->Key;
    558                if (_AddKey(hObj, Key)) {
   \   000000F6   0x6801             LDR      R1,[R0, #+0]
   \   000000F8   0x4620             MOV      R0,R4
   \   000000FA   0x.... 0x....      BL       _AddKey
   \   000000FE   0x2800             CMP      R0,#+0
   \   00000100   0xD003             BEQ.N    ??_LISTVIEW_Callback_7
    559                  return;
   \   00000102   0xBD7F             POP      {R0-R6,PC}
    560                }
    561              }
    562              break;  /* No return here ... WM_DefaultProc needs to be called */
    563            case WM_DELETE:
    564              _FreeAttached(pObj);
   \                     ??_LISTVIEW_Callback_2: (+1)
   \   00000104   0x4628             MOV      R0,R5
   \   00000106   0x.... 0x....      BL       _FreeAttached
    565              break;  /* No return here ... WM_DefaultProc needs to be called */
    566            }
    567            WM_DefaultProc(pMsg);
   \                     ??_LISTVIEW_Callback_7: (+1)
   \   0000010A   0x4630             MOV      R0,R6
   \   0000010C   0x.... 0x....      BL       WM_DefaultProc
    568          }
   \                     ??_LISTVIEW_Callback_0: (+1)
   \   00000110   0xBD7F             POP      {R0-R6,PC}       ;; return
    569          
    570          /*********************************************************************
    571          *
    572          *       Exported routines:  Create
    573          *
    574          **********************************************************************
    575          */
    576          
    577          /* Note: the parameters to a create function may vary.
    578                   Some widgets may have multiple create functions */
    579          
    580          /*********************************************************************
    581          *
    582          *       LISTVIEW_CreateEx
    583          */

   \                                 In section .text, align 2, keep-with-next
    584          LISTVIEW_Handle LISTVIEW_CreateEx(int x0, int y0, int xsize, int ysize, WM_HWIN hParent,
    585                                            int WinFlags, int ExFlags, int Id)
    586          {
   \                     LISTVIEW_CreateEx: (+1)
   \   00000000   0xB57F             PUSH     {R0-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0xF9BD 0x6020      LDRSH    R6,[SP, #+32]
    587            LISTVIEW_Handle hObj;
    588            GUI_USE_PARA(ExFlags);
    589            /* Create the window */
    590            if ((xsize == 0) && (ysize == 0) && (x0 == 0) && (y0 == 0)) {
   \   0000000A   0xEA43 0x0002      ORR      R0,R3,R2
   \   0000000E   0x4320             ORRS     R0,R4,R0
   \   00000010   0x4328             ORRS     R0,R5,R0
   \   00000012   0xD10F             BNE.N    ??LISTVIEW_CreateEx_0
    591              GUI_RECT Rect;
    592              WM_GetClientRectEx(hParent, &Rect);
   \   00000014   0xA900             ADD      R1,SP,#+0
   \   00000016   0x4630             MOV      R0,R6
   \   00000018   0x.... 0x....      BL       WM_GetClientRectEx
    593              xsize = Rect.x1 - Rect.x0 + 1;
   \   0000001C   0xF9BD 0x0004      LDRSH    R0,[SP, #+4]
   \   00000020   0xF9BD 0x1000      LDRSH    R1,[SP, #+0]
   \   00000024   0x1A40             SUBS     R0,R0,R1
   \   00000026   0x1C42             ADDS     R2,R0,#+1
    594              ysize = Rect.y1 - Rect.y0 + 1;
   \   00000028   0xF9BD 0x0006      LDRSH    R0,[SP, #+6]
   \   0000002C   0xF9BD 0x1002      LDRSH    R1,[SP, #+2]
   \   00000030   0x1A40             SUBS     R0,R0,R1
   \   00000032   0x1C43             ADDS     R3,R0,#+1
    595            }
    596            hObj = WM_CreateWindowAsChild(x0, y0, xsize, ysize, hParent, WinFlags, &_LISTVIEW_Callback,
    597                                          sizeof(LISTVIEW_Obj) - sizeof(WM_Obj));
   \                     ??LISTVIEW_CreateEx_0: (+1)
   \   00000034   0x2064             MOVS     R0,#+100
   \   00000036   0x9003             STR      R0,[SP, #+12]
   \   00000038   0x....             LDR.N    R0,??DataTable1
   \   0000003A   0x9002             STR      R0,[SP, #+8]
   \   0000003C   0x9809             LDR      R0,[SP, #+36]
   \   0000003E   0xB280             UXTH     R0,R0
   \   00000040   0x9001             STR      R0,[SP, #+4]
   \   00000042   0x9600             STR      R6,[SP, #+0]
   \   00000044   0x4629             MOV      R1,R5
   \   00000046   0x4620             MOV      R0,R4
   \   00000048   0x.... 0x....      BL       WM_CreateWindowAsChild
   \   0000004C   0x0004             MOVS     R4,R0
    598            if (hObj) {
   \   0000004E   0xD026             BEQ.N    ??LISTVIEW_CreateEx_1
    599              LISTVIEW_Obj* pObj;
    600              WM_LOCK();
    601              pObj = LISTVIEW_H2P(hObj);
   \   00000050   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000054   0x4605             MOV      R5,R0
    602              /* Init sub-classes */
    603              GUI_ARRAY_CREATE(&pObj->RowArray);
    604              GUI_ARRAY_CREATE(&pObj->AlignArray);
    605              /* Init widget specific variables */
    606              WIDGET__Init(&pObj->Widget, Id, WIDGET_STATE_FOCUSSABLE);
   \   00000056   0x2210             MOVS     R2,#+16
   \   00000058   0x990B             LDR      R1,[SP, #+44]
   \   0000005A   0x.... 0x....      BL       WIDGET__Init
    607              /* Init member variables */
    608              LISTVIEW_INIT_ID(pObj);
    609              pObj->Props = LISTVIEW_DefaultProps;
   \   0000005E   0xF105 0x0034      ADD      R0,R5,#+52
   \   00000062   0x....             LDR.N    R1,??DataTable1_1
   \   00000064   0x2220             MOVS     R2,#+32
   \   00000066   0x.... 0x....      BL       __aeabi_memcpy4
    610              pObj->ShowGrid  = 0;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x65A8             STR      R0,[R5, #+88]
    611              pObj->RowDistY  = 0;
   \   0000006E   0x65E8             STR      R0,[R5, #+92]
    612              pObj->Sel       = -1;
   \   00000070   0xF04F 0x30FF      MOV      R0,#-1
   \   00000074   0x6568             STR      R0,[R5, #+84]
    613              pObj->LBorder   = 1;
   \   00000076   0x2001             MOVS     R0,#+1
   \   00000078   0x6628             STR      R0,[R5, #+96]
    614              pObj->RBorder   = 1;
   \   0000007A   0x6668             STR      R0,[R5, #+100]
    615              pObj->hHeader   = HEADER_CreateEx(0, 0, 0, 0, hObj, WM_CF_SHOW, 0, 0);
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x9003             STR      R0,[SP, #+12]
   \   00000080   0x9002             STR      R0,[SP, #+8]
   \   00000082   0x2002             MOVS     R0,#+2
   \   00000084   0x9001             STR      R0,[SP, #+4]
   \   00000086   0x9400             STR      R4,[SP, #+0]
   \   00000088   0x2300             MOVS     R3,#+0
   \   0000008A   0x461A             MOV      R2,R3
   \   0000008C   0x4611             MOV      R1,R2
   \   0000008E   0x4608             MOV      R0,R1
   \   00000090   0x.... 0x....      BL       HEADER_CreateEx
   \   00000094   0x8528             STRH     R0,[R5, #+40]
    616              LISTVIEW__UpdateScrollParas(hObj, pObj);
   \   00000096   0x4629             MOV      R1,R5
   \   00000098   0x4620             MOV      R0,R4
   \   0000009A   0x.... 0x....      BL       LISTVIEW__UpdateScrollParas
    617              WM_UNLOCK();
    618            } else {
    619              GUI_DEBUG_ERROROUT_IF(hObj==0, "LISTVIEW_Create failed")
    620            }
    621            return hObj;
   \                     ??LISTVIEW_CreateEx_1: (+1)
   \   0000009E   0x4620             MOV      R0,R4
   \   000000A0   0xB004             ADD      SP,SP,#+16
   \   000000A2   0xBD70             POP      {R4-R6,PC}       ;; return
    622          }
    623          
    624          /*********************************************************************
    625          *
    626          *       Exported routines: Member functions
    627          *
    628          **********************************************************************
    629          */
    630          /*********************************************************************
    631          *
    632          *       LISTVIEW_IncSel
    633          */

   \                                 In section .text, align 2, keep-with-next
    634          void LISTVIEW_IncSel(LISTVIEW_Handle hObj) {
   \                     LISTVIEW_IncSel: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    635            int Sel = LISTVIEW_GetSel(hObj);
   \   00000004   0x.... 0x....      BL       LISTVIEW_GetSel
    636            LISTVIEW_SetSel(hObj, Sel + 1);
   \   00000008   0x1C41             ADDS     R1,R0,#+1
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0xE8BD 0x4010      POP      {R4,LR}
   \   00000010   0x.... 0x....      B.W      LISTVIEW_SetSel
    637          }
    638          
    639          /*********************************************************************
    640          *
    641          *       LISTVIEW_DecSel
    642          */

   \                                 In section .text, align 2, keep-with-next
    643          void LISTVIEW_DecSel(LISTVIEW_Handle hObj) {
   \                     LISTVIEW_DecSel: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    644            int Sel = LISTVIEW_GetSel(hObj);
   \   00000004   0x.... 0x....      BL       LISTVIEW_GetSel
    645            if (Sel) {
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD005             BEQ.N    ??LISTVIEW_DecSel_0
    646              LISTVIEW_SetSel(hObj, Sel - 1);
   \   0000000C   0x1E41             SUBS     R1,R0,#+1
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0xE8BD 0x4010      POP      {R4,LR}
   \   00000014   0x.... 0x....      B.W      LISTVIEW_SetSel
    647            }
    648          }
   \                     ??LISTVIEW_DecSel_0: (+1)
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
    649          
    650          /*********************************************************************
    651          *
    652          *       LISTVIEW_AddColumn
    653          */

   \                                 In section .text, align 2, keep-with-next
    654          void LISTVIEW_AddColumn(LISTVIEW_Handle hObj, int Width, const char * s, int Align) {
   \                     LISTVIEW_AddColumn: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    655            if (hObj) {
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD02A             BEQ.N    ??LISTVIEW_AddColumn_0
    656              LISTVIEW_Obj* pObj;
    657              unsigned NumRows;
    658              WM_LOCK();
    659              pObj = LISTVIEW_H2P(hObj);
   \   0000000C   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000010   0x4607             MOV      R7,R0
    660              HEADER_AddItem(pObj->hHeader, Width, s, Align);   /* Modify header */
   \   00000012   0x9B00             LDR      R3,[SP, #+0]
   \   00000014   0x4632             MOV      R2,R6
   \   00000016   0x4629             MOV      R1,R5
   \   00000018   0xF9B7 0x0028      LDRSH    R0,[R7, #+40]
   \   0000001C   0x.... 0x....      BL       HEADER_AddItem
    661              GUI_ARRAY_AddItem(&pObj->AlignArray, &Align, sizeof(int));
   \   00000020   0x2204             MOVS     R2,#+4
   \   00000022   0xA900             ADD      R1,SP,#+0
   \   00000024   0xF107 0x002E      ADD      R0,R7,#+46
   \   00000028   0x.... 0x....      BL       GUI_ARRAY_AddItem
    662              NumRows = LISTVIEW_GetNumRows(hObj);
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       LISTVIEW_GetNumRows
   \   00000032   0x0005             MOVS     R5,R0
    663              if (NumRows) {
   \   00000034   0xD00D             BEQ.N    ??LISTVIEW_AddColumn_1
    664                GUI_ARRAY* pRow;
    665                unsigned i;
    666                for (i = 0; i < NumRows; i++) {
   \   00000036   0x2600             MOVS     R6,#+0
   \   00000038   0xE009             B.N      ??LISTVIEW_AddColumn_2
    667                  pRow = (GUI_ARRAY*) GUI_ARRAY_GetpItem(&pObj->RowArray, i);
   \                     ??LISTVIEW_AddColumn_3: (+1)
   \   0000003A   0x4631             MOV      R1,R6
   \   0000003C   0xF107 0x002A      ADD      R0,R7,#+42
   \   00000040   0x.... 0x....      BL       GUI_ARRAY_GetpItem
    668                  GUI_ARRAY_AddItem(pRow, NULL, sizeof(LISTVIEW_ITEM) + 1);
   \   00000044   0x2205             MOVS     R2,#+5
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0x.... 0x....      BL       GUI_ARRAY_AddItem
    669                }
   \   0000004C   0x1C76             ADDS     R6,R6,#+1
   \                     ??LISTVIEW_AddColumn_2: (+1)
   \   0000004E   0x42AE             CMP      R6,R5
   \   00000050   0xD3F3             BCC.N    ??LISTVIEW_AddColumn_3
    670              }
    671              LISTVIEW__UpdateScrollParas(hObj, pObj);
   \                     ??LISTVIEW_AddColumn_1: (+1)
   \   00000052   0x4639             MOV      R1,R7
   \   00000054   0x4620             MOV      R0,R4
   \   00000056   0x.... 0x....      BL       LISTVIEW__UpdateScrollParas
    672              LISTVIEW__InvalidateInsideArea(hObj, pObj);
   \   0000005A   0x4639             MOV      R1,R7
   \   0000005C   0x4620             MOV      R0,R4
   \   0000005E   0x.... 0x....      BL       LISTVIEW__InvalidateInsideArea
    673              WM_UNLOCK();
    674            }
    675          }
   \                     ??LISTVIEW_AddColumn_0: (+1)
   \   00000062   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    676          
    677          /*********************************************************************
    678          *
    679          *       LISTVIEW_AddRow
    680          */

   \                                 In section .text, align 2, keep-with-next
    681          void LISTVIEW_AddRow(LISTVIEW_Handle hObj, const GUI_ConstString* ppText) {
   \                     LISTVIEW_AddRow: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    682            if (hObj) {
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD04D             BEQ.N    ??LISTVIEW_AddRow_0
    683              LISTVIEW_Obj* pObj;
    684              int NumRows;
    685              WM_LOCK();
    686              pObj = LISTVIEW_H2P(hObj);
   \   0000000C   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000010   0x4606             MOV      R6,R0
    687              NumRows = GUI_ARRAY_GetNumItems(&pObj->RowArray);
   \   00000012   0xF106 0x002A      ADD      R0,R6,#+42
   \   00000016   0x.... 0x....      BL       GUI_ARRAY_GetNumItems
   \   0000001A   0x4607             MOV      R7,R0
    688          
    689              /* Create GUI_ARRAY for the new row */
    690              if (GUI_ARRAY_AddItem(&pObj->RowArray, NULL, sizeof(GUI_ARRAY)) == 0) {
   \   0000001C   0x2204             MOVS     R2,#+4
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0xF106 0x002A      ADD      R0,R6,#+42
   \   00000024   0x.... 0x....      BL       GUI_ARRAY_AddItem
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD13D             BNE.N    ??LISTVIEW_AddRow_0
    691                int i, NumColumns, NumBytes;
    692                GUI_ARRAY* pRow;
    693                const char* s;
    694                GUI_ARRAY_CREATE((GUI_ARRAY *)GUI_ARRAY_GetpItem(&pObj->RowArray, NumRows));  /* For higher debug levels only */
    695                /* Add columns for the new row */
    696                NumColumns = HEADER_GetNumItems(pObj->hHeader);
   \   0000002C   0xF9B6 0x0028      LDRSH    R0,[R6, #+40]
   \   00000030   0x.... 0x....      BL       HEADER_GetNumItems
   \   00000034   0x9000             STR      R0,[SP, #+0]
    697                for (i = 0; i < NumColumns; i++) {
   \   00000036   0xF04F 0x0800      MOV      R8,#+0
   \   0000003A   0xE01D             B.N      ??LISTVIEW_AddRow_1
    698                  LISTVIEW_ITEM * pItem;
    699                  pRow = (GUI_ARRAY *)GUI_ARRAY_GetpItem(&pObj->RowArray, NumRows);
    700                  s = (ppText) ? *ppText++ : 0;
   \                     ??LISTVIEW_AddRow_2: (+1)
   \   0000003C   0xF04F 0x0900      MOV      R9,#+0
    701                  if (s == 0) {
   \                     ??LISTVIEW_AddRow_3: (+1)
   \   00000040   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000044   0xD100             BNE.N    ??LISTVIEW_AddRow_4
    702                    ppText = 0;
   \   00000046   0x2500             MOVS     R5,#+0
    703                  }
    704                  NumBytes = GUI__strlen(s) + 1;     /* 0 if no string is specified (s == NULL) */
   \                     ??LISTVIEW_AddRow_4: (+1)
   \   00000048   0x4648             MOV      R0,R9
   \   0000004A   0x.... 0x....      BL       GUI__strlen
   \   0000004E   0xF100 0x0A01      ADD      R10,R0,#+1
    705                  GUI_ARRAY_AddItem(pRow, NULL, sizeof(LISTVIEW_ITEM) + NumBytes);
   \   00000052   0xF10A 0x0204      ADD      R2,R10,#+4
   \   00000056   0x2100             MOVS     R1,#+0
   \   00000058   0x4658             MOV      R0,R11
   \   0000005A   0x.... 0x....      BL       GUI_ARRAY_AddItem
    706                  pItem = (LISTVIEW_ITEM *)GUI_ARRAY_GetpItem(pRow, i);
   \   0000005E   0x4641             MOV      R1,R8
   \   00000060   0x4658             MOV      R0,R11
   \   00000062   0x.... 0x....      BL       GUI_ARRAY_GetpItem
    707                  if (NumBytes > 1) {
   \   00000066   0xF1BA 0x0F02      CMP      R10,#+2
   \   0000006A   0xDB03             BLT.N    ??LISTVIEW_AddRow_5
    708                    strcpy(pItem->acText, s);
   \   0000006C   0x4649             MOV      R1,R9
   \   0000006E   0x1C80             ADDS     R0,R0,#+2
   \   00000070   0x.... 0x....      BL       strcpy
    709                  }
   \                     ??LISTVIEW_AddRow_5: (+1)
   \   00000074   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??LISTVIEW_AddRow_1: (+1)
   \   00000078   0x9800             LDR      R0,[SP, #+0]
   \   0000007A   0x4580             CMP      R8,R0
   \   0000007C   0xDA0A             BGE.N    ??LISTVIEW_AddRow_6
   \   0000007E   0x4639             MOV      R1,R7
   \   00000080   0xF106 0x002A      ADD      R0,R6,#+42
   \   00000084   0x.... 0x....      BL       GUI_ARRAY_GetpItem
   \   00000088   0x4683             MOV      R11,R0
   \   0000008A   0x2D00             CMP      R5,#+0
   \   0000008C   0xD0D6             BEQ.N    ??LISTVIEW_AddRow_2
   \   0000008E   0xF855 0x9B04      LDR      R9,[R5], #+4
   \   00000092   0xE7D5             B.N      ??LISTVIEW_AddRow_3
    710                }
    711                LISTVIEW__UpdateScrollParas(hObj, pObj);
   \                     ??LISTVIEW_AddRow_6: (+1)
   \   00000094   0x4631             MOV      R1,R6
   \   00000096   0x4620             MOV      R0,R4
   \   00000098   0x.... 0x....      BL       LISTVIEW__UpdateScrollParas
    712                LISTVIEW__InvalidateRow(hObj, pObj, NumRows);
   \   0000009C   0x463A             MOV      R2,R7
   \   0000009E   0x4631             MOV      R1,R6
   \   000000A0   0x4620             MOV      R0,R4
   \   000000A2   0xE8BD 0x4FF8      POP      {R3-R11,LR}
   \   000000A6   0x....             B.N      LISTVIEW__InvalidateRow
    713              }
    714              WM_UNLOCK();
    715            }
    716          }
   \                     ??LISTVIEW_AddRow_0: (+1)
   \   000000A8   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     _LISTVIEW_Callback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x........         DC32     LISTVIEW_DefaultProps

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {0}>`:
   \   00000000   0x00000000         DC32 0
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
    717          
    718          #else
    719            void LISTVIEW_C(void);
    720            void LISTVIEW_C(void) {}
    721          #endif  /* #if GUI_WINSUPPORT */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   LISTVIEW_AddColumn
        24   -> GUI_ALLOC_h2p
        24   -> GUI_ARRAY_AddItem
        24   -> GUI_ARRAY_GetpItem
        24   -> HEADER_AddItem
        24   -> LISTVIEW_GetNumRows
        24   -> LISTVIEW__InvalidateInsideArea
        24   -> LISTVIEW__UpdateScrollParas
      40   LISTVIEW_AddRow
        40   -> GUI_ALLOC_h2p
        40   -> GUI_ARRAY_AddItem
        40   -> GUI_ARRAY_GetNumItems
        40   -> GUI_ARRAY_GetpItem
        40   -> GUI__strlen
        40   -> HEADER_GetNumItems
         0   -> LISTVIEW__InvalidateRow
        40   -> LISTVIEW__UpdateScrollParas
        40   -> strcpy
      32   LISTVIEW_CreateEx
        32   -> GUI_ALLOC_h2p
        32   -> HEADER_CreateEx
        32   -> LISTVIEW__UpdateScrollParas
        32   -> WIDGET__Init
        32   -> WM_CreateWindowAsChild
        32   -> WM_GetClientRectEx
        32   -> __aeabi_memcpy4
       8   LISTVIEW_DecSel
         8   -> LISTVIEW_GetSel
         0   -> LISTVIEW_SetSel
       8   LISTVIEW_IncSel
         8   -> LISTVIEW_GetSel
         0   -> LISTVIEW_SetSel
       8   LISTVIEW__GetRowDistY
         8   -> GUI_GetYDistOfFont
      24   LISTVIEW__InvalidateInsideArea
        24   -> HEADER_GetHeight
        24   -> WM_GetInsideRectExScrollbar
        24   -> WM_InvalidateRect
      32   LISTVIEW__InvalidateRow
        32   -> HEADER_GetHeight
        32   -> LISTVIEW__GetRowDistY
        32   -> WM_GetInsideRectExScrollbar
        32   -> WM_InvalidateRect
      16   LISTVIEW__UpdateScrollParas
        16   -> GUI_ARRAY_GetNumItems
         0   -> LISTVIEW__UpdateScrollPos
        16   -> _GetHeaderWidth
        16   -> _GetNumVisibleRows
        16   -> _GetXSize
      16   LISTVIEW__UpdateScrollPos
        16   -> WIDGET__SetScrollState
        16   -> WM_CheckScrollBounds
        16   -> WM_CheckScrollPos
       8   _AddKey
         8   -> LISTVIEW_DecSel
         8   -> LISTVIEW_IncSel
      32   _FreeAttached
        32   -> GUI_ALLOC_Free
         0   -> GUI_ARRAY_Delete
        32   -> GUI_ARRAY_Delete
        32   -> GUI_ARRAY_GetNumItems
        32   -> GUI_ARRAY_GetpItem
      24   _GetHeaderWidth
        24   -> HEADER_GetItemWidth
        24   -> HEADER_GetNumItems
      24   _GetNumVisibleRows
        24   -> HEADER_GetHeight
        24   -> LISTVIEW__GetRowDistY
        24   -> WM_GetInsideRectExScrollbar
      16   _GetXSize
        16   -> WM_GetInsideRectExScrollbar
      32   _LISTVIEW_Callback
        32   -> GUI_ALLOC_h2p
        32   -> HEADER_SetScrollPos
        32   -> LISTVIEW__InvalidateInsideArea
        32   -> LISTVIEW__UpdateScrollParas
        32   -> WIDGET_HandleActive
        32   -> WM_DefaultProc
        32   -> WM_GetScrollState
        32   -> WM_GetScrollbarH
        32   -> WM_GetScrollbarV
        32   -> _AddKey
        32   -> _FreeAttached
        32   -> _NotifyOwner
        32   -> _OnTouch
        32   -> _Paint
      24   _NotifyOwner
        24   -> GUI_ALLOC_h2p
        24   -> WM_GetParent
        24   -> WM_SendMessage
      16   _OnTouch
        16   -> WM_SetFocus
         0   -> _NotifyOwner
        16   -> _SetSelFromPos
      96   _Paint
        96   -> GUI_ALLOC_h2p
        96   -> GUI_ARRAY_GetNumItems
        96   -> GUI_ARRAY_GetpItem
        96   -> GUI_ClearRect
        96   -> GUI_DispStringInRect
        96   -> GUI_DrawHLine
        96   -> GUI_DrawVLine
        96   -> GUI_MoveRect
        96   -> GUI_SetFont
        96   -> GUI_SetTextMode
        96   -> GUI__IntersectRect
        96   -> HEADER_GetHeight
        96   -> HEADER_GetItemWidth
        96   -> HEADER_GetNumItems
        96   -> LCD_SetBkColor
        96   -> LCD_SetColor
        96   -> LISTVIEW__GetRowDistY
        96   -> WIDGET__EFFECT_DrawDown
        96   -> WM_GetInsideRectExScrollbar
        96   -> _GetNumVisibleRows
        96   -> __aeabi_memcpy
      32   _SetSelFromPos
        32   -> GUI_ARRAY_GetNumItems
        32   -> HEADER_GetHeight
        32   -> LISTVIEW_SetSel
        32   -> LISTVIEW__GetRowDistY
        32   -> WM_GetInsideRectExScrollbar


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      12  ?<Constant {0}>
       4  ??DataTable1
       4  ??DataTable1_1
     100  LISTVIEW_AddColumn
     172  LISTVIEW_AddRow
     164  LISTVIEW_CreateEx
      26  LISTVIEW_DecSel
      32  LISTVIEW_DefaultProps
      20  LISTVIEW_IncSel
      26  LISTVIEW__GetRowDistY
      44  LISTVIEW__InvalidateInsideArea
      82  LISTVIEW__InvalidateRow
      64  LISTVIEW__UpdateScrollParas
      64  LISTVIEW__UpdateScrollPos
      30  _AddKey
     108  _FreeAttached
      64  _GetHeaderWidth
      58  _GetNumVisibleRows
      18  _GetXSize
     274  _LISTVIEW_Callback
      54  _NotifyOwner
      48  _OnTouch
     696  _Paint
     128  _SetSelFromPos

 
    32 bytes in section .data
    12 bytes in section .rodata
 2 248 bytes in section .text
 
 2 248 bytes of CODE  memory
    12 bytes of CONST memory
    32 bytes of DATA  memory

Errors: none
Warnings: none
