###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  10:57:45
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Widget\CHECKBOX.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Widget\CHECKBOX.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\CHECKBOX.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\CHECKBOX.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Widget\CHECKBOX.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              µC/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : CHECKBOX.c
     16          Purpose     : Implementation of checkbox widget
     17          ---------------------------END-OF-HEADER------------------------------
     18          */
     19          
     20          #include <stdlib.h>
     21          #include <string.h>
     22          #include "GUI_Protected.h"
     23          #include "CHECKBOX_Private.h"
     24          #include "WIDGET.h"
     25          
     26          #if GUI_WINSUPPORT
     27          
     28          /*********************************************************************
     29          *
     30          *       Private config defaults
     31          *
     32          **********************************************************************
     33          */
     34          
     35          /* Define default fonts */
     36          #ifndef CHECKBOX_FONT_DEFAULT
     37            #define CHECKBOX_FONT_DEFAULT &GUI_Font13_1
     38          #endif
     39          
     40          /* Define default images */
     41          #ifndef CHECKBOX_IMAGE0_DEFAULT
     42            #define CHECKBOX_IMAGE0_DEFAULT &CHECKBOX__abmCheck[0]
     43          #endif
     44          
     45          #ifndef CHECKBOX_IMAGE1_DEFAULT
     46            #define CHECKBOX_IMAGE1_DEFAULT &CHECKBOX__abmCheck[1]
     47          #endif
     48          
     49          /* Define widget background color */
     50          #ifndef CHECKBOX_BKCOLOR_DEFAULT
     51            #define CHECKBOX_BKCOLOR_DEFAULT 0xC0C0C0           /* Text background color */
     52          #endif
     53          
     54          #ifndef CHECKBOX_SPACING_DEFAULT
     55            #define CHECKBOX_SPACING_DEFAULT 4
     56          #endif
     57          
     58          #ifndef CHECKBOX_TEXTCOLOR_DEFAULT
     59            #define CHECKBOX_TEXTCOLOR_DEFAULT GUI_BLACK
     60          #endif
     61          
     62          #ifndef CHECKBOX_TEXTALIGN_DEFAULT
     63            #define CHECKBOX_TEXTALIGN_DEFAULT (GUI_TA_LEFT | GUI_TA_VCENTER)
     64          #endif
     65          
     66          /*********************************************************************
     67          *
     68          *       Static data
     69          *
     70          **********************************************************************
     71          */
     72          

   \                                 In section .data, align 4
     73          CHECKBOX_PROPS CHECKBOX__DefaultProps = {
   \                     CHECKBOX__DefaultProps:
   \   00000000   0x........         DC32 GUI_Font13_1, 8421504, 16777215, 12632256, 0
   \              0x00808080   
   \              0x00FFFFFF   
   \              0x00C0C0C0   
   \              0x00000000   
   \   00000014   0x000C             DC16 12
   \   00000016   0x04 0x00          DC8 4, 0
   \   00000018   0x........         DC32 CHECKBOX__abmCheck, CHECKBOX__abmCheck + 14H
   \              0x........   
   \   00000020   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
     74            CHECKBOX_FONT_DEFAULT,
     75            CHECKBOX_BKCOLOR0_DEFAULT,
     76            CHECKBOX_BKCOLOR1_DEFAULT,
     77            CHECKBOX_BKCOLOR_DEFAULT,
     78            CHECKBOX_TEXTCOLOR_DEFAULT,
     79            CHECKBOX_TEXTALIGN_DEFAULT,
     80            CHECKBOX_SPACING_DEFAULT,
     81            CHECKBOX_IMAGE0_DEFAULT, 
     82            CHECKBOX_IMAGE1_DEFAULT
     83          };
     84          
     85          /*********************************************************************
     86          *
     87          *       Macros for internal use
     88          *
     89          **********************************************************************
     90          */
     91          
     92          #define CHECKBOX_ID 0x4544   /* Magic numer, should be unique if possible */
     93          
     94          #if GUI_DEBUG_LEVEL > 1
     95            #define CHECKBOX_ASSERT_IS_VALID_PTR(p) DEBUG_ERROROUT_IF(p->DebugId != CHECKBOX_ID, "xxx.c: Wrong handle type or Object not init'ed")
     96            #define CHECKBOX_INIT_ID(p)   p->DebugId = CHECKBOX_ID
     97            #define CHECKBOX_DEINIT_ID(p) p->DebugId = CHECKBOX_ID+1
     98          #else
     99            #define CHECKBOX_ASSERT_IS_VALID_PTR(p)
    100            #define CHECKBOX_INIT_ID(p)
    101            #define CHECKBOX_DEINIT_ID(p)
    102          #endif
    103          
    104          /*********************************************************************
    105          *
    106          *       Static routines
    107          *
    108          **********************************************************************
    109          */
    110          /*********************************************************************
    111          *
    112          *       _Paint
    113          */

   \                                 In section .text, align 2, keep-with-next
    114          static void _Paint(CHECKBOX_Obj* pObj, CHECKBOX_Handle hObj) {
   \                     _Paint: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x4688             MOV      R8,R1
    115            GUI_RECT RectBox = {0};
   \   0000000A   0x.... 0x....      ADR.W    R0,`?<Constant {0}>`
   \   0000000E   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \   00000012   0xE9CD 0x2304      STRD     R2,R3,[SP, #+16]
    116            int ColorIndex, EffectSize;
    117            EffectSize = pObj->Widget.pEffect->EffectSize;
   \   00000016   0x6A20             LDR      R0,[R4, #+32]
   \   00000018   0x6945             LDR      R5,[R0, #+20]
    118            ColorIndex = WM__IsEnabled(hObj);
   \   0000001A   0x4640             MOV      R0,R8
   \   0000001C   0x.... 0x....      BL       WM__IsEnabled
   \   00000020   0x4607             MOV      R7,R0
    119            /* Clear inside ... Just in case      */
    120            /* Fill with parents background color */
    121          #if WM_SUPPORT_TRANSPARENCY
    122            if (!WM_GetHasTrans(hObj))
   \   00000022   0xF104 0x0620      ADD      R6,R4,#+32
   \   00000026   0x4640             MOV      R0,R8
   \   00000028   0x.... 0x....      BL       WM_GetHasTrans
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD10E             BNE.N    ??_Paint_0
    123          #endif
    124            {
    125              if (pObj->Props.BkColor == GUI_INVALID_COLOR) {
   \   00000030   0x6970             LDR      R0,[R6, #+20]
   \   00000032   0xF06F 0x4170      MVN      R1,#-268435456
   \   00000036   0x4288             CMP      R0,R1
   \   00000038   0xD105             BNE.N    ??_Paint_1
    126                LCD_SetBkColor(WIDGET__GetBkColor(hObj));
   \   0000003A   0x4640             MOV      R0,R8
   \   0000003C   0x.... 0x....      BL       WIDGET__GetBkColor
   \   00000040   0x.... 0x....      BL       LCD_SetBkColor
   \   00000044   0xE001             B.N      ??_Paint_2
    127              } else {
    128                LCD_SetBkColor(pObj->Props.BkColor);
   \                     ??_Paint_1: (+1)
   \   00000046   0x.... 0x....      BL       LCD_SetBkColor
    129              }
    130              GUI_Clear();
   \                     ??_Paint_2: (+1)
   \   0000004A   0x.... 0x....      BL       GUI_Clear
    131            }
    132            /* Get size from bitmap */
    133            RectBox.x1 = pObj->Props.apBm[0]->XSize - 1 + 2 * EffectSize;
   \                     ??_Paint_0: (+1)
   \   0000004E   0x6A31             LDR      R1,[R6, #+32]
   \   00000050   0xF9B1 0x1000      LDRSH    R1,[R1, #+0]
   \   00000054   0xEB11 0x0145      ADDS     R1,R1,R5, LSL #+1
   \   00000058   0x1E49             SUBS     R1,R1,#+1
   \   0000005A   0xF8AD 0x1014      STRH     R1,[SP, #+20]
    134            RectBox.y1 = pObj->Props.apBm[0]->YSize - 1 + 2 * EffectSize;
   \   0000005E   0x6A31             LDR      R1,[R6, #+32]
   \   00000060   0xF9B1 0x1002      LDRSH    R1,[R1, #+2]
   \   00000064   0xEB11 0x0045      ADDS     R0,R1,R5, LSL #+1
   \   00000068   0x1E40             SUBS     R0,R0,#+1
   \   0000006A   0xF8AD 0x0016      STRH     R0,[SP, #+22]
    135            WM_SetUserClipRect(&RectBox);
   \   0000006E   0xA804             ADD      R0,SP,#+16
   \   00000070   0x.... 0x....      BL       WM_SetUserClipRect
    136            /* Clear inside  ... Just in case */
    137            LCD_SetBkColor(pObj->Props.aBkColorBox[ColorIndex]);
   \   00000074   0xEB04 0x0087      ADD      R0,R4,R7, LSL #+2
   \   00000078   0x6AC0             LDR      R0,[R0, #+44]
   \   0000007A   0x.... 0x....      BL       LCD_SetBkColor
    138            GUI_Clear();
   \   0000007E   0x.... 0x....      BL       GUI_Clear
    139            if (pObj->CurrentState) {
   \   00000082   0xF894 0x0051      LDRB     R0,[R4, #+81]
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD008             BEQ.N    ??_Paint_3
    140              int Index = (pObj->CurrentState - 1) * 2 + ColorIndex;
    141              GUI_DrawBitmap(pObj->Props.apBm[Index], EffectSize, EffectSize);
   \   0000008A   0x462A             MOV      R2,R5
   \   0000008C   0x4629             MOV      R1,R5
   \   0000008E   0xEB07 0x0040      ADD      R0,R7,R0, LSL #+1
   \   00000092   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   00000096   0x6B80             LDR      R0,[R0, #+56]
   \   00000098   0x.... 0x....      BL       GUI_DrawBitmap
    142            }
    143            /* Draw the effect arround the box */
    144            WIDGET__EFFECT_DrawDownRect(&pObj->Widget, &RectBox);
   \                     ??_Paint_3: (+1)
   \   0000009C   0xA904             ADD      R1,SP,#+16
   \   0000009E   0x4620             MOV      R0,R4
   \   000000A0   0x.... 0x....      BL       WIDGET__EFFECT_DrawDownRect
    145            WM_SetUserClipRect(NULL);
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0x.... 0x....      BL       WM_SetUserClipRect
    146            /* Draw text if needed */
    147            if (pObj->hpText) {
   \   000000AA   0xF9B4 0x0052      LDRSH    R0,[R4, #+82]
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD075             BEQ.N    ??_Paint_4
    148              const char * s;
    149              GUI_RECT RectText;
    150              /* Draw the text */
    151              s = (const char *) GUI_ALLOC_h2p(pObj->hpText);
   \   000000B2   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   000000B6   0x4605             MOV      R5,R0
    152              WM_GetClientRect(&RectText);
   \   000000B8   0xA802             ADD      R0,SP,#+8
   \   000000BA   0x.... 0x....      BL       WM_GetClientRect
    153              RectText.x0 += RectBox.x1 + 1 + pObj->Props.Spacing;
   \   000000BE   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   000000C2   0xF8BD 0x1014      LDRH     R1,[SP, #+20]
   \   000000C6   0x7FB2             LDRB     R2,[R6, #+30]
   \   000000C8   0x1889             ADDS     R1,R1,R2
   \   000000CA   0x1C49             ADDS     R1,R1,#+1
   \   000000CC   0x1808             ADDS     R0,R1,R0
   \   000000CE   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    154              GUI_SetTextMode(GUI_TM_TRANS);
   \   000000D2   0x2002             MOVS     R0,#+2
   \   000000D4   0x.... 0x....      BL       GUI_SetTextMode
    155              LCD_SetColor(pObj->Props.TextColor);
   \   000000D8   0x69B0             LDR      R0,[R6, #+24]
   \   000000DA   0x.... 0x....      BL       LCD_SetColor
    156              GUI_SetFont(pObj->Props.pFont);
   \   000000DE   0x68B0             LDR      R0,[R6, #+8]
   \   000000E0   0x.... 0x....      BL       GUI_SetFont
    157              GUI_DispStringInRect(s, &RectText, pObj->Props.Align);
   \   000000E4   0xF9B6 0x201C      LDRSH    R2,[R6, #+28]
   \   000000E8   0xA902             ADD      R1,SP,#+8
   \   000000EA   0x4628             MOV      R0,R5
   \   000000EC   0x.... 0x....      BL       GUI_DispStringInRect
    158              /* Draw focus rectangle */
    159              if (pObj->Widget.State & WIDGET_STATE_FOCUS) {
   \   000000F0   0x79B0             LDRB     R0,[R6, #+6]
   \   000000F2   0x07C0             LSLS     R0,R0,#+31
   \   000000F4   0xD553             BPL.N    ??_Paint_4
    160                int xSizeText = GUI_GetStringDistX(s);
   \   000000F6   0x4628             MOV      R0,R5
   \   000000F8   0x.... 0x....      BL       GUI_GetStringDistX
   \   000000FC   0x4605             MOV      R5,R0
    161                int ySizeText = GUI_GetFontSizeY();
   \   000000FE   0x.... 0x....      BL       GUI_GetFontSizeY
    162                GUI_RECT RectFocus = RectText;
   \   00000102   0xE9DD 0x2302      LDRD     R2,R3,[SP, #+8]
   \   00000106   0xE9CD 0x2300      STRD     R2,R3,[SP, #+0]
    163                switch (pObj->Props.Align & ~(GUI_TA_HORIZONTAL)) {
   \   0000010A   0x8BB1             LDRH     R1,[R6, #+28]
   \   0000010C   0xF64F 0x72EC      MOVW     R2,#+65516
   \   00000110   0x4011             ANDS     R1,R2,R1
   \   00000112   0x2904             CMP      R1,#+4
   \   00000114   0xD00A             BEQ.N    ??_Paint_5
   \   00000116   0x290C             CMP      R1,#+12
   \   00000118   0xD10D             BNE.N    ??_Paint_6
    164                case GUI_TA_VCENTER:
    165                  RectFocus.y0 = (RectText.y1 - ySizeText) / 2;
   \   0000011A   0xF9BD 0x100E      LDRSH    R1,[SP, #+14]
   \   0000011E   0x1A09             SUBS     R1,R1,R0
   \   00000120   0xEB01 0x71D1      ADD      R1,R1,R1, LSR #+31
   \   00000124   0x1049             ASRS     R1,R1,#+1
   \   00000126   0xF8AD 0x1002      STRH     R1,[SP, #+2]
    166                  break;
   \   0000012A   0xE004             B.N      ??_Paint_6
    167                case GUI_TA_BOTTOM:
    168                  RectFocus.y0 = RectText.y1 - ySizeText;
   \                     ??_Paint_5: (+1)
   \   0000012C   0xF8BD 0x100E      LDRH     R1,[SP, #+14]
   \   00000130   0x1A09             SUBS     R1,R1,R0
   \   00000132   0xF8AD 0x1002      STRH     R1,[SP, #+2]
    169                  break;
    170                }
    171                switch (pObj->Props.Align & ~(GUI_TA_VERTICAL)) {
   \                     ??_Paint_6: (+1)
   \   00000136   0x8BB1             LDRH     R1,[R6, #+28]
   \   00000138   0xF64F 0x72F3      MOVW     R2,#+65523
   \   0000013C   0x4011             ANDS     R1,R2,R1
   \   0000013E   0x2901             CMP      R1,#+1
   \   00000140   0xD010             BEQ.N    ??_Paint_7
   \   00000142   0x2902             CMP      R1,#+2
   \   00000144   0xD119             BNE.N    ??_Paint_8
    172                case GUI_TA_HCENTER:
    173                  RectFocus.x0 += ((RectText.x1 - RectText.x0) - xSizeText) / 2;
   \   00000146   0xF9BD 0x100C      LDRSH    R1,[SP, #+12]
   \   0000014A   0xF9BD 0x2008      LDRSH    R2,[SP, #+8]
   \   0000014E   0x1A89             SUBS     R1,R1,R2
   \   00000150   0x1B49             SUBS     R1,R1,R5
   \   00000152   0xF8BD 0x2000      LDRH     R2,[SP, #+0]
   \   00000156   0xEB01 0x71D1      ADD      R1,R1,R1, LSR #+31
   \   0000015A   0xEB02 0x0161      ADD      R1,R2,R1, ASR #+1
   \   0000015E   0xF8AD 0x1000      STRH     R1,[SP, #+0]
    174                  break;
   \   00000162   0xE00A             B.N      ??_Paint_8
    175                case GUI_TA_RIGHT:
    176                  RectFocus.x0 += (RectText.x1 - RectText.x0) - xSizeText;
   \                     ??_Paint_7: (+1)
   \   00000164   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   00000168   0xF8BD 0x200C      LDRH     R2,[SP, #+12]
   \   0000016C   0x1851             ADDS     R1,R2,R1
   \   0000016E   0xF8BD 0x2008      LDRH     R2,[SP, #+8]
   \   00000172   0x1A89             SUBS     R1,R1,R2
   \   00000174   0x1B49             SUBS     R1,R1,R5
   \   00000176   0xF8AD 0x1000      STRH     R1,[SP, #+0]
    177                  break;
    178                }
    179                RectFocus.x1 = RectFocus.x0 + xSizeText;
   \                     ??_Paint_8: (+1)
   \   0000017A   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   0000017E   0x1869             ADDS     R1,R5,R1
   \   00000180   0xF8AD 0x1004      STRH     R1,[SP, #+4]
    180                RectFocus.y1 = RectFocus.y0 + ySizeText;
   \   00000184   0xF8BD 0x1002      LDRH     R1,[SP, #+2]
   \   00000188   0x1840             ADDS     R0,R0,R1
   \   0000018A   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    181                LCD_SetColor(GUI_BLACK);
   \   0000018E   0x2000             MOVS     R0,#+0
   \   00000190   0x.... 0x....      BL       LCD_SetColor
    182                WIDGET__DrawFocusRect(&pObj->Widget, &RectFocus, 0);
   \   00000194   0x2200             MOVS     R2,#+0
   \   00000196   0xA900             ADD      R1,SP,#+0
   \   00000198   0x4620             MOV      R0,R4
   \   0000019A   0x.... 0x....      BL       WIDGET__DrawFocusRect
    183              }
    184            }
    185          }
   \                     ??_Paint_4: (+1)
   \   0000019E   0xB006             ADD      SP,SP,#+24
   \   000001A0   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    186          
    187          /*********************************************************************
    188          *
    189          *       _OnTouch
    190          */

   \                                 In section .text, align 2, keep-with-next
    191          static void _OnTouch(CHECKBOX_Handle hObj, CHECKBOX_Obj* pObj, WM_MESSAGE*pMsg) {
   \                     _OnTouch: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    192            int Notification = 0;
   \   00000008   0x2700             MOVS     R7,#+0
    193            int Hit = 0;
   \   0000000A   0x463E             MOV      R6,R7
    194            const GUI_PID_STATE* pState = (const GUI_PID_STATE*)pMsg->Data.p;
   \   0000000C   0xF8D2 0x8008      LDR      R8,[R2, #+8]
    195            if (pMsg->Data.p) {  /* Something happened in our area (pressed or released) */
   \   00000010   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000014   0xD01E             BEQ.N    ??_OnTouch_0
    196              if (!WM_HasCaptured(hObj)) {
   \   00000016   0x.... 0x....      BL       WM_HasCaptured
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD11B             BNE.N    ??_OnTouch_1
    197                if (pState->Pressed) {
   \   0000001E   0xF898 0x0008      LDRB     R0,[R8, #+8]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD013             BEQ.N    ??_OnTouch_2
    198                  WM_SetCapture(hObj, 1);
   \   00000026   0x2101             MOVS     R1,#+1
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       WM_SetCapture
    199                  pObj->CurrentState = (pObj->CurrentState + 1) % pObj->NumStates;
   \   0000002E   0xF105 0x0050      ADD      R0,R5,#+80
   \   00000032   0x7841             LDRB     R1,[R0, #+1]
   \   00000034   0x1C49             ADDS     R1,R1,#+1
   \   00000036   0xF895 0x2050      LDRB     R2,[R5, #+80]
   \   0000003A   0xFB91 0xF3F2      SDIV     R3,R1,R2
   \   0000003E   0xFB02 0x1113      MLS      R1,R2,R3,R1
   \   00000042   0x7041             STRB     R1,[R0, #+1]
    200                  WM_Invalidate(hObj);
   \   00000044   0x4620             MOV      R0,R4
   \   00000046   0x.... 0x....      BL       WM_InvalidateWindow
    201                  Notification = WM_NOTIFICATION_CLICKED;
   \   0000004A   0x2701             MOVS     R7,#+1
   \   0000004C   0xE003             B.N      ??_OnTouch_1
    202                } else {
    203                  Hit =1;
   \                     ??_OnTouch_2: (+1)
   \   0000004E   0x2601             MOVS     R6,#+1
    204                  Notification = WM_NOTIFICATION_RELEASED;
   \   00000050   0x2702             MOVS     R7,#+2
   \   00000052   0xE000             B.N      ??_OnTouch_1
    205                }
    206              }
    207            } else {
    208              Notification = WM_NOTIFICATION_MOVED_OUT;
   \                     ??_OnTouch_0: (+1)
   \   00000054   0x2703             MOVS     R7,#+3
    209            }
    210            WM_NotifyParent(hObj, Notification);
   \                     ??_OnTouch_1: (+1)
   \   00000056   0x4639             MOV      R1,R7
   \   00000058   0x4620             MOV      R0,R4
   \   0000005A   0x.... 0x....      BL       WM_NotifyParent
    211            if (Hit == 1) {
   \   0000005E   0x2E01             CMP      R6,#+1
   \   00000060   0xD105             BNE.N    ??_OnTouch_3
    212              GUI_DEBUG_LOG("CHECKBOX: Hit\n");
    213              GUI_StoreKey(pObj->Widget.Id);
   \   00000062   0xF9B5 0x0024      LDRSH    R0,[R5, #+36]
   \   00000066   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   0000006A   0x.... 0x....      B.W      GUI_StoreKey
    214            }
    215          }
   \                     ??_OnTouch_3: (+1)
   \   0000006E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    216          
    217          /*********************************************************************
    218          *
    219          *       _OnKey
    220          */

   \                                 In section .text, align 2, keep-with-next
    221          static void  _OnKey(CHECKBOX_Handle hObj, CHECKBOX_Obj * pObj, WM_MESSAGE * pMsg) {
   \                     _OnKey: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    222            WM_KEY_INFO * pKeyInfo;
    223            if (WM__IsEnabled(hObj)) {
   \   00000008   0x.... 0x....      BL       WM__IsEnabled
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD016             BEQ.N    ??_OnKey_0
    224              pKeyInfo = (WM_KEY_INFO *)(pMsg->Data.p);
   \   00000010   0x68B0             LDR      R0,[R6, #+8]
    225              if (pKeyInfo->PressedCnt > 0) {
   \   00000012   0x6841             LDR      R1,[R0, #+4]
   \   00000014   0x2901             CMP      R1,#+1
   \   00000016   0xDB12             BLT.N    ??_OnKey_0
    226                switch (pKeyInfo->Key) {
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x2820             CMP      R0,#+32
   \   0000001C   0xD10F             BNE.N    ??_OnKey_0
    227                case GUI_KEY_SPACE:
    228                  pObj->CurrentState = (pObj->CurrentState + 1) % pObj->NumStates;
   \   0000001E   0xF105 0x0050      ADD      R0,R5,#+80
   \   00000022   0x7841             LDRB     R1,[R0, #+1]
   \   00000024   0x1C49             ADDS     R1,R1,#+1
   \   00000026   0xF895 0x2050      LDRB     R2,[R5, #+80]
   \   0000002A   0xFB91 0xF3F2      SDIV     R3,R1,R2
   \   0000002E   0xFB02 0x1113      MLS      R1,R2,R3,R1
   \   00000032   0x7041             STRB     R1,[R0, #+1]
    229                  WM_Invalidate(hObj);
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000003A   0x.... 0x....      B.W      WM_InvalidateWindow
    230                  break;                    /* Send to parent by not doing anything */
    231                }
    232              }
    233            }
    234          }
   \                     ??_OnKey_0: (+1)
   \   0000003E   0xBD70             POP      {R4-R6,PC}       ;; return
    235          
    236          /*********************************************************************
    237          *
    238          *       _CHECKBOX_Callback
    239          */

   \                                 In section .text, align 2, keep-with-next
    240          static void _CHECKBOX_Callback (WM_MESSAGE *pMsg) {
   \                     _CHECKBOX_Callback: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    241            CHECKBOX_Handle hObj;
    242            CHECKBOX_Obj* pObj;
    243            hObj = pMsg->hWin;
   \   00000004   0xF9B4 0x5004      LDRSH    R5,[R4, #+4]
    244            pObj = CHECKBOX_H2P(hObj);
   \   00000008   0x4628             MOV      R0,R5
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000000E   0x4606             MOV      R6,R0
    245            /* Let widget handle the standard messages */
    246            if (WIDGET_HandleActive(hObj, pMsg) == 0) {
   \   00000010   0x4621             MOV      R1,R4
   \   00000012   0x4628             MOV      R0,R5
   \   00000014   0x.... 0x....      BL       WIDGET_HandleActive
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD01C             BEQ.N    ??_CHECKBOX_Callback_0
    247              return;
    248            }
    249            switch (pMsg->MsgId) {
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x280C             CMP      R0,#+12
   \   00000020   0xD00F             BEQ.N    ??_CHECKBOX_Callback_1
   \   00000022   0x280E             CMP      R0,#+14
   \   00000024   0xD002             BEQ.N    ??_CHECKBOX_Callback_2
   \   00000026   0x280F             CMP      R0,#+15
   \   00000028   0xD006             BEQ.N    ??_CHECKBOX_Callback_3
   \   0000002A   0xE00F             B.N      ??_CHECKBOX_Callback_4
    250            case WM_KEY:
    251              _OnKey(hObj, pObj, pMsg);
   \                     ??_CHECKBOX_Callback_2: (+1)
   \   0000002C   0x4622             MOV      R2,R4
   \   0000002E   0x4631             MOV      R1,R6
   \   00000030   0x4628             MOV      R0,R5
   \   00000032   0x.... 0x....      BL       _OnKey
    252              break;
   \   00000036   0xE009             B.N      ??_CHECKBOX_Callback_4
    253            case WM_PAINT:
    254              GUI_DEBUG_LOG("CHECKBOX: _Callback(WM_PAINT)\n");
    255              _Paint(pObj, hObj);
   \                     ??_CHECKBOX_Callback_3: (+1)
   \   00000038   0x4629             MOV      R1,R5
   \   0000003A   0x4630             MOV      R0,R6
   \   0000003C   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000040   0x....             B.N      _Paint
    256              return;
    257            case WM_TOUCH:
    258              _OnTouch(hObj, pObj, pMsg);
   \                     ??_CHECKBOX_Callback_1: (+1)
   \   00000042   0x4622             MOV      R2,R4
   \   00000044   0x4631             MOV      R1,R6
   \   00000046   0x4628             MOV      R0,R5
   \   00000048   0x.... 0x....      BL       _OnTouch
    259              break;
    260            }
    261            WM_DefaultProc(pMsg);
   \                     ??_CHECKBOX_Callback_4: (+1)
   \   0000004C   0x4620             MOV      R0,R4
   \   0000004E   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000052   0x.... 0x....      B.W      WM_DefaultProc
   \                     ??_CHECKBOX_Callback_0: (+1)
   \   00000056   0xBD70             POP      {R4-R6,PC}       ;; return
    262          }
    263          
    264          /*********************************************************************
    265          *
    266          *       Exported routines:  Create
    267          *
    268          **********************************************************************
    269          */
    270          
    271          /* Note: the parameters to a create function may vary.
    272                   Some widgets may have multiple create functions */
    273          
    274          /*********************************************************************
    275          *
    276          *       CHECKBOX_CreateEx
    277          */

   \                                 In section .text, align 2, keep-with-next
    278          CHECKBOX_Handle CHECKBOX_CreateEx(int x0, int y0, int xsize, int ysize, WM_HWIN hParent,
    279                                              int WinFlags, int ExFlags, int Id)
    280          {
   \                     CHECKBOX_CreateEx: (+1)
   \   00000000   0xE92D 0x41FF      PUSH     {R0-R8,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460E             MOV      R6,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x461F             MOV      R7,R3
    281            CHECKBOX_Handle hObj;
    282            GUI_USE_PARA(ExFlags);
    283            WM_LOCK();
    284            /* Calculate size if needed */
    285            if ((xsize == 0) || (ysize == 0)) {
   \   0000000C   0x....             LDR.N    R4,??DataTable1
   \   0000000E   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000012   0xD001             BEQ.N    ??CHECKBOX_CreateEx_0
   \   00000014   0x2F00             CMP      R7,#+0
   \   00000016   0xD111             BNE.N    ??CHECKBOX_CreateEx_1
    286              int EffectSize;
    287              EffectSize = WIDGET_GetDefaultEffect()->EffectSize;
   \                     ??CHECKBOX_CreateEx_0: (+1)
   \   00000018   0x.... 0x....      BL       WIDGET_GetDefaultEffect
   \   0000001C   0x6940             LDR      R0,[R0, #+20]
    288              if (xsize == 0) {
   \   0000001E   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000022   0xD104             BNE.N    ??CHECKBOX_CreateEx_2
    289                xsize = CHECKBOX__DefaultProps.apBm[0]->XSize + 2 * EffectSize;
   \   00000024   0x69A1             LDR      R1,[R4, #+24]
   \   00000026   0x8809             LDRH     R1,[R1, #+0]
   \   00000028   0x0042             LSLS     R2,R0,#+1
   \   0000002A   0xFA12 0xF881      UXTAH    R8,R2,R1
    290              }
    291              if (ysize == 0) {
   \                     ??CHECKBOX_CreateEx_2: (+1)
   \   0000002E   0x2F00             CMP      R7,#+0
   \   00000030   0xD104             BNE.N    ??CHECKBOX_CreateEx_1
    292                ysize = CHECKBOX__DefaultProps.apBm[0]->YSize + 2 * EffectSize;
   \   00000032   0x69A1             LDR      R1,[R4, #+24]
   \   00000034   0x8849             LDRH     R1,[R1, #+2]
   \   00000036   0x0040             LSLS     R0,R0,#+1
   \   00000038   0xFA10 0xF781      UXTAH    R7,R0,R1
   \                     ??CHECKBOX_CreateEx_1: (+1)
   \   0000003C   0x980B             LDR      R0,[SP, #+44]
    293              }
    294            }
    295          #if WM_SUPPORT_TRANSPARENCY
    296            if (CHECKBOX__DefaultProps.BkColor == GUI_INVALID_COLOR) {
   \   0000003E   0x68E1             LDR      R1,[R4, #+12]
   \   00000040   0xF06F 0x4270      MVN      R2,#-268435456
   \   00000044   0x4291             CMP      R1,R2
   \   00000046   0xD101             BNE.N    ??CHECKBOX_CreateEx_3
    297              WinFlags |= WM_CF_HASTRANS;
   \   00000048   0xF040 0x0001      ORR      R0,R0,#0x1
    298            }
    299          #endif
    300            /* Create the window */
    301            hObj = WM_CreateWindowAsChild(x0, y0, xsize, ysize, hParent, WinFlags, _CHECKBOX_Callback,
    302                                          sizeof(CHECKBOX_Obj) - sizeof(WM_Obj));
   \                     ??CHECKBOX_CreateEx_3: (+1)
   \   0000004C   0x2134             MOVS     R1,#+52
   \   0000004E   0x9103             STR      R1,[SP, #+12]
   \   00000050   0x....             LDR.N    R1,??DataTable1_1
   \   00000052   0x9102             STR      R1,[SP, #+8]
   \   00000054   0xB280             UXTH     R0,R0
   \   00000056   0x9001             STR      R0,[SP, #+4]
   \   00000058   0xF9BD 0x0028      LDRSH    R0,[SP, #+40]
   \   0000005C   0x9000             STR      R0,[SP, #+0]
   \   0000005E   0x463B             MOV      R3,R7
   \   00000060   0x4642             MOV      R2,R8
   \   00000062   0x4631             MOV      R1,R6
   \   00000064   0x4628             MOV      R0,R5
   \   00000066   0x.... 0x....      BL       WM_CreateWindowAsChild
   \   0000006A   0x0005             MOVS     R5,R0
    303            if (hObj) {
   \   0000006C   0xD00F             BEQ.N    ??CHECKBOX_CreateEx_4
    304              CHECKBOX_Obj* pObj = CHECKBOX_H2P(hObj);
   \   0000006E   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000072   0x4606             MOV      R6,R0
    305              /* init widget specific variables */
    306              WIDGET__Init(&pObj->Widget, Id, WIDGET_STATE_FOCUSSABLE);
   \   00000074   0x2210             MOVS     R2,#+16
   \   00000076   0x990D             LDR      R1,[SP, #+52]
   \   00000078   0x.... 0x....      BL       WIDGET__Init
    307              CHECKBOX_INIT_ID(pObj);
    308              /* init member variables */
    309              pObj->Props = CHECKBOX__DefaultProps;
   \   0000007C   0xF106 0x0028      ADD      R0,R6,#+40
   \   00000080   0x4621             MOV      R1,R4
   \   00000082   0x2228             MOVS     R2,#+40
   \   00000084   0x.... 0x....      BL       __aeabi_memcpy4
    310              pObj->NumStates   = 2; /* Default behaviour is 2 states: checked and unchecked */
   \   00000088   0x2002             MOVS     R0,#+2
   \   0000008A   0xF886 0x0050      STRB     R0,[R6, #+80]
    311            } else {
    312              GUI_DEBUG_ERROROUT_IF(hObj==0, "CHECKBOX_Create failed")
    313            }
    314            WM_UNLOCK();
    315            return hObj;
   \                     ??CHECKBOX_CreateEx_4: (+1)
   \   0000008E   0x4628             MOV      R0,R5
   \   00000090   0xB004             ADD      SP,SP,#+16
   \   00000092   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    316          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     CHECKBOX__DefaultProps

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x........         DC32     _CHECKBOX_Callback

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>`:
   \   00000000   0x0000             DC16 0
   \   00000002   0x00 0x00          DC8 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
    317          
    318          #else                            /* Avoid problems with empty object modules */
    319            void CHECKBOX_C(void);
    320            void CHECKBOX_C(void) {}
    321          #endif  /* #if GUI_WINSUPPORT */
    322          
    323          
    324          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   CHECKBOX_CreateEx
        40   -> GUI_ALLOC_h2p
        40   -> WIDGET_GetDefaultEffect
        40   -> WIDGET__Init
        40   -> WM_CreateWindowAsChild
        40   -> __aeabi_memcpy4
      16   _CHECKBOX_Callback
        16   -> GUI_ALLOC_h2p
        16   -> WIDGET_HandleActive
         0   -> WM_DefaultProc
        16   -> _OnKey
        16   -> _OnTouch
         0   -> _Paint
      16   _OnKey
         0   -> WM_InvalidateWindow
        16   -> WM__IsEnabled
      24   _OnTouch
         0   -> GUI_StoreKey
        24   -> WM_HasCaptured
        24   -> WM_InvalidateWindow
        24   -> WM_NotifyParent
        24   -> WM_SetCapture
      48   _Paint
        48   -> GUI_ALLOC_h2p
        48   -> GUI_Clear
        48   -> GUI_DispStringInRect
        48   -> GUI_DrawBitmap
        48   -> GUI_GetFontSizeY
        48   -> GUI_GetStringDistX
        48   -> GUI_SetFont
        48   -> GUI_SetTextMode
        48   -> LCD_SetBkColor
        48   -> LCD_SetColor
        48   -> WIDGET__DrawFocusRect
        48   -> WIDGET__EFFECT_DrawDownRect
        48   -> WIDGET__GetBkColor
        48   -> WM_GetClientRect
        48   -> WM_GetHasTrans
        48   -> WM_SetUserClipRect
        48   -> WM__IsEnabled


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       8  ?<Constant {0}>
       4  ??DataTable1
       4  ??DataTable1_1
     150  CHECKBOX_CreateEx
      40  CHECKBOX__DefaultProps
      88  _CHECKBOX_Callback
      64  _OnKey
     114  _OnTouch
     420  _Paint

 
  40 bytes in section .data
 852 bytes in section .text
 
 852 bytes of CODE memory
  40 bytes of DATA memory

Errors: none
Warnings: none
