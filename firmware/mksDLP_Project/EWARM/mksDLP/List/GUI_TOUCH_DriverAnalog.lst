###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  10:58:19
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Core\GUI_TOUCH_DriverAnalog.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Core\GUI_TOUCH_DriverAnalog.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\GUI_TOUCH_DriverAnalog.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\GUI_TOUCH_DriverAnalog.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Core\GUI_TOUCH_DriverAnalog.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              µC/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : GUITOUCH.C
     16          Purpose     : Touch screen manager
     17          ----------------------------------------------------------------------
     18          This module handles the touch screen. It is configured in the file
     19          GUITouch.conf.h (Should be located in the Config\ directory).
     20          ----------------------------------------------------------------------
     21          */
     22          
     23          #include <stdio.h>
     24          #include <stdlib.h>
     25          #include <string.h>
     26          #include "LCD_Private.h"      /* private modul definitions & config */
     27          #include "GUI_Protected.h"
     28          
     29          /* Generate code only if configuration says so ! */
     30          #if GUI_SUPPORT_TOUCH
     31          
     32          #include "GUITouchConf.h"    /* Located in GUIx, will include GUITouchConf.h */
     33          
     34          /*********************************************************************
     35          *
     36          *       Defines, config defaults
     37          *
     38          **********************************************************************
     39          */
     40          
     41          #ifndef GUI_TOUCH_AD_LEFT         /* max value returned by AD-converter */
     42            #define GUI_TOUCH_AD_LEFT 30   
     43          #endif
     44          
     45          #ifndef GUI_TOUCH_AD_RIGHT        /* min value returned by AD-converter */
     46            #define GUI_TOUCH_AD_RIGHT 220    
     47          #endif
     48          
     49          #ifndef GUI_TOUCH_AD_TOP          /* max value returned by AD-converter */
     50            #define GUI_TOUCH_AD_TOP 30
     51          #endif
     52          
     53          #ifndef GUI_TOUCH_AD_BOTTOM       /* min value returned by AD-converter */
     54            #define GUI_TOUCH_AD_BOTTOM 220
     55          #endif
     56          
     57          #ifndef GUI_TOUCH_SWAP_XY         /* Is XY of touch swapped ? */
     58            #define GUI_TOUCH_SWAP_XY 0
     59          #endif
     60          
     61          #ifndef GUI_TOUCH_MIRROR_X
     62            #define GUI_TOUCH_MIRROR_X 0
     63          #endif
     64          
     65          #ifndef GUI_TOUCH_MIRROR_Y
     66            #define GUI_TOUCH_MIRROR_Y 0
     67          #endif
     68          
     69          #ifndef GUI_TOUCH_YSIZE
     70            #define GUI_TOUCH_YSIZE LCD_YSIZE
     71          #endif
     72          
     73          #ifndef GUI_TOUCH_XSIZE
     74            #define GUI_TOUCH_XSIZE LCD_XSIZE
     75          #endif
     76          
     77          /*********************************************************************
     78          *
     79          *       Types
     80          *
     81          **********************************************************************
     82          */
     83          
     84          typedef struct {int Min; int Max; } tMinMax;
     85          
     86          /*********************************************************************
     87          *
     88          *       Static data
     89          *
     90          **********************************************************************
     91          */
     92          

   \                                 In section .data, align 4
     93          static int xPhys, yPhys;
     94          
     95          static tMinMax xyMinMax[2] = {
   \                     xyMinMax:
   \   00000000   0x00000168         DC32 360, 3960, 100, 4000
   \              0x00000F78   
   \              0x00000064   
   \              0x00000FA0   
   \   00000010   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000014   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000018   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000001C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000020   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000024   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
     96          #if ((GUI_TOUCH_SWAP_XY==0) && (GUI_TOUCH_MIRROR_X==0)) || ((GUI_TOUCH_SWAP_XY) && (GUI_TOUCH_MIRROR_Y==0))
     97            { GUI_TOUCH_AD_LEFT, GUI_TOUCH_AD_RIGHT },
     98          #else
     99            { GUI_TOUCH_AD_RIGHT, GUI_TOUCH_AD_LEFT },
    100          #endif
    101          #if ((GUI_TOUCH_SWAP_XY==0) && (GUI_TOUCH_MIRROR_Y==0)) || ((GUI_TOUCH_SWAP_XY) && (GUI_TOUCH_MIRROR_X==0))
    102            { GUI_TOUCH_AD_TOP,  GUI_TOUCH_AD_BOTTOM }
    103          #else
    104            { GUI_TOUCH_AD_BOTTOM,  GUI_TOUCH_AD_TOP }
    105          #endif
    106          };
    107          
    108          #ifndef WIN32
    109          static int xMin;
    110          static int xMax;
    111          static int yMin;
    112          static int yMax;
    113          #endif
    114          
    115          /*********************************************************************
    116          *
    117          *       Static code
    118          *
    119          **********************************************************************
    120          */
    121          /*********************************************************************
    122          *
    123          *       _AD2X
    124          *
    125          * Purpose:
    126          *   Convert physical value into (logical) coordinates.
    127          */
    128          #ifndef WIN32

   \                                 In section .text, align 2, keep-with-next
    129          static int _AD2X(int adx) {
    130            I32 r = adx - xyMinMax[GUI_COORD_X].Min;
    131            r *= GUI_TOUCH_XSIZE - 1;
    132            return r / (xyMinMax[GUI_COORD_X].Max - xyMinMax[GUI_COORD_X].Min);    
   \                     _AD2X: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable9
   \   00000002   0x680A             LDR      R2,[R1, #+0]
   \   00000004   0x1A80             SUBS     R0,R0,R2
   \   00000006   0xF240 0x13DF      MOVW     R3,#+479
   \   0000000A   0x4358             MULS     R0,R3,R0
   \   0000000C   0x6849             LDR      R1,[R1, #+4]
   \   0000000E   0x1A89             SUBS     R1,R1,R2
   \   00000010   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000014   0x4770             BX       LR               ;; return
    133          }
    134          
    135          /*********************************************************************
    136          *
    137          *       _AD2Y
    138          *
    139          * Purpose:
    140          *   Convert physical value into (logical) coordinates.
    141          */

   \                                 In section .text, align 2, keep-with-next
    142          static int _AD2Y(int ady) {
    143            I32 r = ady - xyMinMax[GUI_COORD_Y].Min;
    144            r *= GUI_TOUCH_YSIZE - 1;
    145            return GUI_TOUCH_YSIZE -  r/(xyMinMax[GUI_COORD_Y].Max - xyMinMax[GUI_COORD_Y].Min);    
   \                     _AD2Y: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable9
   \   00000002   0x688A             LDR      R2,[R1, #+8]
   \   00000004   0x1A80             SUBS     R0,R0,R2
   \   00000006   0xF240 0x133F      MOVW     R3,#+319
   \   0000000A   0x4358             MULS     R0,R3,R0
   \   0000000C   0x68C9             LDR      R1,[R1, #+12]
   \   0000000E   0x1A89             SUBS     R1,R1,R2
   \   00000010   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000014   0xF5C0 0x70A0      RSB      R0,R0,#+320
   \   00000018   0x4770             BX       LR               ;; return
    146          }
    147          #endif
    148          
    149          /*********************************************************************
    150          *
    151          *       _Log2Phys
    152          */

   \                                 In section .text, align 2, keep-with-next
    153          static int _Log2Phys(int l, I32 l0, I32 l1, I32 p0, I32 p1) {
   \                     _Log2Phys: (+1)
   \   00000000   0xB410             PUSH     {R4}
    154            return p0+ ((p1 - p0) * (l - l0)) / (l1 - l0);
   \   00000002   0x9C01             LDR      R4,[SP, #+4]
   \   00000004   0x1AE4             SUBS     R4,R4,R3
   \   00000006   0x1A40             SUBS     R0,R0,R1
   \   00000008   0x4360             MULS     R0,R0,R4
   \   0000000A   0x1A51             SUBS     R1,R2,R1
   \   0000000C   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000010   0x18C0             ADDS     R0,R0,R3
   \   00000012   0xBC10             POP      {R4}
   \   00000014   0x4770             BX       LR               ;; return
    155          }
    156          
    157          /*********************************************************************
    158          *
    159          *       _StoreUnstable
    160          */

   \                                 In section .text, align 2, keep-with-next
    161          static void _StoreUnstable(int x, int y) {
   \                     _StoreUnstable: (+1)
   \   00000000   0xB418             PUSH     {R3,R4}
    162            static int _xLast = -1;
    163            static int _yLast = -1;
    164            int xOut, yOut;
    165          
    166            if ((x != -1) && (y != -1) && (_xLast != -1) && (_yLast != -1)) {
   \   00000002   0xF110 0x0F01      CMN      R0,#+1
   \   00000006   0xD00B             BEQ.N    ??_StoreUnstable_0
   \   00000008   0xF111 0x0F01      CMN      R1,#+1
   \   0000000C   0xD008             BEQ.N    ??_StoreUnstable_0
   \   0000000E   0x....             LDR.N    R4,??DataTable9_1
   \   00000010   0x6823             LDR      R3,[R4, #+0]
   \   00000012   0xF113 0x0F01      CMN      R3,#+1
   \   00000016   0xD003             BEQ.N    ??_StoreUnstable_0
   \   00000018   0x6862             LDR      R2,[R4, #+4]
   \   0000001A   0xF112 0x0F01      CMN      R2,#+1
   \   0000001E   0xD102             BNE.N    ??_StoreUnstable_1
    167              xOut = _xLast;    
    168              yOut = _yLast;    
    169            } else {
    170              xOut = -1;
   \                     ??_StoreUnstable_0: (+1)
   \   00000020   0xF04F 0x33FF      MOV      R3,#-1
    171              yOut = -1;    
   \   00000024   0x461A             MOV      R2,R3
    172            }
    173            _xLast = x;
   \                     ??_StoreUnstable_1: (+1)
   \   00000026   0x....             LDR.N    R4,??DataTable9_1
   \   00000028   0x6020             STR      R0,[R4, #+0]
    174            _yLast = y;
   \   0000002A   0x6061             STR      R1,[R4, #+4]
    175            GUI_TOUCH_StoreUnstable(xOut, yOut);
   \   0000002C   0x4611             MOV      R1,R2
   \   0000002E   0x4618             MOV      R0,R3
   \   00000030   0xBC14             POP      {R2,R4}
   \   00000032   0x.... 0x....      B.W      GUI_TOUCH_StoreUnstable
    176          }

   \                                 In section .data, align 4
   \                     ??_xLast:
   \   00000000   0xFFFFFFFF         DC32 -1
   \   00000004   0xFFFFFFFF         DC32 -1
    177          /*********************************************************************
    178          *
    179          *       Public code
    180          *
    181          **********************************************************************
    182          */
    183          /*********************************************************************
    184          *
    185          *       GUI_TOUCH_GetxPhys
    186          */

   \                                 In section .text, align 2, keep-with-next
    187          int  GUI_TOUCH_GetxPhys(void) {
    188            return xPhys;
   \                     GUI_TOUCH_GetxPhys: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable9
   \   00000002   0x6900             LDR      R0,[R0, #+16]
   \   00000004   0x4770             BX       LR               ;; return
    189          }
    190          
    191          /*********************************************************************
    192          *
    193          *       GUI_TOUCH_GetyPhys
    194          */

   \                                 In section .text, align 2, keep-with-next
    195          int  GUI_TOUCH_GetyPhys(void) {
    196            return yPhys;
   \                     GUI_TOUCH_GetyPhys: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable9
   \   00000002   0x6940             LDR      R0,[R0, #+20]
   \   00000004   0x4770             BX       LR               ;; return
    197          }
    198          
    199          /*********************************************************************
    200          *
    201          *       GUI_TOUCH_SetDefaultCalibration
    202          */

   \                                 In section .text, align 2, keep-with-next
    203          void GUI_TOUCH_SetDefaultCalibration(void) {
    204            xyMinMax[0].Min = GUI_TOUCH_AD_LEFT;
   \                     GUI_TOUCH_SetDefaultCalibration: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable9
   \   00000002   0xF44F 0x71B4      MOV      R1,#+360
   \   00000006   0x6001             STR      R1,[R0, #+0]
    205            xyMinMax[0].Max = GUI_TOUCH_AD_RIGHT;
   \   00000008   0xF640 0x7178      MOVW     R1,#+3960
   \   0000000C   0x6041             STR      R1,[R0, #+4]
    206            xyMinMax[1].Min = GUI_TOUCH_AD_TOP;
   \   0000000E   0x2164             MOVS     R1,#+100
   \   00000010   0x6081             STR      R1,[R0, #+8]
    207            xyMinMax[1].Max = GUI_TOUCH_AD_BOTTOM;
   \   00000012   0xF44F 0x617A      MOV      R1,#+4000
   \   00000016   0x60C1             STR      R1,[R0, #+12]
    208          }
   \   00000018   0x4770             BX       LR               ;; return
    209          
    210          /*********************************************************************
    211          *
    212          *       GUI_TOUCH_Calibrate
    213          */

   \                                 In section .text, align 2, keep-with-next
    214          int GUI_TOUCH_Calibrate(int Coord, int Log0, int Log1, int Phys0, int Phys1) {
   \                     GUI_TOUCH_Calibrate: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4616             MOV      R6,R2
   \   0000000C   0x461F             MOV      R7,R3
    215            int l0 = 0;
    216            int l1 = (Coord == GUI_COORD_X) ? LCD_XSIZE - 1 : LCD_YSIZE - 1;
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD102             BNE.N    ??GUI_TOUCH_Calibrate_0
   \   00000012   0xF240 0x19DF      MOVW     R9,#+479
   \   00000016   0xE001             B.N      ??GUI_TOUCH_Calibrate_1
   \                     ??GUI_TOUCH_Calibrate_0: (+1)
   \   00000018   0xF240 0x193F      MOVW     R9,#+319
   \                     ??GUI_TOUCH_Calibrate_1: (+1)
   \   0000001C   0xF8DD 0x8028      LDR      R8,[SP, #+40]
    217            if (labs(Phys0 - Phys1) < 20) {
   \   00000020   0xEBA7 0x0008      SUB      R0,R7,R8
   \   00000024   0x.... 0x....      BL       labs
   \   00000028   0x2814             CMP      R0,#+20
   \   0000002A   0xDA01             BGE.N    ??GUI_TOUCH_Calibrate_2
    218              return 1;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xE01E             B.N      ??GUI_TOUCH_Calibrate_3
    219            }
    220            if (labs(Log0 - Log1) < 20) {
   \                     ??GUI_TOUCH_Calibrate_2: (+1)
   \   00000030   0x1BA8             SUBS     R0,R5,R6
   \   00000032   0x.... 0x....      BL       labs
   \   00000036   0x2814             CMP      R0,#+20
   \   00000038   0xDA01             BGE.N    ??GUI_TOUCH_Calibrate_4
    221              return 1;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0xE017             B.N      ??GUI_TOUCH_Calibrate_3
    222            }
    223            xyMinMax[Coord].Min = _Log2Phys(l0, Log0, Log1, Phys0, Phys1);  
   \                     ??GUI_TOUCH_Calibrate_4: (+1)
   \   0000003E   0x.... 0x....      LDR.W    R10,??DataTable9
   \   00000042   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   00000046   0x463B             MOV      R3,R7
   \   00000048   0x4632             MOV      R2,R6
   \   0000004A   0x4629             MOV      R1,R5
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x.... 0x....      BL       _Log2Phys
   \   00000052   0xF84A 0x0034      STR      R0,[R10, R4, LSL #+3]
    224            xyMinMax[Coord].Max = _Log2Phys(l1, Log0, Log1, Phys0, Phys1);
   \   00000056   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   0000005A   0x463B             MOV      R3,R7
   \   0000005C   0x4632             MOV      R2,R6
   \   0000005E   0x4629             MOV      R1,R5
   \   00000060   0x4648             MOV      R0,R9
   \   00000062   0x.... 0x....      BL       _Log2Phys
   \   00000066   0xEB0A 0x01C4      ADD      R1,R10,R4, LSL #+3
   \   0000006A   0x6048             STR      R0,[R1, #+4]
    225            return 0;
   \   0000006C   0x2000             MOVS     R0,#+0
   \                     ??GUI_TOUCH_Calibrate_3: (+1)
   \   0000006E   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
    226          }
    227          
    228          /*********************************************************************
    229          *
    230          *       GUI_TOUCH_GetCalData
    231          */

   \                                 In section .text, align 2, keep-with-next
    232          void GUI_TOUCH_GetCalData(int Coord, int* pMin,int* pMax) {
   \                     GUI_TOUCH_GetCalData: (+1)
   \   00000000   0xB410             PUSH     {R4}
    233            *pMin = xyMinMax[Coord].Min;
   \   00000002   0x....             LDR.N    R3,??DataTable9
   \   00000004   0xF853 0x4030      LDR      R4,[R3, R0, LSL #+3]
   \   00000008   0x600C             STR      R4,[R1, #+0]
    234            *pMax = xyMinMax[Coord].Max; 
   \   0000000A   0xEB03 0x00C0      ADD      R0,R3,R0, LSL #+3
   \   0000000E   0x6840             LDR      R0,[R0, #+4]
   \   00000010   0x6010             STR      R0,[R2, #+0]
    235          }
   \   00000012   0xBC10             POP      {R4}
   \   00000014   0x4770             BX       LR               ;; return
    236            
    237          /*********************************************************************
    238          *
    239          *       GUI_TOUCH_Exec
    240          */

   \                                 In section .text, align 2, keep-with-next
    241          void GUI_TOUCH_Exec(void) {
   \                     GUI_TOUCH_Exec: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    242            #ifndef WIN32
    243            static U8 ReadState;
                             ^
Warning[Pe177]: variable "ReadState" was declared but never referenced
    244            int x,y;
    245            /* calculate Min / Max values */
    246            if (xyMinMax[GUI_COORD_X].Min < xyMinMax[GUI_COORD_X].Max) {
   \   00000002   0x....             LDR.N    R4,??DataTable9
   \   00000004   0x6860             LDR      R0,[R4, #+4]
   \   00000006   0x6821             LDR      R1,[R4, #+0]
   \   00000008   0x4281             CMP      R1,R0
   \   0000000A   0xDA02             BGE.N    ??GUI_TOUCH_Exec_0
    247              xMin = xyMinMax[GUI_COORD_X].Min;
   \   0000000C   0x61A1             STR      R1,[R4, #+24]
    248              xMax = xyMinMax[GUI_COORD_X].Max;
   \   0000000E   0x61E0             STR      R0,[R4, #+28]
   \   00000010   0xE001             B.N      ??GUI_TOUCH_Exec_1
    249            } else {
    250              xMax = xyMinMax[GUI_COORD_X].Min;
   \                     ??GUI_TOUCH_Exec_0: (+1)
   \   00000012   0x61E1             STR      R1,[R4, #+28]
    251              xMin = xyMinMax[GUI_COORD_X].Max;
   \   00000014   0x61A0             STR      R0,[R4, #+24]
    252            }
    253            if (xyMinMax[GUI_COORD_Y].Min < xyMinMax[GUI_COORD_Y].Max) {
   \                     ??GUI_TOUCH_Exec_1: (+1)
   \   00000016   0x68E0             LDR      R0,[R4, #+12]
   \   00000018   0x68A1             LDR      R1,[R4, #+8]
   \   0000001A   0x4281             CMP      R1,R0
   \   0000001C   0xDA02             BGE.N    ??GUI_TOUCH_Exec_2
    254              yMin = xyMinMax[GUI_COORD_Y].Min;
   \   0000001E   0x6221             STR      R1,[R4, #+32]
    255              yMax = xyMinMax[GUI_COORD_Y].Max;
   \   00000020   0x6260             STR      R0,[R4, #+36]
   \   00000022   0xE001             B.N      ??GUI_TOUCH_Exec_3
    256            } else {
    257              yMax = xyMinMax[GUI_COORD_Y].Min;
   \                     ??GUI_TOUCH_Exec_2: (+1)
   \   00000024   0x6261             STR      R1,[R4, #+36]
    258              yMin = xyMinMax[GUI_COORD_Y].Max;
   \   00000026   0x6220             STR      R0,[R4, #+32]
    259            }
    260          
    261          
    262            #if 0
    263            /* Execute the state machine which reads the touch */
    264            switch (ReadState) {
    265            case 0:
    266              yPhys = TOUCH_X_MeasureY();
    267              TOUCH_X_ActivateY();  /* Prepare X- measurement */
    268              ReadState++;
    269              break;
    270            default:
    271              xPhys = TOUCH_X_MeasureX();
    272              TOUCH_X_ActivateX();  /* Prepare Y- measurement */
    273              /* Convert values into logical values */
    274              #if !GUI_TOUCH_SWAP_XY   /* Is X/Y swapped ? */
    275                x = xPhys;
    276                y = yPhys;
    277              #else
    278                x = yPhys;
    279                y = xPhys;
    280              #endif
    281              if ((x < xMin) || (x > xMax)  || (y < yMin) || (y > yMax)) {
    282                _StoreUnstable(-1, -1);
    283              } else {
    284                x = _AD2X(x);
    285                y = _AD2Y(y);
    286                _StoreUnstable(x, y);
    287              }
    288              /* Reset state machine */
    289              ReadState = 0;
    290              break;
    291            }
    292          
    293            #else
    294            	TOUCH_X_MeasureXY((unsigned short *)&xPhys, (unsigned short *)&yPhys);
   \                     ??GUI_TOUCH_Exec_3: (+1)
   \   00000028   0xF104 0x0114      ADD      R1,R4,#+20
   \   0000002C   0xF104 0x0010      ADD      R0,R4,#+16
   \   00000030   0x.... 0x....      BL       GUI_TOUCH_X_MeasureXY
    295          
    296            #if !GUI_TOUCH_SWAP_XY   /* Is X/Y swapped ? */
    297                x = xPhys;
    298                y = yPhys;
    299              #else
    300                x = yPhys;
   \   00000034   0x6965             LDR      R5,[R4, #+20]
    301                y = xPhys;
   \   00000036   0x6926             LDR      R6,[R4, #+16]
    302              #endif
    303              if ((x < xMin) || (x > xMax)  || (y < yMin) || (y > yMax)) {
   \   00000038   0x69A0             LDR      R0,[R4, #+24]
   \   0000003A   0x4285             CMP      R5,R0
   \   0000003C   0xDB08             BLT.N    ??GUI_TOUCH_Exec_4
   \   0000003E   0x69E0             LDR      R0,[R4, #+28]
   \   00000040   0x42A8             CMP      R0,R5
   \   00000042   0xDB05             BLT.N    ??GUI_TOUCH_Exec_4
   \   00000044   0x6A20             LDR      R0,[R4, #+32]
   \   00000046   0x4286             CMP      R6,R0
   \   00000048   0xDB02             BLT.N    ??GUI_TOUCH_Exec_4
   \   0000004A   0x6A60             LDR      R0,[R4, #+36]
   \   0000004C   0x42B0             CMP      R0,R6
   \   0000004E   0xDA05             BGE.N    ??GUI_TOUCH_Exec_5
    304                _StoreUnstable(-1, -1);
   \                     ??GUI_TOUCH_Exec_4: (+1)
   \   00000050   0xF04F 0x31FF      MOV      R1,#-1
   \   00000054   0x4608             MOV      R0,R1
   \   00000056   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000005A   0x....             B.N      _StoreUnstable
    305              } else {
    306                x = _AD2X(x);
   \                     ??GUI_TOUCH_Exec_5: (+1)
   \   0000005C   0x4628             MOV      R0,R5
   \   0000005E   0x.... 0x....      BL       _AD2X
   \   00000062   0x4605             MOV      R5,R0
    307                y = _AD2Y(y);
   \   00000064   0x4630             MOV      R0,R6
   \   00000066   0x.... 0x....      BL       _AD2Y
   \   0000006A   0x4606             MOV      R6,R0
    308                _StoreUnstable(x, y);
   \   0000006C   0x4631             MOV      R1,R6
   \   0000006E   0x4628             MOV      R0,R5
   \   00000070   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000074   0x....             B.N      _StoreUnstable
    309              }
    310            #endif
    311            
    312            #endif /* WIN32 */
    313          }
    314          

   \                                 In section .text, align 2, keep-with-next
    315          void setTouchBound(int x0, int x1, int y0, int y1 )
    316          {
   \                     setTouchBound: (+1)
   \   00000000   0xB410             PUSH     {R4}
    317          	//if(x0 < x1)
    318          	{
    319          		xyMinMax[GUI_COORD_X].Min = x0;
   \   00000002   0x....             LDR.N    R4,??DataTable9
   \   00000004   0x6020             STR      R0,[R4, #+0]
    320          		xyMinMax[GUI_COORD_X].Max = x1;
   \   00000006   0x6061             STR      R1,[R4, #+4]
    321          	}
    322          /*	else
    323          	{
    324          		xyMinMax[GUI_COORD_X].Min = x1;
    325          		xyMinMax[GUI_COORD_X].Max = x0;
    326          	}
    327          
    328          	if(y0 < y1)*/
    329          	{
    330          		xyMinMax[GUI_COORD_Y].Min = y0;
   \   00000008   0x60A2             STR      R2,[R4, #+8]
    331          		xyMinMax[GUI_COORD_Y].Max = y1;
   \   0000000A   0x60E3             STR      R3,[R4, #+12]
    332          	}
    333          	/*else
    334          	{
    335          		xyMinMax[GUI_COORD_Y].Min = y1;
    336          		xyMinMax[GUI_COORD_Y].Max = y0;
    337          	}*/
    338          	
    339          	
    340          	
    341          }
   \   0000000C   0xBC10             POP      {R4}
   \   0000000E   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     xyMinMax

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x........         DC32     ??_xLast
    342          
    343          
    344          #else
    345          
    346          void GUI_TOUCH_DriverAnalog_C(void);  /* Avoid "no prototype" warnings */
    347          void GUI_TOUCH_DriverAnalog_C(void) {}
    348          
    349          #endif    /* defined(GUI_SUPPORT_TOUCH) && GUI_SUPPORT_TOUCH */
    350          
    351          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   GUI_TOUCH_Calibrate
        40   -> _Log2Phys
        40   -> labs
      16   GUI_TOUCH_Exec
        16   -> GUI_TOUCH_X_MeasureXY
        16   -> _AD2X
        16   -> _AD2Y
         0   -> _StoreUnstable
       4   GUI_TOUCH_GetCalData
       0   GUI_TOUCH_GetxPhys
       0   GUI_TOUCH_GetyPhys
       0   GUI_TOUCH_SetDefaultCalibration
       0   _AD2X
       0   _AD2Y
       4   _Log2Phys
       8   _StoreUnstable
         0   -> GUI_TOUCH_StoreUnstable
       4   setTouchBound


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
     114  GUI_TOUCH_Calibrate
     118  GUI_TOUCH_Exec
      22  GUI_TOUCH_GetCalData
       6  GUI_TOUCH_GetxPhys
       6  GUI_TOUCH_GetyPhys
      26  GUI_TOUCH_SetDefaultCalibration
      22  _AD2X
      26  _AD2Y
      22  _Log2Phys
      54  _StoreUnstable
       8  _xLast
          _yLast
      16  setTouchBound
      40  xyMinMax
          xPhys
          yPhys
          xMin
          xMax
          yMin
          yMax

 
  48 bytes in section .data
 440 bytes in section .text
 
 440 bytes of CODE memory
  48 bytes of DATA memory

Errors: none
Warnings: 1
