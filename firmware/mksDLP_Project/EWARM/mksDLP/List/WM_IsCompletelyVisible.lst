###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  10:59:32
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\WM\WM_IsCompletelyVisible.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\WM\WM_IsCompletelyVisible.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\WM_IsCompletelyVisible.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\WM_IsCompletelyVisible.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\WM\WM_IsCompletelyVisible.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              µC/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : WM_IsCompletelyVisible.c
     16          Purpose     : Windows manager, implementation of said function
     17          ----------------------------------------------------------------------
     18          */
     19          
     20          #include "WM_Intern.h"
     21          
     22          #if GUI_WINSUPPORT    /* If 0, WM will not generate any code */
     23          
     24          /*********************************************************************
     25          *
     26          *       Static code
     27          *
     28          **********************************************************************
     29          */
     30          
     31          
     32          /*********************************************************************
     33          *
     34          *       _IsEqualRect
     35          *
     36          */

   \                                 In section .text, align 2, keep-with-next
     37          static char _CompareRect(const GUI_RECT * pRect0, const GUI_RECT * pRect1 ) {
     38            if (pRect0->x0 != pRect1->x0) {
   \                     _CompareRect: (+1)
   \   00000000   0xF9B0 0x2000      LDRSH    R2,[R0, #+0]
   \   00000004   0xF9B1 0x3000      LDRSH    R3,[R1, #+0]
   \   00000008   0x429A             CMP      R2,R3
   \   0000000A   0xD001             BEQ.N    ??_CompareRect_0
     39              return 1;                          /* Not equal */
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x4770             BX       LR
     40            }
     41            if (pRect0->x1 != pRect1->x1) {
   \                     ??_CompareRect_0: (+1)
   \   00000010   0xF9B0 0x2004      LDRSH    R2,[R0, #+4]
   \   00000014   0xF9B1 0x3004      LDRSH    R3,[R1, #+4]
   \   00000018   0x429A             CMP      R2,R3
   \   0000001A   0xD001             BEQ.N    ??_CompareRect_1
     42              return 1;                          /* Not equal */
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x4770             BX       LR
     43            }
     44            if (pRect0->y0 != pRect1->y0) {
   \                     ??_CompareRect_1: (+1)
   \   00000020   0xF9B0 0x2002      LDRSH    R2,[R0, #+2]
   \   00000024   0xF9B1 0x3002      LDRSH    R3,[R1, #+2]
   \   00000028   0x429A             CMP      R2,R3
   \   0000002A   0xD001             BEQ.N    ??_CompareRect_2
     45              return 1;                          /* Not equal */
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x4770             BX       LR
     46            }
     47            if (pRect0->y1 != pRect1->y1) {
   \                     ??_CompareRect_2: (+1)
   \   00000030   0xF9B0 0x0006      LDRSH    R0,[R0, #+6]
   \   00000034   0xF9B1 0x1006      LDRSH    R1,[R1, #+6]
   \   00000038   0x4288             CMP      R0,R1
   \   0000003A   0xD001             BEQ.N    ??_CompareRect_3
     48              return 1;                          /* Not equal */
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x4770             BX       LR
     49            }
     50            return 0;                            /* Equal */
   \                     ??_CompareRect_3: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x4770             BX       LR               ;; return
     51          }
     52          
     53          /*********************************************************************
     54          *
     55          *        _WindowSiblingsOverlapRect
     56          *
     57          */

   \                                 In section .text, align 2, keep-with-next
     58          static char _WindowSiblingsOverlapRect(WM_HWIN iWin, GUI_RECT* pRect) {
   \                     _WindowSiblingsOverlapRect: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0xE001             B.N      ??_WindowSiblingsOverlapRect_0
     59            WM_Obj* pWin;
     60            for (; iWin; iWin = pWin->hNext) { 
   \                     ??_WindowSiblingsOverlapRect_1: (+1)
   \   00000006   0xF9B5 0x001A      LDRSH    R0,[R5, #+26]
   \                     ??_WindowSiblingsOverlapRect_0: (+1)
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD00D             BEQ.N    ??_WindowSiblingsOverlapRect_2
     61              int Status = (pWin = WM_H2P(iWin))->Status;
   \   0000000E   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000012   0x4605             MOV      R5,R0
     62              /* Check if this window affects us at all */    
     63              if (Status & WM_SF_ISVIS) {
   \   00000014   0x7F28             LDRB     R0,[R5, #+28]
   \   00000016   0x0780             LSLS     R0,R0,#+30
   \   00000018   0xD5F5             BPL.N    ??_WindowSiblingsOverlapRect_1
     64                /* Check if this window affects us at all */    
     65                if (GUI_RectsIntersect(pRect, &pWin->Rect)) {
   \   0000001A   0x4629             MOV      R1,R5
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       GUI_RectsIntersect
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD0EF             BEQ.N    ??_WindowSiblingsOverlapRect_1
     66                  return 1;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xBD32             POP      {R1,R4,R5,PC}
     67                }
     68              }
     69            }
     70            return 0;
   \                     ??_WindowSiblingsOverlapRect_2: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     71          }
     72          
     73          
     74          /*********************************************************************
     75          *
     76          *       _HasOverlap
     77          */

   \                                 In section .text, align 2, keep-with-next
     78          static int _HasOverlap(WM_Obj * pWin, GUI_RECT * pRect) {
   \                     _HasOverlap: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
     79            WM_Obj * pParent;
     80            WM_HMEM hParent;
     81            /* Step 1:
     82             Check if there are any visible children. If this is so, then the
     83             window has an overlap.
     84             */
     85            /* Check all children */
     86            if (_WindowSiblingsOverlapRect(pWin->hFirstChild, pRect)) {
   \   00000006   0xF9B4 0x0018      LDRSH    R0,[R4, #+24]
   \   0000000A   0x.... 0x....      BL       _WindowSiblingsOverlapRect
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD110             BNE.N    ??_HasOverlap_0
     87              return 1;
     88            }
     89          
     90            /* STEP 2:
     91                 Find out the max. height (r.y1) if we are at the left border.
     92                 Since we are using the same height for all IVRs at the same y0,
     93                 we do this only for the leftmost one.
     94            */
     95          
     96            /* Iterate over all windows which are above */
     97            /* Check all siblings above (Iterate over Parents and top siblings (hNext) */
     98            for (hParent = pWin->hParent; hParent; hParent = pParent->hParent) {
   \   00000012   0xF9B4 0x0016      LDRSH    R0,[R4, #+22]
   \   00000016   0xE001             B.N      ??_HasOverlap_1
   \                     ??_HasOverlap_2: (+1)
   \   00000018   0xF9B4 0x0016      LDRSH    R0,[R4, #+22]
   \                     ??_HasOverlap_1: (+1)
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD00B             BEQ.N    ??_HasOverlap_3
     99              pParent = WM_H2P(hParent);
   \   00000020   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000024   0x4604             MOV      R4,R0
    100              if (_WindowSiblingsOverlapRect(pParent->hNext, pRect)) {
   \   00000026   0x4629             MOV      R1,R5
   \   00000028   0xF9B4 0x001A      LDRSH    R0,[R4, #+26]
   \   0000002C   0x.... 0x....      BL       _WindowSiblingsOverlapRect
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD0F1             BEQ.N    ??_HasOverlap_2
    101                return 1;
   \                     ??_HasOverlap_0: (+1)
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0xBD32             POP      {R1,R4,R5,PC}
    102              }
    103            }
    104            return 0;
   \                     ??_HasOverlap_3: (+1)
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    105          }
    106          
    107          /*********************************************************************
    108          *
    109          *       _IsCompletelyVisible
    110          *
    111          */

   \                                 In section .text, align 2, keep-with-next
    112          static char _IsCompletelyVisible(WM_HWIN hWin) {
   \                     _IsCompletelyVisible: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x4604             MOV      R4,R0
    113            WM_Obj * pWin;
    114            GUI_RECT Rect;
    115          
    116            pWin = WM_H2P(hWin);
   \   00000006   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000000A   0x4605             MOV      R5,R0
    117            Rect = pWin->Rect;
   \   0000000C   0xA800             ADD      R0,SP,#+0
   \   0000000E   0x4629             MOV      R1,R5
   \   00000010   0x2208             MOVS     R2,#+8
   \   00000012   0x.... 0x....      BL       __aeabi_memcpy
    118            if (WM__ClipAtParentBorders(&Rect, hWin) == 0) {
   \   00000016   0x4621             MOV      R1,R4
   \   00000018   0xA800             ADD      R0,SP,#+0
   \   0000001A   0x.... 0x....      BL       WM__ClipAtParentBorders
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD101             BNE.N    ??_IsCompletelyVisible_0
    119              return 0;                 /* Nothing is left */
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xBD3E             POP      {R1-R5,PC}
    120            }
    121            /* Check if the window is still the original one */
    122            if (_CompareRect(&Rect, &pWin->Rect)) {
   \                     ??_IsCompletelyVisible_0: (+1)
   \   00000026   0x4629             MOV      R1,R5
   \   00000028   0xA800             ADD      R0,SP,#+0
   \   0000002A   0x.... 0x....      BL       _CompareRect
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD001             BEQ.N    ??_IsCompletelyVisible_1
    123              return 0;                 /* Not completely visible */
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xBD3E             POP      {R1-R5,PC}
    124            }
    125            /* Now the difficult part ...
    126               Find the rectangles.
    127            */
    128            if (_HasOverlap(pWin, &Rect)) {
   \                     ??_IsCompletelyVisible_1: (+1)
   \   00000036   0xA900             ADD      R1,SP,#+0
   \   00000038   0x4628             MOV      R0,R5
   \   0000003A   0x.... 0x....      BL       _HasOverlap
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD001             BEQ.N    ??_IsCompletelyVisible_2
    129              return 0;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xBD3E             POP      {R1-R5,PC}
    130            }
    131            return 1;                   /* Is completely visible */
   \                     ??_IsCompletelyVisible_2: (+1)
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0xBD3E             POP      {R1-R5,PC}       ;; return
    132          }
    133          
    134          
    135          /*********************************************************************
    136          *
    137          *       Public code
    138          *
    139          **********************************************************************
    140          */
    141          /*********************************************************************
    142          *
    143          *       WM_IsCompletelyVisible
    144          *
    145          */

   \                                 In section .text, align 2, keep-with-next
    146          char WM_IsCompletelyVisible(WM_HWIN hWin) {
   \                     WM_IsCompletelyVisible: (+1)
   \   00000000   0x4601             MOV      R1,R0
    147            int r = 0;
   \   00000002   0x2000             MOVS     R0,#+0
    148            if (hWin) {
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD001             BEQ.N    ??WM_IsCompletelyVisible_0
    149              WM_LOCK();
    150              r = _IsCompletelyVisible(hWin);
   \   00000008   0x4608             MOV      R0,R1
   \   0000000A   0x....             B.N      _IsCompletelyVisible
    151              WM_UNLOCK();
    152            }
    153            return r;
   \                     ??WM_IsCompletelyVisible_0: (+1)
   \   0000000C   0x4770             BX       LR               ;; return
    154          }
    155          
    156          #else
    157            void WM_IsCompletelyVisible_C(void) {} /* avoid empty object files */
    158          #endif
    159          
    160          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   WM_IsCompletelyVisible
         0   -> _IsCompletelyVisible
       0   _CompareRect
      16   _HasOverlap
        16   -> GUI_ALLOC_h2p
        16   -> _WindowSiblingsOverlapRect
      24   _IsCompletelyVisible
        24   -> GUI_ALLOC_h2p
        24   -> WM__ClipAtParentBorders
        24   -> _CompareRect
        24   -> _HasOverlap
        24   -> __aeabi_memcpy
      16   _WindowSiblingsOverlapRect
        16   -> GUI_ALLOC_h2p
        16   -> GUI_RectsIntersect


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      14  WM_IsCompletelyVisible
      68  _CompareRect
      60  _HasOverlap
      74  _IsCompletelyVisible
      46  _WindowSiblingsOverlapRect

 
 262 bytes in section .text
 
 262 bytes of CODE memory

Errors: none
Warnings: none
