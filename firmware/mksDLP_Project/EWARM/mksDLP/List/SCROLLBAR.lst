###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  10:59:22
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Widget\SCROLLBAR.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Widget\SCROLLBAR.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\SCROLLBAR.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\SCROLLBAR.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Widget\SCROLLBAR.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              µC/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : SCROLLBAR.c
     16          Purpose     : Implementation of scrollbar widget
     17          ---------------------------END-OF-HEADER------------------------------
     18          */
     19          
     20          #include <stdlib.h>
     21          #include <string.h>
     22          #include "GUI_Protected.h"
     23          #include "SCROLLBAR_Private.h"
     24          #include "WIDGET.h"
     25          #include "WM_Intern.h"
     26          
     27          #if GUI_WINSUPPORT
     28          
     29          /*********************************************************************
     30          *
     31          *       Private config defaults
     32          *
     33          **********************************************************************
     34          */
     35          
     36          /* Support for 3D effects */
     37          #ifndef SCROLLBAR_USE_3D
     38            #define SCROLLBAR_USE_3D 1
     39          #endif
     40          
     41          /* Define colors */
     42          #ifndef SCROLLBAR_BKCOLOR0_DEFAULT
     43            #define SCROLLBAR_BKCOLOR0_DEFAULT 0x808080
     44          #endif
     45          
     46          #ifndef SCROLLBAR_BKCOLOR1_DEFAULT
     47            #define SCROLLBAR_BKCOLOR1_DEFAULT GUI_BLACK
     48          #endif
     49          
     50          #ifndef SCROLLBAR_COLOR0_DEFAULT
     51            #define SCROLLBAR_COLOR0_DEFAULT 0xc0c0c0
     52          #endif
     53          
     54          #ifndef SCROLLBAR_COLOR1_DEFAULT
     55            #define SCROLLBAR_COLOR1_DEFAULT GUI_BLACK
     56          #endif
     57          
     58          #ifndef SCROLLBAR_DEFAULT_WIDTH
     59            #define SCROLLBAR_DEFAULT_WIDTH 11
     60          #endif
     61          
     62          /*********************************************************************
     63          *
     64          *       Module internal data
     65          *
     66          **********************************************************************
     67          */
     68          

   \                                 In section .data, align 4
     69          GUI_COLOR SCROLLBAR__aDefaultBkColor[2] = {SCROLLBAR_BKCOLOR0_DEFAULT, SCROLLBAR_BKCOLOR1_DEFAULT};
     70          GUI_COLOR SCROLLBAR__aDefaultColor[2]   = {SCROLLBAR_COLOR0_DEFAULT, SCROLLBAR_COLOR1_DEFAULT};
     71          I16       SCROLLBAR__DefaultWidth       =  SCROLLBAR_DEFAULT_WIDTH;
   \                     SCROLLBAR__DefaultWidth:
   \   00000000   0x000B             DC16 11
   \   00000002   0x00 0x00          DC8 0, 0
   \                     SCROLLBAR__aDefaultBkColor:
   \   00000004   0x00808080         DC32 8421504, 0
   \              0x00000000   
   \                     SCROLLBAR__aDefaultColor:
   \   0000000C   0x00C0C0C0         DC32 12632256, 0
   \              0x00000000   
     72          
     73          /*********************************************************************
     74          *
     75          *       Static routines
     76          *
     77          **********************************************************************
     78          */
     79          /*********************************************************************
     80          *
     81          *       _GetArrowSize
     82          *
     83          */

   \                                 In section .text, align 2, keep-with-next
     84          static int _GetArrowSize(SCROLLBAR_Obj* pObj) {
   \                     _GetArrowSize: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
     85            unsigned int r;
     86            unsigned int xSize = WIDGET__GetXSize(&pObj->Widget);
   \   00000004   0x.... 0x....      BL       WIDGET__GetXSize
   \   00000008   0x4605             MOV      R5,R0
     87            unsigned int ySize = WIDGET__GetYSize(&pObj->Widget);
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       WIDGET__GetYSize
     88            r = ySize/2 + 5;
   \   00000010   0x0840             LSRS     R0,R0,#+1
   \   00000012   0x1D40             ADDS     R0,R0,#+5
     89            if (r > xSize-5)
   \   00000014   0x1F69             SUBS     R1,R5,#+5
   \   00000016   0x4281             CMP      R1,R0
   \   00000018   0xD200             BCS.N    ??_GetArrowSize_0
     90              r = xSize-5;
   \   0000001A   0x4608             MOV      R0,R1
     91            return r;
   \                     ??_GetArrowSize_0: (+1)
   \   0000001C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     92          }
     93          
     94          /*********************************************************************
     95          *
     96          *       _WIDGET__RECT2VRECT
     97          *
     98          * Purpose:
     99          *   Convert rectangle in real coordinates into virtual coordinates
    100          *
    101          * Add. info:
    102          *   This function could eventualy be made none-static and move into
    103          *   a module of its own.
    104          */

   \                                 In section .text, align 2, keep-with-next
    105          static void _WIDGET__RECT2VRECT(const WIDGET* pWidget, GUI_RECT* pRect) {
    106            if (pWidget->State & WIDGET_STATE_VERTICAL) {
   \                     _WIDGET__RECT2VRECT: (+1)
   \   00000000   0xF890 0x2026      LDRB     R2,[R0, #+38]
   \   00000004   0x0712             LSLS     R2,R2,#+28
   \   00000006   0xD400             BMI.N    ??_WIDGET__RECT2VRECT_0
   \   00000008   0x4770             BX       LR
    107              int xSize = pWidget->Win.Rect.x1 - pWidget->Win.Rect.x0 + 1;
   \                     ??_WIDGET__RECT2VRECT_0: (+1)
   \   0000000A   0xB410             PUSH     {R4}
   \   0000000C   0xF9B0 0x2004      LDRSH    R2,[R0, #+4]
   \   00000010   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000014   0x1A10             SUBS     R0,R2,R0
   \   00000016   0x1C40             ADDS     R0,R0,#+1
    108              int x0, x1;
    109              x0 = pRect->x0;
   \   00000018   0xF9B1 0x2000      LDRSH    R2,[R1, #+0]
    110              x1 = pRect->x1;
   \   0000001C   0xF9B1 0x3004      LDRSH    R3,[R1, #+4]
    111              pRect->x0 = pRect->y0;
   \   00000020   0x884C             LDRH     R4,[R1, #+2]
   \   00000022   0x800C             STRH     R4,[R1, #+0]
    112              pRect->x1 = pRect->y1;
   \   00000024   0x88CC             LDRH     R4,[R1, #+6]
   \   00000026   0x808C             STRH     R4,[R1, #+4]
    113              pRect->y1 = xSize - 1 - x0;
   \   00000028   0x1E40             SUBS     R0,R0,#+1
   \   0000002A   0x1A82             SUBS     R2,R0,R2
   \   0000002C   0x80CA             STRH     R2,[R1, #+6]
    114              pRect->y0 = xSize - 1 - x1;
   \   0000002E   0x1AC0             SUBS     R0,R0,R3
   \   00000030   0x8048             STRH     R0,[R1, #+2]
    115            }
    116          }
   \   00000032   0xBC10             POP      {R4}
   \   00000034   0x4770             BX       LR               ;; return
    117          
    118          /*********************************************************************
    119          *
    120          *       _CalcPositions
    121          *
    122          *  Calculates all positions required for drawing or for mouse / touch
    123          *  evaluation.
    124          */

   \                                 In section .text, align 2, keep-with-next
    125          static void _CalcPositions(SCROLLBAR_Obj* pObj, SCROLLBAR_POSITIONS* pPos) {
   \                     _CalcPositions: (+1)
   \   00000000   0xE92D 0x47FF      PUSH     {R0-R10,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460C             MOV      R4,R1
    126            int xSizeArrow, xSize, xSizeMoveable, ThumbSize, NumItems, xSizeThumbArea;
    127            WM_HWIN hWin;
    128            GUI_RECT r, rSub;
    129            int x0, y0;
    130            r = pObj->Widget.Win.Rect;
   \   00000008   0xA800             ADD      R0,SP,#+0
   \   0000000A   0x4629             MOV      R1,R5
   \   0000000C   0x2208             MOVS     R2,#+8
   \   0000000E   0x.... 0x....      BL       __aeabi_memcpy
    131            x0 = r.x0;
   \   00000012   0xF9BD 0x6000      LDRSH    R6,[SP, #+0]
    132            y0 = r.y0;
   \   00000016   0xF9BD 0x7002      LDRSH    R7,[SP, #+2]
    133            pPos->x1  = (pObj->Widget.State & WIDGET_STATE_VERTICAL) ? r.y1 : r.x1;
   \   0000001A   0xF895 0x0026      LDRB     R0,[R5, #+38]
   \   0000001E   0x0700             LSLS     R0,R0,#+28
   \   00000020   0xD502             BPL.N    ??_CalcPositions_0
   \   00000022   0xF9BD 0x0006      LDRSH    R0,[SP, #+6]
   \   00000026   0xE001             B.N      ??_CalcPositions_1
   \                     ??_CalcPositions_0: (+1)
   \   00000028   0xF9BD 0x0004      LDRSH    R0,[SP, #+4]
   \                     ??_CalcPositions_1: (+1)
   \   0000002C   0x61A0             STR      R0,[R4, #+24]
    134            /* Subtract the rectangle of the other scrollbar (if existing and visible) */
    135            if (pObj->Widget.Id == GUI_ID_HSCROLL) {
   \   0000002E   0xF9B5 0x0024      LDRSH    R0,[R5, #+36]
   \   00000032   0x28FF             CMP      R0,#+255
   \   00000034   0xD113             BNE.N    ??_CalcPositions_2
    136              hWin = WM_GetScrollbarV(pObj->Widget.Win.hParent);
   \   00000036   0xF9B5 0x0016      LDRSH    R0,[R5, #+22]
   \   0000003A   0x.... 0x....      BL       WM_GetScrollbarV
    137              if (hWin) {
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD00D             BEQ.N    ??_CalcPositions_2
    138                WM_GetWindowRectEx(hWin, &rSub);
   \   00000042   0xA902             ADD      R1,SP,#+8
   \   00000044   0x.... 0x....      BL       WM_GetWindowRectEx
    139                if (r.x1 == rSub.x1) {
   \   00000048   0xF9BD 0x0004      LDRSH    R0,[SP, #+4]
   \   0000004C   0xF9BD 0x100C      LDRSH    R1,[SP, #+12]
   \   00000050   0x4288             CMP      R0,R1
   \   00000052   0xD104             BNE.N    ??_CalcPositions_2
    140                  r.x1 = rSub.x0 -1;
   \   00000054   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   00000058   0x1E40             SUBS     R0,R0,#+1
   \   0000005A   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    141                }
    142              }
    143            }
    144            if (pObj->Widget.Id == GUI_ID_VSCROLL) {
   \                     ??_CalcPositions_2: (+1)
   \   0000005E   0xF9B5 0x0024      LDRSH    R0,[R5, #+36]
   \   00000062   0x28FE             CMP      R0,#+254
   \   00000064   0xD113             BNE.N    ??_CalcPositions_3
    145              hWin = WM_GetScrollbarH(pObj->Widget.Win.hParent);
   \   00000066   0xF9B5 0x0016      LDRSH    R0,[R5, #+22]
   \   0000006A   0x.... 0x....      BL       WM_GetScrollbarH
    146              if (hWin) {
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD00D             BEQ.N    ??_CalcPositions_3
    147                WM_GetWindowRectEx(hWin, &rSub);
   \   00000072   0xA902             ADD      R1,SP,#+8
   \   00000074   0x.... 0x....      BL       WM_GetWindowRectEx
    148                if (r.y1 == rSub.y1) {
   \   00000078   0xF9BD 0x0006      LDRSH    R0,[SP, #+6]
   \   0000007C   0xF9BD 0x100E      LDRSH    R1,[SP, #+14]
   \   00000080   0x4288             CMP      R0,R1
   \   00000082   0xD104             BNE.N    ??_CalcPositions_3
    149                  r.y1 = rSub.y0 -1;
   \   00000084   0xF8BD 0x000A      LDRH     R0,[SP, #+10]
   \   00000088   0x1E40             SUBS     R0,R0,#+1
   \   0000008A   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    150                }
    151              }
    152            }
    153            /* Convert coordinates of this window */
    154            GUI_MoveRect(&r, -x0, -y0);
   \                     ??_CalcPositions_3: (+1)
   \   0000008E   0x427A             RSBS     R2,R7,#+0
   \   00000090   0x4271             RSBS     R1,R6,#+0
   \   00000092   0xA800             ADD      R0,SP,#+0
   \   00000094   0x.... 0x....      BL       GUI_MoveRect
    155            /* Convert real into virtual coordinates */
    156            _WIDGET__RECT2VRECT(&pObj->Widget, &r);
   \   00000098   0xA900             ADD      R1,SP,#+0
   \   0000009A   0x4628             MOV      R0,R5
   \   0000009C   0x.... 0x....      BL       _WIDGET__RECT2VRECT
    157            NumItems      = pObj->NumItems;
   \   000000A0   0x6BAE             LDR      R6,[R5, #+56]
    158            xSize         = r.x1 - r.x0 + 1;
   \   000000A2   0xF9BD 0x0004      LDRSH    R0,[SP, #+4]
   \   000000A6   0xF9BD 0x1000      LDRSH    R1,[SP, #+0]
   \   000000AA   0x1A40             SUBS     R0,R0,R1
   \   000000AC   0x1C47             ADDS     R7,R0,#+1
    159            xSizeArrow    = _GetArrowSize(pObj);
   \   000000AE   0x4628             MOV      R0,R5
   \   000000B0   0x.... 0x....      BL       _GetArrowSize
   \   000000B4   0x4680             MOV      R8,R0
    160            xSizeThumbArea= xSize - 2 * xSizeArrow;     /* Number of pixels available for thumb and movement */
   \   000000B6   0xEBA7 0x0A48      SUB      R10,R7,R8, LSL #+1
    161            ThumbSize     = GUI__DivideRound(xSizeThumbArea * pObj->PageSize, NumItems);
   \   000000BA   0x4631             MOV      R1,R6
   \   000000BC   0x6C28             LDR      R0,[R5, #+64]
   \   000000BE   0xFB00 0xF00A      MUL      R0,R0,R10
   \   000000C2   0x.... 0x....      BL       GUI__DivideRound
    162            if (ThumbSize < 4) {
   \   000000C6   0x2804             CMP      R0,#+4
   \   000000C8   0xDA00             BGE.N    ??_CalcPositions_4
    163              ThumbSize = 4;
   \   000000CA   0x2004             MOVS     R0,#+4
    164            }
    165            if (ThumbSize > xSizeThumbArea) {
   \                     ??_CalcPositions_4: (+1)
   \   000000CC   0x46D1             MOV      R9,R10
   \   000000CE   0x4582             CMP      R10,R0
   \   000000D0   0xDD00             BLE.N    ??_CalcPositions_5
   \   000000D2   0x4681             MOV      R9,R0
    166              ThumbSize = xSizeThumbArea;
    167            }
    168            xSizeMoveable = xSizeThumbArea - ThumbSize;
   \                     ??_CalcPositions_5: (+1)
   \   000000D4   0xEBAA 0x0A09      SUB      R10,R10,R9
    169            pPos->x0_LeftArrow  = r.x0;
   \   000000D8   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \   000000DC   0x6020             STR      R0,[R4, #+0]
    170            pPos->x1_LeftArrow  = xSizeArrow - 1;
   \   000000DE   0xF1A8 0x0001      SUB      R0,R8,#+1
   \   000000E2   0x6060             STR      R0,[R4, #+4]
    171            pPos->x1_RightArrow = xSize - 1;
   \   000000E4   0x1E78             SUBS     R0,R7,#+1
   \   000000E6   0x6160             STR      R0,[R4, #+20]
    172            pPos->x0_RightArrow = xSize - xSizeArrow;
   \   000000E8   0xEBA7 0x0008      SUB      R0,R7,R8
   \   000000EC   0x6120             STR      R0,[R4, #+16]
    173            pPos->x0_Thumb      = pPos->x1_LeftArrow + 1+ GUI__DivideRound(xSizeMoveable * pObj->v, NumItems - pObj->PageSize);
   \   000000EE   0x6C28             LDR      R0,[R5, #+64]
   \   000000F0   0x1A31             SUBS     R1,R6,R0
   \   000000F2   0x6BE8             LDR      R0,[R5, #+60]
   \   000000F4   0xFB00 0xF00A      MUL      R0,R0,R10
   \   000000F8   0x.... 0x....      BL       GUI__DivideRound
   \   000000FC   0x6861             LDR      R1,[R4, #+4]
   \   000000FE   0x1840             ADDS     R0,R0,R1
   \   00000100   0x1C40             ADDS     R0,R0,#+1
   \   00000102   0x60A0             STR      R0,[R4, #+8]
    174            pPos->x1_Thumb      = pPos->x0_Thumb + ThumbSize - 1;
   \   00000104   0x4448             ADD      R0,R9,R0
   \   00000106   0x1E40             SUBS     R0,R0,#+1
   \   00000108   0x60E0             STR      R0,[R4, #+12]
    175            pPos->xSizeMoveable = xSizeMoveable;
   \   0000010A   0xF8C4 0xA01C      STR      R10,[R4, #+28]
    176            pPos->ThumbSize     = ThumbSize;
   \   0000010E   0xF8C4 0x9020      STR      R9,[R4, #+32]
    177          }
   \   00000112   0xE8BD 0x87FF      POP      {R0-R10,PC}      ;; return
    178          
    179          /*********************************************************************
    180          *
    181          *       _DrawTriangle
    182          */

   \                                 In section .text, align 2, keep-with-next
    183          static void _DrawTriangle(WIDGET* pWidget, int x, int y, int Size, int Inc) {
   \                     _DrawTriangle: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x4615             MOV      R5,R2
   \   00000006   0x461E             MOV      R6,R3
   \   00000008   0x9F06             LDR      R7,[SP, #+24]
    184            if (pWidget->State & WIDGET_STATE_VERTICAL) {
   \   0000000A   0xF890 0x0026      LDRB     R0,[R0, #+38]
   \   0000000E   0x0700             LSLS     R0,R0,#+28
   \   00000010   0xD510             BPL.N    ??_DrawTriangle_0
    185              for (; Size >= 0; Size--, x += Inc) {
   \                     ??_DrawTriangle_1: (+1)
   \   00000012   0x2E00             CMP      R6,#+0
   \   00000014   0xD410             BMI.N    ??_DrawTriangle_2
    186                GUI_DrawHLine(x, y - Size, y + Size);
   \   00000016   0x1972             ADDS     R2,R6,R5
   \   00000018   0x1BA9             SUBS     R1,R5,R6
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       GUI_DrawHLine
    187              }
   \   00000020   0x1E76             SUBS     R6,R6,#+1
   \   00000022   0x193C             ADDS     R4,R7,R4
   \   00000024   0xE7F5             B.N      ??_DrawTriangle_1
    188            } else {
    189              for (; Size >= 0; Size--, x += Inc) {
    190                GUI_DrawVLine(x, y - Size, y + Size);
   \                     ??_DrawTriangle_3: (+1)
   \   00000026   0x1972             ADDS     R2,R6,R5
   \   00000028   0x1BA9             SUBS     R1,R5,R6
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       GUI_DrawVLine
    191              }
   \   00000030   0x1E76             SUBS     R6,R6,#+1
   \   00000032   0x193C             ADDS     R4,R7,R4
   \                     ??_DrawTriangle_0: (+1)
   \   00000034   0x2E00             CMP      R6,#+0
   \   00000036   0xD5F6             BPL.N    ??_DrawTriangle_3
    192            }
    193          }
   \                     ??_DrawTriangle_2: (+1)
   \   00000038   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    194          
    195          /*********************************************************************
    196          *
    197          *       _Paint
    198          */

   \                                 In section .text, align 2, keep-with-next
    199          static void _Paint(SCROLLBAR_Obj* pObj) {
   \                     _Paint: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB08E             SUB      SP,SP,#+56
   \   00000004   0x4604             MOV      R4,R0
    200            int ArrowSize, ArrowOff;
    201            SCROLLBAR_POSITIONS Pos;
    202            GUI_RECT r, rClient;
    203            /*
    204              Get / calc position info
    205            */
    206            _CalcPositions(pObj, &Pos);
   \   00000006   0xA905             ADD      R1,SP,#+20
   \   00000008   0x.... 0x....      BL       _CalcPositions
    207            WIDGET__GetClientRect(&pObj->Widget, &rClient);
   \   0000000C   0xA903             ADD      R1,SP,#+12
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       WIDGET__GetClientRect
    208            r = rClient;
   \   00000014   0xE9DD 0x0103      LDRD     R0,R1,[SP, #+12]
   \   00000018   0xE9CD 0x0101      STRD     R0,R1,[SP, #+4]
    209            ArrowSize = ((r.y1 - r.y0) /3) - 1;
   \   0000001C   0xF9BD 0x000A      LDRSH    R0,[SP, #+10]
   \   00000020   0xF9BD 0x1006      LDRSH    R1,[SP, #+6]
   \   00000024   0x1A40             SUBS     R0,R0,R1
   \   00000026   0x2103             MOVS     R1,#+3
   \   00000028   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000002C   0x1E45             SUBS     R5,R0,#+1
    210            ArrowOff = 3 + ArrowSize+ ArrowSize/3;
   \   0000002E   0x4608             MOV      R0,R1
   \   00000030   0xFB95 0xF0F0      SDIV     R0,R5,R0
   \   00000034   0x1940             ADDS     R0,R0,R5
   \   00000036   0x1CC6             ADDS     R6,R0,#+3
    211            /*
    212              Draw left Arrow
    213            */
    214            LCD_SetColor(pObj->aColor[0]);
   \   00000038   0x6B20             LDR      R0,[R4, #+48]
   \   0000003A   0x.... 0x....      BL       LCD_SetColor
    215            r = rClient;
   \   0000003E   0xE9DD 0x0103      LDRD     R0,R1,[SP, #+12]
   \   00000042   0xE9CD 0x0101      STRD     R0,R1,[SP, #+4]
    216            r.x0 = Pos.x0_LeftArrow;
   \   00000046   0x9805             LDR      R0,[SP, #+20]
   \   00000048   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    217            r.x1 = Pos.x1_LeftArrow;
   \   0000004C   0x9806             LDR      R0,[SP, #+24]
   \   0000004E   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    218            WIDGET__FillRectEx(&pObj->Widget, &r);
   \   00000052   0xA901             ADD      R1,SP,#+4
   \   00000054   0x4620             MOV      R0,R4
   \   00000056   0x.... 0x....      BL       WIDGET__FillRectEx
    219            LCD_SetColor(pObj->aBkColor[1]);
   \   0000005A   0x6AE0             LDR      R0,[R4, #+44]
   \   0000005C   0x.... 0x....      BL       LCD_SetColor
    220            _DrawTriangle(&pObj->Widget, r.x0 + ArrowOff, (r.y1 - r.y0) >> 1, ArrowSize, -1);
   \   00000060   0xF04F 0x30FF      MOV      R0,#-1
   \   00000064   0x9000             STR      R0,[SP, #+0]
   \   00000066   0x462B             MOV      R3,R5
   \   00000068   0xF9BD 0x000A      LDRSH    R0,[SP, #+10]
   \   0000006C   0xF9BD 0x1006      LDRSH    R1,[SP, #+6]
   \   00000070   0x1A40             SUBS     R0,R0,R1
   \   00000072   0x1042             ASRS     R2,R0,#+1
   \   00000074   0xF9BD 0x0004      LDRSH    R0,[SP, #+4]
   \   00000078   0xFA06 0xF180      SXTAH    R1,R6,R0
   \   0000007C   0x4620             MOV      R0,R4
   \   0000007E   0x.... 0x....      BL       _DrawTriangle
    221            WIDGET__EFFECT_DrawUpRect(&pObj->Widget, &r);
   \   00000082   0xA901             ADD      R1,SP,#+4
   \   00000084   0x4620             MOV      R0,R4
   \   00000086   0x.... 0x....      BL       WIDGET__EFFECT_DrawUpRect
    222            /*
    223              Draw the thumb area which is not covered by the thumb
    224            */
    225            LCD_SetColor(pObj->aBkColor[0]);
   \   0000008A   0x6AA0             LDR      R0,[R4, #+40]
   \   0000008C   0x.... 0x....      BL       LCD_SetColor
    226            r.x0 = Pos.x1_LeftArrow + 1;
   \   00000090   0x9806             LDR      R0,[SP, #+24]
   \   00000092   0x1C40             ADDS     R0,R0,#+1
   \   00000094   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    227            r.x1 = Pos.x0_Thumb - 1;
   \   00000098   0x9807             LDR      R0,[SP, #+28]
   \   0000009A   0x1E40             SUBS     R0,R0,#+1
   \   0000009C   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    228            WIDGET__FillRectEx(&pObj->Widget, &r);
   \   000000A0   0xA901             ADD      R1,SP,#+4
   \   000000A2   0x4620             MOV      R0,R4
   \   000000A4   0x.... 0x....      BL       WIDGET__FillRectEx
    229            r = rClient;
   \   000000A8   0xE9DD 0x0103      LDRD     R0,R1,[SP, #+12]
   \   000000AC   0xE9CD 0x0101      STRD     R0,R1,[SP, #+4]
    230            r.x0 = Pos.x1_Thumb + 1;
   \   000000B0   0x9808             LDR      R0,[SP, #+32]
   \   000000B2   0x1C40             ADDS     R0,R0,#+1
   \   000000B4   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    231            r.x1 = Pos.x0_RightArrow - 1;
   \   000000B8   0x9809             LDR      R0,[SP, #+36]
   \   000000BA   0x1E40             SUBS     R0,R0,#+1
   \   000000BC   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    232            WIDGET__FillRectEx(&pObj->Widget, &r);
   \   000000C0   0xA901             ADD      R1,SP,#+4
   \   000000C2   0x4620             MOV      R0,R4
   \   000000C4   0x.... 0x....      BL       WIDGET__FillRectEx
    233            /*
    234              Draw Thumb
    235            */
    236            r = rClient;
   \   000000C8   0xE9DD 0x0103      LDRD     R0,R1,[SP, #+12]
   \   000000CC   0xE9CD 0x0101      STRD     R0,R1,[SP, #+4]
    237            r.x0 = Pos.x0_Thumb;
   \   000000D0   0x9807             LDR      R0,[SP, #+28]
   \   000000D2   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    238            r.x1 = Pos.x1_Thumb;
   \   000000D6   0x9808             LDR      R0,[SP, #+32]
   \   000000D8   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    239            LCD_SetColor(pObj->aColor[0]);
   \   000000DC   0x6B20             LDR      R0,[R4, #+48]
   \   000000DE   0x.... 0x....      BL       LCD_SetColor
    240            WIDGET__FillRectEx(&pObj->Widget, &r);
   \   000000E2   0xA901             ADD      R1,SP,#+4
   \   000000E4   0x4620             MOV      R0,R4
   \   000000E6   0x.... 0x....      BL       WIDGET__FillRectEx
    241            WIDGET__EFFECT_DrawUpRect(&pObj->Widget, &r);
   \   000000EA   0xA901             ADD      R1,SP,#+4
   \   000000EC   0x4620             MOV      R0,R4
   \   000000EE   0x.... 0x....      BL       WIDGET__EFFECT_DrawUpRect
    242            /*
    243              Draw right Arrow
    244            */
    245            LCD_SetColor(pObj->aColor[0]);
   \   000000F2   0x6B20             LDR      R0,[R4, #+48]
   \   000000F4   0x.... 0x....      BL       LCD_SetColor
    246            r.x0 = Pos.x0_RightArrow;
   \   000000F8   0x9809             LDR      R0,[SP, #+36]
   \   000000FA   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    247            r.x1 = Pos.x1_RightArrow;
   \   000000FE   0x980A             LDR      R0,[SP, #+40]
   \   00000100   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    248            WIDGET__FillRectEx(&pObj->Widget, &r);
   \   00000104   0xA901             ADD      R1,SP,#+4
   \   00000106   0x4620             MOV      R0,R4
   \   00000108   0x.... 0x....      BL       WIDGET__FillRectEx
    249            LCD_SetColor(pObj->aBkColor[1]);
   \   0000010C   0x6AE0             LDR      R0,[R4, #+44]
   \   0000010E   0x.... 0x....      BL       LCD_SetColor
    250            _DrawTriangle(&pObj->Widget, r.x1 - ArrowOff, (r.y1 - r.y0) >> 1, ArrowSize, 1);
   \   00000112   0x2001             MOVS     R0,#+1
   \   00000114   0x9000             STR      R0,[SP, #+0]
   \   00000116   0x462B             MOV      R3,R5
   \   00000118   0xF9BD 0x000A      LDRSH    R0,[SP, #+10]
   \   0000011C   0xF9BD 0x1006      LDRSH    R1,[SP, #+6]
   \   00000120   0x1A40             SUBS     R0,R0,R1
   \   00000122   0x1042             ASRS     R2,R0,#+1
   \   00000124   0xF9BD 0x0008      LDRSH    R0,[SP, #+8]
   \   00000128   0x1B81             SUBS     R1,R0,R6
   \   0000012A   0x4620             MOV      R0,R4
   \   0000012C   0x.... 0x....      BL       _DrawTriangle
    251            WIDGET__EFFECT_DrawUpRect(&pObj->Widget, &r);
   \   00000130   0xA901             ADD      R1,SP,#+4
   \   00000132   0x4620             MOV      R0,R4
   \   00000134   0x.... 0x....      BL       WIDGET__EFFECT_DrawUpRect
    252            /*
    253              Draw overlap area (if any ...)
    254            */
    255            if (Pos.x1_RightArrow != Pos.x1) {
   \   00000138   0x980A             LDR      R0,[SP, #+40]
   \   0000013A   0x990B             LDR      R1,[SP, #+44]
   \   0000013C   0x4288             CMP      R0,R1
   \   0000013E   0xD00C             BEQ.N    ??_Paint_0
    256              r.x0 = Pos.x1_RightArrow + 1;
   \   00000140   0x1C40             ADDS     R0,R0,#+1
   \   00000142   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    257              r.x1 = Pos.x1;
   \   00000146   0x980B             LDR      R0,[SP, #+44]
   \   00000148   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    258              LCD_SetColor(pObj->aColor[0]);
   \   0000014C   0x6B20             LDR      R0,[R4, #+48]
   \   0000014E   0x.... 0x....      BL       LCD_SetColor
    259              WIDGET__FillRectEx(&pObj->Widget, &r);
   \   00000152   0xA901             ADD      R1,SP,#+4
   \   00000154   0x4620             MOV      R0,R4
   \   00000156   0x.... 0x....      BL       WIDGET__FillRectEx
    260            }
    261          }
   \                     ??_Paint_0: (+1)
   \   0000015A   0xB00E             ADD      SP,SP,#+56
   \   0000015C   0xBD70             POP      {R4-R6,PC}       ;; return
    262          
    263          /*********************************************************************
    264          *
    265          *       _ScrollbarPressed
    266          */

   \                                 In section .text, align 2, keep-with-next
    267          static void _ScrollbarPressed(SCROLLBAR_Handle hObj, SCROLLBAR_Obj* pObj) {
   \                     _ScrollbarPressed: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    268            WIDGET_OrState(hObj, SCROLLBAR_STATE_PRESSED);
   \   00000006   0xF44F 0x7180      MOV      R1,#+256
   \   0000000A   0x.... 0x....      BL       WIDGET_OrState
    269            if (pObj->Widget.Win.Status & WM_SF_ISVIS) {
   \   0000000E   0x7F28             LDRB     R0,[R5, #+28]
   \   00000010   0x0780             LSLS     R0,R0,#+30
   \   00000012   0xD505             BPL.N    ??_ScrollbarPressed_0
    270              WM_NotifyParent(hObj, WM_NOTIFICATION_CLICKED);
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   0000001C   0x.... 0x....      B.W      WM_NotifyParent
    271            }
    272          }
   \                     ??_ScrollbarPressed_0: (+1)
   \   00000020   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    273          
    274          /*********************************************************************
    275          *
    276          *       _ScrollbarReleased
    277          */

   \                                 In section .text, align 2, keep-with-next
    278          static void _ScrollbarReleased(SCROLLBAR_Handle hObj, SCROLLBAR_Obj* pObj) {
   \                     _ScrollbarReleased: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    279            WIDGET_AndState(hObj, SCROLLBAR_STATE_PRESSED);
   \   00000006   0xF44F 0x7180      MOV      R1,#+256
   \   0000000A   0x.... 0x....      BL       WIDGET_AndState
    280            if (pObj->Widget.Win.Status & WM_SF_ISVIS) {
   \   0000000E   0x7F28             LDRB     R0,[R5, #+28]
   \   00000010   0x0780             LSLS     R0,R0,#+30
   \   00000012   0xD505             BPL.N    ??_ScrollbarReleased_0
    281              WM_NotifyParent(hObj, WM_NOTIFICATION_RELEASED);
   \   00000014   0x2102             MOVS     R1,#+2
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   0000001C   0x.... 0x....      B.W      WM_NotifyParent
    282            }
    283          }
   \                     ??_ScrollbarReleased_0: (+1)
   \   00000020   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    284          
    285          /*********************************************************************
    286          *
    287          *       _OnTouch
    288          */

   \                                 In section .text, align 2, keep-with-next
    289          static void _OnTouch(SCROLLBAR_Handle hObj, SCROLLBAR_Obj* pObj, WM_MESSAGE*pMsg) {
   \                     _OnTouch: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    290            SCROLLBAR_POSITIONS Pos;
    291            GUI_PID_STATE* pState = (GUI_PID_STATE*)pMsg->Data.p;
   \   00000008   0x6897             LDR      R7,[R2, #+8]
    292            if (pMsg->Data.p) {  /* Something happened in our area (pressed or released) */
   \   0000000A   0x2F00             CMP      R7,#+0
   \   0000000C   0xD050             BEQ.N    ??_OnTouch_0
    293              if (pState->Pressed) {
   \   0000000E   0x7A38             LDRB     R0,[R7, #+8]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD047             BEQ.N    ??_OnTouch_1
    294                int Sel;
    295                int Range;
    296                int x;
    297                Sel = pObj->v;
   \   00000014   0x6BEE             LDR      R6,[R5, #+60]
    298                _CalcPositions(pObj, &Pos);
   \   00000016   0xA900             ADD      R1,SP,#+0
   \   00000018   0x4628             MOV      R0,R5
   \   0000001A   0x.... 0x....      BL       _CalcPositions
    299                Range = pObj->NumItems - pObj->PageSize;
   \   0000001E   0x6BA8             LDR      R0,[R5, #+56]
   \   00000020   0x6C29             LDR      R1,[R5, #+64]
   \   00000022   0x1A40             SUBS     R0,R0,R1
    300                /* Swap mouse coordinates if necessary */
    301                if (pObj->Widget.State & WIDGET_STATE_VERTICAL) {
   \   00000024   0xF895 0x1026      LDRB     R1,[R5, #+38]
   \   00000028   0x0709             LSLS     R1,R1,#+28
   \   0000002A   0xD503             BPL.N    ??_OnTouch_2
    302                  int t = pState->x;
   \   0000002C   0x6839             LDR      R1,[R7, #+0]
    303                  pState->x = pState->y;
   \   0000002E   0x687A             LDR      R2,[R7, #+4]
   \   00000030   0x603A             STR      R2,[R7, #+0]
    304                  pState->y = t;
   \   00000032   0x6079             STR      R1,[R7, #+4]
    305                }
    306                x = pState->x;
   \                     ??_OnTouch_2: (+1)
   \   00000034   0x683A             LDR      R2,[R7, #+0]
    307                if (x <= Pos.x1_LeftArrow) {         /* left arrow (line left) */
   \   00000036   0x9B01             LDR      R3,[SP, #+4]
   \   00000038   0x4293             CMP      R3,R2
   \   0000003A   0xDB01             BLT.N    ??_OnTouch_3
    308                  Sel--;
   \   0000003C   0x1E76             SUBS     R6,R6,#+1
   \   0000003E   0xE021             B.N      ??_OnTouch_4
    309                } else if (x < Pos.x0_Thumb) {       /* left area  (page left) */
   \                     ??_OnTouch_3: (+1)
   \   00000040   0x9902             LDR      R1,[SP, #+8]
   \   00000042   0x428A             CMP      R2,R1
   \   00000044   0xDA02             BGE.N    ??_OnTouch_5
    310                  Sel -= pObj->PageSize;
   \   00000046   0x6C28             LDR      R0,[R5, #+64]
   \   00000048   0x1A36             SUBS     R6,R6,R0
   \   0000004A   0xE01B             B.N      ??_OnTouch_4
    311                } else if (x <= Pos.x1_Thumb) {      /* Thumb area */
   \                     ??_OnTouch_5: (+1)
   \   0000004C   0x9903             LDR      R1,[SP, #+12]
   \   0000004E   0x4291             CMP      R1,R2
   \   00000050   0xDB0E             BLT.N    ??_OnTouch_6
    312                  if (Pos.xSizeMoveable > 0) {
   \   00000052   0x9907             LDR      R1,[SP, #+28]
   \   00000054   0x2901             CMP      R1,#+1
   \   00000056   0xDB15             BLT.N    ??_OnTouch_4
    313                    x = x - Pos.ThumbSize/2 - Pos.x1_LeftArrow-1;
    314                    Sel = GUI__DivideRound(Range * x, Pos.xSizeMoveable);
   \   00000058   0x9E08             LDR      R6,[SP, #+32]
   \   0000005A   0xEB06 0x76D6      ADD      R6,R6,R6, LSR #+31
   \   0000005E   0xEBA2 0x0266      SUB      R2,R2,R6, ASR #+1
   \   00000062   0x1AD2             SUBS     R2,R2,R3
   \   00000064   0x1E52             SUBS     R2,R2,#+1
   \   00000066   0x4350             MULS     R0,R2,R0
   \   00000068   0x.... 0x....      BL       GUI__DivideRound
   \   0000006C   0x4606             MOV      R6,R0
   \   0000006E   0xE009             B.N      ??_OnTouch_4
    315                  }
    316                } else if (x < Pos.x0_RightArrow) {  /* right area (page right) */
   \                     ??_OnTouch_6: (+1)
   \   00000070   0x9804             LDR      R0,[SP, #+16]
   \   00000072   0x4282             CMP      R2,R0
   \   00000074   0xDA02             BGE.N    ??_OnTouch_7
    317                  Sel += pObj->PageSize;
   \   00000076   0x6C28             LDR      R0,[R5, #+64]
   \   00000078   0x1986             ADDS     R6,R0,R6
   \   0000007A   0xE003             B.N      ??_OnTouch_4
    318                } else  if (x <= Pos.x1_RightArrow) {
   \                     ??_OnTouch_7: (+1)
   \   0000007C   0x9805             LDR      R0,[SP, #+20]
   \   0000007E   0x4290             CMP      R0,R2
   \   00000080   0xDB00             BLT.N    ??_OnTouch_4
    319                  Sel++;
   \   00000082   0x1C76             ADDS     R6,R6,#+1
    320                }
    321                /* WM_SetFocus(hObj); */
    322                WM_SetCapture(hObj, 1);
   \                     ??_OnTouch_4: (+1)
   \   00000084   0x2101             MOVS     R1,#+1
   \   00000086   0x4620             MOV      R0,R4
   \   00000088   0x.... 0x....      BL       WM_SetCapture
    323                SCROLLBAR_SetValue(hObj, Sel);
   \   0000008C   0x4631             MOV      R1,R6
   \   0000008E   0x4620             MOV      R0,R4
   \   00000090   0x.... 0x....      BL       SCROLLBAR_SetValue
    324                if ((pObj->Widget.State & SCROLLBAR_STATE_PRESSED) == 0){   
   \   00000094   0x8CE8             LDRH     R0,[R5, #+38]
   \   00000096   0x05C0             LSLS     R0,R0,#+23
   \   00000098   0xD40A             BMI.N    ??_OnTouch_0
    325                  _ScrollbarPressed(hObj, pObj);
   \   0000009A   0x4629             MOV      R1,R5
   \   0000009C   0x4620             MOV      R0,R4
   \   0000009E   0x.... 0x....      BL       _ScrollbarPressed
   \   000000A2   0xE005             B.N      ??_OnTouch_0
    326                }
    327              } else {
    328                /* React only if button was pressed before ... avoid problems with moving / hiding windows above (such as dropdown) */
    329                if (pObj->Widget.State & SCROLLBAR_STATE_PRESSED) {   
   \                     ??_OnTouch_1: (+1)
   \   000000A4   0x8CE8             LDRH     R0,[R5, #+38]
   \   000000A6   0x05C0             LSLS     R0,R0,#+23
   \   000000A8   0xD502             BPL.N    ??_OnTouch_0
    330                  _ScrollbarReleased(hObj, pObj);
   \   000000AA   0x4620             MOV      R0,R4
   \   000000AC   0x.... 0x....      BL       _ScrollbarReleased
    331                }
    332              }
    333            }
    334          }
   \                     ??_OnTouch_0: (+1)
   \   000000B0   0xB009             ADD      SP,SP,#+36
   \   000000B2   0xBDF0             POP      {R4-R7,PC}       ;; return
    335          
    336          /*********************************************************************
    337          *
    338          *       _OnKey
    339          */

   \                                 In section .text, align 2, keep-with-next
    340          static void  _OnKey(SCROLLBAR_Handle hObj, WM_MESSAGE*pMsg) {
    341            const WM_KEY_INFO* pKeyInfo;
    342            int Key;
    343            pKeyInfo = (const WM_KEY_INFO*)(pMsg->Data.p);
   \                     _OnKey: (+1)
   \   00000000   0x6889             LDR      R1,[R1, #+8]
    344            Key = pKeyInfo->Key;
    345            if (pKeyInfo->PressedCnt > 0) {
   \   00000002   0x684A             LDR      R2,[R1, #+4]
   \   00000004   0x2A01             CMP      R2,#+1
   \   00000006   0xDB07             BLT.N    ??_OnKey_0
    346              switch (Key) {
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x3910             SUBS     R1,R1,#+16
   \   0000000C   0x2901             CMP      R1,#+1
   \   0000000E   0xD904             BLS.N    ??_OnKey_1
   \   00000010   0x1E89             SUBS     R1,R1,#+2
   \   00000012   0x2901             CMP      R1,#+1
   \   00000014   0xD800             BHI.N    ??_OnKey_0
    347                case GUI_KEY_RIGHT:
    348                case GUI_KEY_DOWN:
    349                  SCROLLBAR_Inc(hObj);
   \   00000016   0x....             B.N      SCROLLBAR_Inc
    350                  break;                    /* Send to parent by not doing anything */
    351                case GUI_KEY_LEFT:
    352                case GUI_KEY_UP:
    353                  SCROLLBAR_Dec(hObj);
    354                  break;                    /* Send to parent by not doing anything */
    355                default:
    356                  return;
    357              }
    358            }
    359          }
   \                     ??_OnKey_0: (+1)
   \   00000018   0x4770             BX       LR               ;; return
   \                     ??_OnKey_1: (+1)
   \   0000001A   0x....             B.N      SCROLLBAR_Dec
    360          
    361          /*********************************************************************
    362          *
    363          *       _OnSetScrollState 
    364          */

   \                                 In section .text, align 2, keep-with-next
    365          static void _OnSetScrollState(SCROLLBAR_Handle hObj, SCROLLBAR_Obj* pObj, const WM_SCROLL_STATE* pState) {
   \                     _OnSetScrollState: (+1)
   \   00000000   0xB43C             PUSH     {R2-R5}
    366            if (  (pState->NumItems != pObj->NumItems)
    367                || (pObj->PageSize   != pState->PageSize)
    368                || (pObj->v          != pState->v))
   \   00000002   0x6813             LDR      R3,[R2, #+0]
   \   00000004   0x6B8C             LDR      R4,[R1, #+56]
   \   00000006   0x42A3             CMP      R3,R4
   \   00000008   0xD107             BNE.N    ??_OnSetScrollState_0
   \   0000000A   0x6C0C             LDR      R4,[R1, #+64]
   \   0000000C   0x6895             LDR      R5,[R2, #+8]
   \   0000000E   0x42AC             CMP      R4,R5
   \   00000010   0xD103             BNE.N    ??_OnSetScrollState_0
   \   00000012   0x6BCC             LDR      R4,[R1, #+60]
   \   00000014   0x6855             LDR      R5,[R2, #+4]
   \   00000016   0x42AC             CMP      R4,R5
   \   00000018   0xD007             BEQ.N    ??_OnSetScrollState_1
    369            {
    370              pObj->NumItems = pState->NumItems;
   \                     ??_OnSetScrollState_0: (+1)
   \   0000001A   0x638B             STR      R3,[R1, #+56]
    371              pObj->PageSize = pState->PageSize;
   \   0000001C   0x6893             LDR      R3,[R2, #+8]
   \   0000001E   0x640B             STR      R3,[R1, #+64]
    372              pObj->v        = pState->v;
   \   00000020   0x6852             LDR      R2,[R2, #+4]
   \   00000022   0x63CA             STR      R2,[R1, #+60]
    373              WM_InvalidateWindow(hObj);
   \   00000024   0xBC36             POP      {R1,R2,R4,R5}
   \   00000026   0x.... 0x....      B.W      WM_InvalidateWindow
    374            }
    375          }
   \                     ??_OnSetScrollState_1: (+1)
   \   0000002A   0xBC33             POP      {R0,R1,R4,R5}
   \   0000002C   0x4770             BX       LR               ;; return
    376          
    377          /*********************************************************************
    378          *
    379          *       SCROLLBAR__InvalidatePartner
    380          */

   \                                 In section .text, align 2, keep-with-next
    381          void SCROLLBAR__InvalidatePartner(SCROLLBAR_Handle hObj) {     /* Invalidate the partner, since it is also affected */
   \                     SCROLLBAR__InvalidatePartner: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    382            WM_InvalidateWindow(WM_GetScrollPartner(hObj));
   \   00000004   0x.... 0x....      BL       WM_GetScrollPartner
   \   00000008   0x.... 0x....      BL       WM_InvalidateWindow
    383            WM_SendMessageNoPara(WM_GetParent(hObj), WM_NOTIFY_CLIENTCHANGE);   /* Client area may have changed */
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       WM_GetParent
   \   00000012   0x2125             MOVS     R1,#+37
   \   00000014   0xE8BD 0x4010      POP      {R4,LR}
   \   00000018   0x.... 0x....      B.W      WM_SendMessageNoPara
    384          }
    385          
    386          /*********************************************************************
    387          *
    388          *       _SCROLLBAR_Callback
    389          */

   \                                 In section .text, align 2, keep-with-next
    390          static void _SCROLLBAR_Callback (WM_MESSAGE *pMsg) {
   \                     _SCROLLBAR_Callback: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    391            SCROLLBAR_Handle hObj;
    392            SCROLLBAR_Obj* pObj;
    393            hObj = pMsg->hWin;
   \   00000004   0xF9B4 0x5004      LDRSH    R5,[R4, #+4]
    394            pObj = SCROLLBAR_H2P(hObj);
   \   00000008   0x4628             MOV      R0,R5
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000000E   0x4606             MOV      R6,R0
    395            /* Let widget handle the standard messages */
    396            if (WIDGET_HandleActive(hObj, pMsg) == 0) {
   \   00000010   0x4621             MOV      R1,R4
   \   00000012   0x4628             MOV      R0,R5
   \   00000014   0x.... 0x....      BL       WIDGET_HandleActive
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD034             BEQ.N    ??_SCROLLBAR_Callback_0
    397              return;
    398            }
    399            switch (pMsg->MsgId) {
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x280B             CMP      R0,#+11
   \   00000020   0xD00A             BEQ.N    ??_SCROLLBAR_Callback_1
   \   00000022   0x280C             CMP      R0,#+12
   \   00000024   0xD010             BEQ.N    ??_SCROLLBAR_Callback_2
   \   00000026   0x280E             CMP      R0,#+14
   \   00000028   0xD014             BEQ.N    ??_SCROLLBAR_Callback_3
   \   0000002A   0x280F             CMP      R0,#+15
   \   0000002C   0xD008             BEQ.N    ??_SCROLLBAR_Callback_4
   \   0000002E   0x2823             CMP      R0,#+35
   \   00000030   0xD01B             BEQ.N    ??_SCROLLBAR_Callback_5
   \   00000032   0x2824             CMP      R0,#+36
   \   00000034   0xD013             BEQ.N    ??_SCROLLBAR_Callback_6
   \   00000036   0xE021             B.N      ??_SCROLLBAR_Callback_7
    400            case WM_DELETE:
    401              SCROLLBAR__InvalidatePartner(hObj);
   \                     ??_SCROLLBAR_Callback_1: (+1)
   \   00000038   0x4628             MOV      R0,R5
   \   0000003A   0x.... 0x....      BL       SCROLLBAR__InvalidatePartner
    402              break;
   \   0000003E   0xE01D             B.N      ??_SCROLLBAR_Callback_7
    403            case WM_PAINT:
    404              GUI_DEBUG_LOG("SCROLLBAR: _Callback(WM_PAINT)\n");
    405              _Paint(pObj);
   \                     ??_SCROLLBAR_Callback_4: (+1)
   \   00000040   0x4630             MOV      R0,R6
   \   00000042   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000046   0x....             B.N      _Paint
    406              return;
    407            case WM_TOUCH:
    408              _OnTouch(hObj, pObj, pMsg);
   \                     ??_SCROLLBAR_Callback_2: (+1)
   \   00000048   0x4622             MOV      R2,R4
   \   0000004A   0x4631             MOV      R1,R6
   \   0000004C   0x4628             MOV      R0,R5
   \   0000004E   0x.... 0x....      BL       _OnTouch
    409              break;
   \   00000052   0xE013             B.N      ??_SCROLLBAR_Callback_7
    410            case WM_KEY:
    411              _OnKey(hObj, pMsg);
   \                     ??_SCROLLBAR_Callback_3: (+1)
   \   00000054   0x4621             MOV      R1,R4
   \   00000056   0x4628             MOV      R0,R5
   \   00000058   0x.... 0x....      BL       _OnKey
    412              break;
   \   0000005C   0xE00E             B.N      ??_SCROLLBAR_Callback_7
    413            case WM_SET_SCROLL_STATE:
    414              _OnSetScrollState(hObj, pObj, (const WM_SCROLL_STATE*)pMsg->Data.p);
   \                     ??_SCROLLBAR_Callback_6: (+1)
   \   0000005E   0x68A2             LDR      R2,[R4, #+8]
   \   00000060   0x4631             MOV      R1,R6
   \   00000062   0x4628             MOV      R0,R5
   \   00000064   0x.... 0x....      BL       _OnSetScrollState
    415              break;
   \   00000068   0xE008             B.N      ??_SCROLLBAR_Callback_7
    416            case WM_GET_SCROLL_STATE:
    417              ((WM_SCROLL_STATE*)pMsg->Data.p)->NumItems = pObj->NumItems;
   \                     ??_SCROLLBAR_Callback_5: (+1)
   \   0000006A   0x6BB0             LDR      R0,[R6, #+56]
   \   0000006C   0x68A1             LDR      R1,[R4, #+8]
   \   0000006E   0x6008             STR      R0,[R1, #+0]
    418              ((WM_SCROLL_STATE*)pMsg->Data.p)->PageSize = pObj->PageSize;
   \   00000070   0x6C30             LDR      R0,[R6, #+64]
   \   00000072   0x68A1             LDR      R1,[R4, #+8]
   \   00000074   0x6088             STR      R0,[R1, #+8]
    419              ((WM_SCROLL_STATE*)pMsg->Data.p)->v        = pObj->v;
   \   00000076   0x6BF0             LDR      R0,[R6, #+60]
   \   00000078   0x68A1             LDR      R1,[R4, #+8]
   \   0000007A   0x6048             STR      R0,[R1, #+4]
    420              break;
    421            }
    422            WM_DefaultProc(pMsg);
   \                     ??_SCROLLBAR_Callback_7: (+1)
   \   0000007C   0x4620             MOV      R0,R4
   \   0000007E   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000082   0x.... 0x....      B.W      WM_DefaultProc
   \                     ??_SCROLLBAR_Callback_0: (+1)
   \   00000086   0xBD70             POP      {R4-R6,PC}       ;; return
    423          }
    424          
    425          /*********************************************************************
    426          *
    427          *       Exported routines:  Create
    428          *
    429          **********************************************************************
    430          */
    431          
    432          /* Note: the parameters to a create function may vary.
    433                   Some widgets may have multiple create functions */
    434          
    435          /*********************************************************************
    436          *
    437          *       SCROLLBAR_CreateEx
    438          */

   \                                 In section .text, align 2, keep-with-next
    439          SCROLLBAR_Handle SCROLLBAR_CreateEx(int x0, int y0, int xsize, int ysize, WM_HWIN hParent,
    440                                              int WinFlags, int ExFlags, int Id)
    441          {
   \                     SCROLLBAR_CreateEx: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0xF9BD 0x5028      LDRSH    R5,[SP, #+40]
   \   00000008   0x9C0C             LDR      R4,[SP, #+48]
    442            SCROLLBAR_Handle hObj;
    443            WM_LOCK();
    444            /* Set defaults if necessary */
    445            if ((xsize == 0) && (ysize == 0)) {
   \   0000000A   0xEA53 0x0602      ORRS     R6,R3,R2
   \   0000000E   0xD11A             BNE.N    ??SCROLLBAR_CreateEx_0
    446              GUI_RECT Rect;
    447              WM_GetInsideRectEx(hParent, &Rect);
   \   00000010   0xA900             ADD      R1,SP,#+0
   \   00000012   0x4628             MOV      R0,R5
   \   00000014   0x.... 0x....      BL       WM_GetInsideRectEx
    448              if (ExFlags & SCROLLBAR_CF_VERTICAL) {
   \   00000018   0xF9BD 0x6006      LDRSH    R6,[SP, #+6]
   \   0000001C   0xF9BD 0x7004      LDRSH    R7,[SP, #+4]
   \   00000020   0x....             LDR.N    R0,??DataTable0
   \   00000022   0xF9B0 0x2000      LDRSH    R2,[R0, #+0]
   \   00000026   0x0720             LSLS     R0,R4,#+28
   \   00000028   0xD506             BPL.N    ??SCROLLBAR_CreateEx_1
    449                xsize = SCROLLBAR__DefaultWidth;
    450                x0    = Rect.x1 + 1 - xsize;
   \   0000002A   0x1C78             ADDS     R0,R7,#+1
   \   0000002C   0x1A80             SUBS     R0,R0,R2
    451                y0    = Rect.y0;
   \   0000002E   0xF9BD 0x1002      LDRSH    R1,[SP, #+2]
    452                ysize = Rect.y1 - Rect.y0 + 1;
   \   00000032   0x1A73             SUBS     R3,R6,R1
   \   00000034   0x1C5B             ADDS     R3,R3,#+1
   \   00000036   0xE006             B.N      ??SCROLLBAR_CreateEx_0
    453              } else {
    454                ysize = SCROLLBAR__DefaultWidth;
   \                     ??SCROLLBAR_CreateEx_1: (+1)
   \   00000038   0x4613             MOV      R3,R2
    455                y0    = Rect.y1 + 1 - ysize;
   \   0000003A   0x1C70             ADDS     R0,R6,#+1
   \   0000003C   0x1AC1             SUBS     R1,R0,R3
    456                x0    = Rect.x0;
   \   0000003E   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
    457                xsize = Rect.x1 - Rect.x0 + 1;
   \   00000042   0x1A3A             SUBS     R2,R7,R0
   \   00000044   0x1C52             ADDS     R2,R2,#+1
    458              }
    459            }
    460            /* Create the window */
    461            hObj = WM_CreateWindowAsChild(x0, y0, xsize, ysize, hParent, WinFlags, _SCROLLBAR_Callback,
    462                                          sizeof(SCROLLBAR_Obj) - sizeof(WM_Obj));
   \                     ??SCROLLBAR_CreateEx_0: (+1)
   \   00000046   0x2624             MOVS     R6,#+36
   \   00000048   0x9603             STR      R6,[SP, #+12]
   \   0000004A   0x....             LDR.N    R6,??DataTable0_1
   \   0000004C   0x9602             STR      R6,[SP, #+8]
   \   0000004E   0x9E0B             LDR      R6,[SP, #+44]
   \   00000050   0xB2B6             UXTH     R6,R6
   \   00000052   0x9601             STR      R6,[SP, #+4]
   \   00000054   0x9500             STR      R5,[SP, #+0]
   \   00000056   0x.... 0x....      BL       WM_CreateWindowAsChild
   \   0000005A   0x0005             MOVS     R5,R0
    463            if (hObj) {
   \   0000005C   0xD026             BEQ.N    ??SCROLLBAR_CreateEx_2
    464              SCROLLBAR_Obj* pObj = SCROLLBAR_H2P(hObj);
   \   0000005E   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000062   0x4606             MOV      R6,R0
    465              U16 InitState;
    466              /* Handle SpecialFlags */
    467              InitState = 0;
   \   00000064   0x2200             MOVS     R2,#+0
    468              if (ExFlags & SCROLLBAR_CF_VERTICAL) {
   \   00000066   0x0720             LSLS     R0,R4,#+28
   \   00000068   0xD500             BPL.N    ??SCROLLBAR_CreateEx_3
    469                InitState |= WIDGET_CF_VERTICAL;
   \   0000006A   0x2208             MOVS     R2,#+8
    470              }
    471              if (ExFlags & SCROLLBAR_CF_FOCUSSABLE) {
   \                     ??SCROLLBAR_CreateEx_3: (+1)
   \   0000006C   0x06E0             LSLS     R0,R4,#+27
   \   0000006E   0xD501             BPL.N    ??SCROLLBAR_CreateEx_4
    472                InitState |= WIDGET_STATE_FOCUSSABLE;
   \   00000070   0xF042 0x0210      ORR      R2,R2,#0x10
   \                     ??SCROLLBAR_CreateEx_4: (+1)
   \   00000074   0x990D             LDR      R1,[SP, #+52]
    473              }
    474              if ((Id != GUI_ID_HSCROLL) && (Id != GUI_ID_VSCROLL)) {
   \   00000076   0x29FF             CMP      R1,#+255
   \   00000078   0xD003             BEQ.N    ??SCROLLBAR_CreateEx_5
   \   0000007A   0x29FE             CMP      R1,#+254
   \   0000007C   0xD001             BEQ.N    ??SCROLLBAR_CreateEx_5
    475                InitState |= WIDGET_STATE_FOCUSSABLE;
   \   0000007E   0xF042 0x0210      ORR      R2,R2,#0x10
    476              }
    477              /* init widget specific variables */
    478              WIDGET__Init(&pObj->Widget, Id, InitState);
   \                     ??SCROLLBAR_CreateEx_5: (+1)
   \   00000082   0x4630             MOV      R0,R6
   \   00000084   0x.... 0x....      BL       WIDGET__Init
    479              /* init member variables */
    480              SCROLLBAR_INIT_ID(pObj);
    481              pObj->aBkColor[0]   = SCROLLBAR__aDefaultBkColor[0];
   \   00000088   0x....             LDR.N    R0,??DataTable0
   \   0000008A   0x6841             LDR      R1,[R0, #+4]
   \   0000008C   0x62B1             STR      R1,[R6, #+40]
    482              pObj->aBkColor[1]   = SCROLLBAR__aDefaultBkColor[1];
   \   0000008E   0x6881             LDR      R1,[R0, #+8]
   \   00000090   0x62F1             STR      R1,[R6, #+44]
    483              pObj->aColor[0]     = SCROLLBAR__aDefaultColor[0];
   \   00000092   0x68C1             LDR      R1,[R0, #+12]
   \   00000094   0x6331             STR      R1,[R6, #+48]
    484              pObj->aColor[1]     = SCROLLBAR__aDefaultColor[1];
   \   00000096   0x6900             LDR      R0,[R0, #+16]
   \   00000098   0x6370             STR      R0,[R6, #+52]
    485              pObj->NumItems      = 100;
   \   0000009A   0x2064             MOVS     R0,#+100
   \   0000009C   0x63B0             STR      R0,[R6, #+56]
    486              pObj->PageSize      =  10;
   \   0000009E   0x200A             MOVS     R0,#+10
   \   000000A0   0x6430             STR      R0,[R6, #+64]
    487              pObj->v             =   0;
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0x63F0             STR      R0,[R6, #+60]
    488              SCROLLBAR__InvalidatePartner(hObj);
   \   000000A6   0x4628             MOV      R0,R5
   \   000000A8   0x.... 0x....      BL       SCROLLBAR__InvalidatePartner
    489            } else {
    490              GUI_DEBUG_ERROROUT_IF(hObj==0, "SCROLLBAR_Create failed")
    491            }
    492            WM_UNLOCK();
    493            return hObj;
   \                     ??SCROLLBAR_CreateEx_2: (+1)
   \   000000AC   0x4628             MOV      R0,R5
   \   000000AE   0xB005             ADD      SP,SP,#+20
   \   000000B0   0xBDF0             POP      {R4-R7,PC}       ;; return
    494          }
    495          
    496          /*********************************************************************
    497          *
    498          *       Exported routines:  Various methods
    499          *
    500          **********************************************************************
    501          */
    502          /*********************************************************************
    503          *
    504          *       SCROLLBAR_Dec
    505          */

   \                                 In section .text, align 2, keep-with-next
    506          void SCROLLBAR_Dec(SCROLLBAR_Handle hObj) {
    507            SCROLLBAR_AddValue(hObj, -1);
   \                     SCROLLBAR_Dec: (+1)
   \   00000000   0xF04F 0x31FF      MOV      R1,#-1
   \   00000004   0x....             B.N      SCROLLBAR_AddValue
    508          }
    509          
    510          /*********************************************************************
    511          *
    512          *       SCROLLBAR_Inc
    513          */

   \                                 In section .text, align 2, keep-with-next
    514          void SCROLLBAR_Inc(SCROLLBAR_Handle hObj) {
    515            SCROLLBAR_AddValue(hObj,  1);
   \                     SCROLLBAR_Inc: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002                      REQUIRE SCROLLBAR_AddValue
   \   00000002                      ;; // Fall through to label SCROLLBAR_AddValue
    516          }
    517          
    518          /*********************************************************************
    519          *
    520          *       SCROLLBAR_AddValue
    521          */

   \                                 In section .text, align 2, keep-with-next
    522          void SCROLLBAR_AddValue(SCROLLBAR_Handle hObj, int Add) {
   \                     SCROLLBAR_AddValue: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    523            SCROLLBAR_Obj* pObj;
    524            if (hObj) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??SCROLLBAR_AddValue_0
    525              WM_LOCK();
    526              pObj = SCROLLBAR_H2P(hObj);
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
    527              SCROLLBAR_SetValue(hObj, pObj->v + Add);
   \   0000000E   0x6BC0             LDR      R0,[R0, #+60]
   \   00000010   0x1829             ADDS     R1,R5,R0
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000018   0x....             B.N      SCROLLBAR_SetValue
    528              WM_UNLOCK();
    529            }
    530          }
   \                     ??SCROLLBAR_AddValue_0: (+1)
   \   0000001A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    531          
    532          /*********************************************************************
    533          *
    534          *       SCROLLBAR_SetValue
    535          */

   \                                 In section .text, align 2, keep-with-next
    536          void SCROLLBAR_SetValue(SCROLLBAR_Handle hObj, int v) {
   \                     SCROLLBAR_SetValue: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    537            SCROLLBAR_Obj* pObj;
    538            int Max;
    539            if (hObj) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD019             BEQ.N    ??SCROLLBAR_SetValue_0
    540              WM_LOCK();
    541              pObj = SCROLLBAR_H2P(hObj);
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
    542              Max = pObj->NumItems - pObj->PageSize;
   \   0000000E   0x6B81             LDR      R1,[R0, #+56]
   \   00000010   0x6C02             LDR      R2,[R0, #+64]
   \   00000012   0x1A89             SUBS     R1,R1,R2
    543              if (Max < 0)
   \   00000014   0xD500             BPL.N    ??SCROLLBAR_SetValue_1
    544                Max =0;
   \   00000016   0x2100             MOVS     R1,#+0
    545              /* Put in min/max range */
    546              if (v < 0) {
   \                     ??SCROLLBAR_SetValue_1: (+1)
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD500             BPL.N    ??SCROLLBAR_SetValue_2
    547                v = 0;
   \   0000001C   0x2500             MOVS     R5,#+0
    548              }
    549              if (v > Max) {
   \                     ??SCROLLBAR_SetValue_2: (+1)
   \   0000001E   0x42A9             CMP      R1,R5
   \   00000020   0xDC00             BGT.N    ??SCROLLBAR_SetValue_3
   \   00000022   0x460D             MOV      R5,R1
    550                v = Max;
    551              }
    552              if (pObj->v != v) {
   \                     ??SCROLLBAR_SetValue_3: (+1)
   \   00000024   0x6BC1             LDR      R1,[R0, #+60]
   \   00000026   0x42A9             CMP      R1,R5
   \   00000028   0xD009             BEQ.N    ??SCROLLBAR_SetValue_0
    553                pObj->v = v;
   \   0000002A   0x63C5             STR      R5,[R0, #+60]
    554                WM_InvalidateWindow(hObj);
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       WM_InvalidateWindow
    555                WM_NotifyParent(hObj, WM_NOTIFICATION_VALUE_CHANGED);
   \   00000032   0x2105             MOVS     R1,#+5
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   0000003A   0x.... 0x....      B.W      WM_NotifyParent
    556              }
    557              WM_UNLOCK();
    558            }
    559          }
   \                     ??SCROLLBAR_SetValue_0: (+1)
   \   0000003E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    560          
    561          /*********************************************************************
    562          *
    563          *       SCROLLBAR_SetNumItems
    564          */

   \                                 In section .text, align 2, keep-with-next
    565          void SCROLLBAR_SetNumItems(SCROLLBAR_Handle hObj, int NumItems) {
   \                     SCROLLBAR_SetNumItems: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    566            SCROLLBAR_Obj* pObj;
    567            if (hObj) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD00A             BEQ.N    ??SCROLLBAR_SetNumItems_0
    568              WM_LOCK();
    569              pObj = SCROLLBAR_H2P(hObj);
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
    570              if (pObj->NumItems != NumItems) {
   \   0000000E   0x6B81             LDR      R1,[R0, #+56]
   \   00000010   0x42A9             CMP      R1,R5
   \   00000012   0xD005             BEQ.N    ??SCROLLBAR_SetNumItems_0
    571                pObj->NumItems = NumItems;
   \   00000014   0x6385             STR      R5,[R0, #+56]
    572                WM_InvalidateWindow(hObj);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000001C   0x.... 0x....      B.W      WM_InvalidateWindow
    573              }
    574              WM_UNLOCK();
    575            }
    576          }
   \                     ??SCROLLBAR_SetNumItems_0: (+1)
   \   00000020   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    577          
    578          /*********************************************************************
    579          *
    580          *       SCROLLBAR_SetPageSize
    581          */

   \                                 In section .text, align 2, keep-with-next
    582          void SCROLLBAR_SetPageSize(SCROLLBAR_Handle hObj, int PageSize) {
   \                     SCROLLBAR_SetPageSize: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    583            SCROLLBAR_Obj* pObj;
    584            if (hObj) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD00A             BEQ.N    ??SCROLLBAR_SetPageSize_0
    585              WM_LOCK();
    586              pObj = SCROLLBAR_H2P(hObj);
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
    587              if (pObj->PageSize != PageSize) {
   \   0000000E   0x6C01             LDR      R1,[R0, #+64]
   \   00000010   0x42A9             CMP      R1,R5
   \   00000012   0xD005             BEQ.N    ??SCROLLBAR_SetPageSize_0
    588                pObj->PageSize = PageSize;
   \   00000014   0x6405             STR      R5,[R0, #+64]
    589                WM_InvalidateWindow(hObj);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000001C   0x.... 0x....      B.W      WM_InvalidateWindow
    590              }
    591              WM_UNLOCK();
    592            }
    593          }
   \                     ??SCROLLBAR_SetPageSize_0: (+1)
   \   00000020   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    594          
    595          /*********************************************************************
    596          *
    597          *       SCROLLBAR_SetState
    598          */

   \                                 In section .text, align 2, keep-with-next
    599          void  SCROLLBAR_SetState   (SCROLLBAR_Handle hObj, const WM_SCROLL_STATE* pState) {
   \                     SCROLLBAR_SetState: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    600            if (hObj) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD00B             BEQ.N    ??SCROLLBAR_SetState_0
    601              SCROLLBAR_SetPageSize(hObj, pState->PageSize);
   \   0000000A   0x68A9             LDR      R1,[R5, #+8]
   \   0000000C   0x.... 0x....      BL       SCROLLBAR_SetPageSize
    602              SCROLLBAR_SetNumItems(hObj, pState->NumItems);
   \   00000010   0x6829             LDR      R1,[R5, #+0]
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       SCROLLBAR_SetNumItems
    603              SCROLLBAR_SetValue   (hObj, pState->v);
   \   00000018   0x6869             LDR      R1,[R5, #+4]
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000020   0x....             B.N      SCROLLBAR_SetValue
    604            }
    605          }
   \                     ??SCROLLBAR_SetState_0: (+1)
   \   00000022   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0x........         DC32     SCROLLBAR__DefaultWidth

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \   00000000   0x........         DC32     _SCROLLBAR_Callback
    606          
    607          
    608          #else /* avoid empty object files */
    609          
    610          void SCROLLBAR_C(void);
    611          void SCROLLBAR_C(void){}
    612          
    613          #endif  /* #if GUI_WINSUPPORT */
    614          
    615          
    616          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   SCROLLBAR_AddValue
        16   -> GUI_ALLOC_h2p
         0   -> SCROLLBAR_SetValue
      40   SCROLLBAR_CreateEx
        40   -> GUI_ALLOC_h2p
        40   -> SCROLLBAR__InvalidatePartner
        40   -> WIDGET__Init
        40   -> WM_CreateWindowAsChild
        40   -> WM_GetInsideRectEx
       0   SCROLLBAR_Dec
         0   -> SCROLLBAR_AddValue
       0   SCROLLBAR_Inc
         0   -> SCROLLBAR_AddValue
      16   SCROLLBAR_SetNumItems
        16   -> GUI_ALLOC_h2p
         0   -> WM_InvalidateWindow
      16   SCROLLBAR_SetPageSize
        16   -> GUI_ALLOC_h2p
         0   -> WM_InvalidateWindow
      16   SCROLLBAR_SetState
        16   -> SCROLLBAR_SetNumItems
        16   -> SCROLLBAR_SetPageSize
         0   -> SCROLLBAR_SetValue
      16   SCROLLBAR_SetValue
        16   -> GUI_ALLOC_h2p
        16   -> WM_InvalidateWindow
         0   -> WM_NotifyParent
       8   SCROLLBAR__InvalidatePartner
         8   -> WM_GetParent
         8   -> WM_GetScrollPartner
         8   -> WM_InvalidateWindow
         0   -> WM_SendMessageNoPara
      48   _CalcPositions
        48   -> GUI_MoveRect
        48   -> GUI__DivideRound
        48   -> WM_GetScrollbarH
        48   -> WM_GetScrollbarV
        48   -> WM_GetWindowRectEx
        48   -> _GetArrowSize
        48   -> _WIDGET__RECT2VRECT
        48   -> __aeabi_memcpy
      24   _DrawTriangle
        24   -> GUI_DrawHLine
        24   -> GUI_DrawVLine
      16   _GetArrowSize
        16   -> WIDGET__GetXSize
        16   -> WIDGET__GetYSize
       0   _OnKey
         0   -> SCROLLBAR_Dec
         0   -> SCROLLBAR_Inc
      16   _OnSetScrollState
         0   -> WM_InvalidateWindow
      56   _OnTouch
        56   -> GUI__DivideRound
        56   -> SCROLLBAR_SetValue
        56   -> WM_SetCapture
        56   -> _CalcPositions
        56   -> _ScrollbarPressed
        56   -> _ScrollbarReleased
      72   _Paint
        72   -> LCD_SetColor
        72   -> WIDGET__EFFECT_DrawUpRect
        72   -> WIDGET__FillRectEx
        72   -> WIDGET__GetClientRect
        72   -> _CalcPositions
        72   -> _DrawTriangle
      16   _SCROLLBAR_Callback
        16   -> GUI_ALLOC_h2p
        16   -> SCROLLBAR__InvalidatePartner
        16   -> WIDGET_HandleActive
         0   -> WM_DefaultProc
        16   -> _OnKey
        16   -> _OnSetScrollState
        16   -> _OnTouch
         0   -> _Paint
      16   _ScrollbarPressed
        16   -> WIDGET_OrState
         0   -> WM_NotifyParent
      16   _ScrollbarReleased
        16   -> WIDGET_AndState
         0   -> WM_NotifyParent
       4   _WIDGET__RECT2VRECT


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
      28  SCROLLBAR_AddValue
     178  SCROLLBAR_CreateEx
       6  SCROLLBAR_Dec
       2  SCROLLBAR_Inc
      34  SCROLLBAR_SetNumItems
      34  SCROLLBAR_SetPageSize
      36  SCROLLBAR_SetState
      64  SCROLLBAR_SetValue
      20  SCROLLBAR__DefaultWidth
          SCROLLBAR__aDefaultBkColor
          SCROLLBAR__aDefaultColor
      28  SCROLLBAR__InvalidatePartner
     278  _CalcPositions
      58  _DrawTriangle
      30  _GetArrowSize
      28  _OnKey
      46  _OnSetScrollState
     180  _OnTouch
     350  _Paint
     136  _SCROLLBAR_Callback
      34  _ScrollbarPressed
      34  _ScrollbarReleased
      54  _WIDGET__RECT2VRECT

 
    20 bytes in section .data
 1 646 bytes in section .text
 
 1 646 bytes of CODE memory
    20 bytes of DATA memory

Errors: none
Warnings: none
