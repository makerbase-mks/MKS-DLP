###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  10:58:19
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Core\GUI_UC_DispString.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Core\GUI_UC_DispString.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\GUI_UC_DispString.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\GUI_UC_DispString.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Core\GUI_UC_DispString.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              µC/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : GUI_UC_DispString.c
     16          Purpose     : Implementation of GUI_UC_DispString
     17          ---------------------------END-OF-HEADER------------------------------
     18          */
     19          
     20          #include <stddef.h>           /* needed for definition of NULL */
     21          #include "GUI_Protected.h"
     22          
     23          /*********************************************************************
     24          *
     25          *       Static code
     26          *
     27          **********************************************************************
     28          */
     29          /*********************************************************************
     30          *
     31          *       _GetLineDistX
     32          */

   \                                 In section .text, align 2, keep-with-next
     33          static int _GetLineDistX(const U16 GUI_UNI_PTR *s, int MaxNumChars) {
   \                     _GetLineDistX: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
     34            int Dist =0;
   \   00000006   0x2600             MOVS     R6,#+0
     35            if (s) {
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD00A             BEQ.N    ??_GetLineDistX_0
   \   0000000C   0xE004             B.N      ??_GetLineDistX_1
     36              U16 Char;
     37              while (((Char = *s) != 0) && MaxNumChars >= 0) {
     38                s++;
   \                     ??_GetLineDistX_2: (+1)
   \   0000000E   0x1CA4             ADDS     R4,R4,#+2
     39                MaxNumChars--;
   \   00000010   0x1E6D             SUBS     R5,R5,#+1
     40                Dist += GUI_GetCharDistX(Char);
   \   00000012   0x.... 0x....      BL       GUI_GetCharDistX
   \   00000016   0x1986             ADDS     R6,R0,R6
     41              }
   \                     ??_GetLineDistX_1: (+1)
   \   00000018   0x8820             LDRH     R0,[R4, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD001             BEQ.N    ??_GetLineDistX_0
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD5F5             BPL.N    ??_GetLineDistX_2
     42            }
     43            return Dist;
   \                     ??_GetLineDistX_0: (+1)
   \   00000022   0x4630             MOV      R0,R6
   \   00000024   0xBD70             POP      {R4-R6,PC}       ;; return
     44          }
     45          
     46          /*********************************************************************
     47          *
     48          *       _GetLineLen
     49          */

   \                                 In section .text, align 2, keep-with-next
     50          static int _GetLineLen(const U16 GUI_UNI_PTR *s, int MaxLen) {
     51            int Len =0;
   \                     _GetLineLen: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
     52            if (!s)
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD103             BNE.N    ??_GetLineLen_0
     53              return 0;
   \   00000006   0x4610             MOV      R0,R2
   \   00000008   0x4770             BX       LR
     54            {
     55              while ((*s !=0) && Len < MaxLen) {
     56                Len++; s++;
   \                     ??_GetLineLen_1: (+1)
   \   0000000A   0x1C52             ADDS     R2,R2,#+1
   \   0000000C   0x1C80             ADDS     R0,R0,#+2
     57              }
   \                     ??_GetLineLen_0: (+1)
   \   0000000E   0x8803             LDRH     R3,[R0, #+0]
   \   00000010   0x2B00             CMP      R3,#+0
   \   00000012   0xD001             BEQ.N    ??_GetLineLen_2
   \   00000014   0x428A             CMP      R2,R1
   \   00000016   0xDBF8             BLT.N    ??_GetLineLen_1
     58            }
     59            return Len;
   \                     ??_GetLineLen_2: (+1)
   \   00000018   0x4610             MOV      R0,R2
   \   0000001A   0x4770             BX       LR               ;; return
     60          }
     61          
     62          /*********************************************************************
     63          *
     64          *       _DispLine_UC
     65          */

   \                                 In section .text, align 2, keep-with-next
     66          static void _DispLine_UC(const U16 GUI_UNI_PTR *s, int Len, const GUI_RECT *pRect) {
   \                     _DispLine_UC: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4611             MOV      R1,R2
   \   00000008   0x....             LDR.N    R0,??DataTable2
   \   0000000A   0x6900             LDR      R0,[R0, #+16]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD008             BEQ.N    ??_DispLine_UC_0
     67            if (GUI_Context.pClipRect_HL) {
     68              if (GUI_RectsIntersect(GUI_Context.pClipRect_HL, pRect) == 0)
   \   00000010   0x.... 0x....      BL       GUI_RectsIntersect
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD104             BNE.N    ??_DispLine_UC_0
     69                return;
   \   00000018   0xBD31             POP      {R0,R4,R5,PC}
     70            }
     71            {
     72              U16 c0;
     73              while (--Len >=0) {
     74                c0=*s++;
   \                     ??_DispLine_UC_1: (+1)
   \   0000001A   0xF834 0x0B02      LDRH     R0,[R4], #+2
     75                GL_DispChar(c0);
   \   0000001E   0x.... 0x....      BL       GL_DispChar
     76              }
   \                     ??_DispLine_UC_0: (+1)
   \   00000022   0x1E6D             SUBS     R5,R5,#+1
   \   00000024   0xD5F9             BPL.N    ??_DispLine_UC_1
     77            }
     78          }
   \   00000026   0xBD31             POP      {R0,R4,R5,PC}    ;; return
     79          
     80          /*********************************************************************
     81          *
     82          *       _DispLine
     83          */

   \                                 In section .text, align 2, keep-with-next
     84          static void _DispLine(const U16 GUI_UNI_PTR *s, int Len, const GUI_RECT* pr) {
   \                     _DispLine: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4611             MOV      R1,R2
     85            GUI_RECT r;
     86            r = *pr;
   \   00000008   0xA800             ADD      R0,SP,#+0
   \   0000000A   0x2208             MOVS     R2,#+8
   \   0000000C   0x.... 0x....      BL       __aeabi_memcpy
     87            #if GUI_WINSUPPORT
     88            WM_ADDORG(r.x0,r.y0);
   \   00000010   0x....             LDR.N    R6,??DataTable2
   \   00000012   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000016   0x6C31             LDR      R1,[R6, #+64]
   \   00000018   0x1808             ADDS     R0,R1,R0
   \   0000001A   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   0000001E   0xF8BD 0x0002      LDRH     R0,[SP, #+2]
   \   00000022   0x6C71             LDR      R1,[R6, #+68]
   \   00000024   0x1808             ADDS     R0,R1,R0
   \   00000026   0xF8AD 0x0002      STRH     R0,[SP, #+2]
     89            WM_ADDORG(r.x1,r.y1);
   \   0000002A   0xF8BD 0x0004      LDRH     R0,[SP, #+4]
   \   0000002E   0x6C31             LDR      R1,[R6, #+64]
   \   00000030   0x1808             ADDS     R0,R1,R0
   \   00000032   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   \   00000036   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \   0000003A   0x6C71             LDR      R1,[R6, #+68]
   \   0000003C   0x1808             ADDS     R0,R1,R0
   \   0000003E   0xF8AD 0x0006      STRH     R0,[SP, #+6]
     90            WM_ITERATE_START(&r) {
   \   00000042   0xA800             ADD      R0,SP,#+0
   \   00000044   0x.... 0x....      BL       WM__InitIVRSearch
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD00E             BEQ.N    ??_DispLine_0
     91            #endif
     92               GUI_Context.DispPosX = r.x0;
   \                     ??_DispLine_1: (+1)
   \   0000004C   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000050   0x8470             STRH     R0,[R6, #+34]
     93               GUI_Context.DispPosY = r.y0;
   \   00000052   0xF8BD 0x0002      LDRH     R0,[SP, #+2]
   \   00000056   0x84B0             STRH     R0,[R6, #+36]
     94               _DispLine_UC(s, Len, &r);    /* Do the actual drawing via routine call. */
   \   00000058   0xAA00             ADD      R2,SP,#+0
   \   0000005A   0x4629             MOV      R1,R5
   \   0000005C   0x4620             MOV      R0,R4
   \   0000005E   0x.... 0x....      BL       _DispLine_UC
     95            #if GUI_WINSUPPORT
     96            } WM_ITERATE_END();
   \   00000062   0x.... 0x....      BL       WM__GetNextIVR
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD1F0             BNE.N    ??_DispLine_1
     97            WM_SUBORG(GUI_Context.DispPosX, GUI_Context.DispPosY);
   \                     ??_DispLine_0: (+1)
   \   0000006A   0x8C70             LDRH     R0,[R6, #+34]
   \   0000006C   0x6C31             LDR      R1,[R6, #+64]
   \   0000006E   0x1A40             SUBS     R0,R0,R1
   \   00000070   0x8470             STRH     R0,[R6, #+34]
   \   00000072   0x8CB0             LDRH     R0,[R6, #+36]
   \   00000074   0x6C71             LDR      R1,[R6, #+68]
   \   00000076   0x1A40             SUBS     R0,R0,R1
   \   00000078   0x84B0             STRH     R0,[R6, #+36]
     98            #endif
     99          }
   \   0000007A   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    100          
    101          /*********************************************************************
    102          *
    103          *       Public code
    104          *
    105          **********************************************************************
    106          */
    107          /*********************************************************************
    108          *
    109          *       GUI_UC_DispString
    110          */

   \                                 In section .text, align 2, keep-with-next
    111          void GUI_UC_DispString(const U16 GUI_UNI_PTR *s) {
   \                     GUI_UC_DispString: (+1)
   \   00000000   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \   00000004   0x4680             MOV      R8,R0
    112            int xAdjust, yAdjust, xOrg;
    113            int FontSizeY;
    114            if (!s)
   \   00000006   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000000A   0xD06C             BEQ.N    ??GUI_UC_DispString_0
    115              return;
    116            GUI_LOCK();
    117            FontSizeY = GUI_Context.pAFont->YSize;
   \   0000000C   0x....             LDR.N    R4,??DataTable2
   \   0000000E   0x69A0             LDR      R0,[R4, #+24]
   \   00000010   0x7D05             LDRB     R5,[R0, #+20]
    118            xOrg = GUI_Context.DispPosX;
   \   00000012   0xF9B4 0x6022      LDRSH    R6,[R4, #+34]
    119           /* Adjust vertical position */
    120            yAdjust = GUI_GetYAdjust();
   \   00000016   0x.... 0x....      BL       GUI_GetYAdjust
   \   0000001A   0x4607             MOV      R7,R0
    121            GUI_Context.DispPosY -= yAdjust;
   \   0000001C   0x8CA0             LDRH     R0,[R4, #+36]
   \   0000001E   0x1BC0             SUBS     R0,R0,R7
   \   00000020   0x84A0             STRH     R0,[R4, #+36]
   \   00000022   0xE001             B.N      ??GUI_UC_DispString_1
    122            for (; *s; s++) {
   \                     ??GUI_UC_DispString_2: (+1)
   \   00000024   0xF108 0x0802      ADD      R8,R8,#+2
   \                     ??GUI_UC_DispString_1: (+1)
   \   00000028   0xF8B8 0x0000      LDRH     R0,[R8, #+0]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD053             BEQ.N    ??GUI_UC_DispString_3
    123              GUI_RECT r;
    124              int LineLen= _GetLineLen(s,0x7fff);
   \   00000030   0xF647 0x71FF      MOVW     R1,#+32767
   \   00000034   0x4640             MOV      R0,R8
   \   00000036   0x.... 0x....      BL       _GetLineLen
   \   0000003A   0x4681             MOV      R9,R0
    125              int xLineSize = _GetLineDistX(s, LineLen);
   \   0000003C   0x4649             MOV      R1,R9
   \   0000003E   0x4640             MOV      R0,R8
   \   00000040   0x.... 0x....      BL       _GetLineDistX
   \   00000044   0x4682             MOV      R10,R0
    126            /* Check if x-position needs to be changed due to h-alignment */
    127              switch (GUI_Context.TextAlign & GUI_TA_HORIZONTAL) { 
   \   00000046   0xF894 0x002C      LDRB     R0,[R4, #+44]
   \   0000004A   0xF000 0x0013      AND      R0,R0,#0x13
   \   0000004E   0x2801             CMP      R0,#+1
   \   00000050   0xD005             BEQ.N    ??GUI_UC_DispString_4
   \   00000052   0x2802             CMP      R0,#+2
   \   00000054   0xD105             BNE.N    ??GUI_UC_DispString_5
    128              case GUI_TA_CENTER: xAdjust= xLineSize/2; break;
   \   00000056   0xEB0A 0x70DA      ADD      R0,R10,R10, LSR #+31
   \   0000005A   0x1040             ASRS     R0,R0,#+1
   \   0000005C   0xE002             B.N      ??GUI_UC_DispString_6
    129              case GUI_TA_RIGHT:  xAdjust= xLineSize; break;
   \                     ??GUI_UC_DispString_4: (+1)
   \   0000005E   0x4650             MOV      R0,R10
   \   00000060   0xE000             B.N      ??GUI_UC_DispString_6
    130              default:            xAdjust= 0;
   \                     ??GUI_UC_DispString_5: (+1)
   \   00000062   0x2000             MOVS     R0,#+0
    131              }
    132              r.x0 = GUI_Context.DispPosX -= xAdjust;
   \                     ??GUI_UC_DispString_6: (+1)
   \   00000064   0x8C61             LDRH     R1,[R4, #+34]
   \   00000066   0x1A08             SUBS     R0,R1,R0
   \   00000068   0x8460             STRH     R0,[R4, #+34]
   \   0000006A   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    133              r.x1 = r.x0 + xLineSize-1;    
   \   0000006E   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000072   0x4450             ADD      R0,R10,R0
   \   00000074   0x1E40             SUBS     R0,R0,#+1
   \   00000076   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    134              r.y0 = GUI_Context.DispPosY;
   \   0000007A   0xF9B4 0x0024      LDRSH    R0,[R4, #+36]
   \   0000007E   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    135              r.y1 = r.y0 + FontSizeY-1;    
   \   00000082   0x1828             ADDS     R0,R5,R0
   \   00000084   0x1E40             SUBS     R0,R0,#+1
   \   00000086   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    136              _DispLine(s, LineLen, &r);
   \   0000008A   0xAA00             ADD      R2,SP,#+0
   \   0000008C   0x4649             MOV      R1,R9
   \   0000008E   0x4640             MOV      R0,R8
   \   00000090   0x.... 0x....      BL       _DispLine
    137              GUI_Context.DispPosY = r.y0;
   \   00000094   0xF8BD 0x0002      LDRH     R0,[SP, #+2]
   \   00000098   0x84A0             STRH     R0,[R4, #+36]
    138              s += LineLen;
   \   0000009A   0xEB08 0x0849      ADD      R8,R8,R9, LSL #+1
    139              if (*s=='\n') {
   \   0000009E   0xF8B8 0x0000      LDRH     R0,[R8, #+0]
   \   000000A2   0x280A             CMP      R0,#+10
   \   000000A4   0xD110             BNE.N    ??GUI_UC_DispString_7
    140                switch (GUI_Context.TextAlign & GUI_TA_HORIZONTAL) { 
   \   000000A6   0xF894 0x002C      LDRB     R0,[R4, #+44]
   \   000000AA   0xF000 0x0013      AND      R0,R0,#0x13
   \   000000AE   0x1E40             SUBS     R0,R0,#+1
   \   000000B0   0x2801             CMP      R0,#+1
   \   000000B2   0xD801             BHI.N    ??GUI_UC_DispString_8
    141                case GUI_TA_CENTER:
    142                case GUI_TA_RIGHT:
    143                  GUI_Context.DispPosX = xOrg;
   \   000000B4   0x8466             STRH     R6,[R4, #+34]
    144                  break;
   \   000000B6   0xE001             B.N      ??GUI_UC_DispString_9
    145                default:
    146                  GUI_Context.DispPosX = GUI_Context.LBorder;
   \                     ??GUI_UC_DispString_8: (+1)
   \   000000B8   0x8C20             LDRH     R0,[R4, #+32]
   \   000000BA   0x8460             STRH     R0,[R4, #+34]
    147                  break;
    148                }
    149                GUI_Context.DispPosY += GUI_GetFontDistY();
   \                     ??GUI_UC_DispString_9: (+1)
   \   000000BC   0x.... 0x....      BL       GUI_GetFontDistY
   \   000000C0   0x8CA1             LDRH     R1,[R4, #+36]
   \   000000C2   0x1840             ADDS     R0,R0,R1
   \   000000C4   0x84A0             STRH     R0,[R4, #+36]
   \   000000C6   0xE003             B.N      ??GUI_UC_DispString_10
    150              } else {
    151                GUI_Context.DispPosX = r.x0+xLineSize;
   \                     ??GUI_UC_DispString_7: (+1)
   \   000000C8   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   000000CC   0x4450             ADD      R0,R10,R0
   \   000000CE   0x8460             STRH     R0,[R4, #+34]
    152              }
    153              if (*s==0)    /* end of string (last line) reached ? */
   \                     ??GUI_UC_DispString_10: (+1)
   \   000000D0   0xF8B8 0x0000      LDRH     R0,[R8, #+0]
   \   000000D4   0x2800             CMP      R0,#+0
   \   000000D6   0xD1A5             BNE.N    ??GUI_UC_DispString_2
    154                break;
    155            }
    156            GUI_Context.DispPosY += yAdjust;
   \                     ??GUI_UC_DispString_3: (+1)
   \   000000D8   0x8CA0             LDRH     R0,[R4, #+36]
   \   000000DA   0x1838             ADDS     R0,R7,R0
   \   000000DC   0x84A0             STRH     R0,[R4, #+36]
    157            GUI_Context.TextAlign &= ~GUI_TA_HORIZONTAL;
   \   000000DE   0x8DA0             LDRH     R0,[R4, #+44]
   \   000000E0   0xF020 0x0013      BIC      R0,R0,#0x13
   \   000000E4   0x85A0             STRH     R0,[R4, #+44]
    158            GUI_UNLOCK();
    159          }
   \                     ??GUI_UC_DispString_0: (+1)
   \   000000E6   0xE8BD 0x87F3      POP      {R0,R1,R4-R10,PC}  ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     GUI_Context
    160          
    161          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   GUI_UC_DispString
        40   -> GUI_GetFontDistY
        40   -> GUI_GetYAdjust
        40   -> _DispLine
        40   -> _GetLineDistX
        40   -> _GetLineLen
      24   _DispLine
        24   -> WM__GetNextIVR
        24   -> WM__InitIVRSearch
        24   -> _DispLine_UC
        24   -> __aeabi_memcpy
      16   _DispLine_UC
        16   -> GL_DispChar
        16   -> GUI_RectsIntersect
      16   _GetLineDistX
        16   -> GUI_GetCharDistX
       0   _GetLineLen


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
     234  GUI_UC_DispString
     124  _DispLine
      40  _DispLine_UC
      38  _GetLineDistX
      28  _GetLineLen

 
 468 bytes in section .text
 
 468 bytes of CODE memory

Errors: none
Warnings: none
